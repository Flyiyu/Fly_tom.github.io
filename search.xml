<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue基础</title>
      <link href="/2019/12/19/2019-12-04-vue-ji-chu/"/>
      <url>/2019/12/19/2019-12-04-vue-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="（一）ES6补充"><a href="#（一）ES6补充" class="headerlink" title="（一）ES6补充"></a>（一）ES6补充</h2><h3 id="1-1块级作用域"><a href="#1-1块级作用域" class="headerlink" title="1.1块级作用域"></a>1.1块级作用域</h3><p>​    ES6之前没有块级作用域，ES5的var没有块级作用域的概念，只有function有作用域的概念，ES6的let、const引入了块级作用域。</p><p>​    ES5之前if和for都没有作用域，所以很多时候需要使用function的作用域，比如闭包。</p><h4 id="1-1-1-什么是变量作用域"><a href="#1-1-1-什么是变量作用域" class="headerlink" title="1.1.1    什么是变量作用域"></a>1.1.1    什么是变量作用域</h4><p>​    变量在什么范围内可用，类似Java的全局变量和局部变量的概念，全局变量，全局都可用，局部变量只在范围内可用。ES5之前的var是没有块级作用域的概念，使用var声明的变量就是全局的。</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'zzz'</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    上述代码中{}外的<code>console.log(name)</code>可以获取到name值并打印出来，用var声明赋值的变量是全局变量，没有块级作用域。</p><h4 id="1-1-2-没有块级作用域造成的问题"><a href="#1-1-2-没有块级作用域造成的问题" class="headerlink" title="1.1.2    没有块级作用域造成的问题"></a>1.1.2    没有块级作用域造成的问题</h4><h5 id="if块级"><a href="#if块级" class="headerlink" title="if块级"></a>if块级</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> func<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'zzz'</span><span class="token punctuation">;</span>    func <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>name <span class="token operator">=</span> <span class="token string">'ttt'</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    代码输出结果为<code>'zzz','ttt','ttt'</code>，第一次调用func()，此时name=‘zzz’，在if块外将name置成‘ttt’，此时生效了，if没有块级作用域。</p><h5 id="for块级"><a href="#for块级" class="headerlink" title="for块级"></a>for块级</h5><p>​    定义五个按钮，增加事件，点击哪个按钮打印“第哪个按钮被点击了”。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>块级作用域<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>按钮5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">      <span class="token comment" spellcheck="true">// 3.没有块级作用域引起的问题:for块级</span>      <span class="token keyword">var</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> btns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        btns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"个按钮被点击了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    for块级中使用<code>var</code>声明变量i时，是全局变量，点击任意按钮结果都是“第五个按钮被点击了”。说明在执行<code>btns[i].addEventListener('click',function())</code>时，for块级循环已经走完，此时<code>i=5</code>，所有添加的事件的i都是5。</p><p>​    改造上述代码，将for循环改造，由于函数有作用域，使用闭包能解决上述问题。</p><pre class=" language-javascript"><code class="language-javascript">      <span class="token comment" spellcheck="true">// 使用闭包,函数有作用域</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> btns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>          btns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"个按钮被点击了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span></code></pre><p>​    结果如图所示，借用函数的作用域解决块级作用域的问题，因为有块级作用域，每次添加的i都是当前i。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/1.1.2-1.png" alt="image"></p><p>​    在ES6中使用let/const解决块级作用域问题，let和const有块级作用域，const定义常量，在for块级中使用let解决块级作用域问题。</p><pre class=" language-javascript"><code class="language-javascript">      <span class="token comment" spellcheck="true">// ES6使用let/const</span>      <span class="token keyword">const</span> btns <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> btns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        btns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"个按钮被点击了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span></code></pre><p>​    结果和使用闭包解决一致。</p><h3 id="1-2-const的使用"><a href="#1-2-const的使用" class="headerlink" title="1.2    const的使用"></a>1.2    const的使用</h3><p>​    1.const用来定义常量，赋值知乎不能再赋值，再次赋值会报错。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>        <span class="token comment" spellcheck="true">//1.定义常量，赋值后不能再赋值，在赋值报错</span>        <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">// count = 2</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><p>​    2.const不能只声明不赋值，会报错。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>        <span class="token comment" spellcheck="true">//2.只声明不赋值，必须赋值</span>        <span class="token comment" spellcheck="true">// const count;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><p>​    3.const常量含义是你不能改变其指向的对象，例如user，都是你可以改变user属性。</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>        <span class="token comment" spellcheck="true">//3.常量的含义是你不能改变其指向的对象user，但是你可以改变user属性</span>        <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span><span class="token string">"zzz"</span><span class="token punctuation">,</span>            age<span class="token punctuation">:</span><span class="token number">24</span><span class="token punctuation">,</span>            height<span class="token punctuation">:</span><span class="token number">175</span>        <span class="token punctuation">}</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>        user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"ttt"</span>        user<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">22</span>        user<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">188</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span></code></pre><p><strong>const内存地址详解</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/1.2-1.png" alt="image"></p><p>​    对象count一开始只想0x10的地址，直接将count（给count重新赋值，指向一个新的对象）指向地址改为0x20会报错，const是常量，无法更改对象地址。</p><p>​    对象user一开始指向0x10地址，user有<code>Name</code>、<code>Age</code>、<code>Height</code>三个属性，此时修改属性<code>Name='ttt'</code>，user对象的地址未改变，不会报错。</p><h3 id="1-3-ES6的增强写法"><a href="#1-3-ES6的增强写法" class="headerlink" title="1.3    ES6的增强写法"></a>1.3    ES6的增强写法</h3><h4 id="1-3-1-ES6的对象属性增强型写法"><a href="#1-3-1-ES6的对象属性增强型写法" class="headerlink" title="1.3.1    ES6的对象属性增强型写法"></a>1.3.1    ES6的对象属性增强型写法</h4><p>​    ES6以前定义一个对象</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"zzz"</span><span class="token punctuation">;</span><span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span>name<span class="token punctuation">,</span>  age<span class="token punctuation">:</span>age<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​    ES6写法</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">"zzz"</span><span class="token punctuation">;</span><span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">,</span>age<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="1-3-2-ES6对象的函数增强型写法"><a href="#1-3-2-ES6对象的函数增强型写法" class="headerlink" title="1.3.2    ES6对象的函数增强型写法"></a>1.3.2    ES6对象的函数增强型写法</h4><p>​    ES6之前对象内定义函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  run<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"奔跑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>  ES6写法</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"奔跑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="1-4-箭头函数"><a href="#1-4-箭头函数" class="headerlink" title="1.4    箭头函数"></a>1.4    箭头函数</h3><h4 id="1-4-1-认识箭头函数"><a href="#1-4-1-认识箭头函数" class="headerlink" title="1.4.1    认识箭头函数"></a>1.4.1    认识箭头函数</h4><blockquote><p>传统定义函数的方式</p></blockquote><pre class=" language-javascript"><code class="language-javascript">  <span class="token keyword">const</span> aaa <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span></code></pre><blockquote><p>对象字面量中定义函数</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    bbb <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><blockquote><p>ES6中的箭头函数</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//const ccc = (参数列表) =&gt; {}</span>  <span class="token keyword">const</span> ccc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="1-4-2-箭头函数的参数和返回值"><a href="#1-4-2-箭头函数的参数和返回值" class="headerlink" title="1.4.2    箭头函数的参数和返回值"></a>1.4.2    箭头函数的参数和返回值</h4><h5 id="1-4-2-1-参数问题"><a href="#1-4-2-1-参数问题" class="headerlink" title="1.4.2.1    参数问题"></a>1.4.2.1    参数问题</h5><blockquote><p>1.放入两个参数</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span>num2<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2 <span class="token punctuation">}</span></code></pre><blockquote><p>2.放入一个参数,()可以省略</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> power <span class="token operator">=</span> num <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> num <span class="token operator">*</span> num<span class="token punctuation">}</span></code></pre><h5 id="1-4-2-2-函数内部"><a href="#1-4-2-2-函数内部" class="headerlink" title="1.4.2.2    函数内部"></a>1.4.2.2    函数内部</h5><blockquote><p>1.函数中代码块中有多行代码</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello zzz"</span><span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello vue"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><blockquote><p>2.函数代码块中只有一行代码，可以省略return</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// const mul = (num1,num2) =&gt; {</span><span class="token comment" spellcheck="true">//   return num1 * num2</span><span class="token comment" spellcheck="true">// }</span><span class="token keyword">const</span> mul <span class="token operator">=</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span>num2<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> num1<span class="token operator">*</span> num2<span class="token comment" spellcheck="true">// const log = () =&gt; {</span><span class="token comment" spellcheck="true">//   console.log("log")</span><span class="token comment" spellcheck="true">// }</span><span class="token keyword">const</span> log <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"log"</span><span class="token punctuation">)</span></code></pre><h4 id="1-4-3-箭头函数的this使用"><a href="#1-4-3-箭头函数的this使用" class="headerlink" title="1.4.3    箭头函数的this使用"></a>1.4.3    箭头函数的this使用</h4><blockquote><p>什么时候使用箭头函数</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//这里this找的是window的this</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>结论：箭头函数没有this，这里this引用的是最近作用域（aaa函数里的this）的this。</p></blockquote><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token function">aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//window</span>         <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//obj</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    obj<span class="token punctuation">.</span><span class="token function">aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><blockquote><p>​    上述中第一个是window对象的this，第二个箭头函数的this是obj的。</p></blockquote><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token function">aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//window</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//window</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//window</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//obj</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    obj<span class="token punctuation">.</span><span class="token function">aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="1-5-高阶函数"><a href="#1-5-高阶函数" class="headerlink" title="1.5 高阶函数"></a>1.5 高阶函数</h3><h4 id="1-5-1-filter过滤函数"><a href="#1-5-1-filter过滤函数" class="headerlink" title="1.5.1    filter过滤函数"></a>1.5.1    filter过滤函数</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">77</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//要求获取nums中大于50的数</span><span class="token comment" spellcheck="true">//回调函数会遍历nums中每一个数，传入回调函数，在回调函数中写判断逻辑，返回true则会被数组接收，false会被拒绝</span><span class="token keyword">let</span> newNums <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">&gt;</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//可以使用箭头函数简写</span><span class="token comment" spellcheck="true">//  let newNums = nums.filter(num =&gt; num &gt;50)</span></code></pre><h4 id="1-5-2-map高阶函数"><a href="#1-5-2-map高阶函数" class="headerlink" title="1.5.2    map高阶函数"></a>1.5.2    map高阶函数</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 要求将已经过滤的新数组每项乘以2</span><span class="token comment" spellcheck="true">//map函数同样会遍历数组每一项，传入回调函数为参数，num是map遍历的每一项，回调函数function返回值会被添加到新数组中</span><span class="token keyword">let</span> newNums2 <span class="token operator">=</span> newNums<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> num <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//简写</span><span class="token comment" spellcheck="true">//  let newNums2 = newNums.map(num =&gt; num * 2)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newNums2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="1-5-3-reduce高阶函数"><a href="#1-5-3-reduce高阶函数" class="headerlink" title="1.5.3    reduce高阶函数"></a>1.5.3    reduce高阶函数</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 3.reduce高阶函数</span><span class="token comment" spellcheck="true">//要求将newNums2的数组所有数累加</span><span class="token comment" spellcheck="true">//reduce函数同样会遍历数组每一项，传入回调函数和‘0’为参数，0表示回调函数中preValue初始值为0，回调函数中参数preValue是每一次回调函数function返回的值，currentValue是当前值</span><span class="token comment" spellcheck="true">//例如数组为[154, 110, 200, 400],则回调函数第一次返回值为0+154=154，第二次preValue为154，返回值为154+110=264，以此类推直到遍历完成</span><span class="token keyword">let</span> newNum <span class="token operator">=</span> newNums2<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>preValue<span class="token punctuation">,</span>currentValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> preValue <span class="token operator">+</span> currentValue <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//简写</span><span class="token comment" spellcheck="true">// let newNum = newNums2.reduce((preValue,currentValue) =&gt; preValue + currentValue)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newNum<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="1-5-4综合使用"><a href="#1-5-4综合使用" class="headerlink" title="1.5.4综合使用"></a>1.5.4综合使用</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//三个需求综合</span><span class="token keyword">let</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>num <span class="token operator">=</span><span class="token operator">&gt;</span> num <span class="token operator">&gt;</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>num <span class="token operator">=</span><span class="token operator">&gt;</span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>preValue<span class="token punctuation">,</span>currentValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> preValue <span class="token operator">+</span> currentValue<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="（二）HelloVue"><a href="#（二）HelloVue" class="headerlink" title="（二）HelloVue"></a>（二）HelloVue</h2><h3 id="2-1-HelloVuejs"><a href="#2-1-HelloVuejs" class="headerlink" title="2.1    HelloVuejs"></a>2.1    HelloVuejs</h3><p>​    如何开始学习Vue，当然是写一个最简单的demo，直接上代码。此处通过cdn<code>&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"&gt;&lt;/script&gt;</code>获取vuejs。</p><p>​    vue是声明式编程，区别于jquery的命令式编程。</p><h4 id="2-1-1命令式编程"><a href="#2-1-1命令式编程" class="headerlink" title="2.1.1命令式编程"></a>2.1.1命令式编程</h4><p>​    原生js做法（命令式编程）</p><ol><li>创建div元素，设置id属性</li><li>定义一个变量叫message</li><li>将message变量放在div元素中显示</li><li>修改message数据</li><li>将修改的元素替换到div</li></ol><h4 id="2-1-2声明式编程"><a href="#2-1-2声明式编程" class="headerlink" title="2.1.2声明式编程"></a>2.1.2声明式编程</h4><p>​    vue写法（声明式）</p><ol><li>创建一个div元素，设置id属性</li><li>定义一个vue对象，将div挂载在vue对象上</li><li>在vue对象内定义变量message，并绑定数据</li><li>将message变量放在div元素上显示</li><li>修改vue对象中的变量message，div元素数据自动改变</li></ol><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>HelloVuejs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">//let变量/const常量</span>    <span class="token comment" spellcheck="true">//编程范式：声明式编程</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//用于挂载要管理的元素</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//定义数据</span>        message<span class="token punctuation">:</span><span class="token string">"HelloVuejs"</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span><span class="token string">"zzz"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    在谷歌浏览器中按F12，在开发者模式中console控制台，改变vue对象的message值，页面显示也随之改变。</p><p>​    <code></code>表示将变量message输出到标签h2中，所有的vue语法都必须在vue对象挂载的div元素中，如果在div元素外使用是不生效的。<code>el:"#app"</code>表示将id为app的div挂载在vue对象上，data表示变量对象。</p><h3 id="2-2-vue列表的展示（v-for）"><a href="#2-2-vue列表的展示（v-for）" class="headerlink" title="2.2    vue列表的展示（v-for）"></a>2.2    vue列表的展示（v-for）</h3><p>​    开发中常用的数组有许多数据，需要全部展示或者部分展示，在原生JS中需要使用for循环遍历依次替换div元素，在vue中，使用<code>v-for</code>可以简单遍历生成元素节点。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>vue列表展示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in movies<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//用于挂载要管理的元素</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//定义数据</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span><span class="token punctuation">,</span>        movies<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"星际穿越"</span><span class="token punctuation">,</span><span class="token string">"海王"</span><span class="token punctuation">,</span><span class="token string">"大话西游"</span><span class="token punctuation">,</span><span class="token string">"复仇者联盟"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//定义一个数组</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>显示结果如图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/2.2.1-1.png" alt="image"></p><p>​    <code>&lt;li v-for="(item, index) in movies" :key="index"&gt;&lt;/li&gt;</code>item表示当前遍历的元素，index表示元素索引， 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。</p><blockquote><p> 不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。 </p></blockquote><h3 id="2-3-vue案例-计数器"><a href="#2-3-vue案例-计数器" class="headerlink" title="2.3    vue案例-计数器"></a>2.3    vue案例-计数器</h3><p>​    使用vue实现一个小计数器，点击<code>+</code>按钮，计数器+1，使用<code>-</code>按钮计数器-1。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>vue计数器<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>当前计数：{{count}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- &lt;button v-on:click="count--"&gt;-&lt;/button&gt;      &lt;button v-on:click="count++"&gt;+&lt;/button&gt; --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sub()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//用于挂载要管理的元素</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//定义数据</span>        count<span class="token punctuation">:</span><span class="token number">0</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        add<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        sub<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"sub"</span><span class="token punctuation">)</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><p>定义vue对象并初始化一个变量<code>count=0</code></p></li><li><p>定义两个方法<code>add</code>和<code>sub</code>，用于对<code>count++</code>或者<code>count--</code></p></li><li><p>定义两个<code>button</code>对象，给<code>button</code>添加上点击事件</p><p>在vue对象中使用methods表示方法集合，使用<code>v-on:click</code>的关键字给元素绑定监听点击事件，给按钮分别绑定上点击事件，并绑定触发事件后回调函数<code>add</code>和<code>sub</code>。也可以在回调方法中直接使用表达式。例如：<code>count++</code>和<code>count--</code>。</p></li></ol><h2 id="（三）插值操作"><a href="#（三）插值操作" class="headerlink" title="（三）插值操作"></a>（三）插值操作</h2><h3 id="3-1-Mustache语法"><a href="#3-1-Mustache语法" class="headerlink" title="3.1    Mustache语法"></a>3.1    <code>Mustache</code>语法</h3><pre><code>​    mustache是胡须的意思，因为 `{{ }}` 像胡须，又叫大括号语法。​    在vue对象挂载的dom元素中， `{{ }}`不仅可以直接写变量，还可以写简单表达式。</code></pre><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Mustache的语法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}},啧啧啧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- Mustache的语法不仅可以直接写变量，还可以写简单表达式 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{firstName + lastName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{firstName + " " + lastName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{firstName}}{{lastName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{count * 2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span><span class="token punctuation">,</span>        firstName<span class="token punctuation">:</span><span class="token string">"skt t1"</span><span class="token punctuation">,</span>        lastName<span class="token punctuation">:</span><span class="token string">"faker"</span><span class="token punctuation">,</span>        count<span class="token punctuation">:</span><span class="token number">100</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="3-2-v-once"><a href="#3-2-v-once" class="headerlink" title="3.2    v-once"></a>3.2    <code>v-once</code></h3><p>​    <code>v-once</code>表示该<code>dom</code>元素只渲染一次，之后数据改变，不会再次渲染。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 只会渲染一次，数据改变不会再次渲染 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-once</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    上述<code></code>的message修改后，第一个h2标签数据会自动改变，第二个h2不会。</p><h3 id="3-3-v-html"><a href="#3-3-v-html" class="headerlink" title="3.3    v-html"></a>3.3    <code>v-html</code></h3><p>​    在某些时候我们不希望直接输出<code>&lt;a href='http://www.baidu.com'&gt;百度一下&lt;/a&gt;</code>这样的字符串，而输出被html自己转化的超链接。此时可以使用<code>v-html</code>。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-html指令的使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>不使用v-html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{url}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>使用v-html，直接插入html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-html</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span><span class="token string">"&lt;a href='http://www.baidu.com'&gt;百度一下&lt;/a&gt;"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>输出结果如下：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/3.3-1.png" alt="image"></p><h3 id="3-4-v-text"><a href="#3-4-v-text" class="headerlink" title="3.4 v-text"></a>3.4 <code>v-text</code></h3><blockquote><p><code>v-text</code>会覆盖dom元素中的数据，相当于js的innerHTML方法。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-text指令的使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>不使用v-text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}}，啧啧啧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>使用v-text，以文本形式显示,会覆盖<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>，啧啧啧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><pre><code>如图所示，使用`{{message}}`是拼接变量和字符串，而是用`v-text`是直接覆盖字符串内容。</code></pre><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/3.4-1.png" alt="image"></p><h3 id="3-5-v-pre"><a href="#3-5-v-pre" class="headerlink" title="3.5    v-pre"></a>3.5    <code>v-pre</code></h3><blockquote><p>有时候我们期望直接输出<code>{{message}}</code>这样的字符串，而不是被<code>{{}}</code>语法转化的message的变量值，此时我们可以使用<code>v-pre</code>标签。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-pre指令的使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>不使用v-pre<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>使用v-pre,不会解析<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-pre</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>结果如图，使用<code>v-pre</code>修饰的dom会直接输出字符串。</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/3.5-1.png" alt="image"></p><h3 id="3-6-v-cloak"><a href="#3-6-v-cloak" class="headerlink" title="3.6    v-cloak"></a>3.6    <code>v-cloak</code></h3><blockquote><p>有时候因为加载延时问题，例如卡掉了，数据没有及时刷新，就造成了页面显示从<code></code>到message变量“你好啊”的变化，这样闪动的变化，会造成用户体验不好。此时需要使用到<code>v-cloak</code>的这个标签。在vue解析之前，div属性中有<code>v-cloak</code>这个标签，在vue解析完成之后，v-cloak标签被移除。简单，类似div开始有一个css属性<code>display:none;</code>，加载完成之后，css属性变成<code>display:block</code>，元素显示出来。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-cloak指令的使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">    <span class="token selector"><span class="token attribute">[v-cloak]</span></span><span class="token punctuation">{</span>      <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span> <span class="token attr-name">v-cloak</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">//在vue解析前，div中有一个属性cloak</span>    <span class="token comment" spellcheck="true">//在vue解析之后，div中没有一个属性v-cloak</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token punctuation">{</span>          message<span class="token punctuation">:</span> <span class="token string">"你好啊"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>这里通过延时1秒模拟加载卡住的状态，结果一开始不显示message的值，div元素中有v-cloak的属性，1秒后显示message变量的值，div中的v-cloak元素被移除。</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/3.6-1.gif" alt="image"></p><h2 id="（四）动态绑定属性"><a href="#（四）动态绑定属性" class="headerlink" title="（四）动态绑定属性"></a>（四）动态绑定属性</h2><h3 id="4-1-v-bind的基本使用"><a href="#4-1-v-bind的基本使用" class="headerlink" title="4.1    v-bind的基本使用"></a>4.1    v-bind的基本使用</h3><blockquote><p>某些时候我们并不想将变量放在标签内容中，像这样<code>&lt;h2&gt;&lt;/h2&gt;</code>是将变量h2标签括起来，类似js的innerHTML。但是我们期望将变量<code>imgURL</code>写在如下位置，想这样<code>&lt;img src="imgURL" alt=""&gt;</code>导入图片是希望动态获取图片的链接，此时的imgURL并非变量而是字符串imgURL，如果要将其生效为变量，需要使用到一个标签<code>v-bind:</code>，像这样<code>&lt;img v-bind:src="imgURL" alt=""&gt;</code>，而且这里也不能使用Mustache语法，类似<code>&lt;img v-bind:src="" alt=""&gt;</code>，这也是错误的。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-bind的基本使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 错误的做法这里不能使用Mustache语法 --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;img v-bind:src="{{imgURL}}" alt=""&gt; --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- 正确的做法使用v-bind指令 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>imgURL<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aHerf<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 语法糖写法 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">:src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>imgURL<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aHerf<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span><span class="token punctuation">,</span>        imgURL<span class="token punctuation">:</span><span class="token string">"https://cn.bing.com/th?id=OIP.NaSKiHPRcquisK2EehUI3gHaE8&amp;pid=Api&amp;rs=1"</span><span class="token punctuation">,</span>        aHerf<span class="token punctuation">:</span><span class="token string">"http://www.baidu.com"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>此时vue对象中定义的<code>imgURL</code>变量和<code>aHerf</code>变量可以动态的绑定到img标签的src属性和a标签的href属性。<code>v-bind:</code>由于用的很多，vue对他有一个语法糖的优化写法也就是<code>:</code>，此时修改imgURL变量图片叶重新加载。</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/4.1-1.gif" alt="image"></p><h3 id="4-2-v-bind动态绑定class-对象语法"><a href="#4-2-v-bind动态绑定class-对象语法" class="headerlink" title="4.2    v-bind动态绑定class(对象语法)"></a>4.2    v-bind动态绑定class(对象语法)</h3><blockquote><p>有时候我们期望对Dom元素的节点的class进行动态绑定，选择此Dom是否有指定class属性。例如，给h2标签加上<code>class="active"</code>，当Dom元素有次class时候，变红<code>&lt;style&gt;.active{color:red;}&lt;/style&gt;</code>，在写一个按钮绑定事件，点击变黑色，再次点击变红色。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-bind动态绑定class(对象语法)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">    <span class="token selector"><span class="token class">.active</span></span><span class="token punctuation">{</span>      <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;h2 class="active"&gt;{{message}}&lt;/h2&gt;    &lt;h2 :class="active"&gt;{{message}}&lt;/h2&gt; --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- 动态绑定class对象用法  --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;h2 :class="{key1:value1,key2:value2}"&gt;{{message}}&lt;/h2&gt;    &lt;h2 :class="{类名1:true,类名2:boolean}"&gt;{{message}}&lt;/h2&gt; --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{active:isActive}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getClasses()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>change<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>点击变色<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span><span class="token punctuation">,</span>        active<span class="token punctuation">:</span><span class="token string">"active"</span><span class="token punctuation">,</span>        isActive<span class="token punctuation">:</span><span class="token boolean">true</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>isActive <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isActive        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">getClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">{</span>active<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>isActive<span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>定义两个变量<code>active</code>和<code>isActive</code>，在Dom元素中使用<code>:class={active:isActive}</code>，此时绑定的<code>class='active'</code>，isActive为true，active显示，定义方法change()绑定在按钮上，点击按钮<code>this.isActive = !this.isActive</code>，控制Dom元素是否有<code>class='active'</code>的属性。</p></blockquote><h3 id="4-3-v-bind动态绑定class-数组用法"><a href="#4-3-v-bind动态绑定class-数组用法" class="headerlink" title="4.3    v-bind动态绑定class(数组用法)"></a>4.3    v-bind动态绑定class(数组用法)</h3><blockquote><p>class属性中可以放数组，会依次解析成对应的class。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-bind动态绑定class(数组用法)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 加上单引号当成字符串 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>[<span class="token punctuation">'</span>active<span class="token punctuation">'</span>,<span class="token punctuation">'</span>line<span class="token punctuation">'</span>]<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 不加会被当成变量 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>[active,line]<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getClasses()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span><span class="token punctuation">,</span>        active<span class="token punctuation">:</span><span class="token string">"aaaa"</span><span class="token punctuation">,</span>        line<span class="token punctuation">:</span><span class="token string">'bbbb'</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">getClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>line<span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><p>加上单引号的表示字符串</p></li><li><p>不加的会当成变量</p></li><li><p>可以直接使用方法返回数组对象</p></li></ol><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/4.3-2.png" alt="image"></p><h3 id="4-4-v-for和v-bind结合"><a href="#4-4-v-for和v-bind结合" class="headerlink" title="4.4    v-for和v-bind结合"></a>4.4    v-for和v-bind结合</h3><blockquote><p>使用v-for和v-bind实现一个小demo，将电影列表展示，并点击某一个电影列表时候，将此电影列表变成红色。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>作业(v-for和v-bind的结合)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">    <span class="token selector"><span class="token class">.active</span></span><span class="token punctuation">{</span>      <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in movies<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{active:index<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span>currentIndex}<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>changeColor(index)<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>{{index+"---"+item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        currentIndex<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>        movies<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"海王"</span><span class="token punctuation">,</span><span class="token string">"海贼王"</span><span class="token punctuation">,</span><span class="token string">"火影忍者"</span><span class="token punctuation">,</span><span class="token string">"复仇者联盟"</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">changeColor</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>currentIndex <span class="token operator">=</span> index        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>v-for时候的index索引，给每行绑定事件点击事件，点击当行是获取此行索引index并赋值给<code>currentIndex</code>，使用<code>v-bind:</code>绑定class，当<code>index===currentIndex</code>Dom元素有active的class，颜色变红。</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/4.4-1.gif" alt="image"></p><h3 id="4-5-v-bind动态绑定style"><a href="#4-5-v-bind动态绑定style" class="headerlink" title="4.5    v-bind动态绑定style"></a>4.5    v-bind动态绑定style</h3><h4 id="4-5-1-v-bind动态绑定style-对象语法"><a href="#4-5-1-v-bind动态绑定style-对象语法" class="headerlink" title="4.5.1    v-bind动态绑定style(对象语法)"></a>4.5.1    v-bind动态绑定style(对象语法)</h4><pre class=" language-html"><code class="language-html">    <span class="token comment" spellcheck="true">&lt;!-- &lt;h2 :style="{key(属性名):value(属性值)}"&gt;{{message}}&lt;/h2&gt; --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- 加单引号，当成字符串解析 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token punctuation">{</span><span class="token property">fontSize</span><span class="token punctuation">:</span><span class="token string">'50px'</span><span class="token punctuation">}</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 不加单引号，变量解析 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token punctuation">{</span><span class="token property">fontSize</span><span class="token punctuation">:</span>fontSize<span class="token punctuation">}</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token function">getStyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="4-5-2-v-bind动态绑定style-数组语法"><a href="#4-5-2-v-bind动态绑定style-数组语法" class="headerlink" title="4.5.2     v-bind动态绑定style(数组语法)"></a>4.5.2     <code>v-bind</code>动态绑定<code>style</code>(数组语法)</h4><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">[baseStyle]</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token function">getStyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"你好啊"</span><span class="token punctuation">,</span>        baseStyle<span class="token punctuation">:</span><span class="token punctuation">{</span>backgroundColor<span class="token punctuation">:</span><span class="token string">'red'</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">getStyle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>baseStyle<span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    类似绑定class，绑定style也是一样的。</p><h2 id="（五）计算属性"><a href="#（五）计算属性" class="headerlink" title="（五）计算属性"></a>（五）计算属性</h2><h3 id="5-1-计算属性的基本使用"><a href="#5-1-计算属性的基本使用" class="headerlink" title="5.1    计算属性的基本使用"></a>5.1    计算属性的基本使用</h3><p>​现在有变量姓氏和名字，要得到完整的名字。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>计算属性的基本使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- Mastache语法 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{firstName+ " " + lastName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 方法 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{getFullName()}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 计算属性 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{fullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        firstName<span class="token punctuation">:</span><span class="token string">"skt t1"</span><span class="token punctuation">,</span>        lastName<span class="token punctuation">:</span><span class="token string">"faker"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>        fullName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">getFullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><pre><code>1. 使用Mastache语法拼接`&lt;h2&gt;{{firstName+ " " + lastName}}&lt;/h2&gt;`2. 使用方法methods`&lt;h2&gt;{{getFullName()}}&lt;/h2&gt;`3. 使用计算属性computed`&lt;h2&gt;{{fullName}}&lt;/h2&gt;`</code></pre><blockquote><p>​    例子中计算属性computed看起来和方法似乎一样，只是方法调用需要使用()，而计算属性不用，方法取名字一般是动词见名知义，而计算属性是属性是名词，但这只是基本使用。</p></blockquote><h3 id="5-2-计算属性的复杂使用"><a href="#5-2-计算属性的复杂使用" class="headerlink" title="5.2    计算属性的复杂使用"></a>5.2    计算属性的复杂使用</h3><p>​    现在有一个数组数据books，里面包含许多book对象，数据结构如下：</p><pre class=" language-javascript"><code class="language-javascript">books<span class="token punctuation">:</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">110</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"JavaScript从入门到入土"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">119</span><span class="token punctuation">}</span><span class="token punctuation">,</span>           <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">111</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"Java从入门到放弃"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">80</span><span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">112</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"编码艺术"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">99</span><span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">113</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"代码大全"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">150</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span></code></pre><p>​    要求计算出所有book的总价格<code>totalPrice</code>。</p><p>​    </p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>计算属性的复杂使用<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>总价格：{{totalPrice}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        books<span class="token punctuation">:</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">110</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"JavaScript从入门到入土"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">119</span><span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">111</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"Java从入门到放弃"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">80</span><span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">112</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"编码艺术"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">99</span><span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>id<span class="token punctuation">:</span><span class="token number">113</span><span class="token punctuation">,</span>name<span class="token punctuation">:</span><span class="token string">"代码大全"</span><span class="token punctuation">,</span>price<span class="token punctuation">:</span><span class="token number">150</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">totalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">let</span> result<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>books<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>books<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>price<span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> result        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    获取每一个book对象的price累加，当其中一个book的价格发生改变时候，总价会随之变化。</p><h3 id="5-3-计算属性的setter和getter"><a href="#5-3-计算属性的setter和getter" class="headerlink" title="5.3    计算属性的setter和getter"></a>5.3    计算属性的setter和getter</h3><p>​    在计算属性中其实是由这样两个方法setter和getter。</p><pre class=" language-javascript"><code class="language-javascript">      computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>        fullName<span class="token punctuation">:</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//计算属性一般没有set方法，只读属性</span>          <span class="token keyword">set</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"-----"</span><span class="token punctuation">)</span>            <span class="token keyword">const</span> names <span class="token operator">=</span> newValue<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> names<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token keyword">get</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span></code></pre><p>​    但是计算属性一般没有set方法，只读属性，只有get方法，但是上述中newValue就是新的值，也可以使用set方法设置值，但是一般不用。</p><p><strong><em>computed的getter/setter</em></strong></p><blockquote><p>请看如下代码：</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Vue计算属性的getter和setter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>计算属性：computed的getter/setter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>fullName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>            {{fullName}}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>firstName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>            {{firstName}}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>lastName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>            {{lastName}}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">            <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span>                firstName<span class="token punctuation">:</span><span class="token string">"zhang"</span><span class="token punctuation">,</span>                lastName<span class="token punctuation">:</span><span class="token string">"san"</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    fullName<span class="token punctuation">:</span><span class="token punctuation">{</span>                        <span class="token keyword">get</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName                        <span class="token punctuation">}</span><span class="token punctuation">,</span>                        <span class="token keyword">set</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token keyword">var</span> list <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">=</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                            <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token operator">=</span>list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p><em>初始化</em></p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/6.png" alt="image"></p><blockquote><p>修改fullName*</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/7.png" alt="image"></p><blockquote><p><em>结论</em></p></blockquote><p>- 通过这种方式，我们可以在改变计算属性值的同时也改变和计算属性相关联的属性值。</p><h3 id="5-4-计算属性和methods的对比"><a href="#5-4-计算属性和methods的对比" class="headerlink" title="5.4    计算属性和methods的对比"></a>5.4    计算属性和methods的对比</h3><p>​    直接看代码，分别使用计算属性和方法获得fullName的值。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>计算属性和methods的对比<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- methods，即使firstName和lastName没有改变，也需要再次执行 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{getFullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{getFullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{getFullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{getFullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 计算属性有缓存，只有关联属性改变才会再次计算 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{fullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{fullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{fullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{fullName}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        firstName<span class="token punctuation">:</span><span class="token string">"skt t1"</span><span class="token punctuation">,</span>        lastName<span class="token punctuation">:</span><span class="token string">"faker"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了计算属性fullName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">getFullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了getFullName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    分别使用方法和计算属性获取四次fullName，结果如图。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/5.4-1.png" alt="image"></p><p>​    由此可见计算属性有缓存，在<code>this.firstName + " " + this.lastName</code>的属性不变的情况下，methods调用了四次，而计算属性才调用了一次，性能上计算属性明显比methods好。而且在改动firstName的情况下，计算属性只调用一次，methods依然要调用4次。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/5.4-2.png" alt="image"></p><h3 id="5-5-Vue计算属性与侦听器总结"><a href="#5-5-Vue计算属性与侦听器总结" class="headerlink" title="5.5    Vue计算属性与侦听器总结"></a>5.5    Vue计算属性与侦听器总结</h3><blockquote><p><strong>照例看一段代码：</strong></p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Vue计算属性/侦听器/方法比较<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>计算属性：computed<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>            {{fullName}}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>方法：methods<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>            {{fullName2()}}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>侦听器：watch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>            {{watchFullName}}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>年龄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>            {{age}}        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">            <span class="token keyword">var</span> other <span class="token operator">=</span> <span class="token string">'This is other'</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span>                firstName<span class="token punctuation">:</span><span class="token string">"zhang"</span><span class="token punctuation">,</span>                lastName<span class="token punctuation">:</span><span class="token string">"san"</span><span class="token punctuation">,</span>                watchFullName<span class="token punctuation">:</span><span class="token string">"zhangsan"</span><span class="token punctuation">,</span>                age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    firstName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>newFirstName<span class="token punctuation">,</span> oldFirstName<span class="token punctuation">)</span><span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"firstName触发了watch,newFirstName="</span><span class="token operator">+</span>newFirstName<span class="token operator">+</span><span class="token string">",oldFirstName="</span><span class="token operator">+</span>oldFirstName<span class="token punctuation">)</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>watchFullName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>other                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                    lastName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>newLastName<span class="token punctuation">,</span> oldLastName<span class="token punctuation">)</span><span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"lastName触发了watch,newLastName="</span><span class="token operator">+</span>newLastName<span class="token operator">+</span><span class="token string">",oldLastName="</span><span class="token operator">+</span>oldLastName<span class="token punctuation">)</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>watchFullName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>other                    <span class="token punctuation">}</span>                  <span class="token punctuation">}</span><span class="token punctuation">,</span>                computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    fullName<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了fullName,计算了一次属性"</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>other<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>                    fullName2<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了fullName,执行了一次方法"</span><span class="token punctuation">)</span>                        fullName2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>other<span class="token punctuation">;</span>                        <span class="token keyword">return</span> fullName2<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>初始化：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/1.png" alt="image"></p></blockquote><blockquote><p>修改firstName/lastName/两者都修改</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/2.png" alt="image"></p><blockquote><p>修改computed中没计算的age</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/3.png" alt="image"></p><blockquote><p>修改Vue实例外的对象</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/4.png" alt="image"></p><blockquote><p>修改Vue实例外对象后在修改Vue实例内的对象</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/5.png" alt="image"></p><blockquote><p>测试结论：</p></blockquote><ol><li>使用computed计算了fullName属性，值为firstName+lastName。计算属性具有<code>缓存功能</code>，当firstName和lastName都不改变的时候，fullName不会重新计算，比如我们改变age的值，fullName的值是不需要重新计算的。</li><li>methods并没有缓存特性，比如我们改变age的值，fullName2()方法会被执行一遍。</li><li>当一个功能可以用上面三个方法来实现的时候，明显使用computed更合适，代码简单也有缓存特性。</li><li>计算属性范围在vue实例内，修改vue实例外部对象，不会重新计算渲染，但是如果先修改了vue实例外对象，在修改vue计算属性的对象，那么外部对象的值也会重新渲染。</li></ol><blockquote><p><em>计算属性：computed</em></p></blockquote><p>计算属性范围在Vue实例的fullName内所管理的firstName和lastName,通常监听多个变量</p><blockquote><p><em>侦听器：watch</em></p></blockquote><p>监听数据变化，一般只监听一个变量或数组</p><blockquote><p>使用场景</p></blockquote><p>watch(<code>异步场景</code>)，computed(<code>数据联动</code>)</p><h2 id="（六）事件监听"><a href="#（六）事件监听" class="headerlink" title="（六）事件监听"></a>（六）事件监听</h2><h3 id="6-1-v-on的基本使用"><a href="#6-1-v-on的基本使用" class="headerlink" title="6.1    v-on的基本使用"></a>6.1    v-on的基本使用</h3><p>​    在前面的计数器案例中使用了<code>v-on:click</code>监听单击事件。这里在回顾一下：</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{count}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- &lt;button v-on:click="count++"&gt;加&lt;/button&gt;      &lt;button v-on:click="count--"&gt;减&lt;/button&gt; --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>increment<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>加<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>decrement()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>减<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        count<span class="token punctuation">:</span><span class="token number">0</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    使用<code>v-on:click</code>给button绑定监听事件以及回调函数，@是<code>v-on:</code>的语法糖，也就是简写也可以使用<code>@click</code>。方法一般是需要写方法名加上()，在<code>@click</code>中可以省掉，如上述的<code>&lt;button @click="increment"&gt;加&lt;/button&gt;</code>。</p><h3 id="6-2-v-on的参数传递"><a href="#6-2-v-on的参数传递" class="headerlink" title="6.2    v-on的参数传递"></a>6.2    v-on的参数传递</h3><p>​    了解了v-on的基本使用，现在需要了解参数传递。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 事件没传参 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 事件调用方法传参，写函数时候省略小括号，但是函数本身需要传递一个参数 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick2(123)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick2()<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 事件调用时候需要传入event还需要传入其他参数 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick3($event,123)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token function">btnClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"点击XXX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">btnClick2</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">"----------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">btnClick3</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token operator">+</span><span class="token string">"----------"</span><span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>    </code></pre><ol><li>事件没传参，可以省略()</li><li>事件调用方法传参了，写函数时候省略了小括号，但是函数本身是需要传递一个参数的，这个参数就是原生事件event参数传递进去</li><li>如果同时需要传入某个参数，同时需要event是，可以通过<code>$event</code>传入事件。</li></ol><p>按钮4调用<code>btnClick2(value){}</code>，此时<code>undefined</code>。按钮5调用时省略了()，会自动传入原生event事件，如果我们需要event对象还需要传入其他参数，可以使用<code>$event</code>对象。</p><h3 id="6-3-v-on的修饰词"><a href="#6-3-v-on的修饰词" class="headerlink" title="6.3    v-on的修饰词"></a>6.3    v-on的修饰词</h3><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-on的修饰符<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!--1. .stop的使用，btn的click事件不会传播，不会冒泡到上层，调用event.stopPropagation() --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>divClick<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click.stop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>按钮1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 2. .prevent 调用event.preeventDefault阻止默认行为  --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>www.baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">@click.prevent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submitClick<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!--3. 监听键盘的事件 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">@click.enter</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>keyup<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token function">btnClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"点击button"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">divClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"点击div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">submitClcik</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"提交被阻止了"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">keyup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"keyup点击"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><code>.stop</code>的使用，btn的click事件不会传播，不会冒泡到上层，调用<code>event.stopPropagation()</code>。</li><li><code>.prevent</code> 调用<code>event.preeventDefault</code>阻止默认行为。</li><li><code>.enter</code>监听键盘事件</li></ol><h2 id="（七）条件判断"><a href="#（七）条件判断" class="headerlink" title="（七）条件判断"></a>（七）条件判断</h2><h3 id="7-1-v-if、v-eles、v-else-if"><a href="#7-1-v-if、v-eles、v-else-if" class="headerlink" title="7.1    v-if、v-eles、v-else-if"></a>7.1    v-if、v-eles、v-else-if</h3><p>​    v-if用于条件判断，判断Dom元素是否显示。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isFlag<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>isFlag为true显示这个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>isShow为true是显示这个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age&lt;18<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>小于18岁未成年<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age&lt;60<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>大于18岁小于60岁正值壮年<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-else</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>大于60岁,暮年<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        isFlag<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>        isShow<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span><span class="token number">66</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><p>单独使用v-if，变量为布尔值，为true才渲染Dom</p></li><li><p>v-show的变量也是布尔值，为true才显示内容，类似css的display</p></li><li><p>v-if、v-else、v-else-if联合使用相当于if、elseif、else，但是在条件比较多的时候建议使用计算属性。</p></li></ol><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/7.1-1.png" alt="image"></p><h3 id="7-2-v-if的demo"><a href="#7-2-v-if的demo" class="headerlink" title="7.2    v-if的demo"></a>7.2    v-if的demo</h3><p>​    在登录网站是经常可以选择使用账户名或者邮箱登录的切换按钮。要求点击按钮切换登录方式。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isUser<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>用户账号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-else</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isUser<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>用户邮箱<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入用户邮箱<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isUser<span class="token punctuation">=</span>!isUser<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>切换类型<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        isUser<span class="token punctuation">:</span><span class="token boolean">true</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    使用<code>v-if</code>和<code>v-else</code>选择渲染指定的Dom，点击按钮对<code>isUser</code>变量取反。</p><blockquote><p>这里有个小问题，如果已经输入了账号了，此时想切换到邮箱输入，输入框未自己清空。</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/7.2-1.gif" alt="image"></p><p>​    这里需要了解一下vue底层操作，此时input输入框值被复用了。</p><ol><li><p>vue在进行DOM渲染是，处于性能考虑，会复用已经存在的元素，而不是每次都创建新的DOM元素。</p></li><li><p>在上面demo中，Vue内部发现原来的input元素不再使用，所以直接将其映射对应虚拟DOM，用来复用。</p></li><li><p>如果不希望出现类似复用问题，可以给对应的dom元素加上<code>key</code>值，并保证<code>key</code>不同。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入用户邮箱<span class="token punctuation">"</span></span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span></code></pre></li></ol><h3 id="7-3-v-show"><a href="#7-3-v-show" class="headerlink" title="7.3    v-show"></a>7.3    v-show</h3><p>​    v-if看似和v-show实现一样的效果，但是内部v-show只是用css将操作的元素隐藏显示，而v-if是新增和删除元素。v-show只是操作元素的style属性display，都没会被创建。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isFlag<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>v-show只是操作元素的style属性display，都没会被创建<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isFlag<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>v-if是新增和删除dom元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        isFlag<span class="token punctuation">:</span><span class="token boolean">true</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><h2 id="（八）遍历循环"><a href="#（八）遍历循环" class="headerlink" title="（八）遍历循环"></a>（八）遍历循环</h2><h3 id="8-1-v-for遍历数组"><a href="#8-1-v-for遍历数组" class="headerlink" title="8.1    v-for遍历数组"></a>8.1    v-for遍历数组</h3><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 1.遍历过程没有使用索引（下标值） --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in names<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 2.遍历过程有使用索引（下标值） --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,index) in names<span class="token punctuation">"</span></span>  <span class="token punctuation">&gt;</span></span>{{index+":"+item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        names<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"zzz"</span><span class="token punctuation">,</span><span class="token string">"ttt"</span><span class="token punctuation">,</span><span class="token string">"yyy"</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    一般需要使用索引值。<code>&lt;li v-for="(item,index) in names"  &gt;undefined:undefined&lt;/li&gt;</code>index表示索引，item表示当前遍历的元素。</p><h3 id="8-2-v-for遍历对象"><a href="#8-2-v-for遍历对象" class="headerlink" title="8.2    v-for遍历对象"></a>8.2    v-for遍历对象</h3><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 1.遍历过程没有使用index索引--&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- 格式为：key-value --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,key) in user<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>{{key+"-"+item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 格式为：key-value-index --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,key,index) in user<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>{{key+"-"+item+"-"+index}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        user<span class="token punctuation">:</span><span class="token punctuation">{</span>          name<span class="token punctuation">:</span><span class="token string">"zzz"</span><span class="token punctuation">,</span>          height<span class="token punctuation">:</span><span class="token number">188</span><span class="token punctuation">,</span>          age<span class="token punctuation">:</span><span class="token number">24</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li>遍历过程没有使用index索引，<code>&lt;li v-for="(item,key) in user" &gt;undefined-undefined&lt;/li&gt;</code>，item表示当前元素是属性值，key表示user对象属性名。</li><li>遍历过程使用index索引，index表示索引从0开始。</li><li><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/8.2-1.png" alt="image"></li></ol><h3 id="8-3-v-for使用key"><a href="#8-3-v-for使用key" class="headerlink" title="8.3    v-for使用key"></a>8.3    v-for使用key</h3><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-for使用key<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 不加key如果要插入f依次改变 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in letters<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>没有key<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 加key如果要插入f使用diff算法高效,如果使用index做key一直变，所以item如果唯一可以使用item--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in letters<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>有key<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        letters<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">add1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>letters<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>letters<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><p>使用key可以提高效率，加key如果要插入f使用diff算法高效,如果使用index做key一直变，所以item如果唯一可以使用item。</p></li><li><p>不加key如果要插入f依次替换。</p></li></ol><p>   <strong>v-for加key与不加</strong><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/8.3-1.png" alt="image"></p><blockquote><p>​    不加key渲染时候会依次替换渲染，加了key会直接将其放在指定位置，加key提升效率。</p></blockquote><h3 id="8-4-数组的响应方式"><a href="#8-4-数组的响应方式" class="headerlink" title="8.4    数组的响应方式"></a>8.4    数组的响应方式</h3><p>​    我们改变DOM绑定的数据时，DOM会动态的改变值。数组也是一样的。但是对于动态变化数据，有要求，不是任何情况改变数据都会变化。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>数组的响应式方法 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 数组的响应式方法 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in letters<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>push<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>通过索引值修改数组<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        letters<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">btn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//1.push</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>letters<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'f'</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//2.pop()删除最后一个元素</span>          <span class="token comment" spellcheck="true">//this.letters.pop()</span>          <span class="token comment" spellcheck="true">//3.shift()删除第一个</span>          <span class="token comment" spellcheck="true">//this.letters.shift()</span>          <span class="token comment" spellcheck="true">//4.unshift()添加在最前面,可以添加多个</span>          <span class="token comment" spellcheck="true">//this.letters.unshift('aaa','bbb','ccc')</span>          <span class="token comment" spellcheck="true">//5.splice():删除元素/插入元素/替换元素</span>          <span class="token comment" spellcheck="true">//splice(1,1)再索引为1的地方删除一个元素,第二个元素不传，直接删除后面所有元素</span>          <span class="token comment" spellcheck="true">//splice(index,0,'aaa')再索引index后面删除0个元素，加上'aaa',</span>          <span class="token comment" spellcheck="true">//splice(1,1,'aaa')替换索引为1的后一个元素为'aaa'</span>          <span class="token comment" spellcheck="true">// this.letters.splice(2,0,'aaa')</span>          <span class="token comment" spellcheck="true">//6.sort()排序可以传入一个函数</span>          <span class="token comment" spellcheck="true">//this.letters.sort()</span>          <span class="token comment" spellcheck="true">//7.reverse()反转</span>          <span class="token comment" spellcheck="true">// this.letters.reverse()</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">btn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>letters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'f'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><p>btn2按钮是通过索引值修改数组的值，这种情况，数组letters变化，DOM不会变化。</p></li><li><p>而数组的方法，例如<code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code>等方法修改数组的数据，DOM元素会随之修改。</p></li><li><blockquote><p>splic()：删除元素、插入元素、替换元素</p><p>splice(1,1)再索引为1的地方删除一个元素,第二个元素不传，直接删除后面所有元素</p><p>splice(index,0,’aaa’)再索引index后面删除0个元素，加上’aaa’</p><p>splice(1,1,’aaa’)替换索引为1的后一个元素为’aaa’</p></blockquote></li></ol><h3 id="8-5-综合练习"><a href="#8-5-综合练习" class="headerlink" title="8.5    综合练习"></a>8.5    综合练习</h3><p>​    现在要求将数组内的电影展示到页面上，并选中某个电影，电影背景变红，为选中状态。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>综合练习<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">    <span class="token selector"><span class="token class">.active</span> </span><span class="token punctuation">{</span>      <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 数组的响应式方法 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,index) in movies<span class="token punctuation">"</span></span>  <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>liClick(index)<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{active:index<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span>curIndex}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{index+"---"+item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        movies<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'复仇者联盟'</span><span class="token punctuation">,</span> <span class="token string">'蝙蝠侠'</span><span class="token punctuation">,</span> <span class="token string">'海贼王'</span><span class="token punctuation">,</span> <span class="token string">'星际穿越'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        curIndex<span class="token punctuation">:</span><span class="token number">0</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">liClick</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>curIndex <span class="token operator">=</span> index        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li>先使用<code>v-for</code>将电影列表展示到页面上，并获取index索引定位当前的<code>&lt;li&gt;</code>标签。</li><li>给每个<code>&lt;li&gt;</code>标签加上,单击事件，并将index传入单击事件的回调函数methods的<code>liClick()</code>。</li><li>定义一个变量<code>curIndex</code>表示当前索引，初始值为0，用于表示选中状态的电影列。</li><li>定义个class样式active，在active为激活状态是，<code>background-color: red;</code>为红色。使用表达式<code>index=curIndex</code>判断当前选中状态的列。</li><li><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/8.5-1.gif" alt="image"></li></ol><h2 id="（十）v-model"><a href="#（十）v-model" class="headerlink" title="（十）v-model"></a>（十）v-model</h2><h3 id="10-1-v-model的基本使用"><a href="#10-1-v-model的基本使用" class="headerlink" title="10.1    v-model的基本使用"></a>10.1    v-model的基本使用</h3><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 输入框内容修改，message也修改，修改message，input内容也修改，双向绑定 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{message}}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"zzz"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    v-model双向绑定，既输入框的value改变，对应的message对象值也会改变，修改message的值，input的value也会随之改变。无论改变那个值，另外一个值都会变化。</p><h3 id="10-2-v-model的原理"><a href="#10-2-v-model的原理" class="headerlink" title="10.2    v-model的原理"></a>10.2    v-model的原理</h3><p>​    先来一个demo实现不使用v-model实现双向绑定。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- v-model = v-bind + v-on --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- 输入框内容修改，message也修改，修改message，input内容也修改，双向绑定 --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;input type="text" v-model="message"&gt; --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- 实现双向绑定 @input监听输入框事件  --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;input type="text" :value="message" @input="valueChange" &gt; --&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- $event获取事件对象，$event.target.value获取input值 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>valueChange($event.target.value)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    {{message}}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"zzz"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// valueChange(event){</span>        <span class="token comment" spellcheck="true">//   console.log("input值改变了");</span>        <span class="token comment" spellcheck="true">//   this.message = event.target.value</span>        <span class="token comment" spellcheck="true">// },</span>        <span class="token function">valueChange</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"input值改变了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> value        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    <code>v-model = v-bind + v-on</code>，实现双向绑定需要是用v-bind和v-on，使用v-bind给input的value绑定message对象，此时message对象改变，input的值也会改变。但是改变input的value并不会改变message的值，此时需要一个v-on绑定一个方法，监听事件，当input的值改变的时候，将最新的值赋值给message对象。<code>$event</code>获取事件对象，target获取监听的对象dom，value获取最新的值。</p><h3 id="10-3-v-model结合radio类型使用"><a href="#10-3-v-model结合radio类型使用" class="headerlink" title="10.3    v-model结合radio类型使用"></a>10.3    v-model结合radio类型使用</h3><p>​    radio单选框的<code>name</code>属性是互斥的，如果使用v-model，可以不使用<code>name</code>就可以互斥。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- name属性radio互斥 使用v-model可以不用name就可以互斥 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>male<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>male<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>男<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>男    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>female<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>female<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>女<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>女    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>你选择的性别是：{{sex}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"zzz"</span><span class="token punctuation">,</span>        sex<span class="token punctuation">:</span><span class="token string">"男"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><pre><code> v-model绑定`sex`属性，初始值为“男”，选择女后`sex`属性变成“女”，因为此时是双向绑定。</code></pre><h3 id="10-4-v-model结合checkbox类型"><a href="#10-4-v-model结合checkbox类型" class="headerlink" title="10.4    v-model结合checkbox类型"></a>10.4    v-model结合checkbox类型</h3><p>​    checkbox可以结合v-model做单选框，也可以多选框。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-model结合checkbox类型<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- checkbox单选框 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>单选框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>agree<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>agree<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isAgree<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>同意协议    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>你选择的结果是：{{isAgree}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">:disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>!isAgree<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>下一步<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- checkbox多选框 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>多选框<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">:for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in oriHobbies<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hobby<span class="token punctuation">"</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">:id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hobbies<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item}}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- &lt;input type="checkbox" name="hobby" value="篮球" v-model="hobbies"&gt;篮球      &lt;input type="checkbox" name="hobby" value="足球" v-model="hobbies"&gt;足球      &lt;input type="checkbox" name="hobby" value="羽毛球"  v-model="hobbies"&gt;羽毛球      &lt;input type="checkbox" name="hobby" value="乒乓球"  v-model="hobbies"&gt;乒乓球 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>你的爱好是：{{hobbies}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"zzz"</span><span class="token punctuation">,</span>        isAgree<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>        hobbies<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        oriHobbies<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"篮球"</span><span class="token punctuation">,</span><span class="token string">"足球"</span><span class="token punctuation">,</span><span class="token string">"羽毛球"</span><span class="token punctuation">,</span><span class="token string">"乒乓球"</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li>checkbox结合v-model实现单选框，定义变量<code>isAgree</code>初始化为<code>false</code>，点击checkbox的值为<code>true</code>，<code>isAgree</code>也是<code>true</code>。</li><li>checkbox结合v-model实现多选框，定义数组对象<code>hobbies</code>，用于存放爱好，将<code>hobbies</code>与checkbox对象双向绑定，此时选中，一个多选框，就多一个true，<code>hobbies</code>就添加一个对象。</li></ol><h3 id="10-5-v-model结合select类型"><a href="#10-5-v-model结合select类型" class="headerlink" title="10.5    v-model结合select类型"></a>10.5    v-model结合select类型</h3><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-model结合select类型<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- select单选 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruit<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruit<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>苹果<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>香蕉<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>香蕉<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>西瓜<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>西瓜<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>你选择的水果是：{{fruit}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- select多选 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruits<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fruits<span class="token punctuation">"</span></span> <span class="token attr-name">multiple</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>苹果<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>香蕉<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>香蕉<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>西瓜<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>西瓜<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>你选择的水果是：{{fruits}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        fruit<span class="token punctuation">:</span><span class="token string">"苹果"</span><span class="token punctuation">,</span>        fruits<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    v-model结合select可以单选也可以多选。</p><h3 id="10-6-v-model的修饰符的使用"><a href="#10-6-v-model的修饰符的使用" class="headerlink" title="10.6    v-model的修饰符的使用"></a>10.6    v-model的修饰符的使用</h3><h4 id="10-6-1-lazy"><a href="#10-6-1-lazy" class="headerlink" title="10.6.1    lazy"></a>10.6.1    lazy</h4><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>v-model修饰符<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>v-model修饰符<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span>lazy,默认情况是实时更新数据，加上lazy，从输入框失去焦点，按下enter都会更新数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model.lazy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span>修饰符number,默认是string类型，使用number赋值为number类型<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span> <span class="token attr-name">v-model.number</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{age}}--{{typeof age}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span>修饰符trim:去空格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model.trim</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>        message<span class="token punctuation">:</span><span class="token string">"zzz"</span><span class="token punctuation">,</span>        age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">,</span>        name<span class="token punctuation">:</span><span class="token string">"ttt"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><ol><li><code>lazy</code>默认情况下是实时更新数据，加上<code>lazy</code>，从输入框失去焦点，按下enter都会更新数据。</li><li><code>number</code>,默认是string类型，使用<code>number</code>复制为number类型。</li><li><code>trim</code>用于 自动过滤用户输入的首尾空白字符 </li></ol><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/10.6-1.png" alt="image"></p><h2 id="（十一）组件化开发"><a href="#（十一）组件化开发" class="headerlink" title="（十一）组件化开发"></a>（十一）组件化开发</h2><h3 id="11-1-组件化的基本使用"><a href="#11-1-组件化的基本使用" class="headerlink" title="11.1    组件化的基本使用"></a>11.1    组件化的基本使用</h3><p>​    简单的组件示例</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 3.使用组件 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpnc</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpnc</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 1.创建组件构造器对象</span>    <span class="token keyword">const</span> cpnc <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`        &lt;div&gt;          &lt;h2&gt;标题&lt;/h2&gt;          &lt;p&gt;内容1...&lt;p&gt;          &lt;p&gt;内容2...&lt;p&gt;        &lt;/div&gt;`</span></span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 2.注册组件</span>    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-cpn'</span><span class="token punctuation">,</span> cpnc<span class="token punctuation">)</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span><span class="token punctuation">{</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//局部组件创建</span>        cpnc<span class="token punctuation">:</span>cpnc      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>​     组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>my-cpn</code>。我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： <code>&lt;my-cpn&gt;&lt;/my-cpn&gt;</code>。</p><h4 id="11-1-1-创建组件构造器对象"><a href="#11-1-1-创建组件构造器对象" class="headerlink" title="11.1.1    创建组件构造器对象"></a>11.1.1    创建组件构造器对象</h4><p>​    <code>template</code>中是组件的DOM元素内容。</p><h4 id="11-1-2·-注册组件"><a href="#11-1-2·-注册组件" class="headerlink" title="11.1.2·    注册组件"></a>11.1.2·    注册组件</h4><ol><li>全局注册，通过 <code>Vue.component</code>。</li><li>局部注册，通过 <code>components:{cpnc:cpnc}</code>。</li></ol><h4 id="11-1-3-使用组件"><a href="#11-1-3-使用组件" class="headerlink" title="11.1.3    使用组件"></a>11.1.3    使用组件</h4><p>​        像使用html标签一样使用。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 3.使用组件 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpnc</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpnc</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/11.1-1.png" alt="image"></p><h3 id="11-2-全局组件和局部组件"><a href="#11-2-全局组件和局部组件" class="headerlink" title="11.2    全局组件和局部组件"></a>11.2    全局组件和局部组件</h3><p>​    组件的注册方式有两种，一种是全局组件一种是局部组件。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>全局组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>局部组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpnc</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpnc</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 1.创建组件构造器对象</span>    <span class="token keyword">const</span> cpnc <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`        &lt;div&gt;          &lt;h2&gt;标题&lt;/h2&gt;          &lt;p&gt;内容1&lt;/p&gt;          &lt;p&gt;内容2&lt;/p&gt;        &lt;/div&gt;`</span></span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 2.注册组件（全局组件，可以在多个vue实例中使用）</span>    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-cpn'</span><span class="token punctuation">,</span> cpnc<span class="token punctuation">)</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//局部组件创建</span>        cpnc<span class="token punctuation">:</span>cpnc      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="11-2-1-全局组件"><a href="#11-2-1-全局组件" class="headerlink" title="11.2.1    全局组件"></a>11.2.1    全局组件</h4><p>​    全局组件，可以在多个vue实例中使用，类似于全局变量。</p><p>​    使用<code>Vue.component('my-cpn', cpnc)</code>方式注册，直接使用<code>&lt;my-cpn&gt;&lt;/my-cpn&gt;</code>调用。<code>my-cpn</code>是全局组件的名字，<code>cpnc</code>是定义的组件对象。</p><h4 id="11-2-2-局部组件"><a href="#11-2-2-局部组件" class="headerlink" title="11.2.2    局部组件"></a>11.2.2    局部组件</h4><p>​    局部组件，只能在当前vue实例挂载的对象中使用，类似于局部变量，有块级作用域。</p><blockquote><p>​    注册方式</p></blockquote><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//局部组件创建</span>        cpnc<span class="token punctuation">:</span>cpnc      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>​    使用方式与全局变量一样，直接使用<code>&lt;cpnc&gt;&lt;/cpnc&gt;</code>调用。<code>cpnc:cpnc</code>第一个cpnc是给组件命名的名字，第二个是定义的组件对象。如果俩个同名也可以直接使用es6语法：</p><pre class=" language-javascript"><code class="language-javascript">components<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//局部组件创建</span>        cpnc<span class="token punctuation">}</span></code></pre><h3 id="11-3-父组件与子组件的区别"><a href="#11-3-父组件与子组件的区别" class="headerlink" title="11.3    父组件与子组件的区别"></a>11.3    父组件与子组件的区别</h3><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 1.创建组件构造器对象</span>    <span class="token keyword">const</span> cpn1 <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`        &lt;div&gt;          &lt;h2&gt;标题1&lt;/h2&gt;          &lt;p&gt;组件1&lt;/p&gt;        &lt;/div&gt;`</span></span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 组件2中使用组件1</span>    <span class="token keyword">const</span> cpn2 <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`        &lt;div&gt;          &lt;h2&gt;标题2&lt;/h2&gt;          &lt;p&gt;组件2&lt;/p&gt;          &lt;cpn1&gt;&lt;/cpn1&gt;        &lt;/div&gt;`</span></span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span><span class="token punctuation">{</span>        cpn1<span class="token punctuation">:</span>cpn1      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//局部组件创建</span>        cpn2<span class="token punctuation">:</span>cpn2      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>​    上述代码中定义了两个组件对象<code>cpn1</code>和<code>cpn2</code>，在组件<code>cpn2</code>中使用局部组件注册了<code>cpn1</code>，并在<code>template</code>中使用了注册的<code>cpn1</code>，然后在vue实例中使用注册了局部组件<code>cpn2</code>，在vue实例挂载的div中调用了<code>cpn2</code>，<code>cpn2</code>与<code>cpn1</code>形成父子组件关系。</p><blockquote><p>注意：组件就是一个vue实例，vue实例的属性，组件也可以有，例如data、methods、computed等。</p></blockquote><h3 id="11-4-注册组件的语法糖"><a href="#11-4-注册组件的语法糖" class="headerlink" title="11.4    注册组件的语法糖"></a>11.4    注册组件的语法糖</h3><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn1</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn2</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 1.注册全局组件语法糖</span>    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'cpn1'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`        &lt;div&gt;          &lt;h2&gt;全局组件语法糖&lt;/h2&gt;          &lt;p&gt;全局组件语法糖&lt;/p&gt;        &lt;/div&gt;`</span></span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//局部组件创建</span>        cpn2<span class="token punctuation">:</span><span class="token punctuation">{</span>          template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`        &lt;div&gt;          &lt;h2&gt;局部组件语法糖&lt;/h2&gt;          &lt;p&gt;局部组件语法糖&lt;/p&gt;        &lt;/div&gt;`</span></span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>注册组件时候可以不实例化组件对象，直接在注册的时候实例化。<code>{}</code>就是一个组件对象。</p><h3 id="11-5-组件模板的分离写法"><a href="#11-5-组件模板的分离写法" class="headerlink" title="11.5    组件模板的分离写法"></a>11.5    组件模板的分离写法</h3><h4 id="11-5-1-script标签"><a href="#11-5-1-script标签" class="headerlink" title="11.5.1    script标签"></a>11.5.1    script标签</h4><p>​    使用<code>script</code>标签定义组件的模板，<code>script</code>标签注意类型是<code>text/x-template</code>。</p><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 1.script标签注意类型是text/x-template --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/x-template<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>组件模板的分离写法<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>script标签注意类型是text<span class="token operator">/</span>x<span class="token operator">-</span>template<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="11-5-2-template标签"><a href="#11-5-2-template标签" class="headerlink" title="11.5.2    template标签"></a>11.5.2    template标签</h4><p>​    使用<code>template</code>标签，将内容写在标签内。</p><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 2.template标签 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>组件模板的分离写法<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>template标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>调用分离的模板，使用<code>template:'#cpn1'</code></p></blockquote><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//局部组件创建</span>        cpn1<span class="token punctuation">:</span><span class="token punctuation">{</span>          template<span class="token punctuation">:</span><span class="token string">'#cpn1'</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        cpn2<span class="token punctuation">:</span> <span class="token punctuation">{</span>          template<span class="token punctuation">:</span> <span class="token string">'#cpn2'</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="11-6-组件的数据"><a href="#11-6-组件的数据" class="headerlink" title="11.6    组件的数据"></a>11.6    组件的数据</h3><h4 id="11-6-1-存放问题"><a href="#11-6-1-存放问题" class="headerlink" title="11.6.1    存放问题"></a>11.6.1    存放问题</h4><p>​    前面说过vue组件就是一个vue实例，相应的vue组件也有<code>data</code>属性来存放数据。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn1</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//局部组件创建</span>        cpn1<span class="token punctuation">:</span><span class="token punctuation">{</span>          template<span class="token punctuation">:</span><span class="token string">'&lt;div&gt;{{msg}}&lt;/div&gt;'</span><span class="token punctuation">,</span>          <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>              msg<span class="token punctuation">:</span><span class="token string">"组件的数据存放必须要是一个函数"</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>在<code>template</code>中使用组件内部的数据<code>msg</code>。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/11.6-1.png" alt="image"></p><h4 id="11-6-2-组件的data为什么必须要是函数"><a href="#11-6-2-组件的data为什么必须要是函数" class="headerlink" title="11.6.2    组件的data为什么必须要是函数"></a>11.6.2    组件的data为什么必须要是函数</h4><p>​    组件的思想是复用，定义组件当然是把通用的公共的东西抽出来复用。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>data不使用函数<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn1</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn1</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>data使用函数<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>count--<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>      当前计数：{{count}}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>count++<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>count--<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>      当前计数：{{count}}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>count++<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>      count<span class="token punctuation">:</span><span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//局部组件创建</span>        cpn1<span class="token punctuation">:</span> <span class="token punctuation">{</span>          template<span class="token punctuation">:</span> <span class="token string">'#cpn1'</span><span class="token punctuation">,</span>          <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> obj<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        cpn2<span class="token punctuation">:</span> <span class="token punctuation">{</span>          template<span class="token punctuation">:</span> <span class="token string">'#cpn2'</span><span class="token punctuation">,</span>          <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>              count<span class="token punctuation">:</span> <span class="token number">0</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>上述代码中定义了两个组件<code>cpn1</code>和<code>cpn2</code>，都是定义了两个计数器，<code>con1</code>的data虽然使用了函数，但是为了模拟<code>data:{count:0}</code>，使用了常量<code>obj</code>来返回count。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/11.6-2.gif" alt="image"></p><p>图中可以看到，不使用<code>data</code>的好像共用一个<code>count</code>属性，而使用函数的<code>data</code>的count是各自用各自的，像局部变量一样有块级作用域，这个块级就是vue组件的作用域。</p><blockquote><p>我们在复用组件的时候肯定希望，各自组件用各自的变量，如果确实需要都用一样的，可以全局组件注册，也可以是用vuex来进行状态管理。</p></blockquote><h3 id="11-7-父组件想子组件传递数据"><a href="#11-7-父组件想子组件传递数据" class="headerlink" title="11.7    父组件想子组件传递数据"></a>11.7    父组件想子组件传递数据</h3><h4 id="11-7-1-父组件如何向子组件传递数据？使用props属性。"><a href="#11-7-1-父组件如何向子组件传递数据？使用props属性。" class="headerlink" title="11.7.1    父组件如何向子组件传递数据？使用props属性。"></a>11.7.1    父组件如何向子组件传递数据？使用<code>props</code>属性。</h4><blockquote><p>使用组件的<code>props</code>属性</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>           cmessage<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> String<span class="token punctuation">,</span>          <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'zzzzz'</span><span class="token punctuation">,</span>          required<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">//在使用组件必传值</span>          <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>向cmessage对象传值</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">:cMessage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        message<span class="token punctuation">:</span> <span class="token string">"你好"</span><span class="token punctuation">,</span>        movies<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"复仇者联盟"</span><span class="token punctuation">,</span> <span class="token string">"钢铁侠"</span><span class="token punctuation">,</span> <span class="token string">"星际穿越"</span><span class="token punctuation">,</span> <span class="token string">"哪吒传奇"</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="11-7-2-props属性使用"><a href="#11-7-2-props属性使用" class="headerlink" title="11.7.2    props属性使用"></a>11.7.2    props属性使用</h4><blockquote><p>数组写法</p></blockquote><pre class=" language-javascript"><code class="language-javascript">props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'cmovies'</span><span class="token punctuation">,</span> <span class="token string">'cmessage'</span><span class="token punctuation">]</span></code></pre><blockquote><p>对象写法</p></blockquote><pre class=" language-javascript"><code class="language-javascript">  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>           cmessage<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> String<span class="token punctuation">,</span>          <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'zzzzz'</span><span class="token punctuation">,</span>          required<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">//在使用组件必传值</span>          <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><blockquote><p>props属性的类型限制</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//1.类型限制(多个类使用数组)</span>cmovies<span class="token punctuation">:</span>Array<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//限制为数组类型</span>cmessage<span class="token punctuation">:</span>String<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//限制为Strin类型</span>cmessage<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'String'</span><span class="token punctuation">,</span><span class="token string">'Number'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//限制为String或Number类型</span></code></pre><blockquote><p>props属性的默认值</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 2.提供一些默认值，以及必传值</span>        cmessage<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> String<span class="token punctuation">,</span>          <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'zzzzz'</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//默认值</span>        <span class="token punctuation">}</span></code></pre><blockquote><p>props属性的必传值</p></blockquote><pre class=" language-javascript"><code class="language-javascript">cmessage<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> String<span class="token punctuation">,</span>          <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'zzzzz'</span><span class="token punctuation">,</span>          required<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">//在使用组件必传值</span>        <span class="token punctuation">}</span></code></pre><blockquote><p>类型是Object/Array，默认值必须是一个函数</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//类型是Object/Array，默认值必须是一个函数</span>cmovies<span class="token punctuation">:</span> <span class="token punctuation">{</span>    type<span class="token punctuation">:</span> Array<span class="token punctuation">,</span>    <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><blockquote><p>自定义验证函数</p></blockquote><pre class=" language-javascript"><code class="language-javascript">vaildator<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这个传递的值必须匹配下列字符串中的一个</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'zzzzz'</span><span class="token punctuation">,</span> <span class="token string">'ttttt'</span><span class="token punctuation">,</span> <span class="token string">'yyy'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span></code></pre><blockquote><p>自定义类型</p></blockquote><pre class=" language-javascript"><code class="language-javascript">    <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>firstName<span class="token punctuation">,</span>lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName      <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName    <span class="token punctuation">}</span>    cmessage<span class="token punctuation">:</span>Person<span class="token comment" spellcheck="true">//限定了cmeessage必须是Person类型</span></code></pre><blockquote><p>综合使用</p></blockquote><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">:cMovies</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>movies<span class="token punctuation">"</span></span> <span class="token attr-name">:cMessage</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in cmovies<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{cmessage}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>firstName<span class="token punctuation">,</span>lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName      <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 父传子：props</span>    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// props: ['cmovies', 'cmessage'],//数组写法</span>      props<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//对象写法</span>        <span class="token comment" spellcheck="true">// 1.类型限制(多个类使用数组)</span>        <span class="token comment" spellcheck="true">// cmovies:Array,</span>        <span class="token comment" spellcheck="true">// cmessage:String,</span>        <span class="token comment" spellcheck="true">// cmessage:['String','Number'],</span>        <span class="token comment" spellcheck="true">// 2.提供一些默认值，以及必传值</span>        cmessage<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> String<span class="token punctuation">,</span>          <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'zzzzz'</span><span class="token punctuation">,</span>          required<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">//在使用组件必传值</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//类型是Object/Array，默认值必须是一个函数</span>        cmovies<span class="token punctuation">:</span> <span class="token punctuation">{</span>          type<span class="token punctuation">:</span> Array<span class="token punctuation">,</span>          <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 3.自定义验证函数</span>        <span class="token comment" spellcheck="true">// vaildator: function (value) {</span>        <span class="token comment" spellcheck="true">//   //这个传递的值必须匹配下列字符串中的一个</span>        <span class="token comment" spellcheck="true">//   return ['zzzzz', 'ttttt', 'yyy'].indexOf(value) !== -1</span>        <span class="token comment" spellcheck="true">// }</span>        <span class="token comment" spellcheck="true">// 4.自定义类型</span>        <span class="token comment" spellcheck="true">// cmessage:Person,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        message<span class="token punctuation">:</span> <span class="token string">"你好"</span><span class="token punctuation">,</span>        movies<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"复仇者联盟"</span><span class="token punctuation">,</span> <span class="token string">"钢铁侠"</span><span class="token punctuation">,</span> <span class="token string">"星际穿越"</span><span class="token punctuation">,</span> <span class="token string">"哪吒传奇"</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="11-8-组件通信"><a href="#11-8-组件通信" class="headerlink" title="11.8    组件通信"></a>11.8    组件通信</h3><h4 id="11-8-1-父传子（props的驼峰标识）"><a href="#11-8-1-父传子（props的驼峰标识）" class="headerlink" title="11.8.1    父传子（props的驼峰标识）"></a>11.8.1    父传子（props的驼峰标识）</h4><p>​    v-bind是 不支持使用驼峰标识的，例如<code>c-User</code>要改成<code>c-User</code>。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- v-bind不支持驼峰 :cUser改成 :c-User--&gt;</span>    <span class="token comment" spellcheck="true">&lt;!-- &lt;cpn :cUser="user"&gt;&lt;/cpn&gt; --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">:c-User</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">:cuser</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 使用驼峰 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{cUser}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 不使用 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{cuser}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 父传子：props</span>    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      props<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//对象写法</span>        <span class="token comment" spellcheck="true">//驼峰</span>        cUser<span class="token punctuation">:</span>Object<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//未使用驼峰</span>        cuser<span class="token punctuation">:</span>Object      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        user<span class="token punctuation">:</span><span class="token punctuation">{</span>          name<span class="token punctuation">:</span><span class="token string">'zzz'</span><span class="token punctuation">,</span>          age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">,</span>          height<span class="token punctuation">:</span><span class="token number">175</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><h4 id="11-8-2-子传父-emit"><a href="#11-8-2-子传父-emit" class="headerlink" title="11.8.2    子传父$emit"></a>11.8.2    子传父<code>$emit</code></h4><p>​    子组件向父组件传值，使用自定义事件<code>$emit</code>。</p><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 不写参数默认传递btnClick的item --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">@itemclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpnClcik<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in categoties<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick(item)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 父传子：props</span>    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          categoties<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>              id<span class="token punctuation">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span>              name<span class="token punctuation">:</span> <span class="token string">'热门推荐'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>              id<span class="token punctuation">:</span> <span class="token string">'bbb'</span><span class="token punctuation">,</span>              name<span class="token punctuation">:</span> <span class="token string">'手机数码'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>              id<span class="token punctuation">:</span> <span class="token string">'ccc'</span><span class="token punctuation">,</span>              name<span class="token punctuation">:</span> <span class="token string">'家用家电'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>              id<span class="token punctuation">:</span> <span class="token string">'ddd'</span><span class="token punctuation">,</span>              name<span class="token punctuation">:</span> <span class="token string">'电脑办公'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">btnClick</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'itemclick'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">cpnClcik</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cpnClick'</span><span class="token operator">+</span>item<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>1.在子组件中定义一个方法<code>btnClick(item)</code>，使用<code>$emit</code>，’itemclick’是事件名，<code>item</code>是传过去的值。</p><pre class=" language-javascript"><code class="language-javascript">      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">btnClick</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'itemclick'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>2.在子组件中监听点击事件并回调此方法</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in categoties<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick(item)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre><p>3.在父组件中定义一个方法cpnClcik(item) </p><pre class=" language-javascript"><code class="language-javascript">methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">cpnClcik</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cpnClick'</span><span class="token operator">+</span>item<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>4.并在父组件（vue实例）中调用<code>&lt;cpn @itemclick="cpnClcik"&gt;&lt;/cpn&gt;</code>（<em>不写参数默认传递btnClick的item</em> ），父组件监听事件名为<code>itemclick</code>的子组件传过来的事件。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">@itemclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpnClcik<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span></code></pre><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/11.8-1.gif" alt="image"></p><h4 id="11-8-3-父子组件通信案例"><a href="#11-8-3-父子组件通信案例" class="headerlink" title="11.8.3    父子组件通信案例"></a>11.8.3    父子组件通信案例</h4><p>​    实现父子组件的值双向绑定。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>组件通信-父子通信案例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">:number1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>num1<span class="token punctuation">'</span></span> <span class="token attr-name">:number2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>num2<span class="token punctuation">'</span></span> <span class="token attr-name">@num1change</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num1Change<span class="token punctuation">"</span></span> <span class="token attr-name">@num2change</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num2Change<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>父组件{{num1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num1<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>父组件{{num2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{number1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{dnumber1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dnumber1<span class="token punctuation">"</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num1input<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{number2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dnumber2<span class="token punctuation">"</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num2input<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 父传子：props</span>    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          dnumber1<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>number1<span class="token punctuation">,</span>          dnumber2<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>number2        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      props<span class="token punctuation">:</span><span class="token punctuation">{</span>        number1<span class="token punctuation">:</span><span class="token punctuation">[</span>Number<span class="token punctuation">,</span>String<span class="token punctuation">]</span><span class="token punctuation">,</span>        number2<span class="token punctuation">:</span><span class="token punctuation">[</span>Number<span class="token punctuation">,</span>String<span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">num1input</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>dnumber1 <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'num1change'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>dnumber1<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">num2input</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>dnumber2 <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'num2change'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>dnumber2<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          num1<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>          num2<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">num1Change</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>num1<span class="token operator">=</span>value        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">num2Change</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>num1<span class="token operator">=</span>value        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>使用watch实现。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>组件通信-父子通信案例(watch实现)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">:number1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>num1<span class="token punctuation">'</span></span> <span class="token attr-name">:number2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>num2<span class="token punctuation">'</span></span> <span class="token attr-name">@num1change</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num1Change<span class="token punctuation">"</span></span> <span class="token attr-name">@num2change</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num2Change<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>父组件{{num1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num1<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>父组件{{num2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>num2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{number1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dnumber1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>{{number2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dnumber2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 父传子：props</span>    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          dnumber1<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>number1<span class="token punctuation">,</span>          dnumber2<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>number2        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      props<span class="token punctuation">:</span><span class="token punctuation">{</span>        number1<span class="token punctuation">:</span><span class="token punctuation">[</span>Number<span class="token punctuation">,</span>String<span class="token punctuation">]</span><span class="token punctuation">,</span>        number2<span class="token punctuation">:</span><span class="token punctuation">[</span>Number<span class="token punctuation">,</span>String<span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">dnumber1</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>dnumber1 <span class="token operator">=</span> newValue <span class="token operator">*</span> <span class="token number">100</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'num1change'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">dnumber2</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>dnumber1 <span class="token operator">=</span> newValue <span class="token operator">*</span> <span class="token number">100</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'num2change'</span><span class="token punctuation">,</span>newValue<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          num1<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>          num2<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">num1Change</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>num1<span class="token operator">=</span>value        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">num2Change</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>num1<span class="token operator">=</span>value        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="11-9-父访问子（children-ref）"><a href="#11-9-父访问子（children-ref）" class="headerlink" title="11.9    父访问子（children-ref）"></a>11.9    父访问子（children-ref）</h3><p>​    父组件访问子组件，有时候我么你需要直接操作子组件的方法，或是属性，此时需要用到<code>$children</code>和<code>$ref</code>。</p><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aaa<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btnClick<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      我是子组件    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token comment" spellcheck="true">// 父传子：props</span>    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          name<span class="token punctuation">:</span><span class="token string">"我是子组件的name"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"showMessage"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          message<span class="token punctuation">:</span><span class="token string">"hello"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">btnClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 1.children</span>          <span class="token comment" spellcheck="true">// console.log(this.$children[0].showMessage)</span>          <span class="token comment" spellcheck="true">// for (let cpn of this.$children) {</span>          <span class="token comment" spellcheck="true">//   console.log(cpn.showMessage)</span>          <span class="token comment" spellcheck="true">// }</span>          <span class="token comment" spellcheck="true">// 2.$ref</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>aaa<span class="token punctuation">.</span>name<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p><code>$children</code>方式</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 1.children</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>showMessage<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> cpn <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cpn<span class="token punctuation">.</span>showMessage<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>使用<code>this.$children</code>直接获取<strong>当前实例的直接子组件，需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong> 如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。 </p><blockquote><p>$refs方式</p></blockquote><p><strong>先定义子组件</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aaa<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span></code></pre><p><strong>直接调用</strong></p><h2 id="（十二）组件化高级"><a href="#（十二）组件化高级" class="headerlink" title="（十二）组件化高级"></a>（十二）组件化高级</h2><h3 id="12-1-slot-插槽的基本使用"><a href="#12-1-slot-插槽的基本使用" class="headerlink" title="12.1    slot-插槽的基本使用"></a>12.1    slot-插槽的基本使用</h3><p>​    我们在使用组件的时候有时候希望，在组件内部定制化内容，例如京东这样。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/12.1-1.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/12.1-2.png" alt="image"></p><p>这两个都是导航栏，组件的思想是可以复用的，把这个导航栏看做一个组件。</p><p>这个组件都可以分成三个部分，左边中间右边，如果可以分割组件，就可以定制化组件内容了。</p><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是插槽内容222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是插槽内容333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 插槽的基本使用使用&lt;slot&gt;&lt;/slot&gt; --&gt;</span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>        {{message}}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 插槽默认值 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>button<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          message<span class="token punctuation">:</span> <span class="token string">"我是子组件"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          message<span class="token punctuation">:</span> <span class="token string">"我是父组件消息"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>简单使用插槽，定义template时候使用<code>slot</code></p></blockquote><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>        {{message}}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 插槽默认值 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span>button<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>插槽可以使用默认值，<code>&lt;button&gt;button&lt;/button&gt;</code>就是插槽的默认值。</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是插槽内容222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>使用插槽，<code>&lt;span style="color:red;"&gt;这是插槽内容222&lt;/span&gt;</code>将替换插槽的默认值</p></blockquote><p>上述代码结果如图所示</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/12.1-3.png" alt="image"></p><blockquote><p>替换了两次插槽，两次未替换显示默认的button。</p><p>如果想实现组件分成三部分就可以使用三个<code>&lt;slot&gt;&lt;/slot&gt;</code>来填充插槽了。</p></blockquote><h3 id="12-2-slot-具名插槽的使用"><a href="#12-2-slot-具名插槽的使用" class="headerlink" title="12.2    slot-具名插槽的使用"></a>12.2    slot-具名插槽的使用</h3><p>​    具名插槽，就是可以让插槽按指定的顺序填充，而没有具名的插槽是按照你填充的顺序排列的，而具名插槽可以自定义排列。</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>没具名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是左边具名插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 新语法 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>center</span><span class="token punctuation">&gt;</span></span>这是中间具名插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 新语法缩写 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#right</span><span class="token punctuation">&gt;</span></span>这是右边具名插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 插槽的基本使用使用&lt;slot&gt;&lt;/slot&gt; --&gt;</span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>左边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>中间<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>右边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span>没有具名的插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          message<span class="token punctuation">:</span> <span class="token string">"我是子组件"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          message<span class="token punctuation">:</span> <span class="token string">"我是父组件消息"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>如图所示</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/12.2-1.png" alt="image"></p><blockquote><p>没有具名的插槽排在最后，因为在定义组件的时候，排在了最后，如果有多个按顺序排列。具名插槽按照自定义的顺序排列。</p></blockquote><blockquote><p>定义具名插槽，使用<code>name</code>属性，给插槽定义一个名字。</p></blockquote><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 插槽的基本使用使用&lt;slot&gt;&lt;/slot&gt; --&gt;</span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件模板 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>左边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>中间<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>右边<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span>没有具名的插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>使用具名插槽，在自定义组件标签内使用<code>slot="left"</code>，插入指定插槽</p></blockquote><pre class=" language-html"><code class="language-html">  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>没具名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>这是左边具名插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 新语法 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>center</span><span class="token punctuation">&gt;</span></span>这是中间具名插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 新语法缩写 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">#right</span><span class="token punctuation">&gt;</span></span>这是右边具名插槽<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>注意：此处有是三种写法，获取指定插槽。</p></blockquote><h3 id="12-3-编译的作用域"><a href="#12-3-编译的作用域" class="headerlink" title="12.3    编译的作用域"></a>12.3    编译的作用域</h3><p>​    前面说过组件都有自己的作用域，自己组件的作用在自己组件内。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>编译的作用域<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 使用的vue实例作用域的isShow --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token comment" spellcheck="true">&lt;!-- 插槽的基本使用使用&lt;slot&gt;&lt;/slot&gt; --&gt;</span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>我是子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>哈哈哈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 组件作用域，使用的子组件的作用域 --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          isShwo<span class="token punctuation">:</span><span class="token boolean">false</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          message<span class="token punctuation">:</span> <span class="token string">"我是父组件消息"</span><span class="token punctuation">,</span>          isShow<span class="token punctuation">:</span><span class="token boolean">true</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>结果如下</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/12.3-1.png" alt="image"></p><blockquote><p>子组件使用的是子组件的isShow，子组件为false，所以button没显示，被隐藏。</p></blockquote><h3 id="12-4-作用域插槽案例"><a href="#12-4-作用域插槽案例" class="headerlink" title="12.4    作用域插槽案例"></a>12.4    作用域插槽案例</h3><p>​    父组件替换插槽的标签，但是内容是由子组件来提供。</p><p>​    当组件需要在多个父组件多个界面展示的时候，将内容放在子组件插槽中，父组件只需要告诉子组件使用什么方式展示界面。</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>作用域插槽案例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token comment" spellcheck="true">&lt;!-- 父组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 目的是获取子组件数据 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span>      <span class="token comment" spellcheck="true">&lt;!-- 2.5以下必须使用template --&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slot<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment" spellcheck="true">&lt;!-- &lt;span v-for="(item, index) in slot.data" :key="index"&gt;{{item}}-&lt;/span&gt; --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{slot.data.join(' - ')}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">&gt;</span></span>        <span class="token comment" spellcheck="true">&lt;!-- 2.5以下必须使用template --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slot<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>          <span class="token comment" spellcheck="true">&lt;!-- &lt;span v-for="(item, index) in slot.data" :key="index"&gt;{{item}}*&lt;/span&gt; --&gt;</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>{{slot.data.join(' * ')}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token comment" spellcheck="true">&lt;!-- 插槽的基本使用使用&lt;slot&gt;&lt;/slot&gt; --&gt;</span>  <span class="token comment" spellcheck="true">&lt;!-- 子组件 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">:data</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pLanguage<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item, index) in pLanguage<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">    <span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>      template<span class="token punctuation">:</span> <span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          isShwo<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>          pLanguage<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'JavaScript'</span><span class="token punctuation">,</span><span class="token string">'Java'</span><span class="token punctuation">,</span><span class="token string">'C++'</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          isShow<span class="token punctuation">:</span><span class="token boolean">true</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      components<span class="token punctuation">:</span> <span class="token punctuation">{</span>        cpn      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><blockquote><p>组件中使用<code>slot-scope="slot"</code><strong>（2.6.0已经废弃）</strong>给插槽属性命名，在通过<code>slot</code>调用绑定在插槽上的属性。也可以使用<code>v-slot="slot"</code>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/12.4-1.png" alt="image"></p><h2 id="（十三）Vue实例的生命周期"><a href="#（十三）Vue实例的生命周期" class="headerlink" title="（十三）Vue实例的生命周期"></a>（十三）Vue实例的生命周期</h2><h3 id="13-1-生命周期图"><a href="#13-1-生命周期图" class="headerlink" title="13.1     生命周期图"></a>13.1     <span id="top">生命周期图</span></h3><p>​    Vue实例的生命周期中有多个状态。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/lifecycle.png" alt="生命周期图"></p><blockquote><p>测试代码</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ie<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Vue实例的生命周期<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token comment" spellcheck="true">&lt;!-- 引入vue.js --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>测试生命周期<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">&gt;</span></span>测试beforeUpdate和update两个钩子函数<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>handlerUpdate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>更新数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>            data<span class="token punctuation">:</span><span class="token punctuation">{</span>                msg<span class="token punctuation">:</span><span class="token string">"12345"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>                handlerUpdate<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//按照示意图依次调用</span>            beforeCreate<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了beforeCreate钩子函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            created<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了created钩子函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            beforeMount<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用了beforeMount钩子函数'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            mounted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'调用了mounted钩子函数'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            beforeUpdate<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了beforeUpdate钩子函数"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            updated<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了updated钩子函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            beforeDestroy<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了beforeDestroy钩子函数"</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            destroyed<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"调用了destroyed钩子函数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><p>如图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/1.png" alt="image"></p><p>初始化页面依次调用了：</p><blockquote><ol><li>调用了beforeCreate钩子函数</li><li>调用了created钩子函数</li><li>调用了beforeMount钩子函数</li><li>调用了mounted钩子函数</li></ol></blockquote><p>点击更新数据后：</p><p><code>12345</code>变成了<code>54321</code>，此时调用了：</p><blockquote><ol><li>调用了beforeUpdate钩子函数</li><li>调用了updated钩子函数</li></ol></blockquote><p>打开F12控制台<br>直接输入<code>app.$destroy()</code>主动销毁Vue实例调用：</p><blockquote><ol><li>调用了beforeDestroy钩子函数</li><li>调用了destroyed钩子函数</li></ol></blockquote><h3 id="13-2-再探究"><a href="#13-2-再探究" class="headerlink" title="13.2    再探究"></a>13.2    再探究</h3><h4 id="13-2-1-beforeCreate之前"><a href="#13-2-1-beforeCreate之前" class="headerlink" title="13.2.1    beforeCreate之前"></a>13.2.1    beforeCreate之前</h4><p>初始化钩子函数和生命周期</p><h4 id="13-2-2-beforeCreate和created钩子函数间的生命周期"><a href="#13-2-2-beforeCreate和created钩子函数间的生命周期" class="headerlink" title="13.2.2    beforeCreate和created钩子函数间的生命周期"></a>13.2.2    beforeCreate和created钩子函数间的生命周期</h4><p>在beforeCreate和created之间，进行数据观测(data observer) ，也就是在这个时候开始监控data中的数据变化了，同时初始化事件。<br><span style="float:right;"><a href="#1">生命周期展示图</a></span></p><h4 id="13-2-3-created钩子函数和beforeMount间的生命周期"><a href="#13-2-3-created钩子函数和beforeMount间的生命周期" class="headerlink" title="13.2.3    created钩子函数和beforeMount间的生命周期"></a>13.2.3    created钩子函数和beforeMount间的生命周期</h4><p>对于created钩子函数和beforeMount有判断：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/2.png" alt="image"></p><h5 id="13-2-3-1el选项对生命周期影响"><a href="#13-2-3-1el选项对生命周期影响" class="headerlink" title="13.2.3.1el选项对生命周期影响"></a>13.2.3.1el选项对生命周期影响</h5><blockquote><ol><li>有el选项</li></ol></blockquote><pre><code>new Vue({    el: '#app',    beforeCreate: function () {        console.log('调用了beforeCreat钩子函数')    },    created: function () {        console.log('调用了created钩子函数')    },    beforeMount: function () {        console.log('调用了beforeMount钩子函数')    },    mounted: function () {        console.log('调用了mounted钩子函数')    }})</code></pre><p>结果:</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/3.png" alt="image"></p><blockquote><ol start="2"><li>无el选项</li></ol></blockquote><pre><code>new Vue({    beforeCreate: function () {        console.log('调用了beforeCreat钩子函数')    },    created: function () {        console.log('调用了created钩子函数')    },    beforeMount: function () {        console.log('调用了beforeMount钩子函数')    },    mounted: function () {        console.log('调用了mounted钩子函数')    }})</code></pre><p>结果：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/4.png" alt="image"></p><blockquote><p>证明没有el选项，则停止编译，也意味着暂时停止了生命周期。生命周期到created钩子函数就结束了。而当我们不加el选项，但是手动执行vm.$mount(el)方法的话，也能够使暂停的生命周期进行下去，例如：</p></blockquote><pre><code>var app = new Vue({    beforeCreate: function () {        console.log('调用了beforeCreat钩子函数')    },    created: function () {        console.log('调用了created钩子函数')    },    beforeMount: function () {        console.log('调用了beforeMount钩子函数')    },    mounted: function () {        console.log('调用了mounted钩子函数')    }})app.$mount('#app')</code></pre><p>结果：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/3.png" alt="image"></p><h4 id="13-2-3-2-template"><a href="#13-2-3-2-template" class="headerlink" title="13.2.3.2    template"></a>13.2.3.2    template</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/5.png" alt="image"></p><blockquote><p>同时使用<code>template</code>和<code>HTML</code>，查看优先级：</p></blockquote><pre><code>    &lt;h1&gt;测试template和HTML的优先级&lt;/h1&gt;    &lt;div id="app"&gt;        &lt;p&gt;HTML优先&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;        var app = new Vue({            el:"#app",            data:{                msg:"template优先"            },            template:"&lt;p&gt;{{msg}}&lt;/p&gt;",        });    &lt;/script&gt;</code></pre><p>结果：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/6.png" alt="image"></p><blockquote><p>结论</p></blockquote><ol><li>如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数</li><li>如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高</li><li>如果1,2条件都不具备，则报错</li></ol><blockquote><p>注意</p></blockquote><ol><li>Vue需要通过el去找对应的template，Vue实例通过el的参数，首先找自己有没有template，如果没有再去找外部的html，找到后将其编译成render函数。</li><li>也可以直接调用<a href="https://cn.vuejs.org/v2/api/#render" target="_blank" rel="noopener">render</a>选项，优先级：<code>render函数选项  &gt; template参数  &gt; 外部HTML</code>。</li></ol><hr><pre><code>new Vue({    el: '#app',    render (createElement) {        return (....)    }})</code></pre><h4 id="13-2-4-beforeMount和mounted钩子函数间的生命周期"><a href="#13-2-4-beforeMount和mounted钩子函数间的生命周期" class="headerlink" title="13.2.4    beforeMount和mounted钩子函数间的生命周期"></a>13.2.4    beforeMount和mounted钩子函数间的生命周期</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/7.png" alt="image"></p><blockquote><p>beforeMount</p></blockquote><p>载入前（完成了data和el数据初始化），但是页面中的内容还是vue中的占位符，data中的message信息没有被挂在到Dom节点中，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取。</p><blockquote><p>Mount</p></blockquote><p>载入后html已经渲染(ajax请求可以放在这个函数中)，把vue实例中的data里的message挂载到DOM节点中去</p><blockquote><p>这里两个钩子函数间是载入数据。</p></blockquote><h4 id="13-2-5-beforeUpdate钩子函数和updated钩子函数间的生命周期"><a href="#13-2-5-beforeUpdate钩子函数和updated钩子函数间的生命周期" class="headerlink" title="13.2.5    beforeUpdate钩子函数和updated钩子函数间的生命周期"></a>13.2.5    beforeUpdate钩子函数和updated钩子函数间的生命周期</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/8.png" alt="image"><br>在Vue中，修改数据会导致重新渲染，依次调用beforeUpdate钩子函数和updated钩子函数</p><p>如果待修改的数据没有载入模板中，不会调用这里两个钩子函数</p><pre><code>var app = new Vue({    el: '#app',    data: {        msg: 1    },    template: '&lt;div id="app"&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;',    beforeUpdate: function () {        console.log('调用了beforeUpdate钩子函数')    },    updated: function () {        console.log('调用了updated钩子函数')    }})app.msg = 2</code></pre><p>结果：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/9.png" alt="image"><br>如果绑定了数据，会调用两个钩子函数：</p><pre><code>&lt;h1&gt;测试有数据绑定修改数据，钩子函数调用情况&lt;/h1&gt;&lt;div id="app"&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue({        el:"#app",        template:"&lt;p&gt;{{msg}}&lt;/p&gt;",        data:{            msg:"原数据"        },        beforeUpdate: function () {            console.log("调用了beforeUpdate钩子函数")        },        updated: function () {            console.log("调用了updated钩子函数");        },    });    app.msg = "数据被修改了";&lt;/script&gt;</code></pre><p>结果：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/10.png" alt="image"></p><blockquote><p>注意只有写入模板的数据才会被追踪</p></blockquote><h4 id="13-2-6-beforeDestroy和destroyed钩子函数间的生命周期"><a href="#13-2-6-beforeDestroy和destroyed钩子函数间的生命周期" class="headerlink" title="13.2.6    beforeDestroy和destroyed钩子函数间的生命周期"></a>13.2.6    beforeDestroy和destroyed钩子函数间的生命周期</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13/11.png" alt="image"></p><h5 id="13-2-6-1-beforeDestroy"><a href="#13-2-6-1-beforeDestroy" class="headerlink" title="13.2.6.1    beforeDestroy"></a>13.2.6.1    beforeDestroy</h5><p>销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等…’)</p><h5 id="13-2-6-2-destroyed"><a href="#13-2-6-2-destroyed" class="headerlink" title="13.2.6.2    destroyed"></a>13.2.6.2    destroyed</h5><p>销毁后 （Dom元素存在，只是不再受vue控制）,卸载watcher，事件监听，子组件</p><blockquote><p>总结</p></blockquote><ul><li>beforecreate : 可以在这加个loading事件</li><li>created ：在这结束loading，还做一些初始数据的获取，实现函数自-执行</li><li>mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情</li><li>beforeDestroy： 你确认删除XX吗？</li><li>destroyed ：当前组件已被删除，清空相关内容</li></ul><hr><div>  <span style="float:left;"><a href="#top">返回顶部</a></span><span style="float:right;"><a href="../README.md">返回首页</a></span></div><h2 id="（十四）前端模块化"><a href="#（十四）前端模块化" class="headerlink" title="（十四）前端模块化"></a>（十四）前端模块化</h2><h3 id="13-1-为什么要有模块化"><a href="#13-1-为什么要有模块化" class="headerlink" title="13.1    为什么要有模块化"></a>13.1    为什么要有模块化</h3><p>​    随着前端项目越来越大，团队人数越来越多，多人协调开发一个项目成为常态。例如现在小明和小张共同开发一个项目，小明定义一个aaa.js，小张定义了一个bbb.js。</p><blockquote><p>aaa.js</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//小明开发</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'小明'</span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">22</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">}</span><span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>此时小明的<code>sum</code>是没有问题的。</p><blockquote><p>bbb.js</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//小红</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"小红"</span><span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">false</span></code></pre><p>此时小明和小红各自用各自的<code>flag</code>你变量没问题。</p><blockquote><p>但是此时小明又创建了一个mmm.js</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//小明</span><span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"flag是true"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在index.html页面导入这些js文件</p><pre class=" language-php+HTML"><code class="language-php+HTML">  <script src="aaa.js"></script>  <script src="bbb.js"></script>  <script src="ccc.js"></script></code></pre><p>此时小明知道自己在aaa.js中定义的<code>flag</code>是<code>true</code>，认为打印没有问题，但是不知道小红的bbb.js中也定义了<code>flag</code>为<code>true</code>，所以mmm.js文件并没有打印出“flag是true”。</p><blockquote><p>这就是全局变量同名问题。</p></blockquote><h3 id="13-2-使用导出全局变量模块解决全局变量同名问题"><a href="#13-2-使用导出全局变量模块解决全局变量同名问题" class="headerlink" title="13.2    使用导出全局变量模块解决全局变量同名问题"></a>13.2    使用导出全局变量模块解决全局变量同名问题</h3><blockquote><p>aaa.js</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//模块对象</span><span class="token keyword">var</span> moduleA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//导出对象</span>  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'小明'</span>  <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">22</span>  <span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2  <span class="token punctuation">}</span>  <span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  obj<span class="token punctuation">.</span>flag<span class="token operator">=</span><span class="token boolean">false</span>  <span class="token keyword">return</span> obj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><blockquote><p>mmm.js</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//小明</span><span class="token comment" spellcheck="true">//使用全局变量moduleA</span><span class="token keyword">if</span><span class="token punctuation">(</span>moduleA<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"flag是true"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这样直接使用aaa.js导出的moduleA变量获取小明自己定义的<code>flag</code>。</p><h3 id="13-3-CommonJS的模块化实现"><a href="#13-3-CommonJS的模块化实现" class="headerlink" title="13.3 CommonJS的模块化实现"></a>13.3 CommonJS的模块化实现</h3><p>​    CommonJS需要nodeJS的依支持。</p><blockquote><p>aaa.js</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//CommonJS需要nodeJS支持</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'小明'</span><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">22</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">}</span><span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// module.exports = {</span><span class="token comment" spellcheck="true">//   flag : flag,</span><span class="token comment" spellcheck="true">//   sum : sum</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">//导出对象</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  flag<span class="token punctuation">,</span>  sum<span class="token punctuation">}</span></code></pre><p>使用<code>module.exports = {}</code>导出需要的对象。</p><blockquote><p>mmm.js</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//导入对象,nodejs语法,需要node支持,从aaa.js取出对象</span><span class="token keyword">var</span> <span class="token punctuation">{</span>flag<span class="token punctuation">,</span>sum<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./aaa"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"flag is true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用 <code>var {flag,sum} = require("./aaa")</code>获取已经导出的对象中自己所需要的对象。</p><h3 id="ES6的模块化实现"><a href="#ES6的模块化实现" class="headerlink" title="ES6的模块化实现"></a>ES6的模块化实现</h3><p>​    如何实现模块化，在html中需要使用<code>type='module'</code>属性。</p><pre class=" language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aaa.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bbb.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mmm.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre><p>此时表示aaa.js是一个单独的模块，此模块是有作用域的。如果要使用aaa.js内的变量，需要在aaa.js中先导出变量，再在需要使用的地方导出变量。</p><h4 id="13-4-1-直接导出"><a href="#13-4-1-直接导出" class="headerlink" title="13.4.1    直接导出"></a>13.4.1    直接导出</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'小明'</span></code></pre><blockquote><p>使用</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>name<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./aaa.js'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></code></pre><p><code>./aaa.js</code>表示aaa.js和mmm.js在同级目录。</p><p>如图打印结果。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13.4-1.png" alt="image"></p><h4 id="13-4-2-统一导出"><a href="#13-4-2-统一导出" class="headerlink" title="13.4.2    统一导出"></a>13.4.2    统一导出</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">22</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">}</span><span class="token keyword">var</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2.最后统一导出</span><span class="token keyword">export</span> <span class="token punctuation">{</span>  flag<span class="token punctuation">,</span>sum<span class="token punctuation">,</span>age<span class="token punctuation">}</span></code></pre><blockquote><p>使用<code>import {name,flag,sum} from './aaa.js'</code>导入多个变量</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span>flag<span class="token punctuation">,</span>sum<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./aaa.js'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"小明是天才"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>使用{}将需要的变量放置进去</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13.4-2.png" alt="image"></p><h4 id="13-4-3-导出函数-类"><a href="#13-4-3-导出函数-类" class="headerlink" title="13.4.3    导出函数/类"></a>13.4.3    导出函数/类</h4><blockquote><p>在aaa.js中添加</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//3.导出函数/类</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">say</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>  <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"奔跑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在mmm.js中添加</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span>flag<span class="token punctuation">,</span>sum<span class="token punctuation">,</span>say<span class="token punctuation">,</span>Person<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./aaa.js'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"小明是天才"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>如图</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/vue/13.4-3.png" alt="image"></p><h4 id="13-4-4-默认导入-export-default"><a href="#13-4-4-默认导入-export-default" class="headerlink" title="13.4.4    默认导入 export default"></a>13.4.4    默认导入 export default</h4><blockquote><p>导出</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  flag<span class="token punctuation">,</span>sum<span class="token punctuation">,</span>age<span class="token punctuation">}</span></code></pre><blockquote><p>导入</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//4.默认导入 export default</span><span class="token keyword">import</span> aaa <span class="token keyword">from</span> <span class="token string">'./aaa.js'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aaa<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>注意：使用默认导出会将所有需要导出的变量打包成一个对象，此时导出一个对象，此时我在<code>mmm.js</code>中导入变量时候命名为aaa，如果要调用变量需要使用aaa.变量。</p></blockquote><h4 id="13-4-5-统一全部导入"><a href="#13-4-5-统一全部导入" class="headerlink" title="13.4.5    统一全部导入"></a>13.4.5    统一全部导入</h4><blockquote><p>​    使用<code>import * as aaa from './aaa.js'</code>统一全部导入</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 5.统一全部导入</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> aaa <span class="token keyword">from</span> <span class="token string">'./aaa.js'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aaa<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aaa<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="认识webpack"><a href="#认识webpack" class="headerlink" title="认识webpack"></a>认识webpack</h3><p>静态模块打包工具，模块化和打包</p><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>AMD,CMD,CommonJs，ES6</p><p>webpack可以将以上转化为浏览器认识的代码，可以处理模块依赖<br>js，css，图片，json文件都可以当作模块</p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p><strong>和grunt/glup的对比</strong></p><ul><li>grunt/glup的核心是Task<ul><li>我们可以配置一系列的task，并且定义task要处理的事务（例如ES6/TS转化，图片压缩，scss转css）</li><li>之后可以让grunt/glup来执行依次这些任务，让整个流程自动化</li><li>所以grunt/glup也被称为前端自动化任务管理工具</li></ul></li><li>看一个gulp例子<ul><li>task将src下的js文件转化为ES5语法</li><li>并输入到dist文件夹中<pre>const gulp = require('gulp')const babel = require('gulp-babel')gulp.task('js'()=&gt;  gulp.src('src/*.js')    .pipe(babel({      presets:['es2015']    }))    .pipe(gulp.dest('dist')));</pre></li></ul></li><li>什么时候使用grunt/gulp呢？<ul><li>如果工程依赖简单，甚至没有模块化</li><li>只需要进行简单的合并/压缩</li><li>如果模块复杂，相互依赖性强，我们需要使用webpack</li></ul></li><li>grunt/glup和webpack区别<ul><li>grunt/glup更加强调的是前端自动化流程，模块化不是其核心</li><li>webpack加强模块化开发管理，而文件压缩/合并/预处理等功能，是附带功能</li></ul></li></ul><p>webpack就是前端模块化打包工具</p><h3 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h3><p>webpack依赖node环境<br>node自带npm<br>通过<code>npm install webpack -g</code>全局安装<br>由于vue-cli2基于webpack3.6.0<br>如果要用vue-cli2的可以使用<code>npm install webpack@3.6.0 -g</code></p><ol><li>全局安装<br><code>npm install webpack -g</code></li><li>局部安装<br><code>npm install webpack --save-dev</code></li></ol><ul><li>在终端执行webpack命令，使用的是全局安装</li><li>当在package.json中定义了scripts时，其中包括了webpack命令，那么使用的是局部webpack</li></ul><h3 id="webpack的起步"><a href="#webpack的起步" class="headerlink" title="webpack的起步"></a>webpack的起步</h3><h3 id="webpack的配置"><a href="#webpack的配置" class="headerlink" title="webpack的配置"></a>webpack的配置</h3><p>1.使用<code>npm init</code> 初始化<br>2.取一个英文名（中文可能有问题）<br>3.<code>npm install</code>安装依赖包<br>4.<code>webpack</code><br>5.在package.json中scripts中添加”build”: “webpack”，使用<code>npm run build</code>，此时执行的是”webpack”,优先寻找本地的webpack版本，本地没有全局（终端执行的是全局的）,package.json中依赖了webpack，使用<code>npm install</code>安装依赖包，会使用安装的webpack<br><code>npm install webpack@3.6.0 --save-dev</code><br>此时webpack使用的是本地的3.6.0的</p><h3 id="loader的使用"><a href="#loader的使用" class="headerlink" title="loader的使用"></a>loader的使用</h3><p>loader是webpack中一个非常核心的概念</p><blockquote><p>webpack用来做什么？</p></blockquote><ul><li>webpack主要用来处理js代码依赖</li><li>css、图片、ES6转ES5、TS转JS、scss、less转css，.vue转js等</li><li>结合loader就可以解决这些问题<blockquote><p>loader使用过程</p></blockquote></li><li>通过npm安装需要的loader</li><li>在webpack.config.js中module关键字下配置<blockquote><p>注意：大部分loader都可以在webpack官网找到，并有相对应的使用方法</p></blockquote></li></ul><h3 id="webpack中配置vue"><a href="#webpack中配置vue" class="headerlink" title="webpack中配置vue"></a>webpack中配置vue</h3><p>使用<code>npm install vue --save</code></p><h3 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h3><ol><li><p>通过npm安装插件</p></li><li><p>在webpack.config.js中配置</p><pre><code> const webpack = require('webpack') module.exports = {   plugins:[     new webpack.BannerPlugin("xxxx")   ] }</code></pre></li></ol><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><p>使用插件webpack-dev-serve</p><h2 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h2><h3 id="vue-cli使用前提"><a href="#vue-cli使用前提" class="headerlink" title="vue-cli使用前提"></a>vue-cli使用前提</h3><p>vue-cli需要webpack<br>webpack依赖node<br>所以vue-cli依赖node8.9以上</p><h3 id="vue-cli安装"><a href="#vue-cli安装" class="headerlink" title="vue-cli安装"></a>vue-cli安装</h3><p><code>npm install -g @vue/cli</code><br>安装完毕使用：<br><code>vue --version</code><br>Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：</p><pre><code>npm install -g @vue/cli-init# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack my-project</code></pre><p>vue-cli-3<br>使用<code>vue create my-project</code></p><h3 id="vue-cli2-test"><a href="#vue-cli2-test" class="headerlink" title="vue-cli2-test"></a>vue-cli2-test</h3><ol><li>build/config都是存放vue-cli的webpack的相关配置</li><li>node_modules是存放需要的依赖模块</li><li>src源码</li><li>static 静态资源,会完全复制到dist文件夹</li><li>.babelrc(ES转化配置文件)</li><li>.editorconfig(编码配置文件)</li><li>.eslintignore(忽略一些不规范的代码)</li><li>.eslintrc(es配置文件)</li><li>.postcssrc.js(css转化配置)</li><li>index.html(模板)</li><li>package.json(包管理,记录大概安装的版本)</li><li>package-lock.json(记录真实安装版本)</li></ol><h3 id="安装cli错误和ESLint规范"><a href="#安装cli错误和ESLint规范" class="headerlink" title="安装cli错误和ESLint规范"></a>安装cli错误和ESLint规范</h3><ol><li>以管理员使用cmd</li><li>清空npm-cache缓存<br>ESLint检测代码规范</li></ol><h3 id="理解runtime-compiler和runtime-only区别"><a href="#理解runtime-compiler和runtime-only区别" class="headerlink" title="理解runtime-compiler和runtime-only区别"></a>理解runtime-compiler和runtime-only区别</h3><blockquote><p>runtime-compiler</p></blockquote><pre><code>import Vue from 'vue'import App from './App'Vue.config.productionTip = false/* eslint-disable no-new */new Vue({  el: '#app',  components: { App },  template: '&lt;App/&gt;'})</code></pre><blockquote><p>runtime-only</p></blockquote><pre><code>import Vue from 'vue'import App from './App'Vue.config.productionTip = false/* eslint-disable no-new */new Vue({  el: '#app',  render: h =&gt; h(App)})</code></pre><p><code>render: h =&gt; h(App)</code></p><pre><code>render:function(h){  return h(App)}</code></pre><p><strong>runtime-compiler</strong><br>template会被解析 =&gt; ast(抽象语法树) =&gt; 然后编译成render函数 =&gt; 渲染成虚拟DOM（vdom）=&gt; 真实dom(UI)<br><strong>runtime-only</strong>(1.性能更高，需要代码量更少)<br>render =&gt; vdom =&gt; UI</p><blockquote><p>render函数</p></blockquote><pre><code>render:function(createElement){  //1.createElement('标签',{标签属性},[''])  return createElement('h2',    {class:'box'},    ['Hello World',createElement('button',['按钮'])])  //2.传入组件对象  //return createElement(cpn)}</code></pre><p>.vue文件的template是由vue-template-compiler解析</p><h3 id="vue-cli2和vue-cli3区别"><a href="#vue-cli2和vue-cli3区别" class="headerlink" title="vue-cli2和vue-cli3区别"></a>vue-cli2和vue-cli3区别</h3><ul><li>vue-cli3基于webpack4，vue-cli2基于webpack3</li><li>vue-cli3的设计原则是0配置，移除build/config等目录</li><li>vue-cli3提供vue ui命令，提供可视化配置</li><li>移除了static文件夹，新增public文件夹，并且将index.html移入public</li></ul><h3 id="vue-cli3-test"><a href="#vue-cli3-test" class="headerlink" title="vue-cli3-test"></a>vue-cli3-test</h3><ol><li>public()</li><li>src(源码)</li></ol><p><code>Vue.config.productionTip = false</code>构建信息是否显示</p><p>vue-cli3配置文件查看和修改<br>通过vue ui图形化设置</p><p>新建一个vue.config.js</p><h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h2><ul><li>认识路由</li><li>vue-router的使用</li><li>vue-router嵌套路由</li><li>vue-router参数传递</li><li>vue-router导航首位</li><li>keep-alive</li></ul><h3 id="前端渲染和后端渲染"><a href="#前端渲染和后端渲染" class="headerlink" title="前端渲染和后端渲染"></a>前端渲染和后端渲染</h3><ol><li>后端渲染（服务端渲染）<br>jsp<br>后端路由，后端处理URL和页面映射关系</li><li>前后端分离（ajax请求数据）<br>后端只负责提供数据<br>静态资源服务器（html+css+js）<br>ajax发送网络请求后端服务器，服务器回传数据<br>js代码渲染dom</li><li>单页面富应用（SPA页面）<br>前后端分离加上前端路由<br>整个网站只有一个html页面</li></ol><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><ol><li>通过hash修改<br><code>location.hash='home'</code></li><li>html5的history(栈结构-先进后出)<br><code>history.pushState({},'','home')</code>入栈<br>使用<code>history.back()</code>出栈<br>替换<code>history.replaceState({},'','about')</code><br>go<code>history.go(-1)</code><br>向前一步<code>history.forwaed()</code>等价于<code>history.go(1)</code></li></ol><h3 id="认识vue-router"><a href="#认识vue-router" class="headerlink" title="认识vue-router"></a>认识vue-router</h3><p>安装<br><code>npm install vue-router --save</code></p><pre><code>//配置路由相关信息import VueRouter from 'vue-router'import Vue from 'vue'import Home from '../components/Home.vue'import About from '../components/About.vue'// 1.通过Vue.use(插件)，安装插件Vue.use(VueRouter)//映射关系const routes = [  {    path:'',    redirect:'/home'//路径为''自动重定向到/home  },  {    path: "/home",    component: Home  },  {    path: "/about",    component: About  }]// 2.创建vueRouter对象const router = new VueRouter({  //配置组件和路由之间关系  routes,  mode:'history',//修改路由默认模式hash为history  linkActiveClass:'active',//统一修改被激活状态路由class为active})// 3.将router对象传入Vue实例中export default router</code></pre><p><code>&lt;router-link to="/home"&gt;首页&lt;/router-link&gt;</code><br>路由组件渲染出来是a标签<br>属性：</p><ul><li>to 路由地址</li><li>tag 默认渲染a标签，可以用<code>tag='button'</code>，渲染为button</li><li>replace 使浏览器history无效</li><li>active-class 默认路由被激活状态时class为<code>router-link-active</code>,想修改使用<code>active-class='active'</code></li></ul><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code><br>路由组件显示组件内容占位</p><blockquote><p>通过代码跳转路由</p></blockquote><pre><code>homeClick(){  //通过代码方式修改路径 vue-router  this.$router.push("/home")  //this.$router.replace("/home")},aboutClick(){  this.$router.push("/about")  //this.$router.replace("/about")}</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><blockquote><p>配置路由</p></blockquote><pre><code>{  path: "/user/:userId",//动态路由  component: User}</code></pre><blockquote><p>设置router-link</p></blockquote><p>  动态路由<br>  <code>&lt;router-link :to="/user/+userId"&gt;用户&lt;/router-link&gt;</code></p><blockquote><p>路由页面获取值<br>在路由组件出使用<code>this.$route.params</code></p></blockquote><pre><code>computed: {    userId(){      //获取活跃状态的路由      return this.$route.params.userId    }  },{{$route.params.userId}}</code></pre><h3 id="认识路由的懒加载"><a href="#认识路由的懒加载" class="headerlink" title="认识路由的懒加载"></a>认识路由的懒加载</h3><p>当打包时候js文件很大，影响加载速度<br>将不同路由的组件分割成不同的代码块，然后当路由被访问时候才加载对应组件<br>使用懒加载</p><pre><code>{  path: "/user/:userId",//动态路由  component: () =&gt; import("../components/Home.vue")}</code></pre><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><blockquote><p>路由配置</p></blockquote><pre><code>children: [  {    path: "news",    component: ()=&gt; import("../components/HomeNews.vue")  },  {    path: "messages",    component: ()=&gt; import("../components/HomeMessages.vue")  }]</code></pre><p>注意path不加’/‘</p><blockquote><p>路由组件</p></blockquote><p>在Home.vue（需要嵌套的路由组件）</p><pre><code>&lt;router-link to="/news"&gt;新闻&lt;/router-link&gt;&lt;router-link to="/messages"&gt;消息&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h3 id="vue-router的参数传递"><a href="#vue-router的参数传递" class="headerlink" title="vue-router的参数传递"></a>vue-router的参数传递</h3><ul><li><p>动态路由方式：通过<code>$route.params.userId</code>获取由<code>path: "/user/:userId"</code>，需要传递的参数<code>&lt;router-link :to="/user/+userId"&gt;用户&lt;/router-link&gt;</code></p><ul><li>配置路由方式<code>/router/:id</code></li><li>传递方式<strong>在path后面跟上对应的值</strong></li><li>传递后形成的路径：<strong>/router/123、/router/aaa</strong></li></ul></li><li><p>通过<code>$route.query</code>获取传过来的对象,路由配置<code>path: "/user"</code>,传递参数<code>&lt;router-link :to="{path:'/profile',query:{id:'zzz',age:18}}"&gt;档案&lt;/router-link&gt;</code></p><ul><li>配置路由方式<code>/router</code>，跟普通配置一样</li><li>传递的方式：对象中使用<strong>query的key作为参数传递</strong></li><li>传递后的路径：<strong>/router?id=123、/router?id=aaa</strong></li></ul></li><li><p>通过方法传递<code>$router.push()</code></p><pre><code>  linkClick() {    const obj = {      path: "/link",      query: {        id: 123,        age: 22,        height: 188      }    };    this.$router.push(obj);  }</code></pre></li></ul><h3 id="理解vue-router-router和route的由来"><a href="#理解vue-router-router和route的由来" class="headerlink" title="理解vue-router-router和route的由来"></a>理解vue-router-router和route的由来</h3><h3 id="vue-router全局导航守卫"><a href="#vue-router全局导航守卫" class="headerlink" title="vue-router全局导航守卫"></a>vue-router全局导航守卫</h3><p>SPA页面修改title，使用全局导航守卫</p><p>定义meta元数据</p><pre><code>{  path: "/home",  component: Home,  meta: { //元数据    title: "首页"  }}</code></pre><p>通过beforeEach(to,from,next)获取，不调用next,路由无法跳转</p><pre><code>//前置钩子(守卫)跳转前-----全局守卫router.beforeEach((to, from, next) =&gt; {  //获取要跳转的路由的元数据  document.title = to.meta.title  //document.title = to.matched[0].meta.title//嵌套路由时候可以使用这个获取父路由元数据  //调用next()  next()})</code></pre><p><code>next('\')</code>跳转到\，<code>next(false)</code>不跳转</p><p>//后置钩子(守卫)跳转后,不需要主动调用next()—–全局守卫</p><pre><code>router.afterEach((to,from)=&gt;{  console.log(to);})</code></pre><p>路由独享守卫</p><p>  {<br>      path: “/home”,<br>      component: Home,<br>      meta: { //元数据<br>        title: “首页”<br>      },<br>      beforeEnter: (to, from, next) =&gt; {<br>        // 进入之前<br>        console.log(“11111”);</p><pre><code>    next()  },</code></pre><p>  }</p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">更多详见Vue-Router</a></p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><ul><li>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染</li><li>router-view也是一个组件，如果直接被包在keep-alive里面，所有路径匹配到的视图组件都被缓存</li></ul><p>两个函数：</p><pre><code>activated() {    console.log("activated");    //处于活跃状态时候跳转页面，活跃状态调用    this.$router.push(this.path);  },  deactivated() {    //失去活跃状态调用    console.log("deactivated");  },</code></pre><p>属性：</p><ul><li>include - 字符串或正则表达式，只有匹配的才会缓存</li><li>exclude - 字符串或正则表达式，只有匹配的才不会缓存</li></ul><h3 id="TabBar案例"><a href="#TabBar案例" class="headerlink" title="TabBar案例"></a>TabBar案例</h3><p>首页/分类/购物车/我的</p><ul><li><p>style中引用使用@import</p></li><li><p>路径起别名（webpack配置文件）</p><p>resolve: {<br>  extensions: [‘.js’, ‘.vue’, ‘.json’],<br>  alias: {</p><pre><code>'@': resolve('src'),'assets': resolve('src/assets'),'components': resolve('src/components'),'views': resolve('scr/views')</code></pre><p>  }<br>},</p></li></ul><blockquote><p>引用路径</p></blockquote><ul><li>import TabBarItem from “components/tabbar/TabBarItem”;</li><li><code>&lt;img src="~assets/img/tarbar/shop.png" alt="" srcset=""&gt;</code>需要使用~<br>vue-cli3中先定义了<code>'@': resolve('src'),</code>,可以使用<code>'assets': resolve('@/assets'),</code></li></ul><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><p>Promise是一种JavaScript异步编程的解决方案。</p><h3 id="使用axaj异步请求"><a href="#使用axaj异步请求" class="headerlink" title="使用axaj异步请求"></a>使用axaj异步请求</h3><p>可能会这样嵌套</p><pre><code>$.ajax({    $.ajax({        ...    })})</code></pre><h3 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h3><h4 id="什么时候使用Promise？"><a href="#什么时候使用Promise？" class="headerlink" title="什么时候使用Promise？"></a>什么时候使用Promise？</h4><p>有异步操作时候，对异步操作进行封装。</p><h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><pre><code>new Promise((resolve, reject) =&gt; {})</code></pre><p>Promise对象需要传入一个函数<code>(resolve, reject) =&gt; {}</code>，这个函数传入的两个参数resolve和reject也是函数。<br>此时用setTimeout模拟异步请求</p><pre><code>// 参数-&gt;函数(resolve,reject)// resolve,reject本身又是函数new Promise((resolve, reject) =&gt; {  //第一次网络请求  setTimeout(() =&gt; {    //调用了resolve()就会到then()    resolve()  },1000)}).then(()=&gt;{  //第一次请求结果  console.log("hello promise");  //返回Promise对象，链式调用  return new Promise((resolve, reject)=&gt;{    //第二次网络请求    setTimeout(()=&gt;{      resolve()    },1000)  }).then(()=&gt;{    //第二次请求结果    console.log("hello vue")  })})</code></pre><p>调用resolve()就会执行到then()，在then()中可以执行异步代码，在网络请求响应后需要执行的代码，then()中可以返回一个Promise对象，嵌套使用异步请求。<br>虽然代码变多了，但是逻辑很清晰。</p><blockquote><h4 id="reject-函数和catch"><a href="#reject-函数和catch" class="headerlink" title="reject()函数和catch()"></a>reject()函数和catch()</h4><pre><code>  // 什么情况下会使用Promise？  // 一般是有异步操作，使用Promise这个异步操作进行封装  // new -&gt; 构造函数(1.保存一些状态信息 2.执行传入的函数)  // 在执行回调函数时候(resolve，reject)本身又是函数  new Promise((resolve,reject) =&gt; {    setTimeout(() =&gt; {      //成功时候调用resolve      //失败的时候调用reject      reject('error message')    }, 1000);  }).catch(error =&gt; {    console.log(error)  })</code></pre></blockquote><h3 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h3><ul><li>pending:等待状态，正在进行网络请求，或定时时间未到</li><li>fulfil:满足状态，当我们主动回调resolve函数，就处于该状态，并且会回调then()</li><li>reject:拒绝状态，主动回调reject函数，就处于该状态，并且会回调catch()</li></ul><h3 id="Promise其他使用形式"><a href="#Promise其他使用形式" class="headerlink" title="Promise其他使用形式"></a>Promise其他使用形式</h3><pre><code>    new Promise((resolve,reject) =&gt; {      setTimeout(() =&gt; {        //成功时候调用resolve        //resolve('success message')        //失败的时候调用reject        reject('error message')      }, 1000);    }).catch(success =&gt; {      console.log(success)    },error =&gt; {      console.log(error)    })</code></pre><h3 id="Promise的链式调用"><a href="#Promise的链式调用" class="headerlink" title="Promise的链式调用"></a>Promise的链式调用</h3><pre><code>    new Promise((resolve, reject) =&gt; {      //第一次网络请求      setTimeout(() =&gt; {        //调用了resolve()就会到then()        resolve()      },1000)    }).then(()=&gt;{      //第一次请求结果      console.log("hello promise");      //返回Promise对象，链式调用      return new Promise((resolve, reject)=&gt;{        //第二次网络请求        setTimeout(()=&gt;{          resolve()        },1000)      }).then(()=&gt;{        //第二次请求结果        console.log("hello vue")      })    })</code></pre><p>第二种</p><pre><code> &lt;script&gt;    //网络请求aaa -&gt;处理（）    //处理 aaa+111 -&gt;处理    //处理aaa111+222 -&gt;处理    new Promise((resolve,reject)=&gt;{      setTimeout(() =&gt; {        resolve('aaa')      }, 1000);    }).then(res=&gt;{      console.log(res)      return new Promise(resolve=&gt;{        resolve(res+'111')      }).then((res)=&gt;{        console.log(res)        return new Promise(resolve=&gt;{          resolve(res+'222')        }).then(res=&gt;{          console.log(res)        })      })    })  &lt;/script&gt;</code></pre><p>简写</p><pre><code>    //简写    new Promise(resolve =&gt; {      setTimeout(() =&gt; {        resolve('aaa')      }, 1000);    }).then(res =&gt; {      console.log(res)      return Promise.resolve(res + '111')    }).then((res) =&gt; {      console.log(res)      return Promise.resolve(res + '222')    }).then(res =&gt; {      console.log(res)    })    //在简写    new Promise(resolve =&gt; {      setTimeout(() =&gt; {        resolve('aaa')      }, 1000);    }).then(res =&gt; {      console.log(res)      return es + '111'    }).then((res) =&gt; {      console.log(res)      return res + '222'    }).then(res =&gt; {      console.log(res)    })</code></pre><p>catch捕获异常</p><pre><code>    //catch    new Promise(resolve =&gt; {      setTimeout(() =&gt; {        resolve('aaa')      }, 1000);    }).then(res =&gt; {      console.log(res)      // return Promise.reject('error message')      throw 'error message'    }).then((res) =&gt; {      console.log(res)      return res + '222'    }).then(res =&gt; {      console.log(res)    }).catch(error){      console.log(error)    }</code></pre><h3 id="Promise的all"><a href="#Promise的all" class="headerlink" title="Promise的all"></a>Promise的all</h3><p>如下情况：<br>有两个网络请求A和B,只有AB都返回结果才进行下一步<br>ajax可能会这么写</p><pre><code>$.ajax({  ...//结果A  resultA = true  callback()})$.ajax({  ...//结果B  resultB = true  callback()})//回调函数function callback(){  if(resultA&amp;&amp;resultB){    ...  }}</code></pre><p>使用Promise的all</p><pre><code>    Promise.all([      new Promise((resolve, reject) =&gt; {        $.ajax({          url:"url1",          success:function(data){            resolve(data)          }        })      }),      new Promise((resolve, reject) =&gt; {        $.ajax({          url:"url2",          success:function(data){            resolve(data)          }        })      }),    ]).then(res =&gt; {      // result[0]网络请求1的结果      // result[1]网络请求2的结果    })</code></pre><h2 id="VueX是做什么的？"><a href="#VueX是做什么的？" class="headerlink" title="VueX是做什么的？"></a>VueX是做什么的？</h2><p>VueX是一个专门为vue.js应用程序开发的状态管理模式</p><p>简单来说就是多个组件都需要的一个变量，放在哪个组件内都不合适，此时由vuex来管理才合适。</p><h3 id="哪些状态需要VueX管理"><a href="#哪些状态需要VueX管理" class="headerlink" title="哪些状态需要VueX管理"></a>哪些状态需要VueX管理</h3><p>多个页面需要共享的，类似java的服务器的application/session，不要什么都放在VueX</p><ul><li>比如用户登录状态、用户名称、头像、地理位置</li><li>商品收藏/购物车</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>npm install vuex --save</code></p><ol><li>src下新建store文件夹，index.js<pre><code>import Vue from 'vue'import Vuex from 'vuex'</code></pre>//1安装插件<pre><code>Vue.use(Vuex)</code></pre></li></ol><p>//2.创建对象</p><pre><code>const store = new Vuex.Store({  state:{//保存状态    counter:1000  },  mutations:{  },  actions:{  },  getters:{  },  modules:{  }})</code></pre><p>//导出对象</p><pre><code>export default store</code></pre><ol start="2"><li>导入到man.js<pre><code>import store from './router'new Vue({el: '#app',router,store,render: h =&gt; h(App)})</code></pre></li></ol><h3 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h3><p>定义了一个state，<code>counter:1000</code>键值对</p><pre><code>const store = new Vuex.Store({  state:{//保存状态    counter:1000  },)}</code></pre><h3 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h3><p>修改counter</p><pre><code>  mutations:{    //定义方法默认传递state参数    increment(state){      state.counter++    },    decrement(state){      state.counter++    }  },</code></pre><p>调用</p><pre><code>  methods: {    add() {      console.log("add");      this.$store.commit("increment");    },    sub() {      console.log("sub")      this.$store.commit("decrement");    }  }</code></pre><p>使用<code>$store.commit('increment')</code>调用<br>mutations中不要使用异步方法，actions（异步操作）无法跟踪到</p><h3 id="Getters的使用"><a href="#Getters的使用" class="headerlink" title="Getters的使用"></a>Getters的使用</h3><p>Getters类似计算属性computed</p><pre><code>    students:[      {      name:"zzz",      age:24      },      {      name:"ttt",      age:19      },      {      name:"yyy",      age:30    more20stu(state){      return state.students.filter(s=&gt; s.age&gt;20)    }</code></pre><p>使用</p><pre><code>    &lt;ul&gt;      &lt;li v-for="(item, index) in $store.getters.more20stu" :key="index"  &gt;{{item}}&lt;/li&gt;    &lt;/ul&gt;</code></pre><p>补充</p><pre><code>    more20studLength(state,getters){//第二个参数可以传getters      return getters.more20stu.length    }</code></pre><p>使用传参</p><pre><code>    moreAgestu(state){      return age=&gt;{ //传入一个参数        return state.students.filter(s=&gt;s.age&gt;age)      }    }</code></pre><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>异步操作，action中调用commit（即mutations），通过promise异步回调</p><pre><code>  actions:{    //context上下文    aUpdateInfo(context,payload){      return new Promise((resolve,reject)=&gt;{        setTimeout(() =&gt; {          context.commit('modifyInfo')          console.log(payload)          resolve('携带数据')        }, 1000)      })    }  },</code></pre><p>调用<code>$store.dispatch('aUpdateInfo',参数)</code></p><pre><code>aUpdateInfo(){      this.$store.dispatch('aUpdateInfo','这是要传递的信息').then(res=&gt;{        console.log('已经完成了提交');        console.log(res)      })    }</code></pre><h3 id="modules的使用"><a href="#modules的使用" class="headerlink" title="modules的使用"></a>modules的使用</h3><p>store可以分割成模块，</p><pre><code>modules:{    a:{      state:{        name:'zhangsan'      },    }  }</code></pre><p>调用</p><pre><code>$store.state.a.name</code></pre><h3 id="对象的结构（ES6）"><a href="#对象的结构（ES6）" class="headerlink" title="对象的结构（ES6）"></a>对象的结构（ES6）</h3><pre><code>const obj = {  name:'zzz',  age:18,  height:177}const {name,age,height} = obj</code></pre><p>此时会把obj的属性赋值给对应的名字属性</p><h3 id="vuex的推荐目录结构"><a href="#vuex的推荐目录结构" class="headerlink" title="vuex的推荐目录结构"></a>vuex的推荐目录结构</h3><pre><code>├── index.html├── main.js├── api│   └── ... # 抽取出API请求├── components│   ├── App.vue│   └── ...└── store    ├── index.js          # 我们组装模块并导出 store 的地方    ├── actions.js        # 根级别的 action    ├── mutations.js      # 根级别的 mutation    └── modules        ├── cart.js       # 购物车模块        └── products.js   # 产品模块</code></pre><h2 id="axios基本使用"><a href="#axios基本使用" class="headerlink" title="axios基本使用"></a>axios基本使用</h2><h3 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h3><pre><code>const arr = ['zzz','ttt','ddd']const {arr1,arr2,arr3} = arr</code></pre><h3 id="axios配置"><a href="#axios配置" class="headerlink" title="axios配置"></a>axios配置</h3><pre><code>axios.defaults.baseURL = 'http://123.207.32.32:8000'axios.defaults.timeout = 5000</code></pre><h3 id="axios的all"><a href="#axios的all" class="headerlink" title="axios的all"></a>axios的all</h3><pre><code>// 2.axios发送并发请求axios.all([  axios({    url:"/api/v1/home/multidata"  }),  axios({    url:"/api/v1/home/data",    params:{      type:'sell',      page:4    }  })]).then(res=&gt;{  //res数组  console.log(res);})//then((res1,res2)=&gt;{console.log(res1);console.log(res2)})</code></pre><h3 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h3><pre><code>import axios from 'axios'export function request(config) {  // 1.创建axios的实例  const instance = axios.create({    baseURL: "http://123.207.32.32:8000'",    timeout: 5000  })  // 2.发送真正的网络请求  return instance(config)}</code></pre><p>调用</p><pre><code>request({  url: "/api/v1/home/multidata",}).then(res =&gt; {  console.log(res)}).catch(err =&gt; {  console.log(err)})</code></pre><h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><pre><code>instance.interceptors.request.useinstance.interceptors.response.us</code></pre><pre><code>  // 2.axios的拦截器  // 2.请求拦截  instance.interceptors.request.use(config =&gt; {    //拦截了config    console.log(config)    //1.修改config一些信息    //2.再发送网络请求，希望再界面显示一个图标    //3.某些网络请求（比如登录（token）），必须携带一些信息    // 需要返回    return config  }, err =&gt; {    //网络未通    console.log(err)  })  // 响应拦截  instance.interceptors.response.use(res=&gt;{    console.log(res)    return res.data  },err=&gt;{    console.log(err)  })</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux解压缩命令</title>
      <link href="/2019/12/17/2019-12-17-linux-jie-ya-suo-ming-ling/"/>
      <url>/2019/12/17/2019-12-17-linux-jie-ya-suo-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>linux中的一些小技巧提高工作效率</p><h3 id="解压及压缩命令"><a href="#解压及压缩命令" class="headerlink" title="解压及压缩命令"></a>解压及压缩命令</h3><h4 id="tar压缩命令"><a href="#tar压缩命令" class="headerlink" title="tar压缩命令"></a>tar压缩命令</h4><pre><code>tar -cvf examples.tar files|dir#说明：-c, --create  create a new archive 创建一个归档文件-v, --verbose verbosely list files processed 显示创建归档文件的进程-f, --file=ARCHIVE use archive file or device ARCHIVE  后面要立刻接被处理的档案名,比如--file=examples.tar#举例：tar -cvf file.tar file1       #file1文件tar -cvf file.tar file1 file2 #file1，file2文件tar -cvf file.tar dir         #dir目录</code></pre><h4 id="tar-解压命令"><a href="#tar-解压命令" class="headerlink" title="tar 解压命令"></a>tar 解压命令</h4><pre><code>tar -xvf examples.tar （解压至当前目录下）tar -xvf examples.tar  -C /path (/path 解压至其它路径)#说明：-x, --extract, extract files from an archive 从一个归档文件中提取文件#举例：tar -xvf file.tartar -xvf file.tar -C /temp  #解压到temp目录下</code></pre><h4 id="tgz压缩命令"><a href="#tgz压缩命令" class="headerlink" title="tgz压缩命令"></a>tgz压缩命令</h4><p> （tar.gz,tgz格式是相同的，命名不同而已）</p><pre><code>tar -zcvf examples.tgz examples (examples当前执行路径下的目录)说明：-z, --gzip filter the archive through gzip 通过gzip压缩的形式对文件进行归档举例：tar -zcvf file.tgz dir #dir目录</code></pre><h4 id="tgz-解压命令"><a href="#tgz-解压命令" class="headerlink" title="tgz 解压命令"></a>tgz 解压命令</h4><pre><code>tar -zxvf examples.tar （解压至当前执行目录下）tar -zxvf examples.tar  -C /path (/path 解压至其它路径)举例：tar -zcvf file.tgztar -zcvf file.tgz -C /temp</code></pre><h4 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h4><pre><code>gzip -d examples.gz examples</code></pre><h4 id="gzip解压"><a href="#gzip解压" class="headerlink" title="gzip解压"></a>gzip解压</h4><pre><code>gunzip examples.gz</code></pre><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><blockquote><p>zip 格式是开放且免费的，所以广泛使用在 Windows、Linux、MacOS 平台，要说 zip<br>有什么缺点的话，就是它的压缩率并不是很高，不如 rar及 tar.gz 等格式。</p></blockquote><p>压缩：</p><p>zip -r examples.zip examples (examples为目录)</p><p>解压：</p><p>zip examples.zip</p><h4 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h4><p>压缩：</p><p>rar -a examples.rar examples<br>解压：</p><p>rar -x examples.rar</p><h3 id="命令编辑及光标移动"><a href="#命令编辑及光标移动" class="headerlink" title="命令编辑及光标移动"></a>命令编辑及光标移动</h3><hr><p>这里有很多快捷键可以帮我们修正自己的命令。接下来使用光标二字代替光标的位置。</p><h4 id="删除从开头到光标处的命令文本"><a href="#删除从开头到光标处的命令文本" class="headerlink" title="删除从开头到光标处的命令文本"></a>删除从开头到光标处的命令文本</h4><p>ctrl + u，例如：</p><pre><code>$ cd /proc/tty;ls -al光标</code></pre><p>如果此时使用ctrl + u快捷键，那么该条命令都会被清除，而不需要长按backspace键。</p><h4 id="删除从光标到结尾处的命令文本"><a href="#删除从光标到结尾处的命令文本" class="headerlink" title="删除从光标到结尾处的命令文本"></a>删除从光标到结尾处的命令文本</h4><p>ctrl+k，例如：</p><pre><code>$ cd /proc/tty光标;ls -al</code></pre><p>如果此时使用ctrl + k快捷键，那么从光标开始处到结尾的命令文本将会被删除。</p><p>还有其他的操作，不再举例，例如：</p><ul><li><p>ctrl + a: 光标移动到命令开头</p></li><li><p>ctrl + e：光标移动到命令结尾</p></li><li><p>alt  f:光标向前移动一个单词</p></li><li><p>alt  b：光标向前移动一个单词</p></li><li><p>ctrl w：删除一个词（以空格隔开的字符串）</p></li></ul><h3 id="历史命令快速执行"><a href="#历史命令快速执行" class="headerlink" title="历史命令快速执行"></a>历史命令快速执行</h3><hr><p>我们都知道history记录了执行的历史命令，而使用!＋历史命令前的数字，可快速执行历史命令。另外，还可以使用ctrl+r搜索执行过的命令。</p><h2 id="部分历史命令查看"><a href="#部分历史命令查看" class="headerlink" title="部分历史命令查看"></a>部分历史命令查看</h2><p>history会显示大量的历史命令，而fs -l只会显示部分。</p><p>history 10</p><h2 id="实时查看日志"><a href="#实时查看日志" class="headerlink" title="实时查看日志"></a>实时查看日志</h2><pre><code>$ tail -f filename.log</code></pre><p>tail -f 加文件名，可以实时显示日志文件内容。当然，使用less命令查看文件内容，并且使用shift+f键，也可达到类似的效果。</p><h3 id="磁盘或内存情况查看"><a href="#磁盘或内存情况查看" class="headerlink" title="磁盘或内存情况查看"></a>磁盘或内存情况查看</h3><hr><h4 id="怎么知道当前磁盘是否满了呢？"><a href="#怎么知道当前磁盘是否满了呢？" class="headerlink" title="怎么知道当前磁盘是否满了呢？"></a>怎么知道当前磁盘是否满了呢？</h4><pre><code>    $ df -h/dev/sda14      4.6G   10M  4.4G   1% /tmp/dev/sda11      454M  366M   61M  86% /boot/dev/sda15       55G   18G   35G  35% /home/dev/sda1       256M   31M  226M  12% /boot/efitmpfs           786M   64K  786M   1% /run/user/1000</code></pre><p>使用df命令可以快速查看各挂载路径磁盘占用情况。</p><h4 id="当前目录各个子目录占用空间大小"><a href="#当前目录各个子目录占用空间大小" class="headerlink" title="当前目录各个子目录占用空间大小"></a>当前目录各个子目录占用空间大小</h4><p>如果你已经知道home目录占用空间较大了，你想知道home目录下各个目录占用情况：</p><pre><code>$ du -h –-max-depth=1 /home(或者-d 1)18G    /home/hyb16K    /home/lost+found18G    /home/</code></pre><p>这里指定了目录深度，否则的话，它会递归统计子目录占用空间大小，可自行尝试。</p><h4 id="当前内存使用情况"><a href="#当前内存使用情况" class="headerlink" title="当前内存使用情况"></a>当前内存使用情况</h4><pre><code>    $ free -h              total        used        free      shared  buff/cache   availableMem:           7.7G        3.5G        452M        345M        3.7G        3.5GSwap:          7.6G          0B        7.6G</code></pre><p>通过free的结果，很容易看到当前总共内存多少，剩余可用内存多少等等。</p><h4 id="使用-h参数"><a href="#使用-h参数" class="headerlink" title="使用-h参数"></a>使用-h参数</h4><p>不知道你是否注意到，我们在前面几个命令中，都使用了-h参数，它的作用是使得结果以人类可读的方式呈现，所以我们看到它呈现的单位是G,M等，如果不使用-h参数，可以自己尝试一下会是什么样的结果呈现。</p><h2 id="根据名称查找进程id"><a href="#根据名称查找进程id" class="headerlink" title="根据名称查找进程id"></a>根据名称查找进程id</h2><p>想快速直接查找进程id，可以使用：</p><pre><code>$ pgrep hello22692</code></pre><p>或者：</p><pre><code>$ pidof hello22692</code></pre><p>其中，hello是进程名称。</p><h2 id="根据名称杀死进程"><a href="#根据名称杀死进程" class="headerlink" title="根据名称杀死进程"></a>根据名称杀死进程</h2><p>一般我们可以使用kill　-9 pid方式杀死一个进程，但是这样就需要先找到这个进程的进程id，实际上我们也可以直接根据名称杀死进程，例如：</p><pre><code>$ killall hello</code></pre><p>或者：</p><pre><code>$ pkill hello</code></pre><h2 id="查看进程运行时间"><a href="#查看进程运行时间" class="headerlink" title="查看进程运行时间"></a>查看进程运行时间</h2><p>可以使用下面的命令查看进程已运行时间：</p><pre><code>$ ps -p 24525 -o lstart,etime                  STARTED     ELAPSEDSat Mar 23 20:52:08 2019       02:45</code></pre><p>其中24525是你要查看进程的进程id。</p><h2 id="快速目录切换"><a href="#快速目录切换" class="headerlink" title="快速目录切换"></a>快速目录切换</h2><ul><li><p>cd -　回到上一个目录</p></li><li><p>cd  回到用户家目录</p></li></ul><h2 id="多条命令执行"><a href="#多条命令执行" class="headerlink" title="多条命令执行"></a>多条命令执行</h2><p>我们知道使用分号隔开可以执行多条命令，例如：</p><pre><code>$ cd /temp/log/;rm -rf *</code></pre><p>但是如果当前目录是/目录，并且/temp/log目录不存在，那么就会发生激动人心的一幕：</p><pre><code>bash: cd: /temp/log: No such file or directory（突然陷入沉默）</code></pre><p>因为;可以执行多条命令，但是不会因为前一条命令失败，而导致后面的不会执行，因此，cd执行失败后，仍然会继续执行rm -rf *，由于处于/目录下，结果可想而知。<br>所以你还以为这种事故是对rf -rf *的力量一无所知的情况下产生的吗？</p><p>如果解决呢？很简单，使用&amp;&amp;，例如:</p><pre><code>$ cd /temp/log/&amp;&amp;rm -rf *</code></pre><p>这样就会确保前一条命令执行成功，才会执行后面一条。</p><h3 id="查看压缩日志文件"><a href="#查看压缩日志文件" class="headerlink" title="查看压缩日志文件"></a>查看压缩日志文件</h3><hr><p>有时候日志文件是压缩的，那么能不能偷懒一下，不解压查看呢？当然可以啦。<br>例如：</p><pre><code>$ zcat test.gztest log</code></pre><p>或者：</p><pre><code>$ zless test.gztest log</code></pre><h2 id="清空文件内容"><a href="#清空文件内容" class="headerlink" title="清空文件内容"></a>清空文件内容</h2><p>比如有一个大文件，你想快速删除，或者不想删除，但是想清空内容：</p><pre><code>&gt;filename</code></pre><h2 id="将日志同时记录文件并打印到控制台"><a href="#将日志同时记录文件并打印到控制台" class="headerlink" title="将日志同时记录文件并打印到控制台"></a>将日志同时记录文件并打印到控制台</h2><p>在执行shell脚本，常常会将日志重定向，但是这样的话，控制台就没有打印了，如何使得既能记录日志文件，又能将日志输出到控制台呢？</p><pre><code>$ ./test.sh |tee test.log</code></pre><h2 id="终止并恢复进程执行"><a href="#终止并恢复进程执行" class="headerlink" title="终止并恢复进程执行"></a>终止并恢复进程执行</h2><p>我们使用ctrl+z 暂停一个进程的执行，也可以使用fg恢复执行。例如我们使用</p><pre><code>$ cat filename</code></pre><p>当我们发现文件内容可能很多时，使用ctrl+z暂停程序，而如果又想要从刚才的地方继续执行，则只需要使用fg命令即可恢复执行。或者使用bg使得进程继续在后台执行。</p><h2 id="计算程序运行时间"><a href="#计算程序运行时间" class="headerlink" title="计算程序运行时间"></a>计算程序运行时间</h2><p>我们可能会进程写一些小程序，并且想要知道它的运行时间，实际上我们可以很好的利用time命令帮我们计算，例如：</p><pre><code>$ time ./fibo 30the 30 result is 832040real    0m0.088suser    0m0.084ssys    0m0.004s</code></pre><p>它会显示系统时间，用户时间以及实际使用的总时间。</p><h2 id="查看内存占用前10的进程"><a href="#查看内存占用前10的进程" class="headerlink" title="查看内存占用前10的进程"></a>查看内存占用前10的进程</h2><pre><code>$ ps -aux|sort -k4nr |head -n 10</code></pre><p>这里综合使用了ps，sort，head命令。</p><h2 id="快速查找你需要的命令"><a href="#快速查找你需要的命令" class="headerlink" title="快速查找你需要的命令"></a>快速查找你需要的命令</h2><p>我们都知道man可以查看命令的帮助手册，但是如果我们想要某个功能却不知道使用哪个命令呢？别着急，还是可以使用man：</p><pre><code>$ man -k "copy files"cp (1)               - copy files and directoriescpio (1)             - copy files to and from archivesgit-checkout-index (1) - Copy files from the index to the working treegvfs-copy (1)        - Copy filesgvfs-move (1)        - Copy filesinstall (1)          - copy files and set attributes</code></pre><p>使用-k参数，使得与copy files相关的帮助手册都显示出来了。</p><h2 id="命令行下的复制粘贴"><a href="#命令行下的复制粘贴" class="headerlink" title="命令行下的复制粘贴"></a>命令行下的复制粘贴</h2><p>我们知道，在命令行下，复制不能再是ctrl + c了，因为它表示终止当前进程，而控制台下的复制粘贴需要使用下面的快捷键：</p><ul><li><p>ctrl +  insert</p></li><li><p>shift + insert</p></li></ul><h2 id="搜索包含某个字符串的文件"><a href="#搜索包含某个字符串的文件" class="headerlink" title="搜索包含某个字符串的文件"></a>搜索包含某个字符串的文件</h2><p>例如，要在当前目录下查找包含test字符串的文件：</p><pre><code>$ grep -rn "test"test2.txt:1:test</code></pre><p>它便可以找到该字符串在哪个文件的第几行。</p><h2 id="屏幕冻结"><a href="#屏幕冻结" class="headerlink" title="屏幕冻结"></a>屏幕冻结</h2><p>程序运行时，终端可能输出大量的日志，你想简单查看一下，又不想记录日志文件，此时可以使用ctrl+s键，冻结屏幕，使得日志不再继续输出，而如果想要恢复，可使用ctrl+q退出冻结。</p><h2 id="无编辑器情况下编辑文本文件"><a href="#无编辑器情况下编辑文本文件" class="headerlink" title="无编辑器情况下编辑文本文件"></a>无编辑器情况下编辑文本文件</h2><p>如果在某些系统上连基本的vi编辑器都没有，那么可以使用下面的方式进行编辑内容：</p><pre><code>$ cat &gt;file.txtsome words(ctrl+d)</code></pre><p>编辑完成后，ctrl+d即可保存。</p><h2 id="查看elf文件"><a href="#查看elf文件" class="headerlink" title="查看elf文件"></a>查看elf文件</h2><h4 id="查看elf文件头信息"><a href="#查看elf文件头信息" class="headerlink" title="查看elf文件头信息"></a>查看elf文件头信息</h4><p>例如：</p><pre><code>$ readelf -h filename</code></pre><p>我们在显示结果中，可以看到运行的平台，elf文件类型，大小端情况等。</p><h4 id="查看库中是否包含某个接口"><a href="#查看库中是否包含某个接口" class="headerlink" title="查看库中是否包含某个接口"></a>查看库中是否包含某个接口</h4><pre><code>$ nm filename |grep interface</code></pre><p>这里是从文件filename中查看是否包含interface接口，前提是该文件包含符号表。</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>线上出现了问题，登上线上的机器查日志是非常常见的操作了。我第一次登上线上机器查日志的时候，我还只记得以下的几个命令（假设现在我们的日志文件叫做service.log)：</p><p>cat service.log</p><p>tail -f service.log</p><p>vim serivice.log</p><p>（明显是不够用的）<br>现在日志每天产出的大小大概1GB：</p><p>每天产出1GB大小的日志</p><p>每天产出1GB大小的日志</p><p>如果是小文件的话，单纯的cat命令还是可以应付的，但如果你直接用cat命令打开一个1GB的日志文件，保证卡死你（ctrl + c退出cat命令需要很久才能将cat命令停下来）。</p><p>一般我只用cat来查看这个小文件的文本内容是什么<br>同样地，如果是小文件，单纯的vim命令去打开文件也是可以应付的，但如果你用vi命令去打开一个1GB甚至更大的文件，也能明显感受到缓慢和卡顿。</p><p>平时我还是很喜欢用vi去查找对应的记录的，我一般的操作：</p><p>vi service</p><h2 id="在命令模式下"><a href="#在命令模式下" class="headerlink" title="在命令模式下"></a>在命令模式下</h2><p>按G跳转到文件的末尾</p><p>输入 / 关键字搜索对应的记录</p><p>按n往上查询，按N往下查询</p><p>tail -f service.log<br>这个命令我一般用于查看流量是否进来了（或者调试的时候可以直接看到日志，再迅速ctrl +c关掉）</p><p>面对比较大的日志文件，这我们就得配合grep来玩了，比如我们现在得知某个手机号收不到短信验证码，想要看一下这个手机号的日志是怎么样的。于是我们就可以这样搞：</p><p>cat service.log | grep 13888888888</p><p>这么一搞，就能将service.log中所有含有13888888888的记录给搜出来，搜索的速度还是贼快的。</p><p>检索日志</p><p>检索日志</p><p>现在我们已经能根据关键字搜到对应的记录了，接着我想看一下那条记录的日志上下文【这样就能知道这条数据大概的执行状态了】</p><p>首先，我们先要查出对应记录的行号，在cat 命令后面加上一个 -n 参数就好了。所以命令是:cat -n service.log | grep 13888888888 ，如下图我们就可以查到对应的行号了</p><p>查看行数</p><p>现在行数是29506，我们一般只要看一下29506的前10行和后10行就差不多知道问题出现在哪了，于是我们可以这样做：</p><p>sed -n “29496,29516p” service.log：从29496行开始检索，到29516行结束<br>cat -n service.log | tail -n +29496 | head -n 20:从29496行开始检索，往前推20条<br>如果关键字不太准确（日志输出的记录太多了），我们可以使用more命令来浏览或者输出到文件上再分析：</p><p>cat service.log | grep 13 |more ：将查询后的结果交由more输出<br>cat service.log | grep 13 &gt; /home/sanwai/aa.txt  将查询后的结果写到/home/sanwai/aa.txt文件上<br>有的时候，我们想统计这个日志输出了多少行，我们可以使用这条命令：</p><p>cat service.log | wc -l<br>查看行数<br>查看行数<br>参考资料：</p><p><a href="https://www.cnblogs.com/xiashan17/p/7059978.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiashan17/p/7059978.html</a></p><h3 id="查进程和端口"><a href="#查进程和端口" class="headerlink" title="查进程和端口"></a>查进程和端口</h3><p>查进程有两个命令：</p><p>ps -ef<br>ps aux<br>上面两个命令都是列出所有的进程，我们还是通过 |管道和grep 来过滤掉想要查的进程，比如说：ps -ef |grep java</p><p>把进程查出来干嘛？知道它的进程ID了，我们可以把他给杀掉。</p><p>kill -9 processId：杀掉某个进程<br>查端口也是一个很常见的操作，常见命令：netstat -lntup：</p><p>l:listening   n:num   t:tcp  u:udp  p:display PID/Program name for sockets</p><p>查看当前所有tcp/udp端口的信息<br>查看某个端口详细的信息：lsof -i:4000</p><p>查看某个端口的详细信息<br>查看某个端口的详细信息<br>三、查看系统的状态</p><p>3.1 TOP实时查看进程的状态</p><p>TOP命令查看进程的状态，其中有个load average可能不是那么好理解，下面来解释一下：</p><p>load average：在特定时间间隔内运行队列中(在CPU上运行或者等待运行多少进程)的平均进程数。</p><p>load average 有三个值，分别代表：1分钟、5分钟、15分钟内运行进程队列中的平均进程数量。</p><p>正在运行的进程 + 准备好等待运行的进程   在特定时间内（1分钟，5分钟，10分钟）的平均进程数<br>Linux进程可以分为三个状态：</p><p>阻塞进程<br>可运行的进程<br>正在运行的进程<br>比如现在系统有2个正在运行的进程，3个可运行进程，那么系统的load就是5，load average就是一定时间内的load数量均值。</p><p>3.2free查看内存使用状况</p><p>linux的内存管理机制的思想包括（不敢说就是）内存利用率最大化，内核会把剩余的内存申请为cached，而cached不属于free范畴。</p><p>如果free的内存不够，内核会把部分cached的内存回收，回收的内存再分配给应用程序。所以对于linux系统，可用于分配的内存不只是free的内存，还包括cached的内存（其实还包括buffers）。</p><p>可用内存=free的内存+cached的内存+buffers<br>Buffer Cache和Page Cache。前者针对磁盘块的读写，后者针对文件inode的读写。这些Cache有效缩短了 I/O系统调用(比如read,write,getdents)的时间。磁盘的操作有逻辑级（文件系统）和物理级（磁盘块)</p><p>//可以防止日志爆盘，将所有标准输出及标准错误输出到/dev/null空设备，即没有任何输出信息。<br>nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL大全</title>
      <link href="/2019/12/17/2019-12-17-mysql-da-quan/"/>
      <url>/2019/12/17/2019-12-17-mysql-da-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><hr><h3 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a>1.主键、外键、超键、候选键</h3><p><strong>超键：</strong> 在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p><strong>候选键：</strong> 是最小超键，即没有冗余元素的超键。</p><p><strong>主键：</strong> 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p><strong>外键：</strong> 在一个表中存在的另一个表的主键称此表的外键。</p><h3 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a>2.为什么用自增列作为主键</h3><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、</p><p>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、</p><p>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p><p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页的中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><h3 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a>3.触发器的作用？</h3><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p><h3 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a>4.什么是存储过程？用什么来调用？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>调用：</strong> </p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java程序。</p><h3 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a>5.存储过程的优缺点？</h3><p><strong>优点：</strong> </p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p><p><strong>缺点：</strong> </p><p>移植性差</p><h3 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a>6.存储过程与函数的区别</h3><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAtEAAAFRCAMAAACFTwFwAAAA/1BMVEX////h4eH//75wADub3P++cAA7m5twAHC+//9wvv///9ybOwDcmzsAAAAAcL4AO5vc//9wAAAAAHC+cDubOzv/vnC+3Js7ADs7m9z/3Js7O5vc3Js7AAC+cHC+/9xwvr5wO5ubvps7AHC+vnAAADub3L4AcJu+/77/3NybcAAAO3BwOwBwcACbm3AAOzs7cL5wm5ubmzs7Ozubm9zcvnBwcHA7m77c/9xwcL4AcHDc/747cHDc3Nyb3NxwcDtwvtw7OwC+mzu+3NybO3Dc3L7cvpvcm3D/3L7Pz8+bcJtwOzubm75wm9ybvv/c3P++vr47cJu+m5twpJukcABwcJtadwYzAAA8XklEQVR42u19C5sTR7JlraSkVVJW6WGSrmo0YNoCBhtj6MUwwADmenfu3r2zd5///7fsF698VJXUUj9odXWc77OBbqkemScjIyMz4mRZlv2nTKHoE5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oFzoYPRiOwj/MvaOx/5HJ+aeTKf3NFqUtELP5Tb/Jd8NgUTCW4yz7YTSZ5pP7o6TVFDeHDkY76CjG5P7IltiFywfHo8GCKY2MtkVRZpmt8Dt3iNECW8Cru3IyzW2ZufKmn0eBaDDaFjHKrD6ZA3sHQ2JzffJwJb+czTN7hxldr5jCf3k0ffzjPDNitBU3i7aNro+j6dNStw2GT+KfiteBjL5rXkd9+lORZ/XpOLOlqWoa4eunR2P8meKm0Wa0qYy3woPFs2nh/10URZW5ShiNPy7vnI0G3prlg9Pni/KvL6oscz//UmWZWY9gQrvph1O0Ge29aFvkmSvKzABlDTHWVERmstGT6V30HckS0/9N5YpyMgV/42UuE5riRtFktLiHk+l6lA2GvxKjmdD4d/BKiNH16tVvfuGfX+DmtxLA5cn09emb2Rzbg5fLlse+4obRYPRgcUaMRg4P/rODfmLWVsRoWAsSo+0ZTrh3zDbVp4+mRfX2dGyKHGy0rKFPHxxr/O4A0GC0qWwZ3ObZHBh9b/EaplgjjBY/enD0phz8OL9zjF5B0BIsdb0qKjbZuKy4U81wsGj50UxP5i7a6IwW9E1G28qWGTqRdypuhSvDguhrKiSyhQnN3R3H66CxA6PP1k/YRg8WJdKZgnV/GfNn75iNjmJ02EoOh7Mrfl+r13EA2IHRBQddq3r1bppE6e4mo1dFHM0cLIq8XuUQGbJK6QNAJ6NdUXDnuHJyf0RmyVT1b/Gm4nKM6/toC/HuAVaGOPQNel3u7vhehws9e6foF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5TRin5BGa3oF5qMDgWD4DidnOfHBH4+jefPlw1+nNen4/pkzong9enYf1tO4tkk9S4pnJANFo28PDd7P8UfDY7wHlHenhRxynxeH/8SShnxXfHB4N/NI3BQQ0cuFZc+mtDd5Lx3ZnY7FeuS06Tx4VLMZNv52Xdpv7hxoh9h1rmbyTfhEKRLu+nuosVo6BDqA9+GSR2KqNtNDjl3uRQPgx5hvvivpqxNGd1iHnzLlNlg+LTFiujsMV1bngkZfRSysx3nsybXLcNj0xNy5u/x00XEARedk90GrJ4kueDyeP7yezz7Du3HSRZiG4jx/IqmyiJG898t/eRupukj9mF0bL+BCIO/1ac/VfzjZ2DOP4QeST7MHPGMNvGFmp99fvT8yFur5Tg2iVxKoJjN6QpYSmT2MbLRJrKan+Kz+cUyWMAPi/LvnoaeRZzPXq/OSeneyug9nj3b2n50PZ5GpEvwWeGXYNzl7UpHubtAZiuj0X/xzmFfG23D5CfVlN6W1KPprImN7ykcuy/Qp1FzO/6sv4+Tade0itvYEh/Nzd4KfRsFFOvj0WRaNX4YXwF+Zchm8qf4D7ccI5epmt02bGP0Ps++vf2S5pZsfM/ozOSmzBIbjR0S7ndnsw+2+9H0s4jR6Ah6x9B8OgYvFmxD1Zw1B8Mn3kSuRzLNjzrrL6WMNmXbF/UgVrxaiT+KFfnYTi/HQFbrRwhZ6/UIvM76dNys6WdjYmNSO17p3Fyc1I8mCKP3evat7Ream17lBFyNwOgs+RzcnoxGldzsLmKrjf6YuBkwKZsyNJaBBDuYKo/G+JP69KfH0OJhMg92osnoaOBUMoyQDPXx5/ujwdHY+yXPYuterD+TnfMFcQbDL/d+nNcnH4/Gg6NxfXYMfixdbzmGITIYjjB7u5QHkWeqV4mpDr7QeUxIbHTiVxTrsz2efXv70a18A2Lafc6M/rgoZqGkZoHVnGzBdtrXxLqjnnSrptLpNq/DrUfx8KcG55aeTIsyELXicqbMlx1stCnRIyhxWL0su57Luy+zOfaXySGvN9joR9PHZHDFRhOjgdR45+jxssn03nCU+PNMZbjD1hnbbvE69nr2re2XXlYKxIqNxjaECAe1paXlbULiO1SKMMFejB4slsEA5SZYCJzpn/Cs6W20n+bB60j96MR2jZjRk2mOfWz95EmX4qUQ/mQids5AbDE3j2OHZfC3QcroFd/8K6yTTLH+Q9ylyn829sR3q2q+ldH7PPvW9qPnlL/CiJQFR2A0Bzsc1nRaJWNBGS1ohlezxMa8Oh3HFf65thAk+NPH6tM34qWyP7nZRktVSF9KrsrMp1XOvqiLHgKdzFXkkNPaqGTDFYZHmQ26bHRmC4lpxSawsTKMoyJbmyz2xzv96F2ffWv78eVCv3yQGU8YDVOgw7HRWWZCGU3AxfUGG+3KOmY0dAQFiSi3HxZfs2/kzZVSejYxe3E8miZaWmfCneBKjjkJo0HmVQ5EtexcmIrpUWbR7WjyDnsN4CxB/4clbZvRmWfEOUVz6ZW3eB27Pvv29mtcNptAqZSY0Vhzk+22Mjqgyeho6dfhRyeMzqTWm1m+hI/CdkFlpUdsaVtWL2a0QRbnuJ7nEp+TKZcaR/vuWESAnMROVtwfUR/Xpw9OHyAPUxtNlhcWUWWoT5dtZDStEs6jAsUftjJ6x2ff2n5Z41HM8mWRe0bb2ceFbLngvYIHLgN5xx3Q3qHBaOJcg9GhXVNGQ3ksu3w0XY7RgACvJERWCk822GgMWdGF6uOnw5HDxd3s7XqE8+lRtF5365ErqubqSi6Hq8kZbieDx5Iw2tHs7SCmUNI8sNnrwEWCv+kW2GjfzzM6BOv2ePZt7ZelrYchGt7jLGbvp7Nv5xW30ugdgdpkMsW4EvaSjYOc3s8DW/DHehS2ac2zaVGaSmL9pWv2SRYxGotTy8WL2Vs+XkEuZyWsgEfIJQIud/3Kdg5tUjWZggXOmWBGItHJTdHy0nVbNjo4z4+Jz+7ckxF8DYpvc+gn/s7Oz84bPRvaL+kPvwMo0bsf5/GC5/WqGRrRHRbFgSJssewJ3QVXHCbq1YUoPZne0XWhMlrRNyijFf2CMlrRLyijFf2CMlrRL5zH6PScb9hR4E0Au3FJjToBho+/w45vQXFhOeCGf97ZoKni2rCB0SL8RJu1TvbZILUtPUO8ca/VzT4ORybnP+DsMm6CfKL9M9oa47QpUrhUciuuAt2M9tvVIR1VTrfnzQM0GyL5LUaDfcfzHkjf53hQqYpOBdk7G0FVXCU6GS00dXz0xUnmHOr3pQfkN9nWJqOBwpjPbEo5jYQnH8KBiItujykUEToZHSUDYSZfzOisaaM3ZJo2Gf1T6Q8Wz+ZJLlP7/JpCcWF0MtrEyUD16Tgw+h4edfsWuFcfPzntMtLhKOmrY7LRi99LXlvaJIM5XOpUPWnFpdHF6HAQEUgmpXuwEsZ6ZIvlv3yDlFBW8iw70547/Gg6k8oqrUWHkd4tJ0qh2IouRgeP1lL5HlkZzl7QcUf5j5aQjUpJjI5Yx8vGmfSGXVZGK64A2xmd2eL35TiL/WhbFMs3YqOpGFWnAwxU/jxtRu/IRid5tD6tTxmtuAJs9zq4ZlbC6NhGk0fcGcGz5WD4+f5IGL0A5wJUlysq7jj5E3msNlpxxeheGUYhtQ+L5XgToyVyhzuBjYRTKAD0lL1ntNHehzGU1oS+Ssxo3UBUXAG6o3c+Zxbyje3sbbRn6IMYJacwZ2LJTbxFguVSvlCJFMh7Pop8F7LS9W/NknoavVNcHht2WLiOxnFUhs1U9arIo8T7mMGQLZdUeHWlK9Znn6lO0HpE2Xf41/CZJIVRd1gUV4LuXfCLOQA+DfpC0F1wxVVgw0ml739uyN754vSKK4Gej1b0C8poRb+gjFb0C8poRb+gjFb0C8poRb+gjFb0C8poRb+gjFb0C8poRb+gjFb0C21G20IUVPyZ0rSoRnTAHw9jJGKnjfRXkYnq1LK9rZhMi6/TRh57pPVaxfIcVMiZZej4s+mpWStt0qVlq9gbTdUKzLayqah1ROH/MgWpiLiaR1G8m+bhKKhntCUBY/inyF819V1uJWD85lxrKqRGRBT+r6v1SP7JxU3WkC/vmmKwaAlYrxP1rzp0EhV7o2WjbcLoREqTBEiOPwvBHWmnoqDe7H2SO1iA6BMLGF+Y0QeqvABvERgdTz6cMmlnD4XgoCxLOZZQQGoVtxCKKrvNjDbn6SoqOtHNaO8dpMaCGOnTELGax8kcpfnieghynT4z2nsdjexIen/fCvAXW2HNk1ji219nM6O7M+z9LcytnuiuEw1Go00uIxsdDMt6lE3+gf8P5TxO3t/Hf7N2X7A/I2H0Zfzog2Q0vcjXYKMjtejZPPvriyLSTYbpDlYhIFWYpznwJBYLjO72ozfX49FKPVvRtNFJahVNfw6yuIWGoGDNBlk8kp9/yU37uP5WP7o+eUvKku9AlNPRUgj6u8IvwtVsUTybVrgUhRuaxwtSF79525SK/ZCmOT5bxS1Yic/sh/Gn0+eL1oNv9aOh+Uq006bMXGlDC1n/LTAX6COaqFjsnUdbF/zVb74jcvY6TLL2biYEoq0BadXgJpYtrwP/Ehi9KrHnLfQEfTeHrpv8ibOznc2hM20RMXpNnXsAdtsWZ7nY0+VYdJuTMd3MaoO3Bz8hmsbyltdhU6/jdJx5RhcVthK1EH4EdKpXsCKnRtRaxR4tXfCzn3+pgrNn7gVvYf00XgQVyzEZ6dl74KmliqP0P+cZLdVNm4w+pWIHVkrhgUT80IcPYCYvydp5RldZUMW+UUzu//HpeBTU0Ye/Rq7E22R5LNrGlUg4W1+wx3hGG/E6tjCaGoFbSBgtFVPQXB9rThujwejB0Zty8OM8MJrlYPMos9W3HtWwI0a7stNG42XQRkfrfGY02yeyurYUAWcaAqaD0XSNm2a0ezbNXRUx2tMszB/SVvRLQzrKJu+y0e/9ajn6ZdFmNOgAHyeMNmzcoRG1eo9HMx4NUTdZwIBeNfYaBjWEx6FEQcxosNF+I8ZxvAQDVNTc1uuA72Cj2ZB12uibxuQ+vJQM0FLWaRjU8ELqMu5iRqON9i6T4XjJ7KHUnKfxsNFGQ0Rps40+iKY5DDQY/ZdxIprO3RWXDbNFiRLtMaN/x0isTTzcqIoYqtGXWcOPRhew5LzzepXDmnTy55g9QnAbrbiP7NA3Vq03g8HfomEe3LMoADGB1a4pyoTRL4H9HMX2n8t9PMfJgjthNDSRKzyjuYWQ57bEppFGVEZ7dMaj/R9GhNaF0RL2h3bOYj+6M6jEFQtghcguhbfRb8Q14bBITpEBinXg+CiKijYacFMyVIC8cVYnjJZlsn/7wULqEKPUffCjO6tGidoxOA9UPC1mNBr7b57R0kKGYx0cI1JGJ+hitN8ofEXNK3thg0UUJDKzeex1dLUp9jb0ArsX6AuutgdbbwFwR0ma6KzkKB2R1UUbfYNFlfjRXYtaDIogMyfeLtikHrFiT9zM2btbzWjFQUMZregX9Hy0ol9QRiv6BWW0ol9QRiv6BWW0ol9QRiv6BWW0ol9QRiv6BWW0ol9QRiv6BWW0ol/4XjWVouuXDV3wIk8TXOgYH56exDQsPoJpKjyoFk5hOzyxViRfpWQRTIrJfW7v8jnIhV7dcbZrqqkUXT9Py4AU5fdpk7Rf8IR6WonkNuA71VTCLqXrhQ7tyDtH+KoI1CVGEsT+Dt0XUrxCVgz35mye/esvlB0wmS4/S8ZqTgK4V8Toa6upZP0I8S+Fgz//3m0SWyzpoNtytOy/fbeaSvCnazJa+jg1DZCrX5TBHkkPCXtsGbVvs/fofHclCVLXwOhrq6kEf0ZpnfGHKUn5e7VJxN5bx+jvV1OJGP0iTIVxlYSke0yVbZkNwSc5Gqe9Z3lido1RtfxJ/nbv6hl99TWVkNE+9R4L17CNxgSt79ImyZiresHo66qp1GWjTeG79jEkgRiwziUx2veX54GLaobIM1Fqr+VqDE4SnF58WvGV8RWu1kZfW02lpo1uMfo7tIl0kzxLD/zo66qpRH70x+EoMNrNvpVJnlLkR395NqXs/8HR8wXeejD8AweAi5K6HLEi7r16VZSZmX3jiQDcTRMXIbgKXFNNJfKjJaWw4XV8pzZpMfr22+jrqqnETWXLOHkaMvQ5tzbYaLrdxPfeWPJGTWUkA93NvnHRg7T3Pi6WUUb2euSwENNVM/qaaioRi+TF0UbzZfDb36VN+sjoa6qpxE3l6wphcIBqt7WqfpnH6QzLtSyg12BxajCf3xbvplwGpjHDhmAWuUfQe/YKC9dcV00lZhEuIvPo+b9nm/SQ0ddVU0maynHhFJy56ZeLBg3Q7KX26P2UWxhuTXYM7c05qyCJpFxtlcPrqqkkLOLgUdIm69H3aZMe+tHXVVOpsTJEw5KOmsgMtHrvWxm52aayy3G9KnJbtH1GvPv6LDxqtBK7mga7tppKjZWhuC68sPk+bdJDG31dNZXSHRa2a769Gq3c6r15FnpvsHg3fUxe62BRTVqxVxgtUGkoUPBqbfS11VRq7rBgo8ze8hLmWtvEW6seMvraaip17bAERg8l2kdlOBOf0SW2pF69myZdU6Qmhx/QhO9ctddxbTWVmjZawklVJoy+rjYJDmXM6Lw/jL6Gmkr+W0VUvLvN6CcYaOKZE39z9ByK5oUe+r3Kon8uHyX26OEq1BBzRfF7wxe9oia7nppK4VvY3ERLmgVwEX6dbRI28/3O0KpYj1Jf/rZ40nr2TpE6Q7cdymhFv6CMVvQLymhFv6CMVvQLymhFv6CMVvQLyuhrRCNDAmHinCwPydLkzbv0l3RyNIqw+X/Uqw1h4sEi3syJA+HOS+OEG+61CeXKaI/3poXLOqCMvjTcxr2HbYymrza0YhNZQhfnENmYO34DcSOh7KvoEHeqakr7YvwUtMm1l0YkbXMervCLMvrSMOWm30SH6Dzr40/jCURXht/Ux3SiPDnpAht74d/4r6GcLthwY7ce8RBIEkULORuc44/5eHDJM8KudpqObx/strgyel8guapATTyNwhvKjilXH0vVB85iwwMTMbfykAzDF4Lv4KlxIL+cRpKsy/goL+e+bGE0XtjEZwyaHzge+bQsW9pmBnl2nt2WcXLjumUdUEbvC2TeqvKMQXnGPINT5XgyCzwJ9h6C1xFOagVhR8nu4vOictYZKd1gdEgEw08kpQ7arKJjduJrBJ+c0w1Mjqeo6lPKv7GvOn3pTYyuV4VPW7DK6D5AhGCF0ZB3wvLGxDs7m6eMvj/qYnScSFiyN07fs8tx6nXIv5Zjz+hss9cBww0OiQmx48o3JOH7+OhlhaKgUd4nnL86+qmANNKioNNqJQ4KtxzjL97ff7pA50lycJTRPUGD0cCKyRTdZF4iuuU4YTQa2Q4bjcB1GjgApDiL185NBTaaL4KZQOhse2HlwSLyOhJnpihyS353Tmu4weLxIowbSsoYHI0dnpykkVKSoO/90WDBFbPg206qZwGj6ReQAYLZSdFgrC7ekNcEZfS+IK8jF0aTh2vAYXa+xEtgdOBb1fKjs7iGTCXXNrN/SX+VSWyipspMk2lcwKtpJjnJgo5tQ+qKt+Qiwu7ITg9HmdhoIKq41aI6njBaSpTh1Q/SMgcoo/cFGii/8vKRMbsebbDRUlVji9cRp2vDp5p2l3+w5FpjfJ482zzxR/n6KaMnU4rrWV9gEH48mVbCaMfjpJvRnA4gvvkhauMqo/eFr2kX560hh/g3JvKjC0iH+hqfP27E+tKiVVFNmXCxLItDfLO35P/uzujI6whZM3ij2I9ObDSPvy2MvuqSEVcHZfS+SBlNa37q+AyLZ2DpEo7e5RR4iHt+G6Pr1TKU+gKb/MAXQir5Z+uRKy9jozPzagU5+cXrVZ4y+oiIK/mIOBkYcMTbjIZ0+EwZ3RckdUe/cnyOJ2Cp+BUShcnoRmmrGxk9mTZ3tG3wk12UIkgjZJMfTdjEaNgdn0wri45MJSvDLAumWOLtk2mB291QV7XB6MKXTFCvo3fo3DqzUSql9LmvoyaMTguV/vxLyo6QMusae4ZQahcz7/ez0RbdcYkvLmlf8jHbaFka7ARf9UltdB9x4Ov+uwhltKJfUEYr+gVltKJfUEYr+gVltKJfUEZfAPYAk5EUDGX0/miKHCgOCcro/REynQ5xz+yuQxm9N5zn8UHumd11KKP3RZS/rYw+QCij98RgwZrgy7Ey+hChjN4bdEynUwhWcfNQRu+NwOjDLVpxh6GM3hvK6IOGMnpvTLwfrYw+QCij90YoTaCMPkAooy8Bo+f9Dw/K6IvB3SZBtDsFZbSiX1BGK/oFZbSiX1BGK/oFZbSiX1BGK/oFZbSiX1BGK/oFZbSiX1BGK/oFZbSiX1BGK/oFZbSiX2gwOhXdxcOSlEw3IS0RG2uXxaJ711BlKK4ZjgUFSNSBDyXTQ5g8OaRcn46NF51KVSftmhXWMptDZX2T76Xv7hG/tNQRpwr8JK0WMlyyhjTbNQil2aLRA7aIlDPxIUBHLq5ybUvOjqTCUFHrgUILiSNN/oSy/oOj8W08AL7RRmPPII9JZPf+qCXdDo0lelBNRm+uO5Tqru8MJ4c3A6MDubwcz+mYBCKaCu4kHuGw2+uTualAKfbkkqMQnwSuQq9E16PH84wu/T9M87XdxsOo7mLHVI0oUARGu8Qk8O+w4Ah3YngqUiEw2FAWpLNMxZp0tws7MBr7ixhdn76JpVC3MHpzp4iOyd5glpxjo0HOeNBQcA9Cwtjl/xiZd3+OycBdpiqSZzS9EzHaPptGZnMbozfnC1w4k8A2Gd1lo7PMVTx55DQPQoLZKp52Jv/2cfjkN263W1bkr8lotnt5xGgyQ/g3ywJiXTbapUIi7dHNP7Il64BswkZF6tOxn2axZsb6V6Fpqv+3ftqh4O6rL4plB022C5Un8NqCgdFozPBvfLtuG23iN+u4d1BHjqSIumA2/DaSGlw+QHWjF0LT1J8EDblsMv1Kk4vYCLmqk0uczLcr3h8iWowWlkaM9o0N7WzCUN7iR3dRhbrhfO+1uw3xvss3JbQ/CVzm8slggvDpRafPK7gnfAdtttOXJen/8Of3Q1A0Doz2z+2CijcKam72oztek1vtfBJ1MpruC8JstqThD4J0zUZ3QXxrMj0TXzrhO+hhfVjkJA7tblvm2a6MJnHdAlZU/tepjQamiRg6dYplY49qf88XNKGxQvbg6MFKhgF0BbQiqvuiMelsRUsKUcxoW5x5XeLA6EgCPii4s1s/+Tst2lagNlUU6y/VxQzQJkaTeCs5Y/Lr1EbD05+85edFMe5pkK83ONOgimCFT+1K64eBY0W2pClbADXkiWf0ZLo+Gxlvf+TpWfITGZ2HvkU/8a8P8a+WheF+/u+jjdPBwWJXRkML1KcvE0ZjSySMFjF0bAdgoFuPRLiU2wb9OBB+hP/wJ/AHfIsZHWhmE/uGAq6e0YPhH++mv3sbbcQZIVWyVMEdWJyDPh8vV3l6dbP5haSuNjEa3/nDMGG0bTF6VZIGG4w6bCuRqDUlD0j6DQoOStVIVP2Ed0iaMosXCGt8zWL5yDPavTp+Aj2WLKOXD8jFYD+aZGbhFexyXK+KnNc/onhbXSwgdJPYldHQhi43idfRwWgWQ4cGoQtMq7QbkFSOhIB5BUSz9XLcYnSDSJ9Onw+/CKPNu2mexTaaV4o0RlIF98yCx52j38jqmTApDIZPL1QIegOj8aZ/eT5MvI42o0/HNKKwmfACx6OU0ZbNp+P2kNcyZYvRDfzwpXQ//8KMfj58cjrOYhtNK8Xg2UTO22Q6e0FLgwerSkwJzGFvb1128A4rQ2g+lnbklmQ7HQeMA6NdcCB4lMfdgDZAGE0mEtds9el5jP7hSbwy/Lf36RKMGW1DCD0ouJvZ+3/HN5v9C7wIDaaK1d73R3tlSPcj2Uv2e9hOxwFjz2hyK7hV4BsJoym0xIyWcClFJM9h9ODHb/HK8J/cNn4iiixQuHh9PHKzj4uq/h/4Zu/+A14EBxNOFdcRRb9edNroLIremQLFd88oWllBC8iyL4oluITRbJ67bDTROmH0bjbalTyL830m0zyMqDLe2ZhMH6cK7jw9lzyZApGRS/XqYpHxhCH1yccFWEC3/gOeG6eE2ZzfYRLFEkzCaPpul432vItc3d1stMlt7EejlYhjcvQc0C716U+RH80bRCv8EM0QsGAqY83c24Pt8Wiwa2BAVyW9G5lrMW0mzPYpo7kLQVF9PRK5dPw48StlNNh/8A/wsyBY3TnR/WPUFY+eTD/9Fj0v+xlPUwV3CJTgqJEHr1fkdX5aXcpJxCdxtHqzRQ57bmyuZUVH81QXo/HpcCFhaEHhUIY7j7ZlI0ZbjBjnSVO2e+zf5h3x6Kw+/pJn8b/Rz3gbMxptFj6yEZtM85ddf7n1XodHNJMa9MIkFjSQlXa805wymlvUFKJpDXLpGS48SP49YTRah5I+/w6tb3eso4PR0eIJZ1vwkks7+5gquNOfPiQCFmiwqPC7O6thd4EoR9RcjjPvtmcStEh2mhNGT8ISlsZaMfuGEUVc2bUYzWGjpCm7nqiD0YZsirQz+D7F1ymHiegiMj6MD4nAkHfrEX73tlG6m9EuijCDgaYXzjPzblrQfE2xYWp7+Fc8DW5ZH+8RC0oPUGAYucFoOsQADP208pt/9aqoBg0Fd7iUHyT8PjSfXngDE5dc8jIibT84Gg+GT1Z0toJjw/TEtrE7ufnAxD5HKdKNJVi/NBj9aEpPVq/WX0KP2mI9kuFiefC5OMJH74Nzzu0TBruOs3ebO0VLiDM2hw0vFFBUBOhpUkW/oIxW9AvKaEW/oIxW9AvKaEW/oIxW9AvKaEW/oIxW9AvKaEW/oIxW9AvKaEW/oIxW9Avn1VSCs0XhwLLJzzttJEfE4ViyK9OTN3HtmSghax/YKkvO+XdUugnnpPDq0em6wZGcgL/EOfYotU+SfUqfalDBK5s8PX4YPQE2RnT+G4rh+AyuDpjo5QY/vt2nX3zqBicohAQ7bhtOAnJx6k0LlBRhfbb/YDiSXsQe3lAK4Cax/cQ/sSIcAYWj6VsZPVic8cu55U/LceMsWaCfZJZsOHa6sQTLYFGmh/vaZx2bjPb/PKcGxn4gHvOzUh0cPINpyigPQp7DM48Y7R+5Pi/jAO8i2ez/nEcc39IvcbIcjF1qzBaj53T3kM/c0dhMVzi6TVcxZRihjrK3sotYpmvEeYw2kVGscGBuO1I8mZaetRbSwKVZk1Yuci5n5DaM780lxvhEfcSJaEJJzGfZZPTlTvc34VmKSRBDeMGKEsZ8bm4xm8dphj6RNuS6nzNVWDL4lnICKEXgKNx2e7+EUiSc3dNidFb/xtegWgbtmQuv4Uo8an488vZDCghZqLWWyX+Hgu2Zs/AilH0aPrHtSLrhPHAkEDAac97aVt3ivEmp2FCOiZrTExkNEFPdMOe9Mfa8rWJLSWTB0kYw/98fUWdxyS7OFzBXxunwqExeLHThoBKIz+ZpV06DT95b+Oo0s3mDZh2txCYRrvU/fVLseHu/xK4j1bX04372LfGZqNaBqdAAd0y+kLd4f4TlI8qYyjKc3Qw9IczxOhRsr24AOT2WU6iaLmTHFE5v6riCKOUeCaOtLzdTCaP/EF8afhdqh1ICE3R5xXkUkBnElqrw6bdGfht1P1wc+fTsP2Kvgzv7Ci2JaSSOYaI6FCaDyp8Ro/3SgXLHvI1uVYNqYTKtQi4iNe6jkP5+fr80y0U1+MpFGShx62yTLz25P7LYXbRMiAtj1pCqcytsdMLo+uz46dGYDbck7FFB1g4XWIjHQ9iVMaOFrti1tgwNyIweLHL5COdTZ36MAC/4B76oDNJ+9tb3Ihu0U6gQG1XCihgNefyRB3AZuNm3knuRDGJOrKLikrGNFu+EUv0ajIYE+E1rq8FwRPUZSq62Sin2lKq4Q78Iozn5uTm1xilu7I+3GC2ttf5SQlKmCTUql4+mmE3qqK7e+tfbwmiuE5C+Ky0RBouv6aJ/9hEXbcHpq1e4nPZeB6/2jNQPA+/6lP20lNHo463KLPpSGRgdJdfJzG6quLCSt1WuKO4Nf5VKL1DFiTrzwrmFER0sZ8dzsa+oTnVRxYzmd2JLa4vi9ekb7+JLBmdX9juwvSS7iPUMJC+wxPTBLf2SN+NVLqosLfacil2KP0KJvFi4rXMWhj6kFwgFxahu7y1YGSaMHvxt0Gq5epV3xvCk3PiMyoJXrngNiZshWEbzLn1MbDT8zJZi2JMiXmRbonqmwUbH/e4ZLb+oV4XPMJ/N//pwxYwOUZhLMxougFUvILTFNhpncQh7LN+UYWXojbPj7NQy++tbWbTWq7MtjIZBXPJEbzAqaL8Ko5+f3y929kJGmYwsqYzKdW5CAR9TibvWeAbHvUclPsbeWYkY/RDzyw+a0enKsN1yBma/ciMtrA/ejcGW5MFV5MJAfvalqAVaIk5IZkbLpaE7O2y0DypxdaaU0W72EKur+K40xRJL1Vvf7JdlNEa92MedzdlG1ydzS2Vb0OkMVhvvJu40+REFVajBgjHSWM2bQFvYVysuS4A1qrE5uXjNOf0CTQe/xPIbvggDFyrgKTPYXKpZkXcwmmvqYHcdhVgsW/3S/o4OtjlsRic1laTlQnDHcn34TRGPKD7sS/gwLcm38OFPb008W8XMyxjgOks0Z0eM5gmT67/w/Ig9hH16KoEsR5EXN/uIBeuviNEUR5OSJJXYaI7ehQoy8YwjtbWxjCUM4nS0dzAafsSOguM2yPGiZczo7n4Bz4JKBeXZ333dzEwo7asAZQMsjSfGYDuj2XOLJmJTlKY6fEZ7dNtoH0Ld9A5djGYKwR/cdwmjq5TRUcG9kndUDJfSQwrZezGj/e2okF0uu3diwDku9TmKpl2O0aJiUkb3JRstNYZlh0UWt/IUUrGcCoc9H466GB21n5UaOmXYbzU//1Kc1y9gmNGUP5py5eOHUg6NimnyaICPPIgZ3VLx8Iz+sOBVb7BNOGiHtNFwOxgdt5m0HFRHlo7cEHeKe8THk32oS0JRkWBEFMdAk8PlYKGlqN3YCFv6w0DN3I54BQZoJdzB27fQuxwAeHw0viobzS/XZLSYZ78KiEq6ePkD7xkPhk9O5h2MDgcFBov1lzK6Q8mlr+l/5/WLubcg7xn1D1K+4bOVEIEz7PJXza6T54786CysrX1A0ZSyVDx4RrtoHz8quLnw1b82hr9C2BlaglurPv6Srr/FRpuOsFVXjJZsLj9J7HVkfvnuV4zyc+xNXyJM4gvuig4hRIyeQJ0ppjDQ5/1UPIGff0le+/WqqKR9rI842o6S7jQieYW5pIAQS4VljUrTnf3i2ys0M+P30HUOnCW20a7zsEvsdYg6U9RlEgFcXYsO2EVxcGfvbl8J7qvEpfW7FAfHaIXiUlBGK/oFZbSiX1BGK/oFZbSiX1BGK/oFZfTe2KIjq7h5KKP3xjb1esWNQxm9N5TRBw1l9N5QRh80lNF7Q/3og4Yyem+ojT5oKKP3hlVGHzKU0XtDGX3QUEbvDat+9CFDGb0vJK1KbfRhQhm9LygbUhl9qFBG7wsblShSRh8elNF7IpRusZeqQ624JiijFf2CMlrRLyijFf2CMlrRLyijFf2CMlrRLyijFf2CMlrRLyijFf2CMlrRLyijFf2CMlrRL5yndO8lvO+PWHTBKwIGDchtMrQ7I5RORpms+Fw9KGp1HLNvqhDbMkh/16u07nn0WbtBYHXX5wSZoqA/53Vs9yh8XZ/Mg6omFiiPJROCMq4tilwUDUKHtCAV0f1rbRD+DJ0b2iY8tWMpiqwpLY7tbVunDA+prn+M7TosxGN81fsi+QTngwcLLDwv1eK3Mtps1lVtfLDi8bJu9EoofJ/cJ+i5SRuXQbUhUK752cn09ards3sA2wPuY+DqXih3n1LuKKYRfSER0oC3dJ7A8dDbwFT7ahVo+aJovHrSwPKpOd2hjIVs7i2SQRaJOHW+3C1mNPKYdF7RLNerwkud25bhbGKLan0DiWhag9GJpRIBl1Lk4hKLgiJTdJlaFHXCZ2UuuLiNJiMKY49vcvJw/xGCgmv+ESIZ5CWrSPgrnc9oh4rK4dE22+iY0fw5I71HM650QFzBgQVdPD7EfdExcG4Y2/UMicfAAa/JbhJaETptNDcbCNlvPUYcuszkKaOJqcsxMBrbm+7DXzCk7da+I6jwOJHg4StHn6V+vQyjow6PxnHbjG2dumzEF68cT1+pT+Ypo42oK3UxFeUVeWriO+7OaFH9le94RpfeRnst6u7+PThs1wX3PKZ3K0hXDOVohyMDrP5hdA6jz03ziLnljRWJq5IwJTH6p6KYPTwdGxEAJhaQ44PUX4/g8/IoiUJU/FmUvryE04FOPrybLVnTucpctRejWarbyf8iHz96fH5CZHTOOuhl18WqoLFlQbpwo+1s+dH22VRU2uECctPluMXolL7RauuSAuvXgF0Z7bOQIhsN70tGxQu2sSdbH48M+YH8mcn9pwt5e6Dtckw204A4Gf4Cu5lZMSCtv4jRLYqAJ8riy5loVqJaJHa6TTo0+awpvDLmBa0MzDqRjeYhLg32ZLUcwxvS2pZUc0GaDn9hvk5xciPhw4ouVh8/XQjPKDXGay+yqPoWRoNjRSubipbD3FhdXn1io9EKfPjxBT89aHfxTYMfH80ityf9fVdGe7niYKPJulpRkofZD9qVu5C/4ejXIEfGeoMk6AsdOYqEzOijg+ET/mmL0RZs9KoirtLq3pKcWy6MBlIf81SCgoCRNpp8tj59eTkbTYz2Npr+g9syrXHUkBAnSasxo+kX6xF6QG72MTijZaQCS/KiMOakGVNGx0wDO4zmHZcIqDn96WSrjU4YDSGbkhod7vKlZaOtdxuja5CE7iHze1dGU2u0bTR+JKgHW2+UJBpUhSVflHNaH4+6GA0KyKvZN5Zubdho6DPrPQefwzqZVux1TKZfI4FLfsyn6WfPQA/+qm002ttgqEnxHN8mYjSzEp2fxp0Do0nDO6eGfrzgi2200SIyja/o1v/r4cnuNvpURMLRJv3TJjZ640oDrxscEXsLGN1eGaIRovhQh432bYDzvWswGmkrjGarjT7GsJPRLFlZtVaGYBfWIwPh2SiwLLwQpWwrVpfNdAh2RIKq5hpstO9r/B899yZG46QOysrBlrYYjT+gEOm5K8M4nFSf7OxHiwdnP/CQj210ui0R+8p4r9tno7MoemfQG16cIZG2MbrTRktFrYjRW2z0w1U+mRZlvVo3/WgTYkY//+IXNk1GQlBlsMgde+SRuHCD0Ze20VsZLW90DqMr/62B96OZ0QamgTW2/Xkrwxaj97DRgx/nfnumaaPF/FdpcPE5Whf/HLfARntIU6OlXZW4IEc3uaI9CgzS55GIruMPWPCY1yRqT+2aMhobycCivEJ1Y98fZvatNDToDZtr7rFo/jNRJDBiNIojP1wVZRaJKMdm6gpttGFGP8NVHjGC1oKe1hxLgzHLzdFk9MOTFxGjh/FypV49Hj5ZcRAn32GHZbuNDjtcTUbDinmw+ECUTmw0zzOlbVl6skOHFoOOsV3pntxW3BvL7PL54t00alO7frKKh6ijSQg69/EQVkpFyUGQhNHINZbonn2DFUhBO2jkP/urN7dUyFLEbWmDj4EeT5HXq9Kxw9yIK12djTazb9Gl69W7aXQZIi4+Km4qzubcHA1GRzN7/EYUQ3scb0rttAu+xUZHO1zNWAfMYoVMZS0/uqPBI9focHGO0n1GBpoa5Pcy9sWWb/J4PupsbLvrDniGM2Dkn+WdNtptsLsZzxHQT6A83y4NEzH66zQdKvsB3LLoOV//Fg++XaOzwVsJ3oHlWcMmzTr7uJ+Nftukv494pr4x2hLHbjAsN2wVfeDxwjeO8URw3GJXcorn+nCtZ+/utmr9YcDtblT6AT1NqugXlNGKfkEZregXlNGKfkEZregXlNGKfkEZfTFwyLjyh0cknIzh88m0a3fYb3bbzVsULuwatU5WUATbVknWy/pC+Z9hx6v+Ldwsp1MOEuCOjra7Iud3crgZb6uD1TdQRu8L3B+uZA9QtvRwx4I2nOVgSxdMfk6YvmM/jg7MVHJRm6QXXDD/c/ID5xja4p+8ec+H/PF4YCTMkflNthp35gdHY0x9CePmwKCM3heYV+AZTUe7XIknq4hxSAfbuX1Yn7wH7nTvL8oh1OaXPKPp0h02+iL5n/Xp2PEh9Qaj6dqzuZz4a+S+uNyWP4z4JQ5wB00ZvS8ajMYp/z6eFUQTLVTupDQwYfZxUXZuaDOjvzFzjGxlB0ZTan7bRmf75H/aMj00w3veSNgXlbyam71dRtpJ3uzLUKpMfqBbwsrofSGMFgs2uT+ylWShTsKxJdc2j3Rw+vdPJ/OuY5jswMisjw6KTRiNMC0bvV/+p4ylwfDXn39homI+YbDRwOhXciI+zbSHO3zBc5dVlA9ySFBG74vUj5ZF1fpLCZ1snoXKMo+mDQ+CMrPs7OPRuL2uGixCBuI2Rncaxt3zPz9PcdDg2US3frIio+44EQsvFZ+TlPFTZZP/MJTrthyjhf+9PNAjS8rofdH0OhiQ5EoVnaijgSSpeSv4KCnYti7zFvzobYwe0EHd1G7uk/9ppXaOPHhR4YNHjOaITMlLWfx2MXvPARxa/5IfftOd0QFl9L4gRnsXwbFlhP5nm3gyjz3P1peBnl3mLTDac6mD0RGNwkX2yf8MHryvy4Y/AkbXq4KTEzDLhlKBXPF6RQmVZjnm94Y0hq/Tg4zfKaP3BTHaV3tAhkH+aSkpbUSZDgPGphWm6zddlTeI0W95dddeGVLKVjj2nDJ61/zP9sqQ7bVQPXgdppxMc7sc/+85uimfwVpTDjQerj68Wh2ZMvoCID+aur/BaGRQkqje+jIXPepKNYiid+C4+tQnZjQxyLyivCFT+upo+X75n95GDxZnYmSjw/6RjQ5eu8HwC2fNLscY84vqRx4UlNH7QjJ/swajP3BiI+f1bWO0i1J+wl5MxOikWCD5IGi4YW2JW5SYXOxt9F75n/JgwEiT5MG1bLTECznzcOkzONG5/rBQr6M3kKoJJvWjsbslmbLq/mJRLF+uuSBNljA/onHihIfqEq6gvbu8XuWuqEKS8D75n4NFUfn8Nlc0qhB754hzDnm81SufnGWKcjItYRuxXh0ipZXRF4Ehs4nB4MjrkCC06c4zH2ChNPaEpbxlHC5JwiLyFc85Pwrch0Ueh6TP9s3/jPOKB4tmsdF3bKNxEViFPHf+OBVdwfGwe93Z7whl9M3iMHcpbjOU0Yp+QRmt6BeU0Yp+QRmt6BeU0Yp+QRm9P/jsZXQKLvora2MkUhxBnM3HyQ7ykE8voIzeE4OGUhQX2Pcn8TgZMA4DN7YFs0S8UXHFUEbvj8RGp4ymoxZ8Mm/9OTn1ibvRaqOvG8roS6LBaDztVplIW5MFT+jDaqOvHcrofZGcxIS94jajz4IvbXJitJxAUht93VBG7ws+wCGHoGO/2tto/CBK5ZZ/F1GqQ8yb7iOU0RdDWpa56UeTFsXRozgnEEVGU7dacQ1QRu+NyCrnHK0jRnvBtwoPk2KyS3qazpvww0w67QWU0XtjIHJRdDS+k9GwYIw1p7h6R0ilPcyMpj5AGb03dmJ0yMAykDvCC0G10dcPZfTe2JnRJ74oo+SmduSrKq4Yyui9wYzmMnOpJjyvDPFz7G9Amm2SSnKoRT17AmX0xdAlQRXZaIfBDFhDMn3hB2ca6/gOUEYr+gVltKJfUEYr+gVltKJfUEYr+gVltKJfUEYr+gVltKJfUEYr+gVltKJfUEYr+gVltKJfUEYr+oXdGF2fzEORbdIivZAIR306NhfNgnZBNCE+wfYlOdA2ew8SUavwpLZ5IjnRA7TPSFablFNSEUw4LwcyPztmnJg8OlhaZZulwc+7TkX1/C/0Xe6UVDiIlV1yfko8t+0/USZScliwPT4caElZLj9MedlO7GijTTjXjrhgd4GYlLtgQlLjex2yEIaJJAkimIVdiW4VP33y5CZ3s/fQheuni3zi1cwMyTqApIlo9537eCThEClkXWzMwwNPLiqr1nFLqvMkmQksKcdahZmXgJa2i96TFTJO5qaCU7K3p77Irl4H5s75Ym7RuF6Ouw8LJ2hJSu6MUG6rwegO5R4yra4UZbQWo13Ddg1I/HUyJTYPjp4votdyezE6Eqaix00kKM4v5d98tp1bKLIz2xjNShtsqUUncROjRU4m+8fIvPuTp7rbcaK7yWjHD26ZrMGk2aixg4w7iWHzjBtLKuGfzSaWMUFH4YnnFX/KFpHEe853q4B0iZ/BVwzPFRS6JTmkPn0AfsfyQYeNTqRDvMTZ41RQhIcGyk61vQ6SQqP7ljGP/HPmyRRiWIrQyONbfgn4syVlYoPnIKq1kDqQ+zet6EbLR1P2DVzZGA95s02Qxyi2aLx2ITZw2WL0YAiyRFgHbfatlDf6en+UFKc8ZDQYjZK7P87JywDVPZauK7y4L/wvkuMTW4gW1IDSzvoPqmX46jRiNHcGtB5axDLLfhhNElleK/QSqUv8sWj0iY3mDp9MvfhO6BGsKlBQIom30Y2pgbuSZVNnL4rSxqOl/k04SAPsbdtGw2h2Fcn5YUqsIZYWUlsJHzkS++NHw8+h7TOvcDhOpmcxo9kmID9ncxAeqn+TgSuMrnwn4exBP8bmx8bzLZa0SeCx2J4qi2104kdDW9v10+Hn6ezv31Ci8SUqeuYsP3r4aDKaWpCFnEzpf4CWme1dffx0IeYaWQPGTNaLbvkTqUc9SRmdi4i6AypVWdRDCaODN8E/LrsYbUtTCbnT3sPUqDf4eK/bNtqbdhC1qlfsUPKUg4rZob7ohjUsP6DxwoP0nFx0hpcbRgZKzgMt5/ehL/CTfksYTa3pQLq4Eh+ri9HBzZYf57symlrSVJl9hjxevmnb6JH/nC2hhQyuv6vsMFXAz2U0K4wFdnlGf1xEpow5xoyGhqQecMuxWz5foM5u3cFoJHVFY34Do0NeqfGFuFqMBlHgiiaSTkaHlaFJGO3dQ4NT8+sTZLT4UFbMHn5psHh18l7sV7RUAyW/hF2e0cHar1naVV4bW5E+Z8rMlA6DCuDNthgNpF6O5Um7GB2mf/6y6ISez2iv/RytDD3LA6PNveGvS6o/yfd0YTF56GitDI3vDrbHwUYHBEazSWG+UXfgVJbXHV4HTPqshyd+tPe2kQ9RwIF/DK3c9KPhZhSPyLsZjSu8ssXoyfSMhyqGbv69BkZ7te4g+E5fOlu+LLsEvtGzkfWYqWIbHcEzmuelaM5BuW14MdvhdQyGT8VpFj+6zCI/mjWMY0ZjVb3Uj97AaK/9bEv8Rt7FaFOUD4cjC0rRHAcFo/L0ELULd2I0us8dNnruK17lmxmNNhqanC1ly0aj+i+iXlVdNrqT0Q0bjT4RdcGqbK6C3Oztp5OP4A2WaZku7D83+xY5jcDoZ9N7cHlxLIWm2eT+r7P3f443SNbP3nfYaB8IRxdtA6PRRqNON1rKlo0GTVd5DM/exEZ3Mrpho9srQ5qAyJ2qfvhSYcfRLJH40bhkGpA2LdOdlhW3xOnoYvRgkRN7YJEWM7ry3Bx4PzplNPrR48y8m1ZZwuhw7Sp07U5+tF+V+egdrUv904TAGP7IFrBGF0ZTnwc/munJ3EUbzS/TZLQro1HcjFu55ZifbhX70fystOgIcYeY0ex4D4ZPSHS+LdsK8we1OoTWd/Cjo+f2BiRtE5MjISfTVysSq303zT2juecir8Ny9NCWSGRHIazbUmWkwWhL5KSyVqFtMzd7ePIiYrR35Rwv9p0ER+AvDifMlNGoB/x5iiGG/3Myh97oZDRGCUKsI5hIYbQU32q3MK/qJtN8IF4HPf42Rr9aPWYbzbW8DAXr/jHizzZsNJLFsCg2BmY8o83rmNHx9OT9aB8cMTyEYkbDICjRH3Oz/5vHU2Qa60BnK8Q6QlNsiEezaDK45vDVwRD2oLzXQe2ergz5eUiFHIZzvfp04Z3M74zWypANkpFw1gptMXA08jqiz1fERSezrRPpaz/n56KIDWydTJfPwUlL4tGFj0DDjLfge3i/k9DYYWkzWjxZK2tJ2HMPo2IDowsOupaDRWmSW3QzGlsEozkLbg3DC4Ciir2OcBlc5+XcpBW/GEbgZIJAa0C/s+uRAw8WQ85RPLrwEWjaz+T2zBMPvs1oemneYagkioXBFDbD8ahor1ngrQaLCiJDt6UA9vY9QyPTrV9kRO3nt0R2LUuILsdkupdHFqbY7YyGrqcPsJWBrin57w5jUEt2iuGj9A6wx8vhblv+6/+bRwss0rC3wcHc+E5RkcbY68j8lkvePaN0wnLhsX3IE/zqBqNDm0TPaaswVuHhnISYsMHShykprsN+3gVPPnxvXMXZu+s8xnJLmvE8XGcw196WNdv3wZWcJj33XMfFcVuioOfg/HMdF7/07TkW912g56MV/YIyWtEvKKMV/YIyWtEvKKMV/YIyWtEvKKMV/YIyWtEf/H+6SWJYRh1CLAAAAABJRU5ErkJggg==" alt=""></p><h3 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a>7.什么叫视图？游标是什么？</h3><p><strong>视图：</strong> </p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong> </p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p><h3 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a>8.视图的优缺点</h3><p><strong>优点：</strong> </p><p>1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p><p>2)用户通过简单的查询可以从复杂查询中得到结果。</p><p>3)维护数据的独立性，试图可从多个表检索数据。</p><p>4)对于相同的数据可产生不同的视图。</p><p><strong>缺点：</strong> </p><p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p><h3 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a>9.drop、truncate、 delete区别</h3><p><strong>最基本：</strong> </p><ul><li><p>drop直接删掉表。</p></li><li><p>truncate删除表中数据，再插入时自增长id又从1开始。</p></li><li><p>delete删除表中数据，可以加where字句。</p></li></ul><p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p><p>（3） 一般而言，drop &gt; truncate &gt; delete</p><p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p><p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p><p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p><p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p><p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p><p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果与事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p><p>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><h3 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a>10.什么是临时表，临时表什么时候删除?</h3><p>临时表可以手动删除：</p><pre><code>DROP TEMPORARY TABLE IF EXISTS temp_tb;</code></pre><p>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。</p><p>创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</p><p>如：</p><pre><code>CREATE TEMPORARY TABLE tmp_table (NAME VARCHAR (10) NOT NULL,time date NOT NULL);select * from tmp_table;</code></pre><h3 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a>11.非关系型数据库和关系型数据库区别，优势比较?</h3><p><strong>非关系型数据库的优势：</strong> </p><p><strong>性能：</strong> NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</p><p><strong>可扩展性：</strong> 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。<br>关系型数据库的优势：</p><p><strong>复杂查询：</strong> 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p><p><strong>事务支持：</strong> 使得对于安全性能很高的数据访问要求得以实现。</p><p><strong>其他：</strong> </p><p>1.对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p>2.NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</p><p>3.对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p><h3 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a>12.数据库范式，根据某个场景设计数据表?</h3><p>第一范式:(确保每列保持原子性)所有字段值都是不可分解的原子值。</p><p><strong>第一范式是最基本的范式。</strong>如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p><p><strong>第一范式的合理遵循需要根据系统的实际需求来定。</strong>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p><p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><p>第二范式:(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p><strong>第二范式在第一范式的基础之上更进一层。</strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p>第三范式:(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p><strong>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</strong></p><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p><strong>BCNF:符合3NF，并且，主属性不依赖于主属性。</strong></p><p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。</p><p>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。</p><p>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。</p><p>还可以这么说：** 若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。**</p><p>一般，一个数据库设计符合3NF或BCNF就可以了。</p><p>第四范式:要求把同一表内的多对多关系删除。</p><p>第五范式:从最终结构重新建立原始结构。</p><h3 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</h3><p><strong>内连接:</strong>  只连接匹配的行</p><p><strong>左外连接:</strong>  包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接:</strong>  包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p>例如1：</p><pre><code>SELECT a.,b. FROM luntan LEFT JOIN usertable as b ON a.username=b.username</code></pre><p>例如2：</p><pre><code>SELECT a.,b. FROM city as a FULL OUTER JOIN user as b ON a.username=b.username</code></pre><p><strong>全外连接:</strong>  包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p><p><strong>交叉连接:</strong>  生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>例如：</p><pre><code>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</code></pre><p><strong>注意：</strong> </p><p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：</p><p><em><a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">https://www.nowcoder.com/ta/sql</a></em></p><p><em><a href="https://leetcode-cn.com/problemset/database/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/database/</a></em></p><p>参考公众号之前发过的：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488088&amp;idx=2&amp;sn=501652bb26f69a11f6aca0953cbfdc50&amp;chksm=ebd62d74dca1a4624c476ceaf04327d826c916f550a5660a287dd175034d2edb9c21b4cb4b02&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">图解 SQL 中 JOIN 的各种用法</a></p><h3 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a>14.varchar和char的使用场景?</h3><p><strong>1.char的长度是不可变的，而varchar的长度是可变的。</strong></p><p>定义一个char[10]和varchar[10]。</p><p>如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p><p><strong>2.char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。</strong></p><p>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。</p><p>varchar是以空间效率为首位。</p><p><strong>3.char的存储方式是：</strong> <strong>对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</strong><br><strong>varchar的存储方式是：</strong> <strong>对每个英文字符占用2个字节，汉字也占用2个字节。</strong></p><p><strong>4.两者的存储数据都非unicode的字符数据。</strong></p><h3 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a>15.SQL语言分类</h3><p>SQL语言共分为四大类：</p><ul><li><p>数据查询语言DQL</p></li><li><p>数据操纵语言DML</p></li><li><p>数据定义语言DDL</p></li><li><p>数据控制语言DCL。</p></li></ul><h4 id="1-数据查询语言DQL"><a href="#1-数据查询语言DQL" class="headerlink" title="1. 数据查询语言DQL"></a>1. 数据查询语言DQL</h4><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p><p>SELECT<br>FROM<br>WHERE</p><h4 id="2-数据操纵语言DML"><a href="#2-数据操纵语言DML" class="headerlink" title="2 .数据操纵语言DML"></a>2 .数据操纵语言DML</h4><p>数据操纵语言DML主要有三种形式：</p><p>1) 插入：INSERT</p><p>2) 更新：UPDATE</p><p>3) 删除：DELETE</p><h4 id="3-数据定义语言DDL"><a href="#3-数据定义语言DDL" class="headerlink" title="3. 数据定义语言DDL"></a>3. 数据定义语言DDL</h4><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：</p><p>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</p><p>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback</p><h4 id="4-数据控制语言DCL"><a href="#4-数据控制语言DCL" class="headerlink" title="4. 数据控制语言DCL"></a>4. 数据控制语言DCL</h4><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><p><strong>1) GRANT：</strong> 授权。</p><p><strong>2) ROLLBACK [WORK] TO [SAVEPOINT]：</strong> 回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</p><p><strong>3) COMMIT [WORK]：</strong> 提交。</p><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。</p><p>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。</p><p><strong>(1) 显式提交</strong></p><p>用COMMIT命令直接完成的提交为显式提交。其格式为：SQL&gt;COMMIT；</p><p><strong>(2) 隐式提交</strong></p><p>用SQL命令间接完成的提交为隐式提交。这些命令是：</p><p>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交</p><p>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。  </p><p>其格式为：SQL&gt;SET AUTOCOMMIT ON；</p><p>参考文章：</p><p><em><a href="https://www.cnblogs.com/study-s/p/5287529.html" target="_blank" rel="noopener">https://www.cnblogs.com/study-s/p/5287529.html</a></em></p><h3 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a>16.like %和-的区别</h3><p>通配符的分类</p><p><strong>%百分号通配符:</strong> 表示任何字符出现任意次数(可以是0次).</p><p><strong>_下划线通配符:</strong> 表示只能匹配单个字符,不能多也不能少,就是一个字符.</p><p><strong>like操作符:</strong>  LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><p>注意: 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.</p><p><strong>%通配符使用:</strong>  匹配以<code>yves</code>开头的记录:(包括记录<code>yves</code>) SELECT FROM products WHERE products.prod_name like ‘yves%’;</p><p>匹配包含<code>yves</code>的记录(包括记录<code>yves</code>) SELECT FROM products WHERE products.prod_name like ‘%yves%’;</p><p>匹配以<code>yves</code>结尾的记录(包括记录<code>yves</code>,不包括记录<code>yves</code>,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’;</p><p><strong><em>通配符使用:</em></strong> <em>SELECT _FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像<code>yyves</code>这样记录. SELECT</em> FROM products WHERE products.prodname like ‘yves_’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)</p><p><strong>注意事项:</strong> </p><p>注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的.</p><p>注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的.</p><p>注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录.</p><p><strong>技巧与建议:</strong> </p><p>正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><p>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。<br>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</p><p>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</p><p>关于优化，参考之前发过的：  </p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247489949&amp;idx=1&amp;sn=8e175c96e625a7586eba860b03655a76&amp;chksm=ebd626b1dca1afa7626025a5ad24a300cb7d88acb45a7cb4da4cc9d6fe93e4dc929e4237bb6c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SQL 性能优化梳理</a>  </p><p>参考博文：</p><p><em><a href="https://blog.csdn.net/u011479200/article/details/78513632" target="_blank" rel="noopener">https://blog.csdn.net/u011479200/article/details/78513632</a></em></p><h3 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a>17.count(*)、count(1)、count(column)的区别</h3><p>count(*)对行的数目进行计算,包含NULL</p><p>count(column)对特定的列的值具有的行数进行计算,不包含NULL值。</p><p>count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。</p><p><strong>性能问题:</strong> </p><p>1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;</p><p>2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;</p><p>3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。</p><p>如果表没有主键,那么count(1)比count(*)快。</p><p>如果有主键,那么count(主键,联合主键)比count(*)快。</p><p>如果表只有一个字段,count(*)最快。</p><p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p><h3 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a>18.最左前缀原则</h3><p><strong>多列索引：</strong> </p><pre><code>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</code></pre><p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p><p><strong>最左前缀原则：</strong> 顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><hr><h3 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a>1.什么是索引？</h3><p><strong>何为索引：</strong> </p><p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>索引详解，参考前几天发的：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247490706&amp;idx=1&amp;sn=d98cd10845923c2bf5d933a8fd963cb5&amp;chksm=ebd623bedca1aaa87256f9729192d024897ba70bc38a0abc314cd59b1a1349c52ec33f1074a1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">带你从头到尾捋一遍MySQL索引结构！</a>  </p><h3 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a>2.索引的作用？它的优点缺点是什么？</h3><p><strong>索引作用：</strong> </p><p>协助快速查询、更新数据库表中数据。</p><p><strong>为表设置索引要付出代价的：</strong> </p><p>一是增加了数据库的存储空间</p><p>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><h3 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a>3.索引的优缺点？</h3><p><strong>创建索引可以大大提高系统的性能（优点）：</strong> </p><p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面(缺点)：</strong> </p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p><h3 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a>4.哪些列适合建立索引、哪些不适合建索引？</h3><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong> </p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong> </p><p><strong>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</strong></p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p><strong>（2）对于那些只有很少数据值的列也不应该增加索引。</strong></p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p><strong>（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。</strong></p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p><strong>(4)当修改性能远远大于检索性能时，不应该创建索引。</strong></p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p><p>索引详解：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247490706&amp;idx=1&amp;sn=d98cd10845923c2bf5d933a8fd963cb5&amp;chksm=ebd623bedca1aaa87256f9729192d024897ba70bc38a0abc314cd59b1a1349c52ec33f1074a1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">带你从头到尾捋一遍MySQL索引结构！</a></p><h3 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a>5.什么样的字段适合建索引</h3><p>唯一、不为空、经常被查询的字段</p><h3 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a>6.MySQL B+Tree索引和Hash索引的区别?</h3><p><strong>Hash索引和B+树索引的特点：</strong> </p><p>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</p><p>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</p><p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p><p>Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</p><p>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</p><p>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</p><p>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</p><p>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</p><p><strong>补充：</strong> </p><p>1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。</p><p>2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p><p><strong>B+树索引和哈希索引的明显区别是：</strong> </p><p>3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p><p>4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p><p>5.哈希索引也不支持多列联合索引的最左匹配规则；</p><p>6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p><p>7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p><h3 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a>7.B树和B+树的区别</h3><p>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。</p><p>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)</p><p><img src="data:image/gif;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAD3AkkDASIAAhEBAxEB/8QAHAABAAIDAQEBAAAAAAAAAAAAAAUGAQMEAgcI/8QAWxAAAAUCAgMKBwoJCQUJAQAAAAECAwQFEQYSEyExFBYiMkFRVWGU0QcVI1RxgZNCUmJyc3SCkrHSJTM0NUWRobLCJCY2RIOjs8HhQ1NkhOIIFydjdaKkw/Hw/8QAGAEBAQEBAQAAAAAAAAAAAAAAAAECAwT/xAAgEQEAAgICAgMBAAAAAAAAAAAAAQIRURITA0EhIjFh/9oADAMBAAIRAxEAPwD9UgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAAGAAZAYABkBgAGQGAAZAYABkBgAGQGAAZAYABkBgAGQGAAZAYABkBgAGQGAAZAYABkBgAGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR9aqjVJiJffQ4tKlk2SW03MzPZqEVvrb6IrXZD7x7xp+Rwfnjf+Y6x57XtyxCS4t9bfRNZ7IfeG+pvoqr9lMdop9IbdjeFKosqlSXWXKY1JJpbl0JNTyyukuQrJDlIsm+pvour9kUG+pvour9kUKjgpMymV4qfW2pTVRkRFPNvrmaZp5CTSlZpLVkNOZHBy+62i+lsDlbYj99TfRVX7IoeWMWNPtJdapVXW2rYaYpmJBw8qDVzFcc+Cy/m7G+M5++oK2tM4yNW+dPQ9a7GfeG+dPQ9a7GfeLFYLDpxtsV7fOnoetdjPvGvfaxpVt+LqnnQSTUk4x3IlbBZDIVZJfzrqPyLH8QzblHtJlu32MdG1bsphvsY6Nq3ZTHfbrETiuLOl4dmsUpRFMcRlbuvJr+NyDHKyZb99jHRtW7KYb7GOjat2Ux85k1mT4thUSnwJ8WdJqu4pbTsrM4lKWVvanvcoMiTwst8qj1ZhdMFympdGszHeimw6tlbTrmkUhxKrK4fKQcrNJLfYx0ZVuymPLmL2G8mkptUTmUSSzRzK5mO5RXETXjt4t+etfaJN77HfvlR0XV+xqDfK30XV+xqE4SbhkHWOWP1UHvlR0XWOxqHh3FCG0mo6VWMpEZme5FCwkQ5akX4Pk/Jq+wJzHtMIBnGcd5pDjVMq60LK6VJimZGQ9772eiqz2Qxrw0VqFA+QT/AJiVIhjlaTCO33s9FVjsh94b72eiqx2Q+8V3wiQSeYbKHJmN1qovJhxtE8ZEgz1rXZPvEEa/UNGIaK0vENFiQ5U5Mh5aXXlFJVZMdpKc2r4Z5C+koTNjC0772eiqx2Q+8N97PRVY7IfeJMBM2MSjixawp1xpum1VS27Z0lFO5X2faNu+Yuh6z2QxzYf/AKVVn4jH2KFoyjpTlMZyIDfKXQ9Z7IYb5S6Jq/ZTFgsMGQ3idiFiYhakzWYy4c6M47fIb7JoI7JuesTRCDrBWxFQPlHv8IxPWCP1QAAbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAFbxutKIMJa8xNpmNmpRFfKWvWObfDS/Ov7pf3Ra7axkcrePM5RVN8NL86/u1/dEGlrDSK6qrpff3c5dClZ3spoUrNltstc1ah9HATq/o+e0re5AlrnMOuLlOJ0ZuvqccWTfGyEpWwtRfqEzvipfnX92vuFpuAdX9FUViKl+df3a+4aMKYgpkeitNOybLJS7lo1++PqFgrVVg0aA5NqktiLGRtcecJBei58vUKVv1qmJUpLA9DffjclUqBGxG9KC47heghY8cxOYkWheLaK2hS3J6EtpK6lKSoiIv1DmpmO8O1OOb8GpsvtEo0GttKlJuW0r2EGz4OvGzpSMc1ORXFbSh5jbiI/sy2/SuL1DiMw47bERlphhsrIaaQSEJLmIi2B9xF766P56j6i/uivs1+nHiWe6mSlTS22SQokq12zX5Be7HyjIxNbW9p+qqrENMP+tf3Z/dHNU6nRqjCVFflOJbctc2zcQZeshc7XDKJ132PnD0TDHi5cAk2bJ/T6QzcNzS7dJn23677OCJKk1ChUqCmJCdJtosylFlVczPao+sXXKGUOu4qp4gpZf1oj+gfcI2s1ynO7g0cklZZbTi/JnqItp8X0C+WCwk+OZVDliekedl7NXcNE7GdBgxXJMuoJaYbK6lm2uxF+oWCw4q1TWKvSZlPlFmYksrZWXUorGOkVurg31Uc0JUUxBpUVyPKruGibielOwZKUSkmrRq1EhZ8h9QjPBLUHJWEGoMwz8ZUh1dNlke3O0eUj+kjIr1i7cgYkUXD9dpqKLBQ7JyLSykjToln/CJE8R0ov61/dL+6LQWozHoZ659SKa9VKG5OjznHUrkxkuJZUppfAzZSVyfBGtqpUFNUdnm6RS1N6AnMi8xII72vbnF2CwcJ2fKqb46T52Xs19wb46V52Xs19wtdiGLEHCdnyodHr1NYxJVHVSbocbaNB6NRXykq/ILCeLKL55/dL7hNjI1SsxGMorTmNqA3OaiLqTSZLqDdQ2aVEZoK1z2cmYh1liekeeI+qruFY8LSFU2PRcUMko3KHNS47l2qjO8B5P6jJX0Be2lk4lK0HmQoiMj5xvE7FalVaHUMQUM4bpuKbW4aiJCthtH1C1gQyEQoAANAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq2Jsb0SgPFGlSTfnqK6IURBvPr+gnZ6xAodxrigj0bTWFKSq/DUZPzVJ6i4jf8A7rALTiXFVHw60hdXnNx1Oam2uM64fwUFrMVfx7i3EhZcP05FEiK4s6rJ8qZfAYT/ABGJrDOBqJh15UmFHW/UnNbtQmrN+Q4fPnVs9CbF1C1kAo9J8HVLYqDNUrrz9frLR3RLqBksmj/8tviI9RX6xeAAAGbDAyAwAAMoAADQAAAAAAyAAAD53F/AHhelsko0wsSxSkJLakpTBZV29LZo+oPoKRSPC7HcLDsesxSLddElNz0ar3Qk7OF60KULlCktyo7T7R3Q4glpPqMFb7DIyAAAAAwAyADADIAI+u09qqUabAkIJbMlpTS0nykZWFY8E9Rcm4RajTFKOoU11UCSStuZvUR+tOU/WLuPnFMIsP8AhdmwEnkg4gh7uZK1k7pZMkOkXWaFIV9EUfRwAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4AADy4tLacyzJKS2mZ2sA9AYotV8IkI5SoOGoUnEVSSeU24NjZb63Xj4CC/WONvC+IcUJJzGtVOLDUVvFFKUaGzLmddPhr9WUgErV8e0uHKOFTUvVmpckWnp0hl8ZXFT6zES/SsZYpX+GalvapV/yKlrJ2U4XMt8ysn6BfSF1oVDptBhIiUiGxEjIKyUNIsRCSsAr+HML0XDjRoo9OaYUrWpw7rWs+dS1XUZ+kxPbR6sFgGAGbBYAAAAAAAAAAQAABQAAAAABAAAAclSjNzYMiI+klMvtqaWR8qTIyP7RTvA/IdPCXiyW5ml0Z9ymOly+TPgH60Gg/WL2ZD50waqF4Y5SFLIoWJIJPNkZ6kyY2pf621oP6ID6IQ9AQAAAAAAAAAAAA+f8AhdYOFSaZiVhOaRQJzcpVi1qYWejeT6Mi830B9AHFWYDVTpcqFJSS2JDamlpPlIysA3svJdQlaDJSFkSkmR7SG0juKZ4J5jkjBkaJKWpc6mrXT5Jq252jy/tSST9YuRAPQAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAABcDFZq5Pv1yPGRLejtKjrWomTy3Uk0/eGL24xlJnCzXC4qvit/pao/XT90aZUCQ0y44qqVR3IgzJDZ5jUXMSbcJQ5938TkuFwuPlcaspfos+pboxAhMJ84zsdxTZPGvglYk3ttWnaZCbpcebNiE+/IrVPUa8qWZDzJrMufyalptt5b6g7v4cl5uFxU/Fcjpef9cu4cdajy6fRpstqqzjcaaNaSUvVcJ80xGcHJeAFZptKckwmHl1OfmcQTh8MuVPoHZ4le6Vn/AFi7hvnM1zENJoBC+JXulZ/1i7hjxK70rP8ArF3CTeY9CbAUinMS3lzUu1SaehkraTZduCWXvHbuB/pOf7UZ7Zn0LUYgcZYlp+EcOy6zV3MkSOm9i2rVyJLrMQ1VRMhRycYcrc5zPkJqM6gjvzmazIsvrFFxlT6HjGlUluqsV6qqWchxFOS8hC2tFwHTXdZFwVcHafG4IvYNuCPC9Nxnh1ldAw6/PrylLKQgl6GLFLOeTO8r4FjskjvrFoLBFQr5GvHdbenEuxqptPvHho+Dfjuekz9Qh/Bv4O8P0CEc/CUyqRWZqErUndCrH73MnZmLMLsumrT+kqgeq34xP3Q7BNUunQ6XERGp8ZmMwgrEhpBJIv1DrMUt9iV45psVNSmkiRpc3lPelqE0dEV0lP8AahXyTb8gTVxm4hPESuk5/tQ8RK6Tn+1Gs20Ju4xcVLEUCRT6S/IYqU3Ogrld0e26Y+tBK8aTy/tBifLMTjCTK1XC4q/ip/pWf7QQtYqsekVKnU+RUaouVOdJlCGlJVo8x2Ja+ZObV9mxQdn8TL6FcLj5dHxCiVU2Y6Xa2iK++5GYnLWhLTjyEqUpBa7lxFWzJ15TFm8XSOlJ/tAjy/wytdxm5Cp+L3+lJ/tBooEKTO3dpqpO8jJW0mzltRGJHlzOMLlcgEKVCWf6VqXtg8Qr6WqXth0zbQmwEJ4hX0tUvbDmgofh4kTD3XIkNLiKds8rNYycIr/tCJn2qyAADoAAB7AABF1gnFqiNNytz53iJVjspZWO5EMv05bmm/l0pGlO/AXbJ8XmGciTH5u/7TdRxrQ5NLq1MajFSIjxPx5zLRm/FdymhRLO+XKole9/d1/e1U5Sluq3dMTpCtZLliR8UuQaKhQWajFkRpsh9+LIZNlxl1WZJkfLbnEzOhG+CUpn/d3Q11R9yROcjk6864dzWpXCM/2i3iJh0ZuIzFaakyCbjtaJKM/BMrWuZD21TFN6HLOmHojvwnL5/jc4ZnQkwEZ4vWWj/lsvgLz8fjdR9XUMUtat3T2lKfVkWk8zp3LWV+D1AJQAAaAAEA2y5MqFSJc1RILI22hlWU29RKufwr39QkzgT456gT64jqYi0NyTSejWtOYkq5DMhxJpZkolbtlnZvR5TXq2WvbnBNNMlsq3ZLPRJy2U5cl7dauc9YzmdD8w4ZqeN1eHuPhmtmmnNSqh4wlNxCUhl4mm85GV9eU8iR+s7CvLw1EVVKfUX3HnpsEnEtPLVw8q9qTPlIdiaa5oW0bvlcBee5L1n1H1dQuRKgIx6nrdQ4nd0tGdee6F2NPUXMXUNFQjLaiTXt1SzuRu5W12Mra7J5g5CaAcsE9JFZXZZZkEdnOMXpHSQ0MgACgAAAAAAAAAAAAAAAAAAAAAAAGK7P8A6UMfNF/vELEIKq0l6VNZkxpWgcbbU3rQarkZ+kcvLEzHwkxltIeJCzQ0tSEaRwkmaWyNJGvqK44ypVZ6VR7H/UDpVZuX4VRt/wBz/qPN86TCm0KBP8VYoZrGHJKm5s92WiLpmbuoO3BzJcskyy8qiLrE1gOmzqa3U91NORIL0knIUNx/TLjtZEEac91FwlpNWUlHbMJddJrJqL8LI2f7ku8ZKk1jlqqPYkNfbQkBD4vP+bFT+QUOrxTV+lE+yIc1Qw9Up8N2LJqSDZcKx+SK/wCsSYtMYwJ6iaqVC+QR9g7xWkUusMsNNR6o2lDaCSRaIuQU+u4nrjNX8Q4ZlN1mvGRG80TBEzET795fufi8Y+YdqTaIxhX1UYMVal07EqYLJTq7FcmEmzptQyJGbq1jo3DXumU9lSNTNtDTRCu7Vfnzn2JElYRLOHqmwp5TFVQWmcU6ojYtrP0GNh0WrdMt+w/6hyjlHocWMH60xS0pw7EXIkuOEhxTa0EtpvlWlKzJKld4rjdHqVMcpU6mUiQ4aYD8F6E6+3pGzUtK0rUebIq5pVfhX4Sdot5UWrdMp9Uc/vD2VHrPLV0H/YEM5toeMH096l4Zp8OSaTeaaSlWU7lewlFFcRq6NVzt+GUl/wAukCo1XIvzyns6RPtoeJOrE9D/ALf9wWkVRdAqpzI8ldWQa2M2S7Cba02Mdu4q30u17BI6eObV9CfAfMJtWxHIxxHw/RKlGUcdBSak+uOlRMoPUhHx1fYQt+4Kx0uzf5uXeOvK2huxj/R2b8UvtIbY/wCKIRdRoVWnwnYz1Xa0bhWO0chkqTWiSSSqrB2/4chytFuWcCXHzbE+D6pJqzE2FUdNpanGkOoU2hKmm2z1cI9pEnNweW5i5eKa30ox2ch6KkVk+NU2T9DBB9tGFMPCbsjFtPcjxJUOmwZy5yycloU0tzIpJaJtN1FrWSrnb9o+iGkhH+KKyXFqrZf2CR6Kl10tlYb9gkTFtDrMhzYS21T54sazptd6Yb9gkaKdRKtC3Roqo2emdN1XkUlrMZ+0Wj4FsAQG4q30k37JPcK3Rp2I5uMsR0dVUjk1TERFIVudNzN1ClHf6o9HK2h9EEAZWxoz8wc/xUDBQa4fGq0cv+X/AOoZptHlNVM50ya2+6TG505GcvBzZucSeU+lT4AA6gAAEiPqSVHJgKSTJ5XTPym3inxesd44atCOWyjRLS3IbVnacUjNlV6BoXEqKlEaJ6SLRkVjaLUfOOf2j0Oue66zFccjR1SX0pM0NEokZz5sx6i9Y5EzpalGSaY6adOlFzdQXkzSRm5t5DuWXbqGG41R0rSjmkaEoyrSbRcM9fC29ZfqGURqgko5KmErJ+M8l+M7v2i5toak1GpLTro7iVaN1VjkI1qSfAR9Mtd+TlEmwtamkKdb0bikkakXvlPmuOFqJPytE5NuaV5lnoS4Zc3UMrhTzQoiqFlG7mI9CWpHvP8AUSbW0JIjuIyluJVVqignHFqSaLkrilwfcjLsScrS5JyW7qI2/JkeQubrG+DFcjvyHHZCnjdNJkWWxJsVtQn2mY+B3AADqAiaZmKo1QjJjLpEWNB3WfALj9YlhEO095qorkRZCWm3S8o3kvnXaxHf9QxYShDhnSJTC7RoSpKdC4u5OpRw05ciNfvrq17Cy9Y0Jj1EtBmmpPId3PJl5Tu/aMtRahkaJU7hJXdxWiLhlzdQnIeVT6hkUo6Sssq2SIjfQVyVbOf0Lnq91bUPcWdMW6SXqcppBrcJS9MlWVKT4Kvpc3Jyjy5EqBtqJNRIlG5mI9CWpPvf9QdiVFzSGiYhKjO7Z6MjyFzdYchLWHFWTSmlTDWa0p0K7qb4xauTrHOuLPUTpJnERLSSUloi4B8p9dx4cgVB1OU6iZJ0GiPKix5/flrEzkSFONJwmDSd0m0gyM9plbaY6rDSw2tDSErWa1EkiNR7TPnG4huAAAGgAAAAAAAAAAAAAAAAAAAAAAAYAAAYsMGQ9AA8gPQAA5qjNjU6E9LmvtR4zKTW446okpSXOZnsEHinGFOw2hhuVpH6jKPLFgxyzvPq+CXNfl2CtRcMVHEktuq+EFaNyNLJyJRGlGbDJlsW9/vF6+XUQDyup17HbhtUBTtHw0vguVNaDKRJLlKOk+IR+/V9EXLCuHabhim7ho8cmWTVnWozNS3VntWtR61KPlMxKNklCUpQkkoIrEkisRDYQg9DIwMijAAAyMWAhhxZNpuY9AMWCw1k82eXhkWbi35RssAGQqmPsRKw/Sm0QmUy6zOXuanRDP8AHPHszF7xO1R8hEJ+VUo8SDKmSXEtRoyVLecUdiQlKbmYoeBYT2JK89jOrsLbuRs0ph0/xLB7XLe5Uv7LDSJ7AeGU4ZpBtvvHKqkpe6J8tRcJ99XGP4pbCLkIhZ8tjHpI9AA8kWsegEAAAAAeULStJKQZKQZXIyPaPQAAAAxYUDB3C8KfhDPmVT0//HM/4h9AHz/A3C8I3hHc2luyGgvVEb7wF/IYIhkhg1cIiFV7IAGtLyFqUlKiM07bcgDYAEdwAAAACwAPK3EoMiUoiM9lz2gPQWADAYsFguFxRkBrdeQ0nMtSUlzqOxDDbzTxnonELttyquINoAAkhYLAAmAsFgAMBYAAMAAAKAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAADkqtRiUqE5LqD7ceM2V1uOKJJEQDrFAruMn51Qco2CWmqjVEGaHpKj/AJNDP4avdK+AXrEa9Jq/hE8lB3VRcImqzknKaJU8uZu/4to9XC2n7kX2h0aBQqazApMZEaI0VktoLV6fT1hkV/BuDIuH3n6hKkO1XEEnXJqkpJaRfUgi1IRzJT+0Wqed4b3xDHSRjVJb0rKm75cxWuA1pzoeS2syMlEZpsey3/6PLanTkOJNd7JTyeke1s3kJdzbE5bWHomjS6twlcYiK1ua/eA1Pqc3UxZdkmZllt1D2+4pLjSStwzMrmV7arj04znUhWayknctQ0ykLN6PlvqUZnYr8h94D2wtS3nW3DLOgkmZkWoyO/cPbOm4eny8bg5eYZabyKUozzLVa525gbQtOfOvPdRmWq1i5hB5UZOukRbE6zCRc8qEnrWdj9HKPbSMqNe09ZjCUGbxr6rWAa5Op+NbjZlWPm4JjLDi1vvNrL8XbXz3IenmVOGhSV5VIMzI7X5LCqY7rbtAgtMU9vdVdqzpRIDBarrtrWfMhBZlmfeAgq80vGeJd7qPzBAfTMqayPVJWSrtxvRmTdfUREPoBPEmOS0oImk8pHsL/wDBHYOoacOURqETxyF8d2QrjPLPWaz6zEkUMzZ0OazezZwsvNcUZW+ZPraTkLKhKzNXLe/cN0NxS46FLtmUV7EVv2DleazvKNalFYiIiJBLv+wbWkvuJbNbmRRHdRZb5i/yAb5DuhZUvLmtyXGpDizWRGlJkZazLVY+YbnmUutmhRmRHzDWRLvw1Eq2yxWAaVSbuE2haCczFcle6K9tQ251G6tCbFltrMr3GpbBualmkyzZiMy1kNpsZVKUhVjUdz1AOdpa0RYZIIjz2Sd+TUZ3/YOhhw1KcI7cFWXUXwSP/MaSiGWg8p+KO+zbqGxUdd5BocyqcO5Hl4uq3rAdVhH6d8ms5khPlNHax++tfaJG449yuEwTelQdlZr6P4V+cBhyQSn1tEttOQkmZr5b/wD8X6x8+wG46vFHhEdSvL+EmFWtf+qMj6ITK9KtaHEpUoiI7pM9l+vrFC8HrelxX4RkXteqNJv/AMqyA+iIuSSzbRraVpcyyKyTuSesucYyKNGVStdratVvQNqdharEA4nHHtK02nISllc9R6k/rGcqlVCQaDSlRJRYzK/OPaYzpJV5VOdSrmrJrtzbeYbCYs+65m49tVtlgGpp5SziqLUTu0vVcZbfUW6b5LtrMi5NWUj/AIh5TCNLUctJ5Rniry/BtsuMqjK8rmcvnUSy1cUyt+zUA2IkZ3ibIjO5GZGerZbvGlMhzRpcUlBFnyGVtXGte43bnPTJcNZHlSZWJNttu4eSjLKPotInjZr5T99fnFGH3nW1KPgWMyJBK5TGH86VxeHdecyvbVxT5B7VHWp9LhuEeUuCRp2Hz7RsJo/JmpV1JO5nbadrANO6NE26a7GaDIrlqvqT3jLb6jcSk1trv7zkGVxSWl8lHcnerZwbD2hpecjcWlVtlk2AaCQRTCsRF5I9hdY9VBJHuczLWTpWPmMZNhZSNLpC4mSxp69u0e5LJvZMqyTlVfWm9wGXTQnyjhFwCMyMy2BEO7ROHxl8IxiUyb8Z1ojsa0mm/MNxFYB6AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAvEkc7m3FmuoJRpJbbJqSoyVY7GM2tEfonwECWJGPMal2ZQ9b5GPMal2VQzzgTgCD3yMeY1Lsqg3yMeY1Lsqg5wJwapD7bDK3HVEltCTWpR7CItpiHPEbHmNS7KofO/DVWazVsJP0LClNmnU6inRLW62bZNMHx1a+fUn1mHZTaTOFwqWP6NFoMGqRHXKh4wItwxoiTW7JM9hJTydZnYi5xFUrC9SxJUGa1jxLZLaPNDozas8eLzKWr/aOdfFL3I+ceALCVewJIlLr0JqS08lKEm3HdXIZLkQlaiIsmvWXUPuB4gb8wqfZF9wdlNpyTNwEHvibL9HVPsqhjfE30dU+yqDnTa8oT5DIgixE30dU+yqHlzE8ZlBrfh1Bpstq1xlERB2U2coTxkMjyhZLSSkmRpMrkZcoOLJtClKOySK5mNZHoBApxPGUhK0Q6itCiulSYyjIyDfNH8xqfZVDHbTap4BA75o/mNT7KoN80fzGp9lUHbTYnwFf3zx/Mqn2VQb54/mVT7KoO6mxzYyxvRsHzKUzXX9zN1E3EtvK4iVIIjsfpuIPweQ3K/WJWNqm1kelN6GmsqK+54l9R9S12ufqHzfw34bleE7FdAhxClw6ZT2XFSHlRlrWlTpkWVKE681m/dWIfSsAxafg6gt0qnxq7IbRwjcktqcWZ/5F1EQd1Nj6CZAQgt8aOjKr2UxksRo6MqvZTDtpsToCC3xo6MqvZTDfGjoyq9lMO2mxPDyZCELEjBLbS5CqDWkWltJuRzSRmZ6hODUWifwebD1YaJ0puFFckPXyIK55SuYiU4kZUhKig1LKorke5j2CWvFf0TlgsITfJH8zqXZVBvkj+Z1HsqhO2mxOAIPfJH8zqPZVBvkj+Z1Hsqg7abHbW6pGolKk1GcbhRY6DW4baDWoi9BFcx8c8FvhHw3Ox5iqLAmqlPVaqIVDJppZ50JjoI1nq4JZkq22H1CVW4kxhbDtPqLjTqTbWk4qtZHqMfG/A9geBg3G2J6qcSc+k3iYgkUZRm02pKVnfVqVwiT6usTupsfoYiCwgixGx5nUOzKHvfGx5nUOzKDupsTQCC3yMeZ1Dsyg3yMeZ1Dsyhe2mxPWGDIQe+RjzOodmUPTOI470tmOcaY0t0zJBvMKQRnlvtDupsTQAA6ZGQABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADFQwwdqZ/auf4ihbzHzuh16lRIRtSpqG3SddunIo7eUV1DjeJmcQLWKv4RUrKgIfZkyWHGZDJp0LpozFpU6jttIdx4ooZfpFHs19wjK9NwtXY7bFSmKW0hWYkpW6jMfwsu0c+M6HNjlmdGqiKw81Kk0WLFu8iNLNlxpaV3NeX3erkzC5xnUSY6HWzulSUrT8U9gp8teE5mgKRPkLQ00lomzfeyKSnZnTy/S28omE4ooaEElM9si+IruDE6E6ZCGfL+d7fzNf75DCcU0U/0g39RXcIpzEVKXidD5TEk1uRbZqymdj0iT/dGZrbRMZXEjHiQzp47rWdbekQpOZB2Vr90XwhCJxfQ/P0+zV3DxIxRQZDTja59krQpB2JZHYxYidMxWVNYlSYGC8WNtT5S3mKsuNHW44tbiyu1ZtKz1le9r8ma4nPBcclKKvGmJkRH2ZJXp0hzTLioUhJp8r7slcI+q9uQcUNjBLEWTHQ+ampK9K8lbjq8y8xKz9SrpTr2iUo9RwtRUyURZvlHlkt51edxbh5ctzM7q2faLxnTWJ0uaVatgisVn+ApnyZjRvuoKdlQT7M+4RmIcUUiVR5bTExKnVNnlTlVrP9QnDP7CcZXqIX8lZL4BfYMS/wAmd+KYxGubTfxEhL/JnPimO/oQWG/zDB+SISQqdDxLSY1HhNPzWkuE0VyJKj/hHbvvonnyPqL+6OcUlUV4QIjL0ZGidleOXiNqmtMuqQekP/amkvckes1HyF1iv12XMVUMTVBU59EuiuRWYiGnDSjWlClmpPFPOpak8L3omqm9hCoVNubKlmmUlnRk4h15s8u23B9P7R7lO4Ml1FudIfS5ISSCMyJyy8nEzJ2Kt8IXrkW1rW2lXvivYZMhEFiiidItfVV3AeKKJ0k19VXcJPjke4BfzsrXyLH8Ym0lrFNhYipLWJao8uagmnWWUJVoz4WXNcuL8IhLliqh9II9mv7ozTxyuEpVG9PT32tG67mbVwGlZVK1bCVcrX2esfLKa/LdfboUp2bDafq+icjLk53WGtCpaW9IR8JKzQR8E+dIu9Tr2HZ8RTEmoHo1bdGTqFeoyK5CINODPFbkRUtSkaQpRuGTukN1Pu8+2431yiT8H63UQKnCdfdfTBqDzDJuHmWlBZTSV+XKajL1C2ZhVKZWcM0qMUaHLaaaLhndKlKUZ61GarazHZvsonSDf1VdwdcjbiVX8lifO2v3xaSO4+e1fENKnJhsRZrbjqpbVk5TL3foH0BJCeOJiZyI7E35infIr+waYX5HH+SR9g2YpPLQJ58zK/sFdi4qoyYzCDnIzJaQRlkXqO3xRL0mbZgWO2sfJ8f4wTvop8aLWUQWINSiodaJVlPGtZZ1H8Ai1fWF8310bz5H1F/dHLUK3hqoJjFOkNOpYfRIbI0q4LqDzErZyGExafQp1SfrFMxUy6/GqJS5FYQyTxupOI5FWViSXC4yU5j4t9Rj6wKa5UcNeOk1Ryatcotac6nFpQeWxqQlWpIlyxTRvPkfUV3CcbaMJqxCEon5bWPnX8CQViqjJ/ryPqK7hDUTE9IblVVTsxCUuPm4g8qtZZS6hOFptHwmJW8iERi2LOl0VbVLTnf0rSjQT+hNaErSakkux2uSTT6x4320PpBH1Fdw5qjXMPVOIph+esk5iMlMqcbWR+lJDXCy4lWozzdbqdFoy/GFOitomHIjrkKzreZU2RINZK1p8opfqIW3BktczDMJb7qnnkZ2zcVtUlK1JSf6iEM4WDEQ48bSZGY7i1sqQbqXEmvj8MtevhX5xJQsRYfisNxosttuO0SW0NobXZJfVE650YssYjqj+d6H85V+4sc++qil/X2/qL+6OZdap1QrtFbhyCcWUgzsRGXuFc4cLR6MSvYAA9OBkAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxUcI/mf+3e/xVC3GKZhWXEao5E/Mjtr0790qcK5eVUELCSrlTbo9MemPIUtKLFkTxlrUZEki9KjIVJjElSbr9aOpxFQ2olPjPFGfkoSi61vcPMdkpKxER394LLW2qVWaY7CfqLaEqNKicZeJK0KJWYjI+e4rknDlIknJdnYjffkPkxmfW63wDZWpaMqbWtdR6gVxycfvzodOeoMRl5TlVKlyvLoWklWSqyFlqVcjLhfaJlvGDB4uj0BxqOTzq3GyUmYla0KQm/DQnWgjIjtfmHE3h2kbgUw3W1qfKoJqW6icbNZPkSS97ly2ItVuUZpeHKTTp8eT48fcaiyHZMdhTrWRK3UqSszJJZlcc7ZtgC8Hc+X9QgZCr4sil/wK/wDESJEqlT/P4vtSEO/Ohlipk91MGhEA0585WvnTqG2srLawoWI8Vy1v6OkQ5G5mKpGhOzCUVjWbrWcsm22VVs3ULmVQh+eRfakKpIw1TH57y0VlxmM7LRPcik63kU8hSVX4ubKZkWq4ww3SMassYl8S7mbXIWpSGyTKQasySvw0cZBHyZhGwscSo2BKbWKxCisOPtaSypaGUKTkzGZZtnNbjDuj4cpMasomKqy3EsynZzEcnGyShb183ubntPaocycL0hmLAYarzje40PNMKStq6WnbXTs6uNxusBbqPPYqtNiToxKNiSyl5s1FY8qk3HNis/5tVD5MeaKqm0mkw6fHmsGxFaSy2pbxKVZKbcIxpxPNhuYcqCETGHFm0eUtKSjMwaha4peSb+IkYl/kzvxTGYv4lv4iRiX+TOfFMREJh38ywvkUfYPGI6yVGhtOlHXJffdTHZYQrKbizLZc9RFZJnfVsGjD06J4lgkqVHSrQouRuERlqGvEbFOrcRpo6qiO8y4T7D7LySW24nYfMfKVj5xsVuk4pmNPYnlVRhEXcsxmOhiVKbabaJTCTvpD1WNSjPn17BupWNpVVdwwdLpyVwqmb6HdJIJKkG1cjIuciNKtfKPTuFqS86cg8QSCm7pKZug3WVK0pIycUk2y25Lesb4tApUSJTmY9dcQ5DfecS9pkGtzTLNa0mduXNxgR04exhFq+IHKOTMdLyGlvJJmWh40klWUyWSeIrhFqFssVtRClYcoNLo0uHIKsKlHDirhRkOutkhts1Eq1klrPgFwlaxak1KCf9di+1IFRED+mdc+Sj//AGCfIxWabOjHi+trVJjk2tqPkWbpWV+ME6U2H57E9qQ018KbOxRLn1jDxxIMiPTZVUXHTKU4mzyEsPbU7SJSk6ue3INVW8IrbXjuNEYYXUYMF+W0lEpDqbNnws5FxDK17Drh4bpTUiIrx26uLEfVKjxDfQbTa1pWR8mYy8qeW56hpiYRosa7C6s6/HbgvwUNG62lKWnOMWos1+sRl6q2O10Og02fWosdK34xPuo3Uho+S+RB8JZ672IXv0ah8+mYUo8qJud7EUhKVwtwvKJ1u7jfufc6rbNQu/jKn+eM+1L7wI4sSFeLH+cN/aLMRCqV2bDdjx0MyWHFnIbslLhGZ6/SLaMzAh8Vl/N2ofIq+waoB2iM/Jp+wbsV/wBHah8ir7BxQ5cTcjH8rjfi0/7ZHN6RIHLiKunS5VOiRoy5c6ctaWWUqJBWQnMtSlHsIi+0hVaRjKTCw4/Oq7bRKKa+ySJcxtlLaUWyourjcthYa/Cp9WkU+WzVERZ8FxS2H2n2jMkqTlURkd0mSi5OpIiWMJ0qIljcmIZEd5s3rvm+2paidMlL1qTYtm1Iqw3U3Fc2p4mpjUKC2VImUxNQJ43SzpufF6uYdWFcXxcQVGXBZS0UiMhLq9DIS8nKd08ZPurp2Dlcw3RSYix26saY7VPVTHG0vI8syabcI7XzdZDow5SIFFmqlprJyntAiMnSvIyobQepJESS5hpuMLWIXD/52r/zsv3CHf4yheeRvakIfD8+GVTrilTIxJXKI0npS1lkIF+FgmPoiRH5Dp2bZbU6r0JK5ihs4oqM3FeGyVT34VPlxZUkiW4hRPpSSDTfmPXf6QuUqTTpLLjD0yIaHkqQotKXFMspipowrSCTGam4ikykx478RhDj7aSaacTZRaiTc7EWs+YQmXDVPCK67R6s9R4UZ+bTtCaiTKQ83lcMyvdPuiyqKwmazjNuhVOnw6nGYYVLdZYUW7G87a3FWTlRxlFe11DlRhiknTalFl1p6Uc6MzFW4440RpS0ZqRYiLLykNcjC1LlSlSHq9IzOvR35CUPMoJ51k0mgz1bMyE8EtQM8n0JQha1+eaF84X/AIZjvOowr/lUf2yPvCLqcmPIrFE0Mhpakvq4KVpMz4B8wLMraQyMDIjkAACAAAAAAAA8JUo+MRF6DuPY82AeiO4wozLYV/WMkBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCLXh6juLNbtLgrWe1So6DM/wBglAARO9+i9EU/syO4N71F6Ip/ZkdwlQBpFb3KKf6Ip/Zkdwb3KL0RT+zI7hKgCIre9RS/RFP7MjuDe9ReiKf2ZHcJUBVRe96i9EU/syO4N71F6Ip/ZkdwlAARe96i9EU/syO4N71F6Ip/ZkdwlAARe96i9EU/syO4Cw/Ri4tKgF6I6O4SgAMDJABCIjd79HL9FQOzI7gLD9HI/wA1QOzI7hKGMCsove/R+ioHZkdwzvfo/RUDsyO4SYAqM8QUcv0VA7OjuDxBR+iYHZ0dwkjAZVGb36P0VA7OjuDe/R+ioHZ0dwlbBYMyZRW96j9FQOzI7g3vUfoqB2dHcJWwGQZkyit79H6KgdnR3Bvfo/RUDsyO4SgDQi00CkocQ41TILbiDulSIyCMv2CUAAGuQyiQ0pt1KVoUVlJUVyMuYRxYdo3RFN7KjuEqACJ3uUXomndlb7g3t0Xomndlb+6JYAETvcovRNO7K33Bvdo3RFO7KjuEsACK3u0boindlR3DG92jdEU7sqO4SoCZVF73aL0RTuyo7g3u0XoindlR3CVATkZRW92i9EU7sqO4N7tF6Ip3ZUdwlRgxcoid7VFv+aad2Rv7o3RaHS4rxOxqdDZdTsW2whBl6yISICoDIwMhIAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAACgAAAAAAAAAAAAAAAAAAAAAAAAAKjIAAgwAAAAAAAAAAAAAAACqCOr1bg0CkSqpV3tzwIqDcedyKXkLnskjMxIj574fi/8HMU/Nf4iGZR7wx4XcC4lq7VMouIGXpzp8Bpxl1nP1EbiEkZ9V7i/j884lrOIKlJwc7jnCcjD1Fp9VjPonMTWZpqe2NJWlJpU22ZnrVZXIVtYk/Drjwm8MYgoW9fFasujR4yKnXhnZaFX0ubZycXaKr7mKpjfwgYbwMmGrFNQ3CmYayYPQOOZzTbNxEnbjFtttGjBONN9EiRH3tYmo2gQS89XgbmQ5r2I4R3MXMUfMYHhz8HtRnRocKv6WVJdSyy3uKQWZajsRXNu20fTLD5n4BDthqu/wDr9Q/xjFXwtiXGJYQk41rteiu0WmHOMqczCQTk1ttS0IzvHlyGS06shayJN7qMRMvugD8y0PH/AIRlViBNdhYqmR35CNNTnsJpYjNoWrhZH0rUuyC4pq224Q9Yh8I2NKvX6kvDSsURabCkORWG6XhluezI0Rmk1reW5e5qvqSWpOXaYiv0wAr+BatOrOEqXUKvBXAqEhhK34ykGjRL5SynrL1ifI7gPQAAoAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAAiAAADAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAAAAAAAAAAACveEDDe+7B9ToW6tx7ta0Wn0ekycIjvluV9nOQsICI+Ss+DGvVKXATjPHcutUqE8iS3AapzcNK3EHdGdSVGaklzejWLvjzDu+vCk+ibq3JuokFptGa8uVZK2XK/F5xZBgFAABRVcCYZ3qU2fEOXurdVQkTs+iyEjSrzZLXO9r7RzYZwVEpeAXcKVB1NQiPHJS6vR6LOh51azK1ztbOZXvyXFzMZIEfJqJ4O8UUw41Pa8I1TXhuMoiRCOC0UjRkd0oOTt5iPg7NWoepvg2rcKs1GXgjGsnD8WovHKkw3IDUxvTqVwlIzmWS+0yLl+iRfVzK4CCLoFPXSqRFhPzZM91lBIVKkqzOOn75R84kiGTIAAAAAAAFUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABkAARAAABgAAFAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEZAAAAAAGAAAAAAVQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/9k=" alt=""></p><h3 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</h3><p><strong>1.B+的磁盘读写代价更低</strong></p><p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p><strong>2.B+tree的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p>B树参考之前发的：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247489450&amp;idx=1&amp;sn=4b1b4f3bf6af813804941320a9adab00&amp;chksm=ebd62886dca1a1903ae2375998863886e39d3d3c19a303c36788ab1b664282e230675056ab31&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">图解 MySQL 索引：B-树、B+树</a>  </p><h3 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a>9.聚集索引和非聚集索引区别?</h3><p><strong>聚合索引(clustered index):</strong> </p><p>聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。</p><p>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p><p><strong>非聚合索引(nonclustered index):</strong> </p><p>非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。</p><p>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p><p><strong>根本区别：</strong> </p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><hr><h3 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a>1.什么是事务？</h3><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p><h3 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</h3><p><strong>原子性（Atomicity）:</strong> </p><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong> </p><p>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p><p><strong>隔离性（Isolation）:</strong> </p><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong> </p><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>事务：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488892&amp;idx=1&amp;sn=49a1520b62a178bce3905da608f3d407&amp;chksm=ebd62a50dca1a3465cd6e1ce219b95bace4bef392d6e9f23821eaa81240f28411e3e70eb33a4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">实战分析：事务的隔离级别和传播属性</a>  </p><h3 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a>3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</h3><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。</p><p><strong>事务的并发问题</strong></p><p><strong>1、脏读：</strong> 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p><strong>2、不可重复读：</strong> 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>3、幻读：</strong> 幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p><p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><p><strong>事务的隔离级别</strong></p><p><strong>读未提交：</strong> 另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p><p><strong>不可重复读：</strong> 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>可重复读：</strong> 在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p><p><strong>串行化：</strong> 最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p><p><strong>特别注意：</strong> </p><p>MySQL默认的事务隔离级别为repeatable-read</p><p><strong>MySQL 支持 4 种事务隔离级别.</strong></p><p>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p><p><strong>Oracle 支持的 2 种事务隔离级别：</strong> <strong>READ_COMMITED , SERIALIZABLE</strong></p><p>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</p><p><strong>事务隔离级别：</strong> 未提交读时，写数据只会锁住相应的行。</p><p><strong>事务隔离级别为：</strong> 可重复读时，写数据会锁住整张表。</p><p><strong>事务隔离级别为：</strong> 串行化时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p><h3 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a>4.事务传播行为</h3><p><strong>1.PROPAGATION_REQUIRED：</strong> 如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p><strong>2.PROPAGATION_SUPPORTS：</strong> 支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p><strong>3.PROPAGATION_MANDATORY：</strong> 支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p><strong>4.PROPAGATION_REQUIRES_NEW：</strong> 创建新事务，无论当前存不存在事务，都创建新事务。</p><p><strong>5.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p><strong>6.PROPAGATION_NEVER：</strong> 以非事务方式执行，如果当前存在事务，则抛出异常。</p><p><strong>7.PROPAGATION_NESTED：</strong> 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p><h3 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a>5.嵌套事务</h3><p><strong>什么是嵌套事务？</strong></p><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p><p><strong>如果子事务回滚，会发生什么？</strong></p><p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p><p><strong>事务的提交，是什么情况？</strong></p><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p><p>参考文章：</p><p><em><a href="https://blog.csdn.net/liangxw1/article/details/51197560" target="_blank" rel="noopener">https://blog.csdn.net/liangxw1/article/details/51197560</a></em></p><h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><hr><h3 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</h3><p><strong>两种存储引擎的大致区别表现在：</strong> </p><p>1.InnoDB支持事务，MyISAM不支持， 这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p><p>2.MyISAM适合查询以及插入为主的应用。</p><p>3.InnoDB适合频繁修改以及涉及到安全性较高的应用。</p><p>4.InnoDB支持外键，MyISAM不支持。</p><p>5.从MySQL5.5.5以后，InnoDB是默认引擎。</p><p>6.InnoDB不支持FULLTEXT类型的索引。</p><p>7.InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表。</p><p>8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p><p>9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。</p><p>10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’。</p><p>往期文章：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247490339&amp;idx=2&amp;sn=03dcec83524fd3aaa2bab57dac2763a2&amp;chksm=ebd6240fdca1ad19a6aa3548e299a1cc9749a52f9191481fe3831e3f10150ed992f44fe4d84a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB一棵B+树可以存放多少行数据？</a>  </p><h3 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a>2.MySQL存储引擎MyISAM与InnoDB如何选择</h3><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p><ol><li><p>INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。</p></li><li><p>MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</p></li></ol><p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。  </p><p>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p><p>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p><p>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。</p><p><strong>MEMORY存储引擎</strong></p><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。</p><p>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。</p><p>值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p><p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p><h3 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</h3><p><strong>事务处理上方面</strong></p><p><strong>MyISAM：</strong> 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</p><p><strong>InnoDB：</strong> 提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><p><strong>锁级别</strong></p><p><strong>MyISAM：</strong> 只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</p><p><strong>InnoDB：</strong> 支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>关于存储引擎MyISAM和InnoDB的其他参考资料如下：</p><p><em><a href="http://blog.csdn.net/lc0817/article/details/52757194" target="_blank" rel="noopener">http://blog.csdn.net/lc0817/article/details/52757194</a></em></p><p><em><a href="https://www.cnblogs.com/kevingrace/p/5685355.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/5685355.html</a></em></p><h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><hr><h3 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</h3><p><strong>1.查询中用到的关键词主要包含六个，并且他们的顺序依次为 select–from–where–group by–having–order by</strong></p><p>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</p><ul><li><p><strong>from:</strong>  需要从哪个数据表检索数据</p></li><li><p><strong>where:</strong>  过滤表中数据的条件</p></li><li><p><strong>group by:</strong>  如何将上面过滤出的数据分组</p></li><li><p><strong>having:</strong> 对上面已经分组的数据进行过滤的条件</p></li><li><p><strong>select:</strong> 查看结果集中的哪个列，或列的计算结果</p></li><li><p><strong>order by :</strong> 按照什么样的顺序来查看返回的数据</p></li></ul><p><strong>2.from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong></p><p>也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p><p>其他参考资源：</p><p><em><a href="http://www.cnblogs.com/huminxxl/p/3149097.html" target="_blank" rel="noopener">http://www.cnblogs.com/huminxxl/p/3149097.html</a></em></p><h3 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a>2.使用explain优化sql和索引?</h3><p>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</p><ul><li><p><strong>table：</strong> 显示这一行的数据是关于哪张表的</p></li><li><p><strong>type：</strong> 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p></li><li><p><strong>all：full table scan ;MySQL将遍历全表以找到匹配的行；</strong></p></li><li><p><strong>index:</strong>  index scan; index 和 all的区别在于index类型只遍历索引；</p></li><li><p><strong>range：</strong> 索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；</p></li><li><p><strong>ref：</strong> 非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p></li><li><p><strong>eq_ref：</strong> 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p></li><li><p><strong>const，system：</strong> 当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。</p></li><li><p><strong>possible_keys：</strong> 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p></li><li><p><strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</p></li><li><p><strong>key_len：</strong> 使用的索引的长度。在不损失精确性的情况下，长度越短越好</p></li><li><p><strong>ref：</strong> 显示索引的哪一列被使用了，如果可能的话，是一个常数</p></li><li><p><strong>rows：</strong> MySQL认为必须检查的用来返回请求数据的行数</p></li><li><p><strong>Extra：</strong> 关于MySQL如何解析查询的额外信息。</p></li></ul><h3 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a>3.MySQL慢查询怎么解决?</h3><p><strong>slow_query_log</strong> 慢查询开启状态。</p><p><strong>slow_query_log_file</strong> 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。</p><p><strong>long_query_time</strong> 查询超过多少秒才记录。</p><h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h3 id="1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a>1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</h3><p>MySQL有三种锁的级别：页级、表级、行级。</p><ul><li><p><strong>表级锁：</strong> 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p></li><li><p><strong>行级锁：</strong> 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p></li><li><p><strong>页面锁：</strong> 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></li></ul><p><strong>什么情况下会造成死锁?</strong></p><p><strong>什么是死锁？</strong>  </p><p><strong>死锁:</strong>  是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p><p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><p><strong>死锁的关键在于：</strong> 两个(或以上)的Session加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p><p><strong>死锁的解决办法?</strong></p><p><strong>1.查出的线程杀死 kill</strong>  </p><pre><code>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</code></pre><p><strong>2.设置锁的超时时间</strong>  </p><p>Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 <strong>innodb_lock_wait_timeout</strong>参数值</p><p>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p><strong>3.指定获取锁的顺序</strong></p><h3 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a>2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</h3><p><strong>悲观锁（Pessimistic Lock）:</strong> </p><p>悲观锁特点:先获取锁，再进行业务操作。</p><p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。</p><p>当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a><strong>补充：</strong></h3><p>不同的数据库对select for update的实现和支持都是有所区别的，</p><p>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</p><p>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</p><p><strong>乐观锁（Optimistic Lock）:</strong> </p><p>1.乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p>2.乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p>3.一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，</p><p><strong>实现方式举例如下：</strong> </p><p>乐观锁（给表加一个版本号字段） 这个并不是乐观锁的定义，给表加版本号，是数据库实现乐观锁的一种方式。</p><pre><code>SELECT data AS old_data, version AS old_version FROM …;//根据获取的数据进行业务操作，得到new_data和new_versionUPDATE SET data = new_data, version = new_version WHERE version = old_versionif (updated row &gt; 0) {// 乐观锁获取成功，操作完成} else {// 乐观锁获取失败，回滚并重试}</code></pre><p><strong>注意：</strong> </p><p>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能<br>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><p><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’</p><p><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</p><p><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</p><p>关于悲观锁和乐观锁：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488293&amp;idx=1&amp;sn=7c2a3dad91dd6b9a470ce0f8e623d8c2&amp;chksm=ebd62c09dca1a51f3c2c672ca23e9560d4afbee003b2e9299c647f783e4e85a49318ca4efcaf&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">面试难点：你了解乐观锁和悲观锁吗？</a>  </p><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><hr><h3 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a>1.数据库的主从复制</h3><p>主从复制的几种方式:</p><p><strong>同步复制:</strong> </p><p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p><p><strong>异步复制:</strong> </p><p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p><p><strong>半同步复制:</strong> </p><p>master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MySQL引入的。</p><h3 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a>2.数据库主从复制分析的 7 个问题?</h3><p><strong>问题1：</strong> <strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</strong></p><p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p><p><strong>问题2：</strong> <strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</strong></p><p><strong>实现数据备份：</strong> </p><p>类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</p><p><strong>异地容灾:</strong> </p><p>比如master在北京，地震挂了，那么在上海的slave还可以继续。<br>主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。</p><p>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</p><p><strong>问题3：</strong> <strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</strong></p><p>我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，</p><p>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。</p><p>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？</p><p>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。</p><p>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</p><p>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p><p><strong>问题4：</strong> <strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</strong></p><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p><p><strong>问题5：</strong> <strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？**</strong>如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？**</p><p>显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。</p><p>可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p><p><strong>问题6：</strong> <strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</strong></p><p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p><p><strong>问题7：</strong> <strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</strong></p><p>scale on ?更好的服务器？没有最好的，只有更好的，太贵了。。。</p><p>scale out ? 主从复制架构已经满足不了。</p><p>可以分库【垂直拆分】，分表【水平拆分】。</p><h3 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a>3.mysql 高并发环境解决方案?</h3><p>MySQL 高并发环境解决方案：分库 分表 分布式 增加二级缓存。。。。。</p><p><strong>需求分析：</strong> 互联网单位 每天大量数据读取，写入，并发性高。</p><p><strong>现有解决方式：</strong> 水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p><p><strong>集群方案：</strong> 解决DB宕机带来的单点DB不能访问问题。</p><p><strong>读写分离策略：</strong> 极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p><h3 id="4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?"></a>4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?</h3><p>来源：</p><p><em><a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html" target="_blank" rel="noopener">https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html</a></em></p><p><strong>Undo Log:</strong> </p><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。</p><p>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。</p><p>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><p><strong>之所以能同时保证原子性和持久化，是因为以下特点：</strong> </p><p>更新数据前记录Undo log。</p><p>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。</p><p>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。</p><p>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong> </p><p>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p><p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p><p><strong>Redo Log:</strong> </p><p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue笔记</title>
      <link href="/2019/12/04/2019-12-04-vue-bi-ji/"/>
      <url>/2019/12/04/2019-12-04-vue-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="vue文章"><a href="#vue文章" class="headerlink" title="vue文章"></a>vue文章</h2><ul><li><a href="https://www.cnblogs.com/sweetbetter/p/11950763.html" target="_blank" rel="noopener">https://www.cnblogs.com/sweetbetter/p/11950763.html</a></li><li><a href="https://www.cnblogs.com/yanghongtao/p/10928071.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanghongtao/p/10928071.html</a></li></ul><h3 id="什么是Vue-js"><a href="#什么是Vue-js" class="headerlink" title="什么是Vue.js"></a>什么是Vue.js</h3><ul><li><p>Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex）</p></li><li><p>Vue.js 是前端的<strong>主流框架之一</strong>，和Angular.js、React.js 一起，并称为前端三大主流框架！</p></li><li><p>Vue.js 是一套构建用户界面的框架，<strong>只关注视图层</strong>，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发）</p></li><li><p>前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果；</p></li></ul><h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><ul><li><p>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</p><ul><li>node 中的 express；</li></ul></li><li><p>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</p><ul><li><ol><li>从Jquery 切换到 Zepto</li></ol></li><li><ol start="2"><li>从 EJS 切换到 art-template</li></ol></li></ul></li></ul><h2 id="Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别"><a href="#Node（后端）中的-MVC-与-前端中的-MVVM-之间的区别" class="headerlink" title="Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别"></a>Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别</h2><ul><li><p>MVC 是后端的分层开发概念；</p></li><li><p>MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</p></li><li><p>为什么有了MVC还要有MVVM</p></li></ul><h2 id="vue实例的生命周期"><a href="#vue实例的生命周期" class="headerlink" title="vue实例的生命周期"></a><a href="https://cn.vuejs.org/v2/guide/instance.html#实例生命周期" target="_blank" rel="noopener">vue实例的生命周期</a></h2><ul><li><p>什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</p></li><li><p><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">生命周期钩子</a>：就是生命周期事件的别名而已；</p></li><li><p>生命周期钩子 = 生命周期函数 = 生命周期事件</p></li><li><p>主要的生命周期函数分类：</p><ul><li>创建期间的生命周期函数：<ul><li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li><li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li><li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li><li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li></ul></li><li>运行期间的生命周期函数：<ul><li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li></ul></li><li>销毁期间的生命周期函数：<ul><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span></code></pre></li></ul></li></ul><p>var app = new Vue({</p><pre><code>el: '#app',data: {    message : "xuxiao is boy" }, beforeCreate: function () {          console.group('beforeCreate 创建前状态===============》');         console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined         console.log("%c%s", "color:red","data   : " + this.$data); //undefined          console.log("%c%s", "color:red","message: " + this.message)    },  created: function () {      console.group('created 创建完毕状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el); //undefined         console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化          console.log("%c%s", "color:red","message: " + this.message); //已被初始化  },  beforeMount: function () {      console.group('beforeMount 挂载前状态===============》');      console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化      console.log(this.$el);         console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化           console.log("%c%s", "color:red","message: " + this.message); //已被初始化    },  mounted: function () {      console.group('mounted 挂载结束状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化      console.log(this.$el);             console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化         console.log("%c%s", "color:red","message: " + this.message); //已被初始化   },  beforeUpdate: function () {      console.group('beforeUpdate 更新前状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el);      console.log(this.$el);            console.log("%c%s", "color:red","data   : " + this.$data);          console.log("%c%s", "color:red","message: " + this.message);   },  updated: function () {      console.group('updated 更新完成状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el);      console.log(this.$el);          console.log("%c%s", "color:red","data   : " + this.$data);          console.log("%c%s", "color:red","message: " + this.message);   },  beforeDestroy: function () {      console.group('beforeDestroy 销毁前状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el);      console.log(this.$el);             console.log("%c%s", "color:red","data   : " + this.$data);          console.log("%c%s", "color:red","message: " + this.message);   },  destroyed: function () {      console.group('destroyed 销毁完成状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el);      console.log(this.$el);           console.log("%c%s", "color:red","data   : " + this.$data);          console.log("%c%s", "color:red","message: " + this.message)  }</code></pre><p>  })<br></p><pre><code>## Vue 基本语法###  v-cloak当网络较慢，网页还在加载 `Vue.js` ，而导致 `Vue` 来不及渲染，这时页面就会显示出 `Vue` 源代码。我们可以使用 `v-cloak` 指令来解决这一问题。</code></pre></li></ul><h3 id="Vue指令之v-model和双向数据绑定"><a href="#Vue指令之v-model和双向数据绑定" class="headerlink" title="Vue指令之v-model和双向数据绑定"></a>Vue指令之<code>v-model</code>和<code>双向数据绑定</code></h3><p>v-model使用了双向绑定之后，就不需要操作dom，进行获取或者设置</p><h3 id="Vue指令之v-text和v-html"><a href="#Vue指令之v-text和v-html" class="headerlink" title="Vue指令之v-text和v-html"></a>Vue指令之<code>v-text</code>和<code>v-html</code></h3><p>实现效果和jquery中的相同</p><h3 id="Vue指令之v-bind的三种用法"><a href="#Vue指令之v-bind的三种用法" class="headerlink" title="Vue指令之v-bind的三种用法"></a>Vue指令之<code>v-bind</code>的三种用法</h3><ol><li><p>直接使用指令<code>v-bind</code></p></li><li><p>使用简化指令<code>:</code></p></li><li><p>在绑定的时候，拼接绑定内容：<code>:title="btnTitle + ', 这是追加的内容'"</code></p></li></ol><p><code>&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt;</code></p><p><code>&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt;</code></p><blockquote><p>注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</p></blockquote><p><code>&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt;</code></p><p>这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。</p><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><p><code>&lt;a v-on:[eventName]="doSomething"&gt; ... &lt;/a&gt;</code></p><p>在这个示例中，当 eventName 的值为 “focus” 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p><h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 <code>Vue</code> 特定的特性。当你在使用 <code>Vue.js</code> 为现有标签添加动态行为 (dynamic behavior) 时，<code>v-</code> 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，<code>v-</code> 前缀也变得没那么重要了。因此，<code>Vue</code> 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p><p>v-bind 缩写</p><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;...&lt;/a&gt;</code></pre><ul><li>v-on 缩写</li></ul><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;...&lt;/a&gt;</code></pre><p>它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于特性名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的。</p><blockquote><p>注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名  或  this.方法名 来进行访问，这里的this，就表示 我们 new 出来的  VM 实例对象</p></blockquote><h3 id="Vue指令之v-if和v-show"><a href="#Vue指令之v-if和v-show" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h3><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><pre><code>&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;也可以用 v-else 添加一个“else 块”：&lt;h1 v-if="awesome"&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</code></pre><p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p><h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h4><p><code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的<code>“else-if 块”</code>，可以连续使用：</p><pre><code>&lt;div v-if="type === 'A'"&gt;  A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt;  B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt;  C&lt;/div&gt;&lt;div v-else&gt;  Not A/B/C&lt;/div&gt;</code></pre><p>类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。</p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h3><p>另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：</p><pre><code>&lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt;</code></pre><p>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。</p><blockquote><p>注意，v-show 不支持 <template> 元素，也不支持 v-else</template></p></blockquote><h3 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h3><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><h3 id="Vue指令之v-on的缩写和事件修饰符"><a href="#Vue指令之v-on的缩写和事件修饰符" class="headerlink" title="Vue指令之v-on的缩写和事件修饰符"></a>Vue指令之<code>v-on的缩写</code>和<code>事件修饰符</code></h3><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;...&lt;/a&gt;</code></pre><h4 id="事件修饰符："><a href="#事件修饰符：" class="headerlink" title="事件修饰符："></a>事件修饰符：</h4><ul><li><p>.stop       阻止冒泡</p></li><li><p>.prevent    阻止默认事件</p></li><li><p>.capture    添加事件侦听器时使用事件捕获模式</p></li><li><p>.self       只当事件在该元素本身（比如不是子元素）触发时触发回调</p></li><li><p>.once       事件只触发一次</p></li></ul><pre><code>&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;</code></pre><h2 id="在Vue中使用样式"><a href="#在Vue中使用样式" class="headerlink" title="在Vue中使用样式"></a>在Vue中使用样式</h2><h3 id="使用class样式"><a href="#使用class样式" class="headerlink" title="使用class样式"></a>使用class样式</h3><ol><li><p>数组</p><pre><code>&lt;h1 :class="['red', 'thin']"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li><li><p>数组中使用三元表达式</p><pre><code>&lt;h1 :class="['red', 'thin', isactive?'active':'']"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li><li><p>数组中嵌套对象</p><pre><code>&lt;h1 :class="['red', 'thin', {'active': isactive}]"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li><li><p>直接使用对象</p><pre><code>&lt;h1 :class="{red:true, italic:true, active:true, thin:true}"&gt;这是一个邪恶的H1&lt;/h1&gt;</code></pre></li></ol><h3 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h3><ol><li><p>直接在元素上通过 <code>:style</code> 的形式，书写样式对象</p><pre><code>&lt;h1 :style="{color: 'red', 'font-size': '40px'}"&gt;这是一个善良的H1&lt;/h1&gt;</code></pre></li><li><p>将样式对象，定义到 <code>data</code> 中，并直接引用到 <code>:style</code> 中</p><ul><li>在data上定义样式：<pre><code>data: {   h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }}</code></pre></li><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<pre><code>&lt;h1 :style="h1StyleObj"&gt;这是一个善良的H1&lt;/h1&gt;</code></pre></li></ul></li><li><p>在 <code>:style</code> 中通过数组，引用多个 <code>data</code> 上的样式对象</p><ul><li>在data上定义样式：<pre><code>data: {   h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' },   h1StyleObj2: { fontStyle: 'italic' }}</code></pre></li><li>在元素中，通过属性绑定的形式，将样式对象应用到元素中：<pre><code>&lt;h1 :style="[h1StyleObj, h1StyleObj2]"&gt;这是一个善良的H1&lt;/h1&gt;</code></pre></li></ul></li></ol><h3 id="Vue指令之v-for和key属性"><a href="#Vue指令之v-for和key属性" class="headerlink" title="Vue指令之v-for和key属性"></a>Vue指令之<code>v-for</code>和<code>key</code>属性</h3><blockquote><p>我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p></blockquote><ol><li>迭代数组</li></ol><pre><code>&lt;ul id="example-1"&gt;  &lt;li v-for="item in items"&gt;    {{ item.message }}  &lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt;    var example1 = new Vue({      el: '#example-1',      data: {        items: [          { message: 'Foo' },          { message: 'Bar' }        ]      }    })&lt;/script&gt;</code></pre><p>在 v-for 块中，我们可以访问所有父作用域的属性。v-for 还支持一个可选的第二个参数，即当前项的索引。</p><pre><code>&lt;ul id="example-2"&gt;  &lt;li v-for="(item, index) in items"&gt;    {{ parentMessage }} - {{ index }} - {{ item.message }}  &lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt;    var example2 = new Vue({      el: '#example-2',      data: {        parentMessage: 'Parent',        items: [          { message: 'Foo' },          { message: 'Bar' }        ]      }    })&lt;/script&gt;</code></pre><p>在 v-for 里使用对象<br>你也可以用 v-for 来遍历一个对象的属性。</p><pre><code>&lt;ul id="v-for-object" class="demo"&gt;  &lt;li v-for="value in object"&gt;    {{ value }}  &lt;/li&gt;&lt;/ul&gt;&lt;script type="text/javascript"&gt;    new Vue({      el: '#v-for-object',      data: {        object: {          title: 'How to do lists in Vue',          author: 'Jane Doe',          publishedAt: '2016-04-10'        }      }    })&lt;/script&gt;</code></pre><blockquote><p>2.2.0+ 的版本里，<strong>当在组件中使用</strong> v-for 时，key 现在是必须的。</p></blockquote><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “<strong>就地复用</strong>” 策略。如果数据项的顺序被改变，Vue将<strong>不是移动 DOM 元素来匹配数据项的顺序</strong>， 而是<strong>简单复用此处每个元素</strong>，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，<strong>以便它能跟踪每个节点的身份，从而重用和重新排序现有元素</strong>，需要为每项提供一个唯一 key 属性。</p><h3 id="Vue指令之v-if和v-show-1"><a href="#Vue指令之v-if和v-show-1" class="headerlink" title="Vue指令之v-if和v-show"></a>Vue指令之<code>v-if</code>和<code>v-show</code></h3><blockquote><p>一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。</p></blockquote><h2 id="Vue调试工具vue-devtools的安装步骤和使用"><a href="#Vue调试工具vue-devtools的安装步骤和使用" class="headerlink" title="Vue调试工具vue-devtools的安装步骤和使用"></a>Vue调试工具<code>vue-devtools</code>的安装步骤和使用</h2><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools - 翻墙安装方式 - 推荐</a></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>概念：Vue.js 允许你自定义过滤器，<strong>可被用作一些常见的文本格式化</strong>。过滤器可以用在两个地方：<strong>mustache 插值和 v-bind 表达式</strong>。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示；</p><h3 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h3><ol><li>HTML元素：</li></ol><pre><code>&lt;td&gt;{{item.ctime | dataFormat('yyyy-mm-dd')}}&lt;/td&gt;</code></pre><ol start="2"><li>私有 <code>filters</code> 定义方式：</li></ol><pre><code>filters: { // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用    dataFormat(input, pattern = "") { // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错      var dt = new Date(input);      // 获取年月日      var y = dt.getFullYear();      var m = (dt.getMonth() + 1).toString().padStart(2, '0');      var d = dt.getDate().toString().padStart(2, '0');      // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日      // 否则，就返回  年-月-日 时：分：秒      if (pattern.toLowerCase() === 'yyyy-mm-dd') {        return `${y}-${m}-${d}`;      } else {        // 获取时分秒        var hh = dt.getHours().toString().padStart(2, '0');        var mm = dt.getMinutes().toString().padStart(2, '0');        var ss = dt.getSeconds().toString().padStart(2, '0');        return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;      }    }  }</code></pre><blockquote><p>使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串；</p></blockquote><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><pre><code>// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') {  var dt = new Date(input);  // 获取年月日  var y = dt.getFullYear();  var m = (dt.getMonth() + 1).toString().padStart(2, '0');  var d = dt.getDate().toString().padStart(2, '0');  // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日  // 否则，就返回  年-月-日 时：分：秒  if (pattern.toLowerCase() === 'yyyy-mm-dd') {    return `${y}-${m}-${d}`;  } else {    // 获取时分秒    var hh = dt.getHours().toString().padStart(2, '0');    var mm = dt.getMinutes().toString().padStart(2, '0');    var ss = dt.getSeconds().toString().padStart(2, '0');    return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;  }});</code></pre><blockquote><p>注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</p></blockquote><h2 id="键盘修饰符以及自定义键盘修饰符"><a href="#键盘修饰符以及自定义键盘修饰符" class="headerlink" title="键盘修饰符以及自定义键盘修饰符"></a>键盘修饰符以及自定义键盘修饰符</h2><h3 id="1-x中自定义键盘修饰符【了解即可】"><a href="#1-x中自定义键盘修饰符【了解即可】" class="headerlink" title="1.x中自定义键盘修饰符【了解即可】"></a>1.x中自定义键盘修饰符【了解即可】</h3><pre><code>Vue.directive('on').keyCodes.f2 = 113;</code></pre><h3 id="2-x中自定义键盘修饰符"><a href="#2-x中自定义键盘修饰符" class="headerlink" title="2.x中自定义键盘修饰符"></a><a href="https://cn.vuejs.org/v2/guide/events.html#键值修饰符" target="_blank" rel="noopener">2.x中自定义键盘修饰符</a></h3><ol><li>通过<code>Vue.config.keyCodes.名称 = 按键值</code>来自定义案件修饰符的别名：</li></ol><pre><code>Vue.config.keyCodes.f2 = 113;</code></pre><ol start="2"><li>使用自定义的按键修饰符：</li></ol><pre><code>&lt;input type="text" v-model="name" @keyup.f2="add"&gt;</code></pre><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener">自定义指令</a></h2><ol><li>自定义全局和局部的 自定义指令：</li></ol><pre><code>    // 自定义全局指令 v-focus，为绑定的元素自动获取焦点：    Vue.directive('focus', {      inserted: function (el) { // inserted 表示被绑定元素插入父节点时调用        el.focus();      }    });    // 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：      directives: {        color: { // 为元素设置指定的字体颜色          bind(el, binding) {            el.style.color = binding.value;          }        },        'font-weight': function (el, binding2) { // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数          el.style.fontWeight = binding2.value;        }      }</code></pre><ol start="2"><li>自定义指令的使用方式：</li></ol><pre><code>&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt;</code></pre><h2 id="Vue-1-x-中-自定义元素指令【已废弃-了解即可】"><a href="#Vue-1-x-中-自定义元素指令【已废弃-了解即可】" class="headerlink" title="Vue 1.x 中 自定义元素指令【已废弃,了解即可】"></a>Vue 1.x 中 自定义元素指令【已废弃,了解即可】</h2><pre><code>Vue.elementDirective('red-color', {  bind: function () {    this.el.style.color = 'red';  }});</code></pre><p>使用方式：</p><pre><code>&lt;red-color&gt;1232&lt;/red-color&gt;</code></pre><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol><li><a href="https://v1-cn.vuejs.org/" target="_blank" rel="noopener">vue.js 1.x 文档</a></li><li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue.js 2.x 文档</a></li><li><a href="http://www.css88.com/archives/7715" target="_blank" rel="noopener">String.prototype.padStart(maxLength, fillString)</a></li><li><a href="http://www.cnblogs.com/wuhua1/p/6686237.html" target="_blank" rel="noopener">js 里面的键盘事件对应的键码</a></li><li><a href="http://www.cnblogs.com/kidney/p/6052935.html" target="_blank" rel="noopener">Vue.js双向绑定的实现原理</a></li></ol><h2 id="vue-resource-实现-get-post-jsonp请求"><a href="#vue-resource-实现-get-post-jsonp请求" class="headerlink" title="vue-resource 实现 get, post, jsonp请求"></a><a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">vue-resource 实现 get, post, jsonp请求</a></h2><p>除了 vue-resource 之外，还可以使用 <code>axios</code> 的第三方包实现实现数据的请求</p><ol><li><p>常见的数据请求类型？  get  post jsonp</p></li><li><p>测试的URL请求资源地址：</p><ul><li>get请求地址： <a href="http://vue.studyit.io/api/getlunbo" target="_blank" rel="noopener">http://vue.studyit.io/api/getlunbo</a></li><li>post请求地址：<a href="http://vue.studyit.io/api/post" target="_blank" rel="noopener">http://vue.studyit.io/api/post</a></li><li>jsonp请求地址：<a href="http://vue.studyit.io/api/jsonp" target="_blank" rel="noopener">http://vue.studyit.io/api/jsonp</a></li></ul></li><li><p>JSONP的实现原理</p><ul><li>由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全；</li><li>可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）；</li><li>具体实现过程：<ul><li>先在客户端定义一个回调方法，预定义对数据的操作；</li><li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口；</li><li>服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行；</li><li>客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了；</li></ul></li></ul></li><li><p>vue-resource 的配置步骤：</p><ul><li>直接在页面中，通过<code>script</code>标签，引入 <code>vue-resource</code> 的脚本文件；</li><li>注意：引用的先后顺序是：先引用 <code>Vue</code> 的脚本文件，再引用 <code>vue-resource</code> 的脚本文件；</li></ul></li><li><p>发送get请求：</p><pre><code>getInfo() { // get 方式获取数据this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; { console.log(res.body);})}</code></pre></li><li><p>发送post请求：</p><pre><code>postInfo() {var url = 'http://127.0.0.1:8899/api/post';// post 方法接收三个参数：// 参数1： 要请求的URL地址// 参数2： 要发送的数据对象// 参数3： 指定post提交的编码类型为 application/x-www-form-urlencodedthis.$http.post(url, { name: 'zs' }, { emulateJSON: true }).then(res =&gt; { console.log(res.body);});}</code></pre></li><li><p>发送JSONP请求获取数据：</p><pre><code>jsonpInfo() { // JSONP形式从服务器获取数据var url = 'http://127.0.0.1:8899/api/jsonp';this.$http.jsonp(url).then(res =&gt; { console.log(res.body);});}</code></pre></li></ol><h2 id="Vue中的动画"><a href="#Vue中的动画" class="headerlink" title="Vue中的动画"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener">Vue中的动画</a></h2><p>为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能；</p><h3 id="使用过渡类名"><a href="#使用过渡类名" class="headerlink" title="使用过渡类名"></a>使用过渡类名</h3><ol><li><p>HTML结构：</p><pre><code>&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt;   &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;</code></pre></li><li><p>VM 实例：</p><pre><code>// 创建 Vue 实例，得到 ViewModelvar vm = new Vue({el: '#app',data: { isshow: false},methods: { myAnimate() {   this.isshow = !this.isshow; }}});</code></pre></li><li><p>定义两组类样式：</p><pre><code>/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active {   transition: all 0.2s ease;   position: absolute; } /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to {   opacity: 0;   transform: translateX(100px); }</code></pre></li></ol><h3 id="使用第三方-CSS-动画库"><a href="#使用第三方-CSS-动画库" class="headerlink" title="使用第三方 CSS 动画库"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#自定义过渡类名" target="_blank" rel="noopener">使用第三方 CSS 动画库</a></h3><ol><li>导入动画类库：<pre><code>&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt;</code></pre></li><li>定义 transition 及属性：<pre><code>&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="{ enter: 500, leave: 800 }"&gt;   &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt;</code></pre></li></ol><h3 id="使用动画钩子函数"><a href="#使用动画钩子函数" class="headerlink" title="使用动画钩子函数"></a>使用动画钩子函数</h3><ol><li>定义 transition 组件以及三个钩子函数：<pre><code>&lt;div id="app"&gt; &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt;   &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;</code></pre></li><li>定义三个 methods 钩子方法：<pre><code>methods: {     beforeEnter(el) { // 动画进入之前的回调       el.style.transform = 'translateX(500px)';     },     enter(el, done) { // 动画进入完成时候的回调       el.offsetWidth;       el.style.transform = 'translateX(0px)';       done();     },     afterEnter(el) { // 动画进入完成之后的回调       this.isshow = !this.isshow;     }   }</code></pre></li><li>定义动画过渡时长和样式：<pre><code>.show{   transition: all 0.4s ease; }</code></pre></li></ol><h3 id="v-for-的列表过渡"><a href="#v-for-的列表过渡" class="headerlink" title="v-for 的列表过渡"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html#列表的进入和离开过渡" target="_blank" rel="noopener">v-for 的列表过渡</a></h3><ol><li><p>定义过渡样式：</p><pre><code>&lt;style&gt; .list-enter, .list-leave-to {   opacity: 0;   transform: translateY(10px); } .list-enter-active, .list-leave-active {   transition: all 0.3s ease; }&lt;/style&gt;</code></pre></li><li><p>定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来：</p><pre><code>&lt;div id="app"&gt; &lt;input type="text" v-model="txt" @keyup.enter="add"&gt; &lt;transition-group tag="ul" name="list"&gt;   &lt;li v-for="(item, i) in list" :key="i"&gt;{{item}}&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;</code></pre></li><li><p>定义 VM中的结构：</p><pre><code> // 创建 Vue 实例，得到 ViewModel var vm = new Vue({   el: '#app',   data: {     txt: '',     list: [1, 2, 3, 4]   },   methods: {     add() {       this.list.push(this.txt);       this.txt = '';     }   } });</code></pre></li></ol><h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h3><p><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，<strong>还可以改变定位</strong>。要使用这个新功能只需了解新增的 <code>v-move</code> 特性，<strong>它会在元素的改变定位的过程中应用</strong>。</p><ul><li><code>v-move</code> 和 <code>v-leave-active</code> 结合使用，能够让列表的过渡更加平缓柔和：<pre><code>.v-move{transition: all 0.8s ease;}.v-leave-active{position: absolute;}</code></pre></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人计划</title>
      <link href="/2019/11/06/2019-11-05-ge-ren-ji-hua/"/>
      <url>/2019/11/06/2019-11-05-ge-ren-ji-hua/</url>
      
        <content type="html"><![CDATA[<ol><li>首先是在1月左右走</li><li>离职之后就需要为找工作做准备，需要学习和巩固之前的技术<ul><li>第一个 “需要学习的技术”（公司中使用的一些技术框架）<ul><li>ELK</li><li>Kafka</li><li>Vue</li><li>Quartz</li></ul></li><li>第二个 “需要巩固的技术”<ul><li>java基础<blockquote><p>看（java基础笔记、需要为面试准备大纲）文章就好</p></blockquote></li></ul></li></ul></li></ol><ol start="3"><li>备忘录<ol><li>需要将微信中的文章转化到自己的博客中</li><li>需要将java基础笔记里面的笔记完善（io流，日期工具）</li><li>针对上面的框架写好比较保存到博客中方便学习</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> myIdea </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础笔记</title>
      <link href="/2019/10/21/2019-07-21-java-duo-xian-cheng-bi-ji/"/>
      <url>/2019/10/21/2019-07-21-java-duo-xian-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="关于线程的文章"><a href="#关于线程的文章" class="headerlink" title="关于线程的文章"></a>关于线程的文章</h3><p><a href="https://www.javazhiyin.com/32391.html" target="_blank" rel="noopener">https://www.javazhiyin.com/32391.html</a></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/thread2.png" alt=""></p><h3 id="单核-CPU-和多核-CPU"><a href="#单核-CPU-和多核-CPU" class="headerlink" title="单核 CPU 和多核 CPU"></a>单核 CPU 和多核 CPU</h3><p>来思考一个问题吧。假如 CPU 只有一个，核数也只有一个，多线程还会有优势吗？</p><p>闭上眼，让思维旋转跳跃会。</p><p>来看答案吧。</p><p>单核 CPU 上运行的多线程程序，同一时间只有一个线程在跑，系统帮忙进行线程切换；系统给每个线程分配时间片（大概 10ms）来执行，看起来像是在同时跑，但实际上是每个线程跑一点点就换到其它线程继续跑。所以效率不会有所提高，线程的切换反到增加了系统开销。</p><p>那多核 CPU 呢？</p><p>当然有优势了！多核需要多线程才能发挥优势（不然巧妇难为无米之炊啊），同样，多线程要在多核上才能有所发挥（好马配好鞍啊）。</p><p>多核 CPU 多线程不仅善于处理 IO 密集型的任务（减少阻塞时间），还善于处理计算密集型的任务，比如加密解密、数据压缩解压缩（视频、音频、普通数据等），让每个核心都物尽其用。</p><h3 id="应该了解的概念"><a href="#应该了解的概念" class="headerlink" title="应该了解的概念"></a>应该了解的概念</h3><ol><li>同步VS异步<blockquote><p>同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。</p></blockquote></li></ol><ol start="2"><li><p>并发与并行</p><blockquote><p>并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。</p></blockquote></li><li><p>阻塞和非阻塞</p><blockquote><p>阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。</p></blockquote></li><li><p>临界区</p><blockquote><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。</p></blockquote></li></ol><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h3><p><strong>什么是进程</strong></p><p>进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例。</p><p><strong>进程时间片的概念</strong></p><pre><code>一个操作系统中，如果同时运行着多个进程，他们是一定交替运行的。每个进程不管有没有运行完毕，都只占据一段时间的CPU。这个运行时间就是进程时间片。它非常短促，所以感觉不到他们是交替占用CPU。</code></pre><p><strong>什么是线程</strong></p><ul><li><p>线程：进程内部的控制流。它也是一段可运行的指令。</p></li><li><p>特点：资源占用小，线程间通信容易。</p></li><li><p>多进程是指操作系统能同时运行多个任务（程序）。</p></li></ul><p>多线程：</p><pre><code>指的是这个程序（一个进程）运行时产生了不止一个线程</code></pre><p><strong>线程进程的区别体现在几个方面：</strong></p><ol><li><p>因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p></li><li><p>体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p></li><li><p>属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p></li><li><p>线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；</p></li><li><p>线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p></li><li><p>体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p></li></ol><h3 id="高并发与多线程的关系"><a href="#高并发与多线程的关系" class="headerlink" title="高并发与多线程的关系"></a>高并发与多线程的关系</h3><ol><li>什么是高并发</li></ol><p>高并发（High Concurrency）是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问收到大量请求（例如：12306的抢票情况；天猫双十一活动）。</p><p>该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。</p><ol start="2"><li>高并发关注哪些指标</li></ol><pre><code>1. 响应时间（Response Time）响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间2. 吞吐量（Throughput）吞吐量：单位时间内处理的请求数量。3. 每秒查询率QPS（Query Per Second）QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。4. 并发用户数并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</code></pre><ol start="3"><li>高并发与多线程的关系</li></ol><p><strong>“高并发和多线程”总是被一起提起，给人感觉两者好像相等，实则 高并发 ≠ 多线程。</strong></p><p><strong>多线程可以这么理解：多线程是处理高并发的一种编程方法。</strong></p><p>高并发不是Java专有的东西，是语言无关的，为提供更好互联网服务而提出的概念。如果要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等……而多线程只是其中解决方法之一。</p><p><strong>并行与并发：</strong></p><pre><code>1.    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。2.    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。并发性（concurrency）和并行性（parallel）</code></pre><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc25.png" alt=""></p><p>java中的线程的生命周期大体可分为5种状态。</p><ol><li><p>新建(NEW)：新创建了一个线程对象。</p></li><li><p>可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p></li><li><p>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p></li><li><p>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><p> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p><p> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p><p> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p></li><li><p>死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。</p><p>由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子：比如一个线程A正在读取一个文件的内容，正读到文件的一半，此时需要暂停线程A，转去执行线程B，当再次切换回来执行线程A的时候，我们不希望线程A又从文件的开头来读取。</p><p>因此需要记录线程A的运行状态，那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p><p>说简单点的：对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。</p><p>虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>　　在java中如果要创建线程的话，一般有两种方式：1）继承Thread类；2）实现Runnable接口。</p><p><strong>三种方法来创建线程：</strong></p><p>继承Thread类创建</p><p>继承Thread创建并启动多线程有三个步骤：</p><ol><li>定义类并继承Thread,重写run()方法,run()方法中为需要多线程执行的任务。</li><li>创建该类的实例，即创建了线程对象。</li><li>调用实例的start()方法启动线程。</li></ol><pre><code>继承java.lang.Thread类，并覆盖run( )方法。 class Mythread extends Thread {     public void run( ) {         /* 覆盖该方法*/      } } // 调用方式： Mythread  m = new Mythread(); m.start();</code></pre><p>第二种方式： </p><p>实现Runnable接口创建并启动多线程也有以下步骤：</p><ol><li>定义类并继承Runnable接口,重写run()方法,run()方法中为需要多线程执行的任务。</li><li>创建该类的实例，并以此实例作为target为参数来创建Thread对象，这个Thread对象才是真正的多线程对象。</li></ol><pre><code>// 实现java.lang.Runnable接口，并实现run( )方法。// 推荐此方式   // a. 覆写Runnable接口实现多线程可以避免单继承局限   // b. 当子类实现Runnable接口，此时子类和Thread的代理模式（子类负责真是业务的操作，thread负责资源调度与线程创建辅助真实业务。class Mythread implements Runnable{      @Override      public void run( ) {          /* 实现该方法*/      } } // 调用 Thread thread = new Thread(new Mythread()); thread.start();</code></pre><p>第三种：</p><p>Callable是Runnable的增加版，主要是接口中的call()方法可以有返回值，并且可以申明抛出异常，使用Callable创建的步骤如下：</p><ol><li>定义类并继承Callable接口,重写call()方法,run()方法中为需要多线程执行的任务。</li><li>创建类实例，使用FutureTask来包装对象实例，</li><li>使用FutureTask对象作为Thread的target来创建多线程，并启动线程。</li><li>调用FutureTask对象的get()方法来获取子线程结束后的返回值。</li></ol><pre><code>class CallableTest{    public static void main(String[] args) {        Callss callss = new Callss();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callss);        Thread thread = new Thread(futureTask);        thread.start();        // 接收线程运算后的结果        try {            // FutureTask 可用于 闭锁 类似于CountDownLatch的作用，在所有的线程没有执行完成之后这里是不会执行的            Integer sum = futureTask.get();            System.out.println(sum);        } catch (InterruptedException | ExecutionException e) {            e.printStackTrace();        }    }}/** * 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。 * 执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类 * 运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。  * 它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。  * 通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。  */class Callss implements Callable&lt;Integer&gt; {    @Override    public Integer call() throws Exception {        int a = 0;        for (int i = 0; i &lt; 5; i++) {            a++;        }        return a;    }}</code></pre><p><strong>一个线程的对象只能执行一次start()方法</strong></p><p><strong>*注</strong> 多次调用start()方法，会出现异常 java.lang.IllegalThreadStateException</p><p><strong>线程执行过程</strong></p><ul><li><p>调用start( )方法时，将创建一个新的线程，并为线程分配系统资源，如内存。接着它将调用 run( ) 方法。</p></li><li><p>run( ) 方法中的代码定义执行线程所需的功能。</p><ul><li>run()方法能够调用其他方法，引用其他的类，申明变量。</li><li>run()方法在程序中确定另一个并发线程的执行入口。</li></ul></li><li><p>当run()方法中的任务完成返回时，该线程也将结束。</p></li></ul><p><strong>注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。<br>从程序运行的结果可以发现，多线程程序是乱序执行。</strong></p><p>另外需要注意的是：</p><blockquote><p>执行start()方法的顺序不代表线程启动的执行顺序</p></blockquote><h3 id="实例变量与线程安全"><a href="#实例变量与线程安全" class="headerlink" title="实例变量与线程安全"></a>实例变量与线程安全</h3><blockquote><p>自定义的线程类中实例变量针对其他线程可以有共享和不共享之分</p></blockquote><ul><li>不共享数据：每个线程访问各自的实例变量。</li><li>共享数据：多个线程访问同一个变量。</li></ul><p>首先来分析下，在JVM中，i–的操作</p><ul><li>取得原有i值。</li><li>计算i-1。</li><li>对i进行赋值。</li></ul><p>非线程安全：是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。</p><p>在run方法中加上synchronized关键字，使多个线程在执行run方法的时候，以队列的方式进行处理，当一个线程调用run方法前，先判断run方法有没有被上锁，如果上锁，说明有其他线程在调用run方法，必须等待其他线程对run方法调用结束才能执行run方法，这样实现了排队调用的目的，也就实现了对count依次–，synchronized可以对任意对象及方法加上锁，而枷锁的这段代码叫做 “互斥区”或“临界区”。</p><h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><p>属于Thread的方法</p><p>0 . </p><ul><li><p>getName和setName</p><p>  用来得到或者设置线程名称。</p></li><li><p>getPriority和setPriority</p><p>  用来获取和设置线程优先级。</p></li><li><p>setDaemon和isDaemon</p><p>  用来设置线程是否成为守护线程和判断线程是否是守护线程。</p><p>  守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p></li></ul><h4 id="1．start-："><a href="#1．start-：" class="headerlink" title="　　1．start() ："></a>　　1．start() ：</h4><p>线程调用该方法将启动线程，使之从新建状态进入就绪队列排队，一旦轮到它来享用CPU资源时，就可以脱离创建它的线程独立开始自己的生命周期了。</p><p>####　　2．run():<br>Thread类的run()方法与Runnable接口中的run()方法的功能和作用相同，都用来定义线程对象被调度之后所执行的操作，都是系统自动调用而用户程序不得引用的方法。</p><h4 id="3．线程休眠——sleep-int-millsecond"><a href="#3．线程休眠——sleep-int-millsecond" class="headerlink" title="　　3．线程休眠——sleep(int millsecond):"></a>　　3．线程休眠——sleep(int millsecond):</h4><p>（1）线程休眠会交出CPU，让CPU去执行其他的任务。</p><p>（2）调用sleep()方法让线程进入休眠状态后，sleep()方法并不会释放锁，即当前线程持有某个对象锁时，即使调用sleep()方法其他线程也无法访问这个对象。</p><p>（3）调用sleep()方法让线程从运行状态转换为阻塞状态；sleep()方法调用结束后，线程从阻塞状态转换为可执行状态。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><h4 id="4．isAlive"><a href="#4．isAlive" class="headerlink" title="　　　　4．isAlive():"></a>　　　　4．isAlive():</h4><p>判断当前线程是否处于活动状态，线程处于“新建”状态时，线程调用isAlive()方法返回false。在线程的run()方法结束之前，即没有进入死亡状态之前，线程调用isAlive()方法返回true.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="5．currentThread"><a href="#5．currentThread" class="headerlink" title="　　5．currentThread():"></a>　　5．currentThread():</h4><p>该方法是Thread类中的类方法，可以用类名调用，该方法返回当前正在使用CPU资源的线程。</p><h4 id="6．interrupt-："><a href="#6．interrupt-：" class="headerlink" title="6．interrupt() ："></a>6．interrupt() ：</h4><p>一个占有CPU资源的线程可以让休眠的线程调用interrupt()方法“吵醒”自己，即导致休眠的线程发生InterruptedException异常，同时会清除中断标志，从而结束休眠，重新排队等待CPU资源。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>blockerLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Interruptible b <span class="token operator">=</span> blocker<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">interrupt0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// Just to set the interrupt flag</span>                b<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">interrupt0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="7-getId-："><a href="#7-getId-：" class="headerlink" title="　　7. getId()："></a>　　7. getId()：</h4><p>获得线程的唯一标识</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> tid<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="8-线程让步——yield"><a href="#8-线程让步——yield" class="headerlink" title="　　8.  线程让步——yield():"></a>　　8.  线程让步——yield():</h4><p>线程让步：暂停当前正在执行的线程对象，并执行其他线程。</p><p>（1）调用yield()方法让当前线程交出CPU权限，让CPU去执行其他线程。</p><p>（2）yield()方法和sleep()方法类似，不会释放锁，但yield()方法不能控制具体交出CPU的时间,不能由用户指定暂停多长时间。</p><p>（3）yield()方法只能让拥有相同优先级的线程获取CPU执行的机会。</p><p>（4）使用yield()方法不会让线程进入阻塞状态，而是让线程从运行状态转换为就绪状态，只需要等待重新获取CPU执行的机会。</p><p>（5）实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="9-suspend"><a href="#9-suspend" class="headerlink" title="　　9. suspend():"></a>　　9. suspend():</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">suspend0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="10-resume-："><a href="#10-resume-：" class="headerlink" title="　　10. resume()："></a>　　10. resume()：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resume0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="11-线程加入——join"><a href="#11-线程加入——join" class="headerlink" title="　　11. 线程加入——join():"></a>　　11. 线程加入——join():</h4><blockquote><p>假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。 </p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">join</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//join()等同于join(0)</span><span class="token punctuation">}</span></code></pre><h4 id="12-wait"><a href="#12-wait" class="headerlink" title="　　12. wait() :"></a>　　12. wait() :</h4><p>调用该方法的线程进入WATTING状态，只有等待另外线程的通知或中断才会返回，调用wait()方法后，会释放对象的锁。</p><ul><li>wait(long):超时等待最多long毫秒，如果没有通知就超时返回。</li></ul><h4 id="14-notify"><a href="#14-notify" class="headerlink" title="　　14. notify() :"></a>　　14. notify() :</h4><p>通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁。</p><h4 id="15-notifyAll-："><a href="#15-notifyAll-：" class="headerlink" title="　　15. notifyAll()："></a>　　15. notifyAll()：</h4><p>通知所有等待在该对象上的线程。</p><h4 id="守护线程Daemon"><a href="#守护线程Daemon" class="headerlink" title="　　守护线程Daemon"></a>　　守护线程Daemon</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT线程就可以理解守护线程。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。下面以一个简单的例子来表述Daemon线程的使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaemonDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread daemonThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i am alive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finally block"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        daemonThread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        daemonThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//确保main线程结束前能给daemonThread能够分到时间片</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果为：</p><pre class=" language-java"><code class="language-java"><span class="token operator">&gt;</span> i am alive<span class="token operator">&gt;</span> <span class="token keyword">finally</span> block<span class="token operator">&gt;</span> i am alive</code></pre><p>上面的例子中daemodThread run方法中是一个while死循环，会一直打印,但是当main线程结束后daemonThread就会退出所以不会出现死循环的情况。main线程先睡眠800ms保证daemonThread能够拥有一次时间片的机会，也就是说可以正常执行一次打印“i am alive”操作和一次finally块中”finally block”操作。紧接着main 线程结束后，daemonThread退出，这个时候只打印了”i am alive”并没有打印finnal块中的。因此，这里需要注意的是<strong>守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的</strong></p><p><strong>线程可以通过setDaemon(true)的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于start()方法，否则会报</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">&gt;</span> Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalThreadStateException<span class="token operator">&gt;</span> at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1365</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> at learn<span class="token punctuation">.</span>DaemonDemo<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>DaemonDemo<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">)</span></code></pre><h4 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run() 和start()的区别"></a>run() 和start()的区别</h4><ol><li><p>start() 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码；通过调用 Thread 类的 start() 方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行操作的， 这里方法 run() 称为线程体，它包含了要执行的这个线程的内容， run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p></li><li><p>run() 方法当作普通方法的方式调用。程序还是要顺序执行，要等待 run 方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</p></li></ol><p>run()，实质上是方法，作用是运行线程，无法开启新的线程</p><p>start()，创建启动新的线程，可以实现多线程工作。通过start()使得线程处于就绪状态，在获得CPU时间片后通过run()开始运行</p><h4 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep() 和wait()的区别"></a>sleep() 和wait()的区别</h4><ol><li>sleep()方法是Thread的静态方法，而wait是Object实例方法</li><li>wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；</li><li>sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。</li></ol><h4 id="线程调度——优先级"><a href="#线程调度——优先级" class="headerlink" title="线程调度——优先级"></a>线程调度——优先级</h4><p>void setPriority(int newPriority)函数设置线程优先级<br>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p><p>线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。<br>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</p><p>setPriority()代码实例</p><h4 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h4><p> 方法isAlive()功能是判断当前线程是否处于活动状态。</p><p>活动状态就是线程启动且尚未终止，比如正在运行或准备开始运行。</p><h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep()"></a>Sleep()</h4><p>Thread.sleep()是Thread类的一个静态方法，使当前线程休眠，进入阻塞状态（暂停执行），如果线程在睡眠状态被中断，将会抛出IterruptedException中断异常。把cpu的时间片交给其他线程，但是并没有指定把CPU的时间片接下来到底交给哪个线程，而是让这些线程自己去竞争</p><p>。主要方法如下：</p><p>【a】sleep(long millis)  线程睡眠 millis 毫秒</p><p>【b】sleep(long millis, int nanos)  线程睡眠 millis 毫秒 + nanos 纳秒</p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><ul><li>本线程中断自身是被允许的，且”中断标记”设置为true</li><li>其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。 <ul><li>若线程在阻塞状态时，调用了它的interrupt()方法，那么它的<strong>“中断状态”会被清除</strong>并且会收到一个InterruptedException异常。 <ul><li>例如，如果线程由于调用Object类的wait()方法、Thread类的join()实例方法以及Thread.sleep()静态方法而被挂起，此时其他线程调用了这个线程的interrupt方法，那么这个线程的中断状态会被清除为“false”，并会抛出一个InterruptedException异常。 </li></ul></li><li>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。<br>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。</li></ul></li></ul><p>可以得出两点结论：</p><p>　　1 即便调用了interrupt方法，之后用isInterrupted()方法检查它的中断状态时也不一定能得到true。</p><p>　　2 如果线程当前运行处的代码块不对InterruptedException异常进行合适的处理，那么interrupt方法就没有任何效果。</p><p>interrupted并不是马上停止线程，而是给线程打一个停止标记，将线程的中断状态设置为true,这类似老板让你好好工作，但是到底好不好工作要看你自己。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            MyThread myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            myThread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果显示还是会打印5万行数据。</p><p>Thread提供了两个方法来判断线程是否终止</p><p>interrupt() 当抛出异常时，会清除中断状态</p><p>static boolean interrupted()：判断当前线程是否中断，清除中断标志。</p><p>boolean isInterrupted()：判断线程是否中断，不清除中断标志。</p><pre><code>Thread.currentThread().interrupt();System.out.println("是否停止1？=" + Thread.interrupted());//true，执行方法后清除了标记System.out.println("是否停止2？=" + Thread.interrupted());//false当调用了interrupted后线程未真正的停止，但已经有了标志状态，也就是说我们可以通过标志状态来对我们的多线程执行的方法进行处理。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FiveThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经是停止状态了!退出!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        FiveThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiveThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>异常法停止线程</p><p>这样虽然可以实现退出for循环，但是在for循环之外的代码依然会被执行，很明显这样没有达到效果，这个时候我们可以抛出异常：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经是停止状态了!退出!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抛出了错误！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然我们也可以使用return方式进行处理，但还是抛出异常处理比较好，可以让线程中断事件得到传播。</p><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>判断的是当前线程是否处于中断状态。是类的静态方法，同时会清除线程的中断状态。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　<span class="token keyword">return</span> <span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h4><p>判断调用线程是否处于中断状态，不清除中断标志。<br>例如:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>　　Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个线程，伪代码没有具体实现</span>　　thread<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断thread是否处于中断状态，而不是主线程是否处于中断状态</span>　　Thread<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//判断主线程是否处于中断状态</span><span class="token punctuation">}</span></code></pre><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>Object.wait（） - 挂起一个线程</li><li>Object.notify（） -唤醒线程</li></ul><p>wait（）方法带有三个重载。</p><h4 id="wait（）"><a href="#wait（）" class="headerlink" title="wait（）"></a>wait（）</h4><ol><li>该wait（）方法导致当前线程无限期地等待，直到另一个线程要么调用notify（）此对象或notifyAll的（） 。</li><li>wait（long timeout）<br> 使用此方法，我们可以指定一个超时，在该超时之后将自动唤醒线程。可以使用notify（）或notifyAll（）在达到超时之前唤醒线程。<br>请注意，调用wait（0）与调用wait（）相同。</li><li>wait（long timeout，int nanos）<br>这是另一个提供相同功能的签名，唯一的区别是这个可以提供更高的精度。<br>总超时时间（以纳秒为单位）计算为1_000_000 *timeout+ nanos。</li></ol><h4 id="notify（）和notifyAll（）"><a href="#notify（）和notifyAll（）" class="headerlink" title="notify（）和notifyAll（）"></a>notify（）和notifyAll（）</h4><p>该notify（）方法用于唤醒正在等待到该对象的监视器接入线程。<br>有两种方法可以通知等待线程。</p><ol><li>notify（）<br>对于在此对象的监视器上等待的所有线程（通过使用任何一个wait（）方法），方法notify（）通知任何一个线程任意唤醒。确切唤醒哪个线程的选择是非确定性的 ，取决于实现。<br>由于notify（）唤醒了一个随机线程，因此它可用于实现线程执行类似任务的互斥锁定，但在大多数情况下，实现notifyAll（）会更可行。</li><li>notifyAll（）<br>此方法只是唤醒正在此对象的监视器上等待的所有线程。<br>唤醒的线程将以通常的方式完成 - 就像任何其他线程一样。<br>但是在我们允许它们继续执行之前，总是要定义快速检查继续执行线程所需的条件 - 因为可能存在某些情况下线程被唤醒而没有收到通知</li></ol><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><ol><li>首先，wait获取对象锁，然后调用wait()方法，此时，<strong>wait线程会放弃对象锁</strong>，同时进入对象的等待队列WaitQueue中;</li><li>notify线程抢占到对象锁，执行一些操作后，调用notify()方法，此时会将等待线程waitThread从等待队列WaitQueue中移到同步队列SynchronizedQueue中，wait由waitting状态变为blocked状态。需要注意的时，<strong>notify此时并不会立即释放锁</strong>，它继续运行，把自己剩余的事儿干完之后才会释放锁;</li><li>wait再次获取到对象锁，从wait()方法返回继续执行后续的操作;</li><li>一个基于等待/通知机制的线程间通信的过程结束。</li></ol><p>至于notifyAll则是在第二步中将等待队列中的所有线程移到同步队列中去。</p><p><strong>避免踩坑</strong></p><p>　　在使用wait/notify/notifyAll时有一些特别留意的，在此再总结一下：</p><ol><li>一定在synchronized中使用wait()/notify()/notifyAll()，也就是说一定要先获取锁，这个前面我们讲过，因为只有加锁后，才能获得监视器。否则jvm也会抛出IllegalMonitorStateException异常。</li><li>使用wait()时，判断线程是否进入wait状态的条件一定要使用while而不要使用if，因为等待线程可能会被错误地唤醒，所以应该使用while循环在等待前等待后都检查唤醒条件是否被满足，保证安全性。</li><li>notify()或notifyAll()方法调用后，线程不会立即释放锁。调用只会将wait中的线程从等待队列移到同步队列，也就是线程状态从waitting变为blocked;</li><li>从wait()方法返回的前提是线程重新获得了调用对象的锁。　　　　　　　　<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3></li></ol><p>停止一个线程的执行有三种办法：</p><ol><li>调用Thread对象的stop()方法，stop()和supend和resume已经被弃用</li><li>interrupt()配合isInterrupt()使用 上面的代码</li><li>使用volatile型共享变量</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 但是使用标志位这种方法有个很大的局限性，那就是通过循环来使每次的操作都需要检查一下标志位。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BestPractice</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ① volatile条件变量</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stopMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ② 发出停止信号</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ③ 检测条件变量</span>            <span class="token comment" spellcheck="true">// do dirty work   // ④业务代码</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="stop不推荐"><a href="#stop不推荐" class="headerlink" title="stop不推荐"></a>stop不推荐</h5><p>不少开发者用过Thread的stop去停止线程，当然此函数确实能停止线程，不过Java官方早已将它废弃，不推荐使用，这是为什么？</p><p>stop是通过立即抛出ThreadDeath异常，来达到停止线程的目的，此异常抛出有可能发生在任何一时间点，包括在catch、finally等语句块中，但是此异常并不会引起程序退出(笔者只测试了Java8)。<br>由于有异常抛出，导致线程会释放全部所持有的锁，极可能引起线程安全问题。</p><p>由于以上2点，stop这种方式停止线程是不安全的。</p><h3 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h3><ol><li><p>存在死锁的可能性 </p></li><li><p>有可能出现数据不一致的情况，因为数据可能被其他运行的线程更改．</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 暂停线程的方式 suspend() 已经不推荐使用这种方式* 恢复暂停线程的方式 resume()*/</span><span class="token keyword">class</span> <span class="token class-name">SuspendThreadTest</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Thread th3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">th</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>th3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     th3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">}</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>th3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"暂停"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 暂停线程</span>     th3<span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">}</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>th3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"恢复执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 恢复暂停线程</span>     th3<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 静态内部类</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">th</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">try</span> <span class="token punctuation">{</span>                 Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抛出异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。</p><p><strong>java的内置锁：</strong> 每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><p>java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p><p><strong>java的对象锁和类锁：</strong> java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的</p><h4 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h4><p>synchronized关键字最主要有以下3种应用方式</p><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h5 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h5><p>当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><ul><li>内存可见性</li><li>留意复合类操作</li><li>解决num++操作的原子性问题</li><li>禁止指令重排序</li></ul><h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>　　volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。同synchronized相比（synchronized通常称为重量级锁），volatile更轻量级，相比使用synchronized所带来的庞大开销，倘若能恰当的合理的使用volatile，自然是美事一桩。</p><p><strong>所谓可见性，是指当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。</strong></p><h4 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h4><p>volatile还有一个特性：禁止指令重排序优化。</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则：</p><ol><li>重排序操作不会对存在数据依赖关系的操作进行重排序。</li></ol><p>　　　　比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><ol start="2"><li>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</li></ol><p>　　　　比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>　　重排序在单线程模式下是一定会保证最终结果的正确性，但是在多线程环境下，问题就出来了</p><p><strong>简单总结下，volatile是一种轻量级的同步机制，它主要有两个特性：一是保证共享变量对所有线程的可见性；二是禁止指令重排序优化。同时需要注意的是，volatile对于单个的共享变量的读/写具有原子性，但是像num++这种复合操作，volatile无法保证其原子性</strong></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><a href="https://www.cnblogs.com/xzwblog/p/7227509.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzwblog/p/7227509.html</a></p><p><a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="noopener">https://www.jianshu.com/p/98b68c97df9b</a></p><p>变量值的共享可以使用public static的形式，所有线程都使用同一个变量，如果想实现每一个线程都有自己的共享变量该如何实现呢？JDK中的ThreadLocal类正是为了解决这样的问题。</p><p>ThreadLocal底层相当于一个map数组，key用来存储当前线程，value用来存储当前线程下共享的数据。它里面有一些方法需要说明一下。</p><ul><li>get()方法用于获取当前线程的副本变量值。</li><li>set()方法用于保存当前线程的副本变量值。</li><li>initialValue()为当前线程初始副本变量值。</li><li>remove()方法移除当前前程的副本变量值。</li></ul><h4 id="ThreadLocal介绍-amp-跳出误区"><a href="#ThreadLocal介绍-amp-跳出误区" class="headerlink" title="ThreadLocal介绍&amp;跳出误区"></a>ThreadLocal介绍&amp;跳出误区</h4><p>　　ThreadLocal一般称为线程本地变量，它是一种特殊的线程绑定机制，将变量与线程绑定在一起，为每一个线程维护一个独立的变量副本。通过ThreadLocal可以将对象的可见范围限制在同一个线程内。</p><p><strong>跳出误区</strong></p><blockquote><p>需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p></blockquote><blockquote><p>没有ThreadLocal的时候，一个线程在其声明周期内，可能穿过多个层级，多个方法，如果有个对象需要在此线程周期内多次调用，且是跨层级的（线程内共享），通常的做法是通过参数进行传递；而ThreadLocal将变量绑定在线程上，在一个线程周期内，无论“你身处何地”，只需通过其提供的get方法就可轻松获取到对象。极大地提高了对于“线程级变量”的访问便利性。</p></blockquote><h4 id="解决第一个get-返回null"><a href="#解决第一个get-返回null" class="headerlink" title="解决第一个get()返回null"></a>解决第一个get()返回null</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">&gt;</span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" threadLocal.get() = "</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyThread myThreadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadA<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"ThreadA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread myThreadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadB<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"ThreadB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>ThreadA threadLocal.get() = 0ThreadB threadLocal.get() = 0ThreadA threadLocal.get() = 1ThreadB threadLocal.get() = 1ThreadA threadLocal.get() = 2ThreadB threadLocal.get() = 2</code></pre><h4 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;根据上面Entry方法的源码，我们知道ThreadLocalMap是使用ThreadLocal的弱引用作为Key的。下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/xc1.png" alt="xc"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value<br>永远无法回收，造成内存泄露。<br>　　<br>&nbsp; &nbsp; &nbsp; &nbsp;ThreadLocalMap设计时的对上面问题的对策：<br>ThreadLocalMap的getEntry函数的流程大概为：</p><p>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (table.length-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；<br>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry。否则，如果key值为null，则擦除该位置的Entry，并继续向下一个位置查询。在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的getEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。<br>关于ThreadLocalMap内部类的简单介绍</p><p><strong>初始容量16，负载因子2/3，解决冲突的方法是再hash法，也就是：在当前hash的基础上再自增一个常量。</strong></p><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p><a href="https://www.cnblogs.com/lucky_dai/p/5498295.html" target="_blank" rel="noopener">https://www.cnblogs.com/lucky_dai/p/5498295.html</a></p><p>从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。</p><p>既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。</p><h4 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h4><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><p>1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p><p>2）线程执行发生异常，此时JVM会让线程自动释放锁。</p><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p><p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p><p>因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><p>1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p><p>2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p><pre class=" language-java"><code class="language-java">通过查看Lock的源码可知，Lock是一个接口<span class="token punctuation">,</span> 位于：<span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取锁，获取不到lock就不罢休,不可被打断,即使当前线程被中断,线程也一直阻塞,直到拿到锁, 比较无赖的做法</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***获取锁，可中断，如果获取锁之前当前线程被interrupt了，*获取锁之后会抛出InterruptedException，并且停止当前线程；*优先响应中断*/</span><span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//立即返回结果；尝试获得锁,如果获得锁立即返回ture,失败立即返回false</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//尝试拿锁，可设置超时时间，超时返回false，即过时不候</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放锁</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回当前线程的Condition ，可多次调用</span>Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><pre class=" language-java"><code class="language-java">Lock lock <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//处理任务</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//释放锁</span><span class="token punctuation">}</span></code></pre><h4 id="Lock接口方法"><a href="#Lock接口方法" class="headerlink" title="Lock接口方法"></a>Lock接口方法</h4><h5 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h5><p>先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><h5 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h5><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//.....</span>    <span class="token punctuation">}</span>    <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><p>因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p><p>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁</p><pre class=" language-java"><code class="language-java">Lock lock <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">try</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//处理任务</span>     <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//释放锁</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果不能获取锁，则直接做其他事情</span><span class="token punctuation">}</span></code></pre><h5 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h5><p>解锁 一旦产生异常，没有解锁就会造成当前无法解锁，其他线程一直等待获取锁，<br>所以：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//处理任务</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span> lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//释放锁</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//如果不能获取锁，则直接做其他事情</span></code></pre><h5 id="newCondition"><a href="#newCondition" class="headerlink" title="newCondition()"></a>newCondition()</h5><pre class=" language-java"><code class="language-java">Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock中除了实现Lock中定义的一些标准函数外，同时提供其他的用于管理锁的public方法：</p><p><strong>默认是非公平锁的</strong></p><p><strong>ReentrantLock锁是完全排他锁,同一时间只有一个线程能执行lock.lock()和lock.unlock()之间的代码.</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//传入boolean值,true时create一个公平锁，false为非公平锁</span><span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//查看有多少线程等待锁</span><span class="token keyword">int</span> <span class="token function">getQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//是否有线程等待抢锁</span><span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//是否有指定线程等待抢锁</span><span class="token keyword">boolean</span> <span class="token function">hasQueuedThread</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//当前线程是否抢到锁。返回0代表没有</span><span class="token keyword">int</span> <span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//查询此锁是否由任何线程持有</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//是否为公平锁</span><span class="token keyword">boolean</span> <span class="token function">isFair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </code></pre><h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>ReentrantLock中另一个重要的应用就是Condition，Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒，而且在粒度和性能上都优于Object的通信方法（wait、notify 和 notifyAll）；</p><p>Condition 接口的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    *Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，    *允许中断如果在阻塞时锁持有线程中断，会抛出异常；    *重要一点是：在当前持有Lock的线程中，当外部调用会await()后，    *ReentrantLock就允许其他线程来抢夺锁当前锁，    *注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁    */</span>    <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span>    <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span>    <span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span>    <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//类似await(long time, TimeUnit unit) </span>    <span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span>Date deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//唤醒指定线程</span>    <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//唤醒全部线程</span>    <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>ReentrantLock.Condition的线程通信：</strong><br>ReentrantLock.Condition是在粒度和性能上都优于Object的notify()、wait()、notifyAll()线程通信的方式。</p><p>Condition中通信方法相对Object的通信在粒度上是粒度更细化，表现在一个Lock对象上引入多个Condition监视器、通信方法中除了和Object对应的三个基本函数外，更是新增了线程中断、阻塞超时的函数；<br>Condition中通信方法相对Object的通信在性能上更高效，性能的优化表现在ReentrantLock比较synchronized的优化 ；</p><blockquote><p>ReentrantLock.Condition线程通信注意点：<br>1.使用<strong>ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作</strong>[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；<br>2.注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;</p></blockquote><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>概述</p><p>&nbsp; &nbsp; &nbsp; &nbsp;ReentrantReadWriteLock是Lock的另一种实现方式，ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><strong>ReentrantReadWriteLock支持以下功能：</strong></p><p>　　　　1）支持公平和非公平的获取锁的方式；</p><p>　　　　2）支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</p><p>　　　　3）还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</p><p>　　　　4）读取锁和写入锁都支持锁获取期间的中断；</p><p>　　　　5）Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </p><h4 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h4><p>总结来说，Lock和synchronized有以下几点不同：</p><p>1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>1.可重入性<br>ReentrantLock和synchronized都具有可重入性，写代码synchronized更简单，ReentrantLock需要将lock()和unlock()进行一一对应否则有死锁的风险；</p><p>2.锁的实现方式<br>Synchronized作为Java关键字是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p><p>3.公平性<br>ReentrantLock提供了公平锁和非公平锁两种API，开发人员完全可以根据应用场景选择锁的公平性；<br>synchronized是作为Java关键字是依赖于JVM实现，Java团队应该是优先考虑性能问题，因此synchronized是非公平锁。</p><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h4 id="ReentrantLock实际开发中的应用场景"><a href="#ReentrantLock实际开发中的应用场景" class="headerlink" title="ReentrantLock实际开发中的应用场景"></a>ReentrantLock实际开发中的应用场景</h4><ol><li><p>公平锁，线程排序执行，防饿死应用场景；<br>公平锁原则必须按照锁申请时间上先到先得的原则分配机制场景；</p><p> 1）. 实现逻辑 上(包括：软件中函数计算、业务先后流程；硬件中操作实现中顺序逻辑)的顺序排队机制的场景；<br> 软件场景：用户交互View中对用户输入结果分析类，分析过程后面算法依赖上一步结果的场景，例如：推荐算法实现[根据性别、年龄筛选]、阻塞队列的实现；<br> 硬件场景：需要先分析确认用户操作类型硬件版本或者厂家，然后发出操作指令；例如：自动售货机；</p><p> 2）.现实 生活中 时间排序的 公平原则：例如：客服分配，必须是先到先服务，不能出现饿死现象；</p></li><li><p>非公平锁,效率的体现者；<br>实际开发中最常用的的场景就是非公平锁，ReentrantLock无参构造默认就时候非公平锁；<br>适应场景除了上面公平锁中提到的其他都是非公平锁的使用场景；</p></li></ol><ol start="3"><li>ReentrantLock.Condition线程通信<br>ReentrantLock.Condition线程通信是最长见的面试题，这里以最简单例子：两个线程之间交替打印 26英文字母和阿拉伯数字为demo：</li></ol><pre><code>private void alternateTask() {    ReentrantLock lock = new ReentrantLock();    Condition condition1 = lock.newCondition();    Condition condition2 = lock.newCondition();    Thread thread1 = new Thread(() -&gt; {        try {            lock.lock();            for (int i = 65; i &lt; 91; i++) {                System.out.println("----------thread1------- " + (char) i);                condition2.signal();                condition1.await();            }            condition2.signal();        } catch (Exception e) {        } finally {            lock.unlock();        }    });    Thread thread2 = new Thread(() -&gt; {        try {            lock.lock();            for (int i = 0; i &lt; 26; i++) {                System.out.println("----------thread2------- " + i);                condition1.signal();                condition2.await();            }            condition1.signal();        } catch (Exception e) {        } finally {            lock.unlock();        }    });    thread1.start();    thread2.start();}</code></pre><p>4.同步功能的使用<br>实现线程同步锁synchronized 功能【单例为例】</p><pre><code>private Singleton() {}private static Singleton instance;private static Lock lock = new ReentrantLock();public static Singleton getInstance() {    lock.lock();    try {        if (instance == null) {            instance = new Singleton();        }    } finally {        lock.unlock();    }    return instance;}</code></pre><p>6.中断杀器应用<br>ReentrantLock中lockInterruptibly()和lock()最大的区别就是中断相应问题：<br>lock()是支持中断相应的阻塞试的获取方式，因此即使主动中断了锁的持有者，但是它不能立即unlock(),仍然要机械版执行完所有操作才会释放锁。<br>lockInterruptibly()是 优先响应中断的，这样有个优势就是可以通过tryLock()、tryLock(timeout, TimeUnit.SECONDS)方法，中断优先级低的Task，及时释放资源给优先级更高的Task，甚至看到网上有人说可以做防止死锁的优化；</p><p>实例代码：</p><pre><code>ReentrantLock lock = new ReentrantLock();    try {        lock.lockInterruptibly();        if (lock.tryLock(timeout, TimeUnit.SECONDS)) {            //TODO        }else{            //超时直接中断优先级低的Task            Thread.currentThread().interrupt();            lock.lock();            //TODO        }    } catch (InterruptedException e) {        e.printStackTrace();    } finally {</code></pre><p>7.非重要任务Lock使用<br>优先级较低的操作让步给优先级更高的操作，提示代码效率/用户体验；<br>忽略重复触发<br>1）.用在定时任务时，如果任务执行时间可能超过下次计划执行时间，确保该有状态任务只有一个正在执行，忽略重复触发。<br>2）.用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）。<br>以上两种情况多用于进行非重要任务防止重复执行，（如：清除无用临时文件，检查某些资源的可用性，数据备份操作等）<br>tryLock()功能：如果已经获得锁立即返回fale，起到防止重复而忽略的效果</p><pre><code>ReentrantLock lock = new ReentrantLock();//防止重复执行，执行耗时操作，例如用户重复点击if (lock.tryLock()) {   try {    //TO DO   } finally {     lock.unlock();   }}</code></pre><p>超时放弃<br>定时操作的例如：错误日志、定时过期缓存清理的操作，遇到优先级更高的操作占用资源时，暂时放弃本次操作下次再处理，可以起到让出CPU，提升用户体验；</p><pre><code>ReentrantLock lock = new ReentrantLock();try {    if (lock.tryLock(timeout, TimeUnit.SECONDS)) {        //TO DO    }} catch (InterruptedException e) {    e.printStackTrace();} finally {    lock.unlock();}</code></pre><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p><strong>公平锁：</strong> 是指多个线程竞争同一资源时[等待同一个锁时]，获取资源的顺序是按照申请锁的先后顺序的；公平锁保障了多线程下各线程获取锁的顺序，先到的线程优先获取锁，有点像早年买火车票一样排队早的人先买到火车票；<br>基本特点： 线程执行会严格按照顺序执行，等待锁的线程不会饿死，但 整体效率相对比较低；</p><p><strong>非公平锁：</strong> 是指多个线程竞争同一资源时，获取资源的顺序是不确定的，一般是抢占式的；非公平锁相对公平锁是增加了获取资源的不确定性，但是整体效率得以提升；<br>基本特点： 整体效率高，线程等待时间片具有不确定性；</p><p>公平锁与非公平锁的测试demo：<br>重入锁ReentrantLock实现公平锁和非公平锁很简单的，因为ReentrantLock构造函数中可以直接传入一个boolean值fair，对公平性进行设置。当fair为true时，表示此锁是公平的，当fair为false时，表示此锁是非公平的锁；<br>来个简单的demo；</p><pre><code>public static void main(String[] args) {    ExecutorService threadPool = Executors.newCachedThreadPool();    ReentrantLock fairLock = new ReentrantLock(true);    ReentrantLock unFairLock = new ReentrantLock();    for (int i = 0; i &lt; 10; i++) {        threadPool.submit(new TestThread(fairLock,i," fairLock"));        threadPool.submit(new TestThread(unFairLock, i, "unFairLock"));    }}</code></pre><h3 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h3><p><a href="https://www.cnblogs.com/liun1994/p/7396026.html" target="_blank" rel="noopener">https://www.cnblogs.com/liun1994/p/7396026.html</a></p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><a href="https://segmentfault.com/a/1190000014741369" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014741369</a><br><a href="https://blog.csdn.net/u013541140/article/details/95225769" target="_blank" rel="noopener">https://blog.csdn.net/u013541140/article/details/95225769</a></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc30.png" alt=""></p><h4 id="1-线程池的优势"><a href="#1-线程池的优势" class="headerlink" title="1 线程池的优势"></a>1 线程池的优势</h4><p>总体来说，线程池有如下的优势：</p><p>（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>（2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>（3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h3 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h3><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）</p><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><ul><li>线程池作用就是限制系统中执行线程的数量。 </li><li>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果。 </li><li>少了浪费了系统资源，多了造成系统拥挤效率不高。 </li><li>用线程池控制线程数量，其他线程排 队等候。 </li><li>一个任务执行完毕，再从队列的中取最前面的任务开始执行。 </li><li>若队列中没有等待进程，线程池的这一资源处于等待。 </li><li>当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。 </li></ul><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a>为什么要用线程池?</h3><ol><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 </li><li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<br>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 </li></ol><h3 id="比较重要的几个类"><a href="#比较重要的几个类" class="headerlink" title="比较重要的几个类"></a>比较重要的几个类</h3><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>ExecutorService</td><td>真正的线程池接口。</td></tr><tr><td>ScheduledExecutorService</td><td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td></tr><tr><td>ThreadPoolExecutor</td><td>ExecutorService的默认实现。</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td></tr></tbody></table><h3 id="Executor和Executors的区别？"><a href="#Executor和Executors的区别？" class="headerlink" title="Executor和Executors的区别？"></a>Executor和Executors的区别？</h3><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 </p><p>Executor 接口对象能执行我们的线程任务。 </p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p><p>使用ThreadPoolExecutor 可以创建自定义线程池。 </p><p>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。</p><h3 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h3><pre><code>public class TestNewThread {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println("start");            }        }).start();    }}</code></pre><p>执行一个异步任务你还只是如下new Thread吗？ </p><p>那你就out太多了，new Thread的弊端如下： </p><ol><li>每次new Thread新建对象性能差。 </li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li><li>缺乏更多功能，如定时执行、定期执行、线程中断。 </li></ol><p>相比new Thread，Java提供的四种线程池的好处在于： </p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 </li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h3 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h3><p>Java通过Executors提供四种线程池，分别为： </p><ol><li>newCachedThreadPoo<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </li><li>newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 </li><li>newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。 </li><li>newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><h3 id="Executors创建线程池"><a href="#Executors创建线程池" class="headerlink" title="Executors创建线程池"></a>Executors创建线程池</h3><p>Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可，比如Executors.newFixedThreadPool(int nThreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。</p><h4 id="线程池中的几种重要的参数"><a href="#线程池中的几种重要的参数" class="headerlink" title="线程池中的几种重要的参数"></a>线程池中的几种重要的参数</h4><p>corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收</p><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p><p>keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，</p><p>util，就是计算这个时间的一个单位。</p><p>workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。</p><p>threadFactory，就是创建线程的线程工厂。</p><p>handler,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</p><p>Executors创建线程池便捷方法列表：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>newFixedThreadPool(int nThreads)</td><td>创建固定大小的线程池</td></tr><tr><td>newSingleThreadExecutor()</td><td>创建只有一个线程的线程池</td></tr><tr><td>newCachedThreadPool()</td><td>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</td></tr></tbody></table><p><strong>小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用ThreadPoolExecutor的构造方法。没错，上述Executors方法创建的线程池就是ThreadPoolExecutor。</strong></p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法（定时任务使用的是ScheduledThreadPoolExecutor），该类构造方法参数列表如下：</p><pre><code>// Java线程池的完整构造函数public ThreadPoolExecutor(  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。  int maximumPoolSize, // 线程数的上限  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，                                     // 超过这个时间，多余的线程会被回收。  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列  ThreadFactory threadFactory, // 新线程的产生方式  RejectedExecutionHandler handler) // 拒绝策略</code></pre><p>竟然有7个参数，很无奈，构造一个线程池确实需要这么多参数。这些参数中，比较容易引起问题的有corePoolSize, maximumPoolSize, workQueue以及handler：</p><p>corePoolSize和maximumPoolSize设置不当会影响效率，甚至耗尽线程；<br>workQueue设置不当容易导致OOM；<br>handler设置不当会导致提交任务时抛出异常。<br>正确的参数设置方式会在下文给出。</p><p>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略</p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>当队列满时，此时便是饱和策略发挥作用的时候了，JDK中定义了四种饱和策略：</p><p>1、AbortPolicy：终止策略是默认的饱和策略，当队列满时，会抛出一个RejectExecutionException异常（第一段代码就是例子），客户可以捕获这个异常，根据需求编写自己的处理代码</p><p>2、DiscardPolicy：策略会悄悄抛弃该任务。</p><p>3、DiscardOldestPolicy：策略将会抛弃下一个将要执行的任务，如果此策略配合优先队列PriorityBlockingQueue，该策略将会抛弃优先级最高的任务</p><p>4、CallerRunsPolicy：调用者运行策略，该策略不会抛出异常，不会抛弃任务，而是将任务回退给调用者线程执行（调用execute方法的线程），由于任务需要执行一段时间，所以在此期间不能提交任务，从而使工作线程有时间执行正在执行的任务。</p><h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p><h4 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h4><p>可以向线程池提交的任务有两种：Runnable和Callable，二者的区别如下：</p><ol><li>方法签名不同，void Runnable.run(), V Callable.call() throws Exception</li><li>是否允许有返回值，Callable允许有返回值</li><li>是否允许抛出异常，Callable允许抛出异常。</li></ol><p>Callable是JDK1.5时加入的接口，作为Runnable的一种补充，允许有返回值，允许抛出异常。</p><p>三种提交任务的方式：<br>提交方式 |    是否关心返回结果<br>—|—<br>Future<t> submit(Callable<t> task) |    是<br>void execute(Runnable command) |    否<br>Future&lt;?&gt; submit(Runnable task)    | 否，虽然返回Future，但是其get()方法总是返回null</t></t></p><h4 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a>线程池都有哪几种工作队列</h4><p>1、ArrayBlockingQueue</p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、LinkedBlockingQueue</p><p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p><p>3、SynchronousQueue</p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、PriorityBlockingQueue</p><p>一个具有优先级的无限阻塞队列。</p><h3 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h3><p><strong>避免使用无界队列</strong></p><p>不要使用Executors.newXXXThreadPool()快捷方法创建线程池，因为这种方式会使用无界的任务队列，为避免OOM，我们应该使用ThreadPoolExecutor的构造方法手动指定队列的最大长度：</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512), // 使用有界队列，避免OOM                new ThreadPoolExecutor.DiscardPolicy());</code></pre><p>明确拒绝任务时的行为<br>任务队列总有占满的时候，这是再submit()提交新的任务会怎么样呢？RejectedExecutionHandler接口为我们提供了控制方式，接口定义如下：</p><pre><code>public interface RejectedExecutionHandler {    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);}</code></pre><table><thead><tr><th>拒绝策略</th><th>拒绝行为</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>抛出RejectedExecutionException</td></tr><tr><td>DiscardPolicy</td><td>什么也不做，直接忽略</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置</td></tr><tr><td>CallerRunsPolicy</td><td>直接由提交任务者执行这个任务</td></tr></tbody></table><p>线程池默认的拒绝行为是AbortPolicy，也就是抛出RejectedExecutionHandler异常，该异常是非受检异常，很容易忘记捕获。如果不关心任务被拒绝的事件，可以将拒绝策略设置成DiscardPolicy，这样多余的任务会悄悄的被忽略。</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512),                 new ThreadPoolExecutor.DiscardPolicy());// 指定拒绝策略</code></pre><h3 id="submit-和execute-的以及shutdown-和shutdownNow-的区别"><a href="#submit-和execute-的以及shutdown-和shutdownNow-的区别" class="headerlink" title="submit()和execute()的以及shutdown()和shutdownNow()的区别"></a>submit()和execute()的以及shutdown()和shutdownNow()的区别</h3><ul><li>submit()，提交一个线程任务，可以接受回调函数的返回值吗，适用于需要处理返回着或者异常的业务场景 </li><li>execute()，执行一个任务，没有返回值 </li><li>shutdown()，表示不再接受新任务，但不会强行终止已经提交或者正在执行中的任务 </li><li>shutdownNow()，对于尚未执行的任务全部取消，正在执行的任务全部发出interrupt()，停止执行 </li></ul><h3 id="五种线程池的适应场景"><a href="#五种线程池的适应场景" class="headerlink" title="五种线程池的适应场景"></a>五种线程池的适应场景</h3><ul><li>newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于服务器负载较轻，执行很多短期异步任务。 </li><li>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于可以预测线程数量的业务中，或者服务器负载较重，对当前线程数量进行限制。 </li><li>newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。 </li><li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。 </li><li>newWorkStealingPool：创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，适用于大耗时的操作，可以并行来执行</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池队列</title>
      <link href="/2019/10/21/2019-06-16-xian-cheng-chi-dui-lie/"/>
      <url>/2019/10/21/2019-06-16-xian-cheng-chi-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构</p><p>Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口。</p><h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>Java中对于队列的实现分为非阻塞和阻塞两种。</p><h4 id="非阻塞队列分为如下："><a href="#非阻塞队列分为如下：" class="headerlink" title="非阻塞队列分为如下："></a>非阻塞队列分为如下：</h4><ul><li>LinkedList</li></ul><p>LinkedList是双相链表结构，在添加和删除元素时具有比ArrayList更好的性能。但在 Get 与 Set 方面弱于ArrayList。当然，这些对比都是指数据量很大或者操作很频繁的情况下的对比。</p><ul><li>PriorityQueue</li></ul><p>PriorityQueue维护了一个有序列表，存储到队列中的元素会按照自然顺序排列。当然，我们也可以给它指定一个实现了 java.util.Comparator 接口的排序类来指定元素排列的顺序。</p><ul><li>ConcurrentLinkedQueue</li></ul><p>ConcurrentLinkedQueue 是基于链接节点的并且线程安全的队列。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大小 ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。</p><h4 id="阻塞队列分为如下："><a href="#阻塞队列分为如下：" class="headerlink" title="阻塞队列分为如下："></a>阻塞队列分为如下：</h4><p>阻塞队列定义在了java.util.concurrent包中，java.util.concurrent.BlockingQueue 继承了Queue接口，它有 5 个实现类，分别是：</p><ul><li>ArrayBlockingQueue </li></ul><p>一个内部由数组支持的有界队列。初始化时必须指定队列的容量，还可以设置内部的ReentrantLock是否使用公平锁。但是公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>它的思想就是如果BlockQueue是空的，那么从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒。同样,如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间才会被唤醒继续操作。</p><ul><li>LinkedBlockingQueue </li></ul><p>一个内部由链接节点支持的可选有界队列。初始化时不需要指定队列的容量，默认是Integer.MAX_VALUE，也可以看成容量无限大。此队列按 FIFO（先进先出）排序元素 。</p><ul><li>PriorityBlockingQueue </li></ul><p>一个内部由优先级堆支持的无界优先级队列。PriorityBlockingQueue是对 PriorityQueue的再次包装，队列中的元素按优先级顺序被移除。</p><ul><li>DelayQueue </li></ul><p>一个内部由优先级堆支持的、基于时间的调度队列。队列中存放Delayed元素，只有在延迟期满后才能从队列中提取元素。当一个元素的getDelay()方法返回值小于等于0时才能从队列中poll中元素，否则poll()方法会返回null。　　</p><ul><li>SynchronousQueue </li></ul><p>一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。</p><h4 id="队列常用方法"><a href="#队列常用方法" class="headerlink" title="队列常用方法"></a>队列常用方法</h4><p>add　　　　添加一个元素　　　　　　　　如果队列已满，抛出一个IllegalStateException（“Queue full”）异常</p><p>offer　　　  添加一个元素并返回true　　    如果队列已满，则返回false</p><p>put　　　　添加一个元素　　　　　　　　 如果队列已满，则阻塞</p><p>remove　　 移除并返回队列头部的元素　　如果队列为空，则抛出一个NoSuchElementException异常</p><p>element　　返回队列头部的元素　　　　　如果队列为空，则抛出一个NoSuchElementException异常</p><p>take　　　　移除并返回队列头部的元素　　如果队列为空，则阻塞　　</p><p>peek　　　  返回队列头部的元素　　　　   如果队列为空，则返回null</p><p>poll　　　　移除并返回队列头部的元素　　如果队列为空，则返回null</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><a href="https://www.cnblogs.com/CarpenterLee/p/9558026.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/9558026.html</a><br><a href="https://blog.csdn.net/achuo/article/details/80623893" target="_blank" rel="noopener">https://blog.csdn.net/achuo/article/details/80623893</a></p><h3 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h3><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>如果每个请求都创建一个线程去处理，那么服务器的资源很快就会被耗尽，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><h3 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h3><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）</p><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><ul><li>线程池作用就是限制系统中执行线程的数量。 </li><li>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果。 </li><li>少了浪费了系统资源，多了造成系统拥挤效率不高。 </li><li>用线程池控制线程数量，其他线程排 队等候。 </li><li>一个任务执行完毕，再从队列的中取最前面的任务开始执行。 </li><li>若队列中没有等待进程，线程池的这一资源处于等待。 </li><li>当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。 </li></ul><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a>为什么要用线程池?</h3><ol><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 </li><li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<br>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 </li></ol><h3 id="比较重要的几个类"><a href="#比较重要的几个类" class="headerlink" title="比较重要的几个类"></a>比较重要的几个类</h3><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>ExecutorService</td><td>真正的线程池接口。</td></tr><tr><td>ScheduledExecutorService</td><td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td></tr><tr><td>ThreadPoolExecutor</td><td>ExecutorService的默认实现。</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td></tr></tbody></table><h3 id="Executor和Executors的区别？"><a href="#Executor和Executors的区别？" class="headerlink" title="Executor和Executors的区别？"></a>Executor和Executors的区别？</h3><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 </p><p>Executor 接口对象能执行我们的线程任务。 </p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p><p>使用ThreadPoolExecutor 可以创建自定义线程池。 </p><p>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。</p><h3 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h3><pre><code>public class TestNewThread {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println("start");            }        }).start();    }}</code></pre><p>执行一个异步任务你还只是如下new Thread吗？ </p><p>那你就out太多了，new Thread的弊端如下： </p><ol><li>每次new Thread新建对象性能差。 </li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li><li>缺乏更多功能，如定时执行、定期执行、线程中断。 </li></ol><p>相比new Thread，Java提供的四种线程池的好处在于： </p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 </li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h3 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h3><p>Java通过Executors提供四种线程池，分别为： </p><ol><li>newCachedThreadPoo<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </li><li>newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 </li><li>newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。 </li><li>newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><h3 id="Executors创建线程池"><a href="#Executors创建线程池" class="headerlink" title="Executors创建线程池"></a>Executors创建线程池</h3><p>Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可，比如Executors.newFixedThreadPool(int nThreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。</p><h4 id="线程池中的几种重要的参数"><a href="#线程池中的几种重要的参数" class="headerlink" title="线程池中的几种重要的参数"></a>线程池中的几种重要的参数</h4><p>corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收</p><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p><p>keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，</p><p>util，就是计算这个时间的一个单位。</p><p>workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。</p><p>threadFactory，就是创建线程的线程工厂。</p><p>handler,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</p><p>Executors创建线程池便捷方法列表：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>newFixedThreadPool(int nThreads)</td><td>创建固定大小的线程池</td></tr><tr><td>newSingleThreadExecutor()</td><td>创建只有一个线程的线程池</td></tr><tr><td>newCachedThreadPool()</td><td>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</td></tr></tbody></table><p><strong>小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用ThreadPoolExecutor的构造方法。没错，上述Executors方法创建的线程池就是ThreadPoolExecutor。</strong></p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法（定时任务使用的是ScheduledThreadPoolExecutor），该类构造方法参数列表如下：</p><pre><code>// Java线程池的完整构造函数public ThreadPoolExecutor(  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。  int maximumPoolSize, // 线程数的上限  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，                                     // 超过这个时间，多余的线程会被回收。  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列  ThreadFactory threadFactory, // 新线程的产生方式  RejectedExecutionHandler handler) // 拒绝策略</code></pre><p>竟然有7个参数，很无奈，构造一个线程池确实需要这么多参数。这些参数中，比较容易引起问题的有corePoolSize, maximumPoolSize, workQueue以及handler：</p><p>corePoolSize和maximumPoolSize设置不当会影响效率，甚至耗尽线程；<br>workQueue设置不当容易导致OOM；<br>handler设置不当会导致提交任务时抛出异常。<br>正确的参数设置方式会在下文给出。</p><p>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略</p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>当队列满时，此时便是饱和策略发挥作用的时候了，JDK中定义了四种饱和策略：</p><p>1、AbortPolicy：终止策略是默认的饱和策略，当队列满时，会抛出一个RejectExecutionException异常（第一段代码就是例子），客户可以捕获这个异常，根据需求编写自己的处理代码</p><p>AbortPolicy（中止策略）</p><pre><code>    public static class AbortPolicy implements RejectedExecutionHandler {        public AbortPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            throw new RejectedExecutionException("Task " + r.toString() +                                                 " rejected from " +                                                 e.toString());        }    }</code></pre><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程<br>使用场景：这个就没有特殊的场景了，但是一点要正确处理抛出的异常。ThreadPoolExecutor 中默认的策略就是AbortPolicy，ExecutorService 接口的系列 ThreadPoolExecutor 因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService 中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><p>2、DiscardPolicy：策略会悄悄抛弃该任务。</p><p>DiscardPolicy（丢弃策略）</p><pre><code>    public static class DiscardPolicy implements RejectedExecutionHandler {        public DiscardPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        }    }</code></pre><p>功能：直接静悄悄的丢弃这个任务，不触发任何动作<br>使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了</p><p>3、DiscardOldestPolicy：策略将会抛弃下一个将要执行的任务，如果此策略配合优先队列PriorityBlockingQueue，该策略将会抛弃优先级最高的任务</p><p>DiscardOldestPolicy（弃老策略）</p><pre><code>    public static class DiscardOldestPolicy implements RejectedExecutionHandler {        public DiscardOldestPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            if (!e.isShutdown()) {                e.getQueue().poll();                e.execute(r);            }        }    }</code></pre><p>功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行<br>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，我能想到的场景就是，发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较</p><p>4、CallerRunsPolicy：调用者运行策略，该策略不会抛出异常，不会抛弃任务，而是将任务回退给调用者线程执行（调用execute方法的线程），由于任务需要执行一段时间，所以在此期间不能提交任务，从而使工作线程有时间执行正在执行的任务。</p><p>CallerRunsPolicy（调用者运行策略）</p><pre><code>    public static class CallerRunsPolicy implements RejectedExecutionHandler {        public CallerRunsPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            if (!e.isShutdown()) {                r.run();            }        }    }</code></pre><p>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。<br>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程<br>使用场景：这个就没有特殊的场景了，但是一点要正确处理抛出的异常。ThreadPoolExecutor 中默认的策略就是AbortPolicy，ExecutorService 接口的系列 ThreadPoolExecutor 因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService 中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p><h4 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h4><p>可以向线程池提交的任务有两种：Runnable和Callable，二者的区别如下：</p><ol><li>方法签名不同，void Runnable.run(), V Callable.call() throws Exception</li><li>是否允许有返回值，Callable允许有返回值</li><li>是否允许抛出异常，Callable允许抛出异常。</li></ol><p>Callable是JDK1.5时加入的接口，作为Runnable的一种补充，允许有返回值，允许抛出异常。</p><p>三种提交任务的方式：<br>提交方式 |    是否关心返回结果<br>—|—<br>Future<t> submit(Callable<t> task) |    是<br>void execute(Runnable command) |    否<br>Future&lt;?&gt; submit(Runnable task)    | 否，虽然返回Future，但是其get()方法总是返回null</t></t></p><h4 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a>线程池都有哪几种工作队列</h4><p>1、ArrayBlockingQueue</p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、LinkedBlockingQueue</p><p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p><p>3、SynchronousQueue</p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、PriorityBlockingQueue</p><p>一个具有优先级的无限阻塞队列。</p><h3 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h3><p><strong>避免使用无界队列</strong></p><p>不要使用Executors.newXXXThreadPool()快捷方法创建线程池，因为这种方式会使用无界的任务队列，为避免OOM，我们应该使用ThreadPoolExecutor的构造方法手动指定队列的最大长度：</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512), // 使用有界队列，避免OOM                new ThreadPoolExecutor.DiscardPolicy());</code></pre><p>明确拒绝任务时的行为<br>任务队列总有占满的时候，这是再submit()提交新的任务会怎么样呢？RejectedExecutionHandler接口为我们提供了控制方式，接口定义如下：</p><pre><code>public interface RejectedExecutionHandler {    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);}</code></pre><table><thead><tr><th>拒绝策略</th><th>拒绝行为</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>抛出RejectedExecutionException</td></tr><tr><td>DiscardPolicy</td><td>什么也不做，直接忽略</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置</td></tr><tr><td>CallerRunsPolicy</td><td>直接由提交任务者执行这个任务</td></tr></tbody></table><p>线程池默认的拒绝行为是AbortPolicy，也就是抛出RejectedExecutionHandler异常，该异常是非受检异常，很容易忘记捕获。如果不关心任务被拒绝的事件，可以将拒绝策略设置成DiscardPolicy，这样多余的任务会悄悄的被忽略。</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512),                 new ThreadPoolExecutor.DiscardPolicy());// 指定拒绝策略</code></pre><h3 id="submit-和execute-的以及shutdown-和shutdownNow-的区别"><a href="#submit-和execute-的以及shutdown-和shutdownNow-的区别" class="headerlink" title="submit()和execute()的以及shutdown()和shutdownNow()的区别"></a>submit()和execute()的以及shutdown()和shutdownNow()的区别</h3><ul><li>submit()，提交一个线程任务，可以接受回调函数的返回值吗，适用于需要处理返回着或者异常的业务场景 </li><li>execute()，执行一个任务，没有返回值 </li><li>shutdown()，表示不再接受新任务，但不会强行终止已经提交或者正在执行中的任务 </li><li>shutdownNow()，对于尚未执行的任务全部取消，正在执行的任务全部发出interrupt()，停止执行 </li></ul><h3 id="五种线程池的适应场景"><a href="#五种线程池的适应场景" class="headerlink" title="五种线程池的适应场景"></a>五种线程池的适应场景</h3><ul><li>newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于服务器负载较轻，执行很多短期异步任务。 </li><li>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于可以预测线程数量的业务中，或者服务器负载较重，对当前线程数量进行限制。 </li><li>newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。 </li><li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。 </li><li>newWorkStealingPool：创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，适用于大耗时的操作，可以并行来执行</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 线程池队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引</title>
      <link href="/2019/10/21/2019-06-16-mysql-suo-yin/"/>
      <url>/2019/10/21/2019-06-16-mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<p>看了很多关于索引的博客，讲的大同小异。但是始终没有让我明白关于索引的一些概念，如B-Tree索引，Hash索引，唯一索引….或许有很多人和我一样，没搞清楚概念就开始研究B-Tree，B+Tree等结构，导致在面试的时候答非所问！</p><h3 id="一、索引是什么"><a href="#一、索引是什么" class="headerlink" title="一、索引是什么?"></a>一、索引是什么?</h3><p>索引是帮助MySQL高效获取数据的数据结构。</p><h3 id="二、索引能干什么"><a href="#二、索引能干什么" class="headerlink" title="二、索引能干什么?"></a>二、索引能干什么?</h3><p>索引非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。 索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。</p><h3 id="三、索引的分类"><a href="#三、索引的分类" class="headerlink" title="三、索引的分类?"></a>三、索引的分类?</h3><p>1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，</p><p>2、从应用层次来分：普通索引，唯一索引，复合索引</p><p>3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</p><p>平时讲的索引类型一般是指在应用层次的划分。</p><p>就像手机分类：安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。</p><p><strong>普通索引**</strong>：**即一个索引只包含单个列，一个表可以有多个单列索引</p><p><strong>唯一索引</strong>：****索引列的值必须唯一，但允许有空值</p><p><strong>复合索引</strong>：****多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p><p><strong>聚簇索引(聚集索引)</strong>：****并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</p><p><strong>非聚簇索引</strong>：****不是聚簇索引，就是非聚簇索引</p><h3 id="四、索引的底层实现"><a href="#四、索引的底层实现" class="headerlink" title="四、索引的底层实现"></a>四、索引的底层实现</h3><p>mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</p><blockquote><p>不谈存储引擎，只讨论实现(抽象)</p></blockquote><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql1.png" alt=""></p><h4 id="B-Tree索引（MySQL使用B-Tree）"><a href="#B-Tree索引（MySQL使用B-Tree）" class="headerlink" title="B-Tree索引（MySQL使用B+Tree）"></a>B-Tree索引（MySQL使用B+Tree）</h4><p>B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql2.png" alt=""></p><p>B+Tree索引</p><p>是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql3.png" alt=""></p><blockquote><p>结合存储引擎来讨论（一般默认使用B+Tree）</p></blockquote><p>案例：假设有一张学生表，id为主键</p><table><thead><tr><th>id</th><th>name</th><th>birthday</th></tr></thead><tbody><tr><td>1</td><td>Tom</td><td>1996-01-01</td></tr><tr><td>2</td><td>Jann</td><td>1996-01-04</td></tr><tr><td>3</td><td>Ray</td><td>1996-01-08</td></tr><tr><td>4</td><td>Michael</td><td>1996-01-10</td></tr><tr><td>5</td><td>Jack</td><td>1996-01-13</td></tr><tr><td>6</td><td>Steven</td><td>1996-01-23</td></tr><tr><td>7</td><td>Lily</td><td>1996-01-25</td></tr></tbody></table><p><strong>在MyISAM引擎中的实现</strong>（二级索引也是这样实现的）</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql4.jpg" alt=""></p><p>在InnoDB中的实现</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql5.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql6.jpg" alt=""></p><h3 id="五、为什么索引结构默认使用B-Tree，而不是Hash，二叉树，红黑树？"><a href="#五、为什么索引结构默认使用B-Tree，而不是Hash，二叉树，红黑树？" class="headerlink" title="五、为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？"></a>五、为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？</h3><p>B+tree：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p><p>Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。</p><p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p><p>红黑树：树的高度随着数据量增加而增加，IO代价高。</p><h3 id="六、为什么官方建议使用自增长主键作为索引？"><a href="#六、为什么官方建议使用自增长主键作为索引？" class="headerlink" title="六、为什么官方建议使用自增长主键作为索引？"></a>六、为什么官方建议使用自增长主键作为索引？</h3><p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。</p><p>插入连续的数据：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql7.gif" alt=""></p><p>插入非连续的数据</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql8.gif" alt=""></p><h3 id="七、简单总结下"><a href="#七、简单总结下" class="headerlink" title="七、简单总结下"></a>七、简单总结下</h3><p>1、MySQL使用B+Tree作为索引数据结构。 2、B+Tree在新增数据时，会根据索引指定列的值对旧的B+Tree做调整。 4、从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。 5、影响MySQL查找性能的主要还是磁盘IO次数，大部分是磁头移动到指定磁道的时间花费。 6、MyISAM存储引擎下索引和数据存储是分离的，InnoDB索引和数据存储在一起。 7、InnoDB存储引擎下索引的实现，(辅助索引)全部是依赖于主索引建立的(辅助索引中叶子结点存储的并不是数据的地址，还是主索引的值，因此，所有依赖于辅助索引的都是先根据辅助索引查到主索引，再根据主索引查数据的地址)。 8、由于InnoDB索引的特性，因此如果主索引不是自增的(id作主键)，那么每次插入新的数据，都很可能对B+Tree的主索引进行重整，影响性能。因此，尽量以自增id作为InnoDB的主索引。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven笔记</title>
      <link href="/2019/10/21/2019-06-16-maven-bi-ji/"/>
      <url>/2019/10/21/2019-06-16-maven-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="一、为什么使用-Maven-这样的构建工具【why】"><a href="#一、为什么使用-Maven-这样的构建工具【why】" class="headerlink" title="一、为什么使用 Maven 这样的构建工具【why】"></a>一、为什么使用 Maven 这样的构建工具【why】</h3><p><strong>① 一个项目就是一个工程</strong></p><p>如果项目非常庞大，就不适合使用 package 来划分模块，最好是每一个模块对应一个工程，利于分工协作。借助于 maven 就可以将一个项目拆分成多个工程</p><p><strong>② 项目中使用 jar 包，需要“复制”、“粘贴”项目的 lib 中</strong></p><p>同样的 jar 包重复的出现在不同的项目工程中，你需要做不停的复制粘贴的重复工作。借助于 maven，可以将 jar 包保存在“仓库”中，不管在哪个项目只要使用引用即可就行。</p><p><strong>③ jar 包需要的时候每次都要自己准备好或到官网下载</strong></p><p>借助于 maven 我们可以使用统一的规范方式下载 jar 包，规范</p><p><strong>④ jar 包版本不一致的风险</strong></p><p>不同的项目在使用 jar 包的时候，有可能会导致各个项目的 jar 包版本不一致，导致未执行错误。借助于 maven，所有的 jar 包都放在“仓库”中，所有的项目都使用仓库的一份 jar 包。</p><p><strong>⑤ 一个 jar 包依赖其他的 jar 包需要自己手动的加入到项目中</strong></p><p>FileUpload 组件-&gt;IO 组件，commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar</p><p>极大的浪费了我们导入包的时间成本，也极大的增加了学习成本。借助于 maven，它会自动的将依赖的 jar 包导入进来。</p><h3 id="二、maven-是什么【what】"><a href="#二、maven-是什么【what】" class="headerlink" title="二、maven 是什么【what】"></a>二、maven 是什么【what】</h3><p><strong>① maven 是一款服务于 java 平台的自动化构建工具</strong></p><p>make-&gt;Ant-&gt;Maven-&gt;Gradle</p><p>名字叫法：我们可以叫妹文也可以叫麦文，但是没有叫妈文的。</p><p><strong>② 构建</strong></p><p>构建定义：把动态的 Web 工程经过编译得到的编译结果部署到服务器上的整个过程。</p><p>编译：java 源文件[.java]-&gt;编译-&gt;Classz 字节码文件[.class]</p><p>部署：最终在 sevlet 容器中部署的不是动态 web 工程，而是编译后的文件</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv1.png" alt="image"></p><p><strong>③ 构建的各个环节</strong></p><ul><li><p>清理 clean：将以前编译得到的旧文件 class 字节码文件删除</p></li><li><p>编译 compile：将 java 源程序编译成 class 字节码文件</p></li><li><p>测试 test：自动测试，自动调用 junit 程序</p></li><li><p>报告 report：测试程序执行的结果</p></li><li><p>打包 package：动态 Web 工程打 War 包，java 工程打 jar 包</p></li><li><p>安装 install：Maven 特定的概念—–将打包得到的文件复制到“仓库”中的指定位置</p></li><li><p>部署 deploy：将动态 Web 工程生成的 war 包复制到 Servlet 容器下，使其可以运行</p></li></ul><h3 id="三、安装-maven"><a href="#三、安装-maven" class="headerlink" title="三、安装 maven"></a>三、安装 maven</h3><p>① 当前系统是否配置 JAVA_HOME 的环境变量</p><p>② 下载 maven，解压 maven 放在一个非中文无空格的路径下</p><p>③ 配置 maven 的相关环境变量</p><ul><li><p>在环境变量增加 M2_HOME，路径是 maven 解压后的根目录</p></li><li><p>在环境变量里的 path 中增加 maven/bin 的目录</p></li></ul><p>④ 验证：maven -v 查看 maven 版本</p><p>看到版本信息，恭喜你已经 OK 了。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv2.png" alt="image"></p><h3 id="四、第一个-maven"><a href="#四、第一个-maven" class="headerlink" title="四、第一个 maven"></a>四、第一个 maven</h3><p><strong>① 创建约定的目录结构</strong>（maven 工程必须按照约定的目录结构创建）</p><blockquote><p>根目录：工程名<br>|—src：源码<br>|—|—main:存放主程序<br>|—|—|—java：java 源码文件<br>|—|—|—resource：存放框架的配置文件<br>|—|—test：存放测试程序<br>|—pop.xml：maven 的核心配置文件</p></blockquote><p>我们按照上面的文件夹目录结构手动创建一下，不用任何 IDE 环境（手动的其实最有助于我们理解 maven）</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv3.png" alt="image"></p><h4 id="文件内容如下"><a href="#文件内容如下" class="headerlink" title="文件内容如下"></a>文件内容如下</h4><p>在 src/main/java/com/hzg/maven 目录下新建文件 Hello.java，内容如下</p><pre><code>package com.hzg.maven;public class Hello {　　public String sayHello(String name){　　　　return "Hello "+name+"!";　　}}</code></pre><p>POM 文件内容：</p><pre><code>&lt;?xml version="1.0" ?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.hzg.maven&lt;/groupId&gt;    &lt;artifactId&gt;Hello&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;Hello&lt;/name&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.0&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p><strong>②  常用 maven 命令</strong></p><ul><li><p>mvn clean：清理</p></li><li><p>mvn compile：编译主程序</p></li><li><p>mvn test-compile：编译测试程序</p></li><li><p>mvn test：执行测试</p></li><li><p>mvn package：打包</p></li><li><p>mvn install：安装</p></li></ul><p><strong>执行 maven 命令必须进入到 pom.xml 的目录中进行执行</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv4.png" alt="image"></p><p>进入到项目的 pom.xml 目录之后，就可以执行啦。</p><p><strong>1、运行 mvn compile</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv5.png" alt="image"></p><p>OK，运行完毕，你在 pom.xml 配置的依赖的包已经导入到仓库了，问题来了，<strong>仓库默认的位置在哪？</strong></p><p><strong>仓库的默认位置：</strong>c:\Usrs[登录当前系统的用户名].m2\repository</p><p>刚才执行完 compile 之后，之前的文件夹发生了变化</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv6.png" alt="image"></p><p>我们发现 Hello 项目里里多了一个 target 文件夹。文件夹的内容为：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv7.png" alt="image"></p><p>发现 target 里主要存放的就是编译后的字节码文件</p><p><strong>2、运行 mvn test-compile</strong>，target 文件夹下面除了 classes 之外多了 test-classes 文件夹</p><p><strong>3、运行 mvn package</strong>，target 文件夹下面又多了一个打好的 jar 包</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv8.png" alt="image"></p><p>4、运行 mvn clean，发现整个 target 文件夹都没了。又回到了编译之前我们手动创建的文件夹</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv9.png" alt="image"></p><h3 id="五、仓库和坐标"><a href="#五、仓库和坐标" class="headerlink" title="五、仓库和坐标"></a>五、仓库和坐标</h3><p><strong>①pom.xml：</strong><br>Project Object Model 项目对象模型。它是 maven 的核心配置文件，所有的构建的配置都在这里设置。</p><p><strong>② 坐标：</strong> 使用下面的三个向量在仓库中唯一的定位一个 maven 工程</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv10.png" alt="image"></p><p><strong>③ maven 工程的坐标与仓库中路径的关系：</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv11.png" alt="image"></p><p>maven 坐标和仓库对应的映射关系：[groupId][artifactId][version][artifactId]-[version].jar</p><p>去本地仓库看一下此目录：org\springframework\spring-core\4.3.4.RELEASE\spring-core-4.3.4.RELEASE.jar</p><p>果然是完全对应的（默认仓库地址上面说过了哦，不要说不知道在哪，没事下面我们再说一下仓库）</p><p><strong>④ 仓库</strong></p><p>仓库的分类：</p><p><strong>1、本地仓库：</strong> 当前电脑上的仓库，路径上已经说过了哦</p><p><strong>2、远程仓库：</strong></p><ul><li><p>私服：搭建在局域网中，一般公司都会有私服，私服一般使用 nexus 来搭建。具体搭建过程可以查询其他资料</p></li><li><p>中央仓库：架设在 Internet 上，像刚才的 springframework 就是在中央仓库上</p></li></ul><h3 id="六、依赖"><a href="#六、依赖" class="headerlink" title="六、依赖"></a>六、依赖</h3><p><strong>① maven 解析依赖信息时会到本地仓库中取查找被依赖的 jar 包</strong></p><ul><li><p>对于本地仓库中没有的会去中央仓库去查找 maven 坐标来获取 jar 包，获取到 jar 之后会下载到本地仓库</p></li><li><p>对于中央仓库也找不到依赖的 jar 包的时候，就会编译失败了</p></li></ul><p><strong>② 如果依赖的是自己或者团队开发的 maven 工程，需要先使用 install 命令把被依赖的 maven 工程的 jar 包导入到本地仓库中</strong></p><p>举例：现在我再创建第二个 maven 工程 HelloFriend，其中用到了第一个 Hello 工程里类的 sayHello(String name)方法。我们在给 HelloFriend 项目使用 mvn compile 命令进行编译的时候，会提示缺少依赖 Hello 的 jar 包。怎么办呢？</p><p>到第一个 maven 工程中执行 mvn install 后，你再去看一下本地仓库，你会发现有了 Hello 项目的 jar 包。一旦本地仓库有了依赖的 maven 工程的 jar 包后，你再到 HelloFriend 项目中使用 mvn compile 命令的时候，可以成功编译</p><p><strong>③ 依赖范围</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv12.png" alt="image"></p><p><em>scope 就是依赖的范围</em></p><p><strong>1、compile，</strong> 默认值，适用于所有阶段（开发、测试、部署、运行），本 jar 会一直存在所有阶段。</p><p><strong>2、provided，</strong> 只在开发、测试阶段使用，目的是不让 Servlet 容器和你本地仓库的 jar 包冲突 。如 servlet.jar。</p><p><strong>3、runtime，</strong> 只在运行时使用，如 JDBC 驱动，适用运行和测试阶段。</p><p><strong>4、test，</strong> 只在测试时使用，用于编译和运行测试代码。不会随项目发布。</p><p><strong>5、system，</strong> 类似 provided，需要显式提供包含依赖的 jar，Maven 不会在 Repository 中查找它。</p><h3 id="七、生命周期"><a href="#七、生命周期" class="headerlink" title="七、生命周期　　"></a>七、生命周期　　</h3><p>Maven 有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将 Maven 的生命周期看成一个整体，其实不然。这三套生命周期分别是：</p><p><strong>① Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</strong> Clean 生命周期一共包含了三个阶段：</p><ul><li><p>pre-clean 执行一些需要在 clean 之前完成的工作</p></li><li><p>clean 移除所有上一次构建生成的文件</p></li><li><p>post-clean 执行一些需要在 clean 之后立刻完成的工作</p></li></ul><p><strong>② Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。</strong></p><ul><li><p>validate</p></li><li><p>generate-sources</p></li><li><p>process-sources</p></li><li><p>generate-resources</p></li><li><p>process-resources 复制并处理资源文件，至目标目录，准备打包</p></li><li><p>compile 编译项目的源代码</p></li><li><p>process-classes</p></li><li><p>generate-test-sources</p></li><li><p>process-test-sources</p></li><li><p>generate-test-resources</p></li><li><p>process-test-resources 复制并处理资源文件，至目标测试目录</p></li><li><p>test-compile 编译测试源代码</p></li><li><p>process-test-classes</p></li><li><p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署</p></li><li><p>prepare-package</p></li><li><p>package 接受编译好的代码，打包成可发布的格式，如 JAR</p></li><li><p>pre-integration-test</p></li><li><p>integration-test</p></li><li><p>post-integration-test</p></li><li><p>verify</p></li><li><p>install 将包安装至本地仓库，以让其它项目依赖。</p></li><li><p>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享</p></li></ul><p>那我们在 Hello 的项目中执行 mvn install 命令，通过日志看看中间经历了什么？</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv13.png" alt="image"></p><p>通过日志我们发现，其实执行 mvn install，其中已经执行了 compile 和 test 。</p><p><strong>总结：</strong> 不论你要执行生命周期的哪一个阶段，maven 都是从这个生命周期的开始执行</p><p><strong>插件：</strong> 每个阶段都有插件（plugin），看上面标红的。插件的职责就是执行它对应的命令。</p><p><strong>③ Site Lifecycle 生成项目报告，站点，发布站点。</strong></p><ul><li><p>pre-site 执行一些需要在生成站点文档之前完成的工作</p></li><li><p>site 生成项目的站点文档</p></li><li><p>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p></li><li><p>site-deploy 将生成的站点文档部署到特定的服务器上</p></li></ul><h3 id="八、maven-工程的依赖高级特性"><a href="#八、maven-工程的依赖高级特性" class="headerlink" title="八、maven 工程的依赖高级特性"></a>八、maven 工程的依赖高级特性</h3><p><strong>① 依赖的传递性</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv14.png" alt="image"></p><p>WebMavenDemo 项目依赖 JavaMavenService1 JavaMavenService1 项目依赖 JavaMavenService2</p><p>pom.xml 文件配置好依赖关系后，必须首先 mvn install 后，依赖的 jar 包才能使用。</p><ul><li><p>WebMavenDemo 的 pom.xml 文件想能编译通过，JavaMavenService1 必须 mvn install</p></li><li><p>JavaMavenService 的 pom.xml 文件想能编译通过，JavaMavenService2 必须 mvn install</p></li></ul><p><strong>传递性：</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv15.png" alt="image"></p><p>在 Eclipse 中，为 JavaMavenService2 中增加了一个 spring-core.jar 包后，会惊喜的发现依赖的两个项目都自动的增加了这个 jar 包，这就是依赖的传递性。</p><blockquote><p>注意：非 compile 范围的依赖是不能传递的。</p></blockquote><p><strong>② 依赖版本的原则：</strong></p><p><strong>1、路径最短者优先原则</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv16.png" alt="image"></p><p>Service2 的 log4j 的版本是 1.2.7 版本，Service1 排除了此包的依赖，自己加了一个 Log4j 的 1.2.9 的版本，那么 WebMavenDemo 项目遵守路径最短优先原则，Log4j 的版本和 Sercive1 的版本一致。</p><p><strong>2、路径相同先声明优先原则</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv17.png" alt="image"></p><p>这种场景依赖关系发生了变化，WebMavenDemo 项目依赖 Sercive1 和 Service2，它俩是同一个路径，那么谁在 WebMavenDemo 的 pom.xml 中先声明的依赖就用谁的版本。</p><p><strong>③ 统一管理依赖的版本：</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv18.png" alt="image"></p><p>为了统一管理版本号，可以使用 properties 标签，里面可以自定义版本的标签名。在使用的地方使用${自定义标签名}</p><h3 id="十、build-配置"><a href="#十、build-配置" class="headerlink" title="十、build 配置"></a>十、build 配置</h3><pre><code>&lt;build&gt;　　&lt;!-- 项目的名字 --&gt;　　&lt;finalName&gt;WebMavenDemo&lt;/finalName&gt;　　&lt;!-- 描述项目中资源的位置 --&gt;　　&lt;resources&gt;　　　　&lt;!-- 自定义资源1 --&gt;　　　　&lt;resource&gt;　　　　　　&lt;!-- 资源目录 --&gt;　　　　　　&lt;directory&gt;src/main/java&lt;/directory&gt;　　　　　　&lt;!-- 包括哪些文件参与打包 --&gt;　　　　　　&lt;includes&gt;　　　　　　　　&lt;include&gt;**/*.xml&lt;/include&gt;　　　　　　&lt;/includes&gt;　　　　　　&lt;!-- 排除哪些文件不参与打包 --&gt;　　　　　　&lt;excludes&gt;　　　　　　　　&lt;exclude&gt;**/*.txt&lt;/exclude&gt;　　　　　　　　　　&lt;exclude&gt;**/*.doc&lt;/exclude&gt;　　　　　　&lt;/excludes&gt;　　　　&lt;/resource&gt;　　&lt;/resources&gt;　　&lt;!-- 设置构建时候的插件 --&gt;　　&lt;plugins&gt;　　　　&lt;plugin&gt;　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;　　　　　　&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;　　　　　　&lt;version&gt;2.1&lt;/version&gt;　　　　　　&lt;configuration&gt;　　　　　　　　&lt;!-- 源代码编译版本 --&gt;　　　　　　　　&lt;source&gt;1.8&lt;/source&gt;　　　　　　　　&lt;!-- 目标平台编译版本 --&gt;　　　　　　　　&lt;target&gt;1.8&lt;/target&gt;　　　　　　&lt;/configuration&gt;　　　　&lt;/plugin&gt;　　　　&lt;!-- 资源插件（资源的插件） --&gt;  　　　　&lt;plugin&gt;  　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  　　　　　　&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;  　　　　　　&lt;version&gt;2.1&lt;/version&gt;  　　　　　　&lt;executions&gt;  　　　　　　　　&lt;execution&gt;  　　　　　　　　　　&lt;phase&gt;compile&lt;/phase&gt;  　　　　　　　　&lt;/execution&gt;  　　　　　　&lt;/executions&gt;  　　　　　　&lt;configuration&gt;  　　　　　　　　&lt;encoding&gt;UTF-8&lt;/encoding&gt;  　　　　　　&lt;/configuration&gt; 　　　　&lt;/plugin&gt;　　　　&lt;!-- war插件(将项目打成war包) --&gt;  　　　　&lt;plugin&gt;  　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  　　　　　　&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;  　　　　　　&lt;version&gt;2.1&lt;/version&gt;  　　　　　　&lt;configuration&gt;　　　　　　　　&lt;!-- war包名字 --&gt;  　　　　　　　　&lt;warName&gt;WebMavenDemo1&lt;/warName&gt;　　　　　　&lt;/configuration&gt;  　　　　&lt;/plugin&gt;  　　&lt;/plugins&gt;&lt;/build&gt;</code></pre><p>配置好 build 后，执行 mvn package 之后，在 maven 工程指定的 target 目录里 war 包和文件都按照配置的生成了</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv19.png" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka配置信息</title>
      <link href="/2019/10/21/2019-06-16-kafka-pei-zhi-xin-xi/"/>
      <url>/2019/10/21/2019-06-16-kafka-pei-zhi-xin-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>  Kafka是分布式发布-订阅消息系统，最初由LinkedIn公司开发，之后成为之后成为Apache基金会的一部分，由Scala和Java编写。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。</p></blockquote><h4 id="Kafka的特性"><a href="#Kafka的特性" class="headerlink" title="Kafka的特性:"></a>Kafka的特性:</h4><ul><li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li><li>可扩展性：kafka集群支持热扩展</li><li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li>高并发：支持数千个客户端同时读写</li></ul><h4 id="Kafka的使用场景："><a href="#Kafka的使用场景：" class="headerlink" title="Kafka的使用场景："></a>Kafka的使用场景：</h4><ul><li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。</li><li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li><li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li><li>流式处理：比如spark streaming和storm</li><li>事件源</li></ul><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>Kafka支持两种模式的集群搭建：</p><ol><li>单机多broker集群配置；</li><li>多机多broker集群配置。</li></ol><h4 id="单机多breoker"><a href="#单机多breoker" class="headerlink" title="单机多breoker"></a>单机多breoker</h4><p>利用单节点部署多个broker。不同的broker不同的id，监听端口以及日志目录，如：</p><p>将配置文件复制两份</p><pre><code>cp config/server.properties config/server-1.propertiescp config/server.properties config/server-2.properties </code></pre><p>修改配置文件信息</p><pre><code>vim config/server-1.properties#修改内容broker.id=2listeners=PLAINTEXT://your.host.name:9093log.dirs=/data/kafka-logs-1vim config/server-2.properties#修改内容broker.id=3listeners=PLAINTEXT://your.host.name:9094log.dirs=/data/kafka-logs-2</code></pre><p>启动多个kafka服务</p><pre><code>in/kafka-server-start.sh config/server-1.properties bin/kafka-server-start.sh config/server-2.properties </code></pre><p>最后按照上面方法产生和消费信息。</p><h4 id="多机多broker"><a href="#多机多broker" class="headerlink" title="多机多broker"></a>多机多broker</h4><p>分别在多个节点按上述方式安装Kafka，配置启动多个Zookeeper 实例。如：192.168.18.130、192.168.18.131、192.168.18.132三台机器</p><p>分别配置多个机器上的Kafka服务 设置不同的broke id，zookeeper.connect设置如下:</p><pre><code>zookeeper.connect=192.168.18.130:2181,192.168.18.131:2181,192.168.18.132:2181</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code>broker.id=0     #当前机器在集群中的唯一标识，和zookeeper的myid性质一样port=9092      #当前kafka对外提供服务的端口默认是9092host.name=10.181.65.180       #这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。num.network.threads=3         #这个是borker进行网络处理的线程数num.io.threads=8              #这个是borker进行I/O处理的线程数log.dirs=/opt/kafka/kafkalogs/       #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个socket.send.buffer.bytes=102400      #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能socket.receive.buffer.bytes=102400   #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘socket.request.max.bytes=104857600   #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小num.partitions=1                     #默认的分区数，一个topic默认1个分区数log.retention.hours=168              #默认消息的最大持久化时间，168小时，7天message.max.byte=5242880             #消息保存的最大值5Mdefault.replication.factor=2         #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务replica.fetch.max.bytes=5242880      #取消息的最大直接数log.segment.bytes=1073741824         #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件log.retention.check.interval.ms=300000         #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除log.cleaner.enable=false                       #是否启用log压缩，一般不用启用，启用的话可以提高性能zookeeper.connect=10.181.65.180:2181,0.181.65.181:2181,0.181.65.182:2181             #设置zookeeper的连接端口</code></pre><h4 id="Kafka的特性-1"><a href="#Kafka的特性-1" class="headerlink" title="Kafka的特性:"></a>Kafka的特性:</h4><ul><li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li><li>可扩展性：kafka集群支持热扩展</li><li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li>高并发：支持数千个客户端同时读写</li></ul><h3 id="springboot整合"><a href="#springboot整合" class="headerlink" title="springboot整合"></a>springboot整合</h3><p><a href="https://blog.csdn.net/qq_26869339/article/details/88324980" target="_blank" rel="noopener">https://blog.csdn.net/qq_26869339/article/details/88324980</a></p><pre><code>#kafka配置信息kafka:  producer:    bootstrap-servers: 10.161.11.222:6667,10.161.11.223:6667,10.161.11.224:6667    batch-size: 16785                                   #一次最多发送数据量    retries: 1                                          #发送失败后的重复发送次数    buffer-memory: 33554432                             #32M批处理缓冲区    linger: 1  consumer:    bootstrap-servers: 10.161.11.222:6667,10.161.11.223:6667,10.161.11.224:6667    auto-offset-reset: earliest                         #最早未被消费的offset    group-id: log-hs-grou20    max-poll-records: 4639                              #批量消费一次最大拉取的数据量    enable-auto-commit: false                           #是否开启自动提交    auto-commit-interval: 1000                          #自动提交的间隔时间    session-timeout: 6000                               #连接超时时间    max-poll-interval: 2000                             #手动提交设置与poll的心跳数  listener:    batch-listener: true                                #是否开启批量消费，true表示批量消费    concurrency: 3                                      #设置消费的线程数    poll-timeout: 1500                                  #自动提交设置，如果消息队列中没有消息，等待timeout毫秒后，调用poll()方法。如果队列中有消息，立即消费消息，每次消费的消息的多少可以通过max.poll.records配置。    topics: hs-test,hs-test1</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka学习笔记</title>
      <link href="/2019/10/21/2019-06-16-kafka-xue-xi-bi-ji/"/>
      <url>/2019/10/21/2019-06-16-kafka-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka学习笔记：知识点整理"><a href="#kafka学习笔记：知识点整理" class="headerlink" title="kafka学习笔记：知识点整理"></a>kafka学习笔记：知识点整理</h2><h2 id="一、为什么需要消息系统"><a href="#一、为什么需要消息系统" class="headerlink" title="一、为什么需要消息系统"></a><strong>一、为什么需要消息系统</strong></h2><p><strong>1.解耦：</strong><br>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。<br><strong>2.冗余：</strong><br>　　消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。<br><strong>3.扩展性：</strong><br>　　因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。<br><strong>4.灵活性 &amp; 峰值处理能力：</strong><br>　　在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。<br><strong>5.可恢复性：</strong><br>　　系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。<br><strong>6.顺序保证：</strong><br>　　在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性）<br><strong>7.缓冲：</strong><br>　　有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。<br><strong>8.异步通信：</strong><br>　　很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h2 id="二、kafka-架构"><a href="#二、kafka-架构" class="headerlink" title="二、kafka 架构"></a><strong>二、kafka 架构</strong></h2><h3 id="2-1-拓扑结构"><a href="#2-1-拓扑结构" class="headerlink" title="2.1 拓扑结构"></a>2.1 拓扑结构</h3><p>如下图：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka1.png" alt="image"></p><p>图.1</p><h3 id="2-2-相关概念"><a href="#2-2-相关概念" class="headerlink" title="2.2 相关概念"></a>2.2 相关概念</h3><ul><li><p><strong>Topic</strong>：Topic在逻辑上可以被认为是一个queue。每条消费都必须指定它的topic，可以简单理解为必须指明把这条消息放进哪个queue里。</p><ul><li>Partition:topic物理上的分区，一个topic可以分为多个partition，每个partition是一个有序的队列。</li><li>offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.</li></ul></li><li><p><strong>Partition</strong>：是物理概念上的分区，为了提供系统吞吐率，在物理上每个Topic会分成一个或多个Partition，每个Partition对应一个文件夹，通过partition实现了并行处理和水平扩展</p><ul><li>Segment：<ul><li>partition物理上由多个segment组成，每个Segment存着message信息</li><li>一个Segment对应一个文件</li><li>Segment由一个个不可变记录组成</li><li>记录只会被append到Segment中，不会被单独修改或删除</li><li>清除过期日志时，直接删除一个或多个Segment</li></ul></li></ul></li><li><p><strong>ISR</strong></p></li><li><p><strong>Producer</strong>：消息产生者，负责生产消息并发送到Kafka Broker</p></li><li><p><strong>Consumer</strong>：消息消费者，向kafka broker读取消息并处理的客户端。</p><ul><li><p>消费者就是消息的使用者，在消费者端也有几个名词需要区分一下。</p><blockquote><p>一般消息队列有两种模式的消费方式，分别是 队列模式 和 订阅模式。</p></blockquote><ul><li>队列模式：一对一，就是一个消息只能被一个消费者消费，不能重复消费。一般情况队列支持存在多个消费者，但是对于一个消息，只会有一个消费者可以消费它。</li><li>订阅模式：一对多，一个消息可能被多次消费，消息生产者将消息发布到Topic中，只要是订阅改Topic的消费者都可以消费。</li></ul></li></ul></li><li><p><strong>Consumer Group</strong>：各个consumer（consumer 线程）可以组成一个组（Consumer group ），partition中的每个message只能被组（Consumer group ）中的一个consumer（consumer 线程）消费，如果一个message可以被多个consumer（consumer 线程）消费的话，那么这些consumer必须在不同的组。Kafka不支持一个partition中的message由两个或两个以上的同一个consumer group下的consumer thread来处理，除非再启动一个新的consumer group。所以如果想同时对一个topic做消费的话，启动多个consumer group就可以了，但是要注意的是，这里的多个consumer的消费都必须是顺序读取partition里面的message，新启动的consumer默认从partition队列最头端最新的地方开始阻塞的读message。</p></li><li><p><strong>Broker</strong>：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</p><ul><li>Controller：中央控制器Control，负责管理分区和副本状态并执行管理着这些分区的重新分配。（里面涉及到partition leader 选举）</li><li>ISR：同步副本组</li></ul></li><li><p><strong>controller</strong>：kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover。</p></li><li><p><strong>删除</strong></p><ul><li>对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略去删除旧数据。一是基于时间，二是基于partition文件大小。例如可以通过配置$KAFKA_HOME/config/server.properties，让Kafka删除一周前的数据，也可通过配置让Kafka在partition文件超过1GB时删除旧数据</li></ul></li></ul><h3 id="2-3-zookeeper-节点"><a href="#2-3-zookeeper-节点" class="headerlink" title="2.3 zookeeper 节点"></a>2.3 zookeeper 节点</h3><p>kafka 在 zookeeper 中的存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka2.png" alt="image"></p><p>图.2</p><h2 id="三、producer-发布消息"><a href="#三、producer-发布消息" class="headerlink" title="三、producer 发布消息"></a><strong>三、producer 发布消息</strong></h2><h3 id="3-1-写入方式"><a href="#3-1-写入方式" class="headerlink" title="3.1 写入方式"></a>3.1 写入方式</h3><p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。</p><h3 id="3-2-消息路由"><a href="#3-2-消息路由" class="headerlink" title="3.2 消息路由"></a>3.2 消息路由</h3><p>producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。其路由机制为：</p><p>1. 指定了 patition，则直接使用；<br>2. 未指定 patition 但指定 key，通过对 key 的 value 进行hash 选出一个 patition<br>3. patition 和 key 都未指定，使用轮询选出一个 patition。</p><p> 附上 java 客户端分区源码，一目了然：</p><pre><code>//创建消息实例  public ProducerRecord(String topic, Integer partition, Long timestamp, K key, V value) {       if (topic == null)            throw new IllegalArgumentException("Topic cannot be null");       if (timestamp != null &amp;&amp; timestamp &lt; 0)            throw new IllegalArgumentException("Invalid timestamp " + timestamp);       this.topic = topic;       this.partition = partition;       this.key = key;       this.value = value;       this.timestamp = timestamp;  }  //计算 patition，如果指定了 patition 则直接使用，否则使用 key 计算  private int partition(ProducerRecord&lt;K, V&gt; record, byte\[\] serializedKey , byte\[\] serializedValue, Cluster cluster) {       Integer partition = record.partition();       if (partition != null) {            List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(record.topic());            int lastPartition = partitions.size() - 1;            if (partition &lt; 0 || partition &gt; lastPartition) {                 throw new IllegalArgumentException(String.format("Invalid partition given with record: %d is not in the range \[0...%d\].", partition, lastPartition));            }            return partition;       }       return this.partitioner.partition(record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);  }  // 使用 key 选取 patition  public int partition(String topic, Object key, byte\[\] keyBytes, Object value, byte\[\] valueBytes, Cluster cluster) {       List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);       int numPartitions = partitions.size();       if (keyBytes == null) {            int nextValue = counter.getAndIncrement();            List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);            if (availablePartitions.size() &gt; 0) {                 int part = DefaultPartitioner.toPositive(nextValue) % availablePartitions.size();                 return availablePartitions.get(part).partition();            } else {                 return DefaultPartitioner.toPositive(nextValue) % numPartitions;            }       } else {            //对 keyBytes 进行 hash 选出一个 patition            return DefaultPartitioner.toPositive(Utils.murmur2(keyBytes)) % numPartitions;       }  }</code></pre><h3 id="3-3-写入流程"><a href="#3-3-写入流程" class="headerlink" title="3.3 写入流程"></a>3.3 写入流程</h3><p> producer 写入消息序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka3.png" alt="image"></p><p>图.3</p><p>流程说明：</p><p>1. producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader<br>2. producer 将消息发送给该 leader<br>3. leader 将消息写入本地 log<br>4. followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK<br>5. leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK</p><h3 id="3-4-producer-delivery-guarantee"><a href="#3-4-producer-delivery-guarantee" class="headerlink" title="3.4 producer delivery guarantee"></a>3.4 producer delivery guarantee</h3><p> 一般情况下存在三种情况：</p><p>1. At most once 消息可能会丢，但绝不会重复传输<br>2. At least one 消息绝不会丢，但可能会重复传输<br>3. Exactly once 每条消息肯定会被传输一次且仅传输一次</p><p>当 producer 向 broker 发送消息时，一旦这条消息被 commit，由于 replication 的存在，它就不会丢。但是如果 producer 发送数据给 broker 后，遇到网络问题而造成通信中断，那 Producer 就无法判断该条消息是否已经 commit。虽然 Kafka 无法确定网络故障期间发生了什么，但是 producer 可以生成一种类似于主键的东西，发生故障时幂等性的重试多次，这样就做到了 Exactly once，但目前还并未实现。所以目前默认情况下一条消息从 producer 到 broker 是确保了 At least once，可通过设置 producer 异步发送实现At most once。</p><h2 id="四、broker-保存消息"><a href="#四、broker-保存消息" class="headerlink" title="四、broker 保存消息"></a><strong>四、broker 保存消息</strong></h2><h3 id="4-1-存储方式"><a href="#4-1-存储方式" class="headerlink" title="4.1 存储方式"></a>4.1 存储方式</h3><p>物理上把 topic 分成一个或多个 patition（对应 server.properties 中的 num.partitions=3 配置），每个 patition 物理上对应一个文件夹（该文件夹存储该 patition 的所有消息和索引文件），如下：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka4.png" alt="image"></p><p>图.4</p><h3 id="4-2-存储策略"><a href="#4-2-存储策略" class="headerlink" title="4.2 存储策略"></a>4.2 存储策略</h3><p>无论消息是否被消费，kafka 都会保留所有消息。有两种策略可以删除旧数据：</p><p>1. 基于时间：log.retention.hours=168<br>2. 基于大小：log.retention.bytes=1073741824</p><p>需要注意的是，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。</p><h3 id="4-3-topic-创建与删除"><a href="#4-3-topic-创建与删除" class="headerlink" title="4.3 topic 创建与删除"></a>4.3 topic 创建与删除</h3><h4 id="4-3-1-创建-topic"><a href="#4-3-1-创建-topic" class="headerlink" title="4.3.1 创建 topic"></a>4.3.1 创建 topic</h4><p>创建 topic 的序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka5.png" alt="image"></p><p>图.5</p><p>流程说明：</p><p>1. controller 在 ZooKeeper 的 /brokers/topics 节点上注册 watcher，当 topic 被创建，则 controller 会通过 watch 得到该 topic 的 partition/replica 分配。<br>2. controller从 /brokers/ids 读取当前所有可用的 broker 列表，对于 set_p 中的每一个 partition：<br>    2.1 从分配给该 partition 的所有 replica（称为AR）中任选一个可用的 broker 作为新的 leader，并将AR设置为新的 ISR<br>    2.2 将新的 leader 和 ISR 写入 /brokers/topics/[topic]/partitions/[partition]/state<br>3. controller 通过 RPC 向相关的 broker 发送 LeaderAndISRRequest。</p><h4 id="4-3-2-删除-topic"><a href="#4-3-2-删除-topic" class="headerlink" title="4.3.2 删除 topic"></a>4.3.2 删除 topic</h4><p>删除 topic 的序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka6.png" alt="image"></p><p>图.6</p><p>流程说明：</p><p>1. controller 在 zooKeeper 的 /brokers/topics 节点上注册 watcher，当 topic 被删除，则 controller 会通过 watch 得到该 topic 的 partition/replica 分配。<br>2. 若 delete.topic.enable=false，结束；否则 controller 注册在 /admin/delete_topics 上的 watch 被 fire，controller 通过回调向对应的 broker 发送 StopReplicaRequest。</p><h2 id="五、kafka-HA"><a href="#五、kafka-HA" class="headerlink" title="五、kafka HA"></a><strong>五、kafka HA</strong></h2><h3 id="5-1-replication"><a href="#5-1-replication" class="headerlink" title="5.1 replication"></a>5.1 replication</h3><p>如图.1所示，同一个 partition 可能会有多个 replica（对应 server.properties 配置中的 default.replication.factor=N）。没有 replica 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。引入replication 之后，同一个 partition 可能会有多个 replica，而这时需要在这些 replica 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replica 作为 follower 从 leader 中复制数据。</p><p>Kafka 分配 Replica 的算法如下：</p><p>1. 将所有 broker（假设共 n 个 broker）和待分配的 partition 排序<br>2. 将第 i 个 partition 分配到第（i mod n）个 broker 上<br>3. 将第 i 个 partition 的第 j 个 replica 分配到第（(i + j) mode n）个 broker上</p><h3 id="5-2-leader-failover"><a href="#5-2-leader-failover" class="headerlink" title="5.2 leader failover"></a>5.2 leader failover</h3><p>当 partition 对应的 leader 宕机时，需要从 follower 中选举出新 leader。在选举新leader时，一个基本的原则是，新的 leader 必须拥有旧 leader commit 过的所有消息。</p><p>kafka 在 zookeeper 中（/brokers/…/state）动态维护了一个 ISR（in-sync replicas），由3.3节的写入流程可知 ISR 里面的所有 replica 都跟上了 leader，只有 ISR 里面的成员才能选为 leader。对于 f+1 个 replica，一个 partition 可以在容忍 f 个 replica 失效的情况下保证消息不丢失。</p><p>当所有 replica 都不工作时，有两种可行的方案：</p><p>1. 等待 ISR 中的任一个 replica 活过来，并选它作为 leader。可保障数据不丢失，但时间可能相对较长。<br>2. 选择第一个活过来的 replica（不一定是 ISR 成员）作为 leader。无法保障数据不丢失，但相对不可用时间较短。</p><p>kafka 0.8.* 使用第二种方式。</p><p>kafka 通过 Controller 来选举 leader，流程请参考5.3节。</p><h3 id="5-3-broker-failover"><a href="#5-3-broker-failover" class="headerlink" title="5.3 broker failover"></a>5.3 broker failover</h3><p>kafka broker failover 序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka7.png" alt="image"></p><p>图.7</p><p>流程说明： </p><p>1. controller 在 zookeeper 的 /brokers/ids/[brokerId] 节点注册 Watcher，当 broker 宕机时 zookeeper 会 fire watch<br>2. controller 从 /brokers/ids 节点读取可用broker<br>3. controller决定set_p，该集合包含宕机 broker 上的所有 partition<br>4. 对 set_p 中的每一个 partition<br>    4.1 从/brokers/topics/[topic]/partitions/[partition]/state 节点读取 ISR<br>    4.2 决定新 leader（如4.3节所描述）<br>    4.3 将新 leader、ISR、controller_epoch 和 leader_epoch 等信息写入 state 节点<br>5. 通过 RPC 向相关 broker 发送 leaderAndISRRequest 命令</p><h3 id="5-4-controller-failover"><a href="#5-4-controller-failover" class="headerlink" title="5.4 controller failover"></a>5.4 controller failover</h3><p> 当 controller 宕机时会触发 controller failover。每个 broker 都会在 zookeeper 的 “/controller” 节点注册 watcher，当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知，每个 broker 都尝试创建新的 controller path，只有一个竞选成功并当选为 controller。</p><p>当新的 controller 当选时，会触发 KafkaController.onControllerFailover 方法，在该方法中完成如下操作：</p><p>1. 读取并增加 Controller Epoch。<br>2. 在 reassignedPartitions Patch(/admin/reassign_partitions) 上注册 watcher。<br>3. 在 preferredReplicaElection Path(/admin/preferred_replica_election) 上注册 watcher。<br>4. 通过 partitionStateMachine 在 broker Topics Patch(/brokers/topics) 上注册 watcher。<br>5. 若 delete.topic.enable=true（默认值是 false），则 partitionStateMachine 在 Delete Topic Patch(/admin/delete_topics) 上注册 watcher。<br>6. 通过 replicaStateMachine在 Broker Ids Patch(/brokers/ids)上注册Watch。<br>7. 初始化 ControllerContext 对象，设置当前所有 topic，“活”着的 broker 列表，所有 partition 的 leader 及 ISR等。<br>8. 启动 replicaStateMachine 和 partitionStateMachine。<br>9. 将 brokerState 状态设置为 RunningAsController。<br>10. 将每个 partition 的 Leadership 信息发送给所有“活”着的 broker。<br>11. 若 auto.leader.rebalance.enable=true（默认值是true），则启动 partition-rebalance 线程。<br>12. 若 delete.topic.enable=true 且Delete Topic Patch(/admin/delete_topics)中有值，则删除相应的Topic。</p><h2 id="6-consumer-消费消息"><a href="#6-consumer-消费消息" class="headerlink" title="6. consumer 消费消息"></a><strong>6. consumer 消费消息</strong></h2><h3 id="6-1-consumer-API"><a href="#6-1-consumer-API" class="headerlink" title="6.1 consumer API"></a>6.1 consumer API</h3><p>kafka 提供了两套 consumer API：</p><p>1. The high-level Consumer API<br>2. The SimpleConsumer API</p><p> 其中 high-level consumer API 提供了一个从 kafka 消费数据的高层抽象，而 SimpleConsumer API 则需要开发人员更多地关注细节。</p><h4 id="6-1-1-The-high-level-consumer-API"><a href="#6-1-1-The-high-level-consumer-API" class="headerlink" title="6.1.1 The high-level consumer API"></a>6.1.1 The high-level consumer API</h4><p>high-level consumer API 提供了 consumer group 的语义，一个消息只能被 group 内的一个 consumer 所消费，且 consumer 消费消息时不关注 offset，最后一个 offset 由 zookeeper 保存。</p><p>使用 high-level consumer API 可以是多线程的应用，应当注意：</p><p>1. 如果消费线程大于 patition 数量，则有些线程将收不到消息<br>2. 如果 patition 数量大于线程数，则有些线程多收到多个 patition 的消息<br>3. 如果一个线程消费多个 patition，则无法保证你收到的消息的顺序，而一个 patition 内的消息是有序的</p><h4 id="6-1-2-The-SimpleConsumer-API"><a href="#6-1-2-The-SimpleConsumer-API" class="headerlink" title="6.1.2 The SimpleConsumer API"></a>6.1.2 The SimpleConsumer API</h4><p>如果你想要对 patition 有更多的控制权，那就应该使用 SimpleConsumer API，比如：</p><p>1. 多次读取一个消息<br>2. 只消费一个 patition 中的部分消息<br>3. 使用事务来保证一个消息仅被消费一次</p><p> 但是使用此 API 时，partition、offset、broker、leader 等对你不再透明，需要自己去管理。你需要做大量的额外工作：</p><p>1. 必须在应用程序中跟踪 offset，从而确定下一条应该消费哪条消息<br>2. 应用程序需要通过程序获知每个 Partition 的 leader 是谁<br>3. 需要处理 leader 的变更</p><p> 使用 SimpleConsumer API 的一般流程如下：</p><p>1. 查找到一个“活着”的 broker，并且找出每个 partition 的 leader<br>2. 找出每个 partition 的 follower<br>3. 定义好请求，该请求应该能描述应用程序需要哪些数据<br>4. fetch 数据<br>5. 识别 leader 的变化，并对之作出必要的响应</p><blockquote><p>以下针对 high-level Consumer API 进行说明。</p></blockquote><h3 id="6-2-consumer-group"><a href="#6-2-consumer-group" class="headerlink" title="6.2 consumer group"></a>6.2 consumer group</h3><p>如 2.2 节所说， kafka 的分配单位是 patition。每个 consumer 都属于一个 group，一个 partition 只能被同一个 group 内的一个 consumer 所消费（也就保障了一个消息只能被 group 内的一个 consuemr 所消费），但是多个 group 可以同时消费这个 partition。</p><p>kafka 的设计目标之一就是同时实现离线处理和实时处理，根据这一特性，可以使用 spark/Storm 这些实时处理系统对消息在线处理，同时使用 Hadoop 批处理系统进行离线处理，还可以将数据备份到另一个数据中心，只需要保证这三者属于不同的 consumer group。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka9.jpg" alt="image"></p><h2 id="6-3-消费方式"><a href="#6-3-消费方式" class="headerlink" title="6.3 消费方式"></a><strong>6.3 消费方式</strong></h2><p>consumer 采用 pull 模式从 broker 中读取数据。</p><p>push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p><p>对于 Kafka 而言，pull 模式更合适，它可简化 broker 的设计，consumer 可自主控制消费消息的速率，同时 consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p><h3 id="6-4-consumer-delivery-guarantee"><a href="#6-4-consumer-delivery-guarantee" class="headerlink" title="6.4 consumer delivery guarantee"></a>6.4 consumer delivery guarantee</h3><p>如果将 consumer 设置为 autocommit，consumer 一旦读到数据立即自动 commit。如果只讨论这一读取消息的过程，那 Kafka 确保了 Exactly once。</p><p>但实际使用中应用程序并非在 consumer 读取完数据就结束了，而是要进行进一步处理，而数据处理与 commit 的顺序在很大程度上决定了consumer delivery guarantee：</p><p><strong>1.读完消息先 commit 再处理消息。</strong><br>    这种模式下，如果 consumer 在 commit 后还没来得及处理消息就 crash 了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于 At most once<br><strong>2.读完消息先处理再 commit。</strong><br>    这种模式下，如果在处理完消息之后 commit 之前 consumer crash 了，下次重新开始工作时还会处理刚刚未 commit 的消息，实际上该消息已经被处理过了。这就对应于 At least once。<br><strong>3.如果一定要做到 Exactly once，就需要协调 offset 和实际操作的输出。</strong><br>    精典的做法是引入两阶段提交。如果能让 offset 和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer 拿到数据后可能把数据放到 HDFS，如果把最新的 offset 和数据本身一起写到 HDFS，那就可以保证数据的输出和 offset 的更新要么都完成，要么都不完成，间接实现 Exactly once。（目前就 high-level API而言，offset 是存于Zookeeper 中的，无法存于HDFS，而SimpleConsuemr API的 offset 是由自己去维护的，可以将之存于 HDFS 中）</p><p>总之，Kafka 默认保证 At least once，并且允许通过设置 producer 异步提交来实现 At most once（见文章《kafka consumer防止数据丢失》）。而 Exactly once 要求与外部存储系统协作，幸运的是 kafka 提供的 offset 可以非常直接非常容易得使用这种方式。</p><p>更多关于 kafka 传输语义的信息请参考《Message Delivery Semantics》。</p><h3 id="6-5-consumer-rebalance"><a href="#6-5-consumer-rebalance" class="headerlink" title="6.5 consumer rebalance"></a>6.5 consumer rebalance</h3><p>当有 consumer 加入或退出、以及 partition 的改变（如 broker 加入或退出）时会触发 rebalance。consumer rebalance算法如下：</p><p>1. 将目标 topic 下的所有 partirtion 排序，存于PT<br>2. 对某 consumer group 下所有 consumer 排序，存于 CG，第 i 个consumer 记为 Ci<br>3. N=size(PT)/size(CG)，向上取整<br>4. 解除 Ci 对原来分配的 partition 的消费权（i从0开始）<br>5. 将第i*N到（i+1）*N-1个 partition 分配给 Ci</p><p>在 0.8.*版本，每个 consumer 都只负责调整自己所消费的 partition，为了保证整个consumer group 的一致性，当一个 consumer 触发了 rebalance 时，该 consumer group 内的其它所有其它 consumer 也应该同时触发 rebalance。这会导致以下几个问题：</p><p><strong>1.Herd effect</strong><br>　　任何 broker 或者 consumer 的增减都会触发所有的 consumer 的 rebalance<br><strong>2.Split Brain</strong><br>　　每个 consumer 分别单独通过 zookeeper 判断哪些 broker 和 consumer 宕机了，那么不同 consumer 在同一时刻从 zookeeper 看到的 view 就可能不一样，这是由 zookeeper 的特性决定的，这就会造成不正确的 reblance 尝试。<br><strong>3. 调整结果不可控</strong><br>　　所有的 consumer 都并不知道其它 consumer 的 rebalance 是否成功，这可能会导致 kafka 工作在一个不正确的状态。</p><p>基于以上问题，kafka 设计者考虑在0.9.*版本开始使用中心 coordinator 来控制 consumer rebalance，然后又从简便性和验证要求两方面考虑，计划在 consumer 客户端实现分配方案。（见文章《Kafka Detailed Consumer Coordinator Design》和《Kafka Client-side Assignment Proposal》），此处不再赘述。</p><h2 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a><strong>七、注意事项</strong></h2><h3 id="7-1-producer-无法发送消息的问题"><a href="#7-1-producer-无法发送消息的问题" class="headerlink" title="7.1 producer 无法发送消息的问题"></a>7.1 producer 无法发送消息的问题</h3><p>最开始在本机搭建了kafka伪集群，本地 producer 客户端成功发布消息至 broker。随后在服务器上搭建了 kafka 集群，在本机连接该集群，producer 却无法发布消息到 broker（奇怪也没有抛错）。最开始怀疑是 iptables 没开放，于是开放端口，结果还不行（又开始是代码问题、版本问题等等，倒腾了很久）。最后没办法，一项一项查看 server.properties 配置，发现以下两个配置：</p><pre><code>\# The address the socket server listens on. It will get the value returned from   \# java.net.InetAddress.getCanonicalHostName() if not configured.  \#   FORMAT:  \#     listeners = security\_protocol://host\_name:port  \#   EXAMPLE:  \#     listeners = PLAINTEXT://your.host.name:9092  listeners=PLAINTEXT://:9092　# Hostname and port the broker will advertise to producers and consumers. If not set,   　# it uses the value for "listeners" if configured. Otherwise, it will use the value  　# returned from java.net.InetAddress.getCanonicalHostName().  　#advertised.listeners=PLAINTEXT://your.host.name:9092</code></pre><p>以上说的就是 advertised.listeners 是 broker 给 producer 和 consumer 连接使用的，如果没有设置，就使用 listeners，而如果 host_name 没有设置的话，就使用 java.net.InetAddress.getCanonicalHostName() 方法返回的主机名。</p><p>修改方法：</p><p>1. listeners=PLAINTEXT://121.10.26.XXX:9092<br>2. advertised.listeners=PLAINTEXT://121.10.26.XXX:9092</p><p>修改后重启服务，正常工作。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ笔记</title>
      <link href="/2019/10/21/2019-05-12-rabbitmq/"/>
      <url>/2019/10/21/2019-05-12-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h3 id="什么叫消息队列"><a href="#什么叫消息队列" class="headerlink" title="什么叫消息队列"></a>什么叫消息队列</h3><p>  消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。<br>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p><h3 id="为何用消息队列"><a href="#为何用消息队列" class="headerlink" title="为何用消息队列"></a>为何用消息队列</h3><p>  从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用 MQ 呢？</p><p>  以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。<br>以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。</p><h3 id="RabbitMQ-特点"><a href="#RabbitMQ-特点" class="headerlink" title="RabbitMQ 特点"></a>RabbitMQ 特点</h3><p>  RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。<br>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability）</li><li>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由（Flexible Routing）</li></ol><p>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。<br>3. 消息集群（Clustering）</p><p>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。<br>4. 高可用（Highly Available Queues）<br>  队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。<br>5. 多种协议（Multi-protocol）</p><p>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。<br>6. 多语言客户端（Many Clients）</p><p>RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。<br>7. 管理界面（Management UI）</p><p>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。<br>8. 跟踪机制（Tracing）</p><p>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。<br>9. 插件机制（Plugin System）</p><p>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p><h3 id="RabbitMQ-中的概念模型"><a href="#RabbitMQ-中的概念模型" class="headerlink" title="RabbitMQ 中的概念模型"></a>RabbitMQ 中的概念模型</h3><h4 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h4><p>所有 MQ 产品从模型抽象上来说都是一样的过程：</p><p>  消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq1.png" alt="image"></p><h4 id="RabbitMQ-基本概念"><a href="#RabbitMQ-基本概念" class="headerlink" title="RabbitMQ 基本概念"></a>RabbitMQ 基本概念</h4><p>  上面只是最简单抽象的描述，具体到 RabbitMQ 则有更详细的概念需要解释。上面介绍过 RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq2.png" alt="image"></p><ol><li>Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</li><li>Publisher<br>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li><li>Binding<br>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li><li>Queue<br>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li><li>Connection<br>网络连接，比如一个TCP连接。</li><li>Channel<br>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li><li>Consumer<br>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li><li>Virtual Host<br>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</li><li>Exchange<br>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li><li>Broker<br>表示消息队列服务器实体。</li></ol><h4 id="RabbitMQ的基本原理"><a href="#RabbitMQ的基本原理" class="headerlink" title="RabbitMQ的基本原理"></a>RabbitMQ的基本原理</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq3.png" alt="image"></p><p>  通过上面这张应用相结合的结构图既能够清晰的看清楚整体的send Message到Receive Message的一个大致的流程。</p><p>　<strong>Queue</strong><br>　<br>  Queue（队列）RabbitMQ的作用是存储消息，队列的特性是先进先出。上图可以清晰地看到Client A和Client B是生产者，生产者生产消息最终被送到RabbitMQ的内部对象Queue中去，而消费者则是从Queue队列中取出数据。可以简化成表示为：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq4.png" alt="image"></p><p>   生产者Send Message “A”被传送到Queue中，消费者发现消息队列Queue中有订阅的消息，就会将这条消息A读取出来进行一些列的业务操作。这里只是一个消费正对应一个队列Queue，也可以多个消费者订阅同一个队列Queue，当然这里就会将Queue里面的消息平分给其他的消费者，但是会存在一个一个问题就是如果每个消息的处理时间不同，就会导致某些消费者一直在忙碌中，而有的消费者处理完了消息后一直处于空闲状态，因为前面已经提及到了Queue会平分这些消息给相应的消费者。这里我们就可以使用prefetchCount来限制每次发送给消费者消息的个数。详情见下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq5.png" alt="image"></p><p>  这里的prefetchCount=1是指每次从Queue中发送一条消息来。等消费者处理完这条消息后Queue会再发送一条消息给消费者。<br><strong>Exchange</strong><br>  我们在开篇的时候就留了一个坑，就是那个应用结构图里面，消费者Client A和消费者Client B是如何知道我发送的消息是给Queue1还是给Queue2，有没有过这个问题，那么我们就来解开这个面纱，看看到底是个什么构造。首先明确一点就是生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，当然这里还会对不符合路由规则的消息进行丢弃掉，这里指的是后续要谈到的Exchange Type。那么Exchange是怎样将消息准确的推送到对应的Queue的呢？那么这里的功劳最大的当属Binding，RabbitMQ是通过Binding将Exchange和Queue链接在一起，这样Exchange就知道如何将消息准确的推送到Queue中去。简单示意图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq6.png" alt="image"></p><p>   <strong>在绑定（Binding）Exchange和Queue的同时，一般会指定一个Binding Key，生产者将消息发送给Exchange的时候，一般会产生一个Routing Key，当Routing Key和Binding Key对应上的时候，消息就会发送到对应的Queue中去</strong>。那么Exchange有四种类型，不同的类型有着不同的策略。也就是表明不同的类型将决定绑定的Queue不同，换言之就是说生产者发送了一个消息，Routing Key的规则是A，那么生产者会将Routing Key=A的消息推送到Exchange中，这时候Exchange中会有自己的规则，对应的规则去筛选生产者发来的消息，如果能够对应上Exchange的内部规则就将消息推送到对应的Queue中去。那么接下来就来详细讲解下Exchange里面类型。</p><h5 id="Exchange-Type"><a href="#Exchange-Type" class="headerlink" title="Exchange Type"></a>Exchange Type</h5><ul><li>fanout</li></ul><p>  fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq7.png" alt="image"></p><p>上图所示，生产者（P）生产消息1将消息1推送到Exchange，由于Exchange Type=fanout这时候会遵循fanout的规则将消息推送到所有与它绑定Queue，也就是图上的两个Queue最后两个消费者消费。</p><ul><li>direct</li></ul><p>  direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq8.png" alt="image"></p><p>当生产者（P）发送消息时Rotuing key=booking时，这时候将消息传送给Exchange，Exchange获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的Queue，这时发现Queue1和Queue2都符合，就会将消息传送给这两个队列，如果我们以Rotuing key=create和Rotuing key=confirm发送消息时，这时消息只会被推送到Queue2队列中，其他Routing Key的消息将会被丢弃。</p><ul><li>topic</li></ul><p>  前面提到的direct规则是严格意义上的匹配，换言之Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue，那么topic这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。它的约定是：</p><ol><li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</li><li>binding key与routing key一样也是句点号“. ”分隔的字符串</li><li>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li><li><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq9.png" alt="image"></li></ol><p>  当生产者发送消息Routing Key=F.C.E的时候，这时候只满足Queue1，所以会被路由到Queue中，如果Routing Key=A.C.E这时候会被同是路由到Queue1和Queue2中，如果Routing Key=A.F.B时，这里只会发送一条消息到Queue2中。</p><ul><li>headers</li></ul><p>  headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><p>该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。<br>这里在对其进行简要的表格整理：</p><table><thead><tr><th>类型名称</th><th>类型描述</th></tr></thead><tbody><tr><td>fanout</td><td>把所有发送到该Exchange的消息路由到所有与它绑定的Queue中</td></tr><tr><td>direct</td><td>Routing Key==Binding Key</td></tr><tr><td>topic</td><td>我这里自己总结的简称模糊匹配</td></tr><tr><td>headers</td><td>Exchange不依赖于routingkey与bindingkey的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。</td></tr></tbody></table><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><p><strong>ConnectionFactory、Connection、Channel</strong></p><p>　　  ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。ConnectionFactory为Connection的制造工厂。</p><p>　  Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。<br>　　Connection就是建立一个TCP连接，生产者和消费者的都是通过TCP的连接到RabbitMQ Server中的，这个后续会再程序中体现出来。</p><p>　　  Channel虚拟连接，建立在上面TCP连接的基础上，数据流动都是通过Channel来进行的。为什么不是直接建立在TCP的基础上进行数据流动呢？如果建立在TCP的基础上进行数据流动，建立和关闭TCP连接有代价。频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。<br>AMQP 中的消息路由</p><p>  AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2019/10/21/2019-04-18-springboot/"/>
      <url>/2019/10/21/2019-04-18-springboot/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><h5 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h5><pre class=" language-java"><code class="language-java"> 微服务架构就是将单一程序开发成一个微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信，通常是HTTP RESTFUL API。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</code></pre><h5 id="微服务由来"><a href="#微服务由来" class="headerlink" title="微服务由来"></a>微服务由来</h5><p> 微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。</p><h5 id="为什么需要微服务？"><a href="#为什么需要微服务？" class="headerlink" title="为什么需要微服务？"></a>为什么需要微服务？</h5><p> 在传统的IT行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了SOA服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。最终 SOA 看起来很美，但却成为了企业级奢侈品，中小公司都望而生畏。</p><h5 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h5><ol><li>将复杂的业务拆分成多个小的业务，每个业务拆分成一个服务，将复杂的问题简单化。利于分工，降低新人的学习成本。 </li><li>微服务系统是分布式系统，业务与业务之间完全解耦，随着业务的增加可以根据业务再拆分，具有极强的横向扩展能力。面对搞并发的场景可以将服务集群化部署，加强系统负载能力。 </li><li>服务间采用HTTP协议通信，服务与服务之间完全独立。每个服务可以根据业务场景选取合适的编程语言和数据库。 </li><li>微服务每个服务都是独立部署的，每个服务的修改和部署对其他服务没有影响。</li></ol><h5 id="微服务和SOA的关系"><a href="#微服务和SOA的关系" class="headerlink" title="微服务和SOA的关系"></a>微服务和SOA的关系</h5><p>SOA即面向服务的架构，SOA是根据企业服务总线（ESB）模式来整合集成大量单一庞大的系统，微服务可以说是SOA的一种实现，将复杂的业务组件化。但它比ESB实现的SOA更加的轻便敏捷和简单。</p><h3 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h3><p>随着使用 Spring 进行开发的个人和企业越来越多，Spring 也慢慢从一个单一简洁的小框架变成一个大而全的开源软件，Spring 的边界不断进行扩充，到了后来 Spring 几乎可以做任何事情，市面上主流的开源软件、中间件都有 Spring 对应组件支持，人们在享用 Spring 的便利之后，也遇到了一些问题。</p><p>2013 年，微服务的概念也慢慢兴起，快速开发微小独立的应用变得更为急迫，Spring刚好处在这样一个交叉点上，于 2013 年初启动了 Spring Boot 项目的研发。2014 年，Spring Boot 伴随着 Spring 4.0 诞生发布了第一个正式版本。</p><p>Spring Boot 并不是要成为 Spring 平台里面众多“Foundation”层项目的替代者。Spring Boot 的目标不在于为已解决的问题域提供新的解决方案，而是为平台带来另一种开发体验，从而简化对这些已有技术的使用。对于已经熟悉 Spring 生态系统的开发人员来说，Spring Boot 是一个很理想的选择；对于采用 Spring 技术的新人来说，Spring Boot 提供一种更简洁的方式来使用这些技术。</p><h4 id="Spring-Boot-的主要优点："><a href="#Spring-Boot-的主要优点：" class="headerlink" title="Spring Boot 的主要优点："></a>Spring Boot 的主要优点：</h4><ul><li><p>为所有 Spring 开发者更快的入门</p></li><li><p>开箱即用，提供各种默认配置来简化项目配置</p></li><li><p>内嵌式容器简化 Web 项目</p></li><li><p>没有冗余代码生成和 XML 配置的要求</p><p>简言之，Spring Boot 是一个快速开发的框架,能够快速的整合第三方框架，简化 XML 配置，全部采用注解形式，内置 Tomcat 容器,帮助开发者能够实现快速开发，简化了应用系统的初始搭建以及开发过程。</p></li></ul><h3 id="与其他框架的区别"><a href="#与其他框架的区别" class="headerlink" title="与其他框架的区别"></a>与其他框架的区别</h3><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring，因此该框架所具备的功能，是为了让人们更容易的使用 Spring。所以说没有 Spring 强大的功能和生态，就不会有后期 Spring Boot 的火热，Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。</p><h4 id="SpringBoot-和-SpringMVC-区别"><a href="#SpringBoot-和-SpringMVC-区别" class="headerlink" title="SpringBoot 和 SpringMVC 区别"></a>SpringBoot 和 SpringMVC 区别</h4><p>SpringBoot 是一个快速开发的框架,能够快速的整合第三方框架，简化 XML 配置，全部采用注解形式，内<br>嵌 Tomcat 容器,帮助开发者能够实现快速开发。SpringMVC 是一个封装了 Servlet API 的 MVC 框架，就像<br>其它的 MVC 框架，比如 Struts 一样负责处理 web 请求。SpringBoot 的 Web 组件默认集成的是 SpringMVC<br>框架。SpringMVC 通常被叫做控制层框架。</p><h4 id="SpringBoot-和-SpringCloud-区别"><a href="#SpringBoot-和-SpringCloud-区别" class="headerlink" title="SpringBoot 和 SpringCloud 区别"></a>SpringBoot 和 SpringCloud 区别</h4><p>SpringCloud 依赖于 SpringBoot 组件，或者说 Spring Cloud 构建于 Spring Boot 之上。它为微服务中涉及的<br>配置管理、服务治理、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理通<br>常我们使用 SpringMVC 编写 http 协议接口，同时使用 SpringCloud 作为一套完整的微服务解决框架。</p><h4 id="Spring-Boot-的核心：约定优于配置"><a href="#Spring-Boot-的核心：约定优于配置" class="headerlink" title="Spring Boot 的核心：约定优于配置"></a>Spring Boot 的核心：约定优于配置</h4><p>那么什么是约定优于配置呢？</p><p>约定优于配置（Convention Over Configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量、获得简单的好处，而又不失灵活性。</p><p>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为“user_info”，才需写有关这个名字的配置。</p><p>我们可以按照这个思路来设想，我们约定 Controller 层就是 Web 请求层可以省略 MVC 的配置；我们约定在 Service 结尾的类自动注入事务，就可以省略了 Spring 的切面事务配置。</p><p>在 Spring 体系中，Spring Boot JPA 就是约定优于配置最佳实现之一，不需要关注表结构，我们约定类名即是表名，属性名即是表的字段，String 对应 varchar，long 对应 bigint，只有需要一些特殊要求的属性，我们再单独进行配置，按照这个约定我们可以将以前的工作大大简化。</p><p>Spring Boot 体系将约定优于配置的思想展现得淋漓尽致，小到配置文件、中间件的默认配置，大到内置容器、生态中的各种 Starters 无不遵循此设计规则。Spring Boot 鼓励各软件组织方创建自己的 Starter，创建 Starter 的核心组件之一就是 autoconfigure 模块，也是 Starter 的核心功能，在启动的时候进行自动装配，属性默认化配置。</p><p>可以说正是因为 Spring Boot 简化的配置和众多的 Starters 才让 Spring Boot 变得简单、易用、快速上手，也可以说正是约定优于配置的思想彻底落地才让 Spring Boot 走向辉煌。Spring Boot 约定优于配置的思想让 Spring Boot 项目非常容易上手，让编程变得更简单，其实编程本该很简单，简单才是编程的美。</p><h4 id="Spring-Boot-2-0-都更新了什么"><a href="#Spring-Boot-2-0-都更新了什么" class="headerlink" title="Spring Boot 2.0 都更新了什么"></a>Spring Boot 2.0 都更新了什么</h4><p>2018 年 3 月 1 号 Spring Boot 2.0.0.RELEASE 正式发布，这是 Spring Boot 1.0 发布 4 年之后第一次重大修订，因此有多新功能和特性值得关注！在 Spring Boot 官方博客中我们了解到：Spring Boot 2.0 版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。</p><p>我们将 Spring Boot 2.0 更新的技术分为三类进行解读：</p><p>第一类，基础环境升级；<br><br>第二类，默认软件替换和优化；<br><br>第三类，新技术的引入。<br><br>基础环境升级<br><br>最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7<br><br>Spring Boot 2.0 要求 Java 8 作为最低版本，许多现有的 API 已更新，以利用 Java 8 的特性。例如，接口上的默认方法，函数回调以及新的 API，如 javax.time。如果你正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，需要升级你的 JDK。</p><p>Spring Boot 2.0 通过测试可以在 JDK 9 下正常运行，同时 Spring Boot 2.0 宣布不再支持 Java 6 和 7，据我了解国内绝大部分互联网公司的基本环境还在 JDK 7 或者 6 环境下运行，考虑升级 Spring Boot 2.0 的团队需要考虑这个因素。</p><p>依赖组件升级<br><br>Spring Boot 2.0 基于 Spring Framework 5 构建，本次 Spring Boot 的升级，同时也升级了部分其依赖的第三方组件，主要有以下几个：</p><ul><li>Jetty 9.4，Jetty 是一个开源的 Servlet 容器，它为基于 Java 的 Web 内容，例如 JSP 和 Servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。</li><li>Tomcat 8.5，Apache Tomcat 8.5.x 旨在取代 8.0.x，完全支持 Java 9。</li><li>Flyway 5，Flyway 是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway 可以像 SVN 管理不同人的代码那样，管理不同人的 SQL 脚本，从而做到数据库同步。</li><li>Hibernate 5.2，Hibernate 是一款非常流行的 ORM 框架。</li><li>Gradle 3.4，Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。</li><li>Thymeleaf 3.0，Thymeleaf 3 相对于 Thymeleaf 2 有非常大的性能提升。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quartz</title>
      <link href="/2019/10/21/2019-04-11-quartz/"/>
      <url>/2019/10/21/2019-04-11-quartz/</url>
      
        <content type="html"><![CDATA[<p><img src="http://www.quartz-scheduler.org/images/favicon.ico" alt="quartz.ico"></p><h3 id="一、什么是Quartz"><a href="#一、什么是Quartz" class="headerlink" title="一、什么是Quartz?"></a>一、什么是Quartz?</h3><p>Quartz是一个完全由Java编写的开源作业调度框架，为在Java应用程序中进行作业调度提供了简单却强大的机制。Quartz允许开发人员根据时间间隔来调度作业。它实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。简单地创建一个org.quarz.Job接口的Java类。</p><h4 id="Quartz的特点；"><a href="#Quartz的特点；" class="headerlink" title="Quartz的特点；"></a>Quartz的特点；</h4><p>作为一个优秀的开源调度框架，Quartz具有以下特点：</p><p>① 强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；</p><p>②   灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；</p><p>③ 分布式和集群能力，Terracotta 收购后在原来功能基础上作了进一步提升。</p><p>④ Quartz 很容易与 Spring 集成实现灵活可配置的调度功能。</p><h4 id="Quartz专用词汇说明；"><a href="#Quartz专用词汇说明；" class="headerlink" title="Quartz专用词汇说明；"></a>Quartz专用词汇说明；</h4><p>下面是本文中用到的一些专用词汇，在此声明：</p><p>scheduler：</p><p>任务调度器</p><p>trigger：</p><p>触发器，用于定义任务调度时间规则</p><p>job：</p><p>任务，即被调度的任务</p><p>misfire：</p><p>错过的，指本来应该被执行但实际没有被执行的任务调度</p><h4 id="Quartz任务调度基本实现原理；"><a href="#Quartz任务调度基本实现原理；" class="headerlink" title="Quartz任务调度基本实现原理；"></a>Quartz任务调度基本实现原理；</h4><p>Quartz任务调度的核心元素是 scheduler, trigger 和 job，其中 trigger 和 job 是任务调度的元数据， scheduler 是实际执行调度的控制器。</p><p>在 Quartz 中，trigger 是用于定义调度时间的元素，即按照什么时间规则去执行任务。Quartz 中主要提供了四种类型的 trigger：SimpleTrigger，CronTirgger，DateIntervalTrigger，和 NthIncludedDayTrigger。这四种 trigger 可以满足企业应用中的绝大部分需求。</p><p>在 Quartz 中，job 用于表示被调度的任务。主要有两种类型的 job：无状态的（stateless）和有状态的（stateful）。对于同一个 trigger 来说，有状态的 job 不能被并行执行，只有上一次触发的任务被执行完之后，才能触发下一次执行。Job 主要有两种属性：volatility 和 durability，其中 volatility 表示任务是否被持久化到数据库存储，而 durability 表示在没有 trigger 关联的时候任务是否被保留。两者都是在值为 true 的时候任务被持久化或保留。一个 job 可以被多个 trigger 关联，但是一个 trigger 只能关联一个 job。</p><p>在 Quartz 中， scheduler 由 scheduler 工厂创建：DirectSchedulerFactory 或者 StdSchedulerFactory。 第二种工厂StdSchedulerFactory 使用较多，因为 DirectSchedulerFactory 使用起来不够方便，需要作许多详细的手工编码设置。 Scheduler 主要有三种：RemoteMBeanScheduler， RemoteScheduler 和 StdScheduler。</p><h3 id="Cron表达式详解"><a href="#Cron表达式详解" class="headerlink" title="Cron表达式详解"></a>Cron表达式详解</h3><p>【1】cron表达式至少要有6个(最多有7个)以空格分割的事件元素。按照从左到右的顺序，它们分别为：</p><table><thead><tr><th>位置</th><th>时间域</th><th>允许值</th><th>特殊值</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>2</td><td>分钟</td><td>0-59</td><td>, - * /</td></tr><tr><td>3</td><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>4</td><td>日期</td><td>1-31</td><td>, - * ? / L W C</td></tr><tr><td>5</td><td>月份</td><td>1-12</td><td>, - * /</td></tr><tr><td>6</td><td>星期</td><td>1-7</td><td>, - * ? / L C #</td></tr><tr><td>7</td><td>年份（可选）</td><td>1-31</td><td>, - * /</td></tr></tbody></table><p>星号(*)：可用在所有字段中，表示对应时间域的每一个时刻，例如， 在分钟字段时，表示“每分钟”；</p><p>问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；</p><p>减号(-)：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；</p><p>逗号(,)：表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；</p><p>斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；</p><p>L：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；如果L用在星期中，则表示星期六，等同于7。但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后X天”，例如，6L表示该月的最后星期五；</p><p>W：该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如15W表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意关联的匹配日期不能够跨月，如你指定1W，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天。W字符串只能指定单一日期，而不能指定日期范围；</p><p>LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日；</p><p>井号(#)：该字符只能在星期字段中使用，表示当月某个工作日。如6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发；</p><p>C：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。</p><p><strong>Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> quartz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2019/10/21/2019-04-11-idea-git-hexo-de-shi-yong-fly-tom/"/>
      <url>/2019/10/21/2019-04-11-idea-git-hexo-de-shi-yong-fly-tom/</url>
      
        <content type="html"><![CDATA[<h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><h2 id="git的基本工作流程："><a href="#git的基本工作流程：" class="headerlink" title="git的基本工作流程："></a>git的基本工作流程：</h2><p><a href="http://img2.tbcdn.cn/L1/461/1/ac6d9422c3f843017b2441b212f39ebc00697e4c" target="_blank" rel="noopener"><img src="http://img2.tbcdn.cn/L1/461/1/ac6d9422c3f843017b2441b212f39ebc00697e4c" alt="git_status"></a></p><ul><li>git clone：将远程的Master分支代码克隆到本地仓库</li><li>git checkout：切出分支出来开发</li><li>git add：将文件加入库跟踪区</li><li>git commit：将库跟踪区改变的代码提交到本地代码库中</li><li>git push： 将本地仓库中的代码提交到远程仓库</li></ul><h3 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h3><ul><li>主分支<ul><li>master分支：存放随时可供生产环境中的部署的代码</li><li>develop分支：存放当前最新开发成果的分支，当代码足够稳定时可以合并到master分支上去。</li></ul></li><li>辅助分支<ul><li>feature分支：开发新功能使用，最终合并到develop分支或抛弃掉</li><li>release分支：做小的缺陷修正、准备发布版本所需的各项说明信息</li><li>hotfix分支：代码的紧急修复工作</li></ul></li></ul><ul><li><p>Git与提交有关的三个命令对应的操作，Add命令是把文件从IDE的工作目录添加到本地仓库的stage区，Commit命令把stage区的暂存文件提交到当前分支的仓库，并清空stage区。Push命令把本地仓库的提交同步到远程仓库。</p></li><li><p>获取更新有两个命令：Fetch和Pull，Fetch是从远程仓库下载文件到本地的origin/master，然后可以手动对比修改决定是否合并到本地的master库。Push则是直接下载并合并。</p></li><li><p>创建分支</p><p><img src="https://img-blog.csdn.net/20160912171844429" alt="图片"></p><p>选择New Branch并输入一个分支的名称</p><p>   <img src="https://img-blog.csdn.net/20160912171858663" alt="图片2"></p></li></ul><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>现在我们要把 dev-100 分支上的代码合并到 master 主分支上<br>先切换到 master 分支<br><img src="http://img12345.5-project.com/blog/20181102172230.png" alt="img"></p><p>合并 dev-100 分支到 master 分支之前，建议先对 master 代码进行 pull 更新操作，然后再执行 Merge into Current</p><p><img src="http://img12345.5-project.com/blog/20181102172650.png" alt="img"></p><pre><code>【new branch】新建分支【local branches】本地分支【master】表示当前是主分支【remote branches】远程仓库分支。我在这里配置了两个远程仓库，所以这里显示2个。</code></pre><p>如果没有冲突，dev-100 中的代码就会被合并到 master 分支上了，合并成功后，需要 <code>push</code> 才能推送到远程仓库,一般情况下只需要将分支提交到本地仓库，不需要将分支提交远程仓库。如果将所有的分支都提交到远程仓库，会让远程仓库杂乱无章。<br><img src="http://img12345.5-project.com/blog/20181102171807.png" alt="img"></p><h2 id="取消分支合并"><a href="#取消分支合并" class="headerlink" title="取消分支合并"></a>取消分支合并</h2><p>合并完成后，但是由于一些问题，我们想要取消本次合并，右键 git，选择 Reset HEAD<br><img src="http://img12345.5-project.com/blog/20181102173946.png" alt="img"><br><img src="http://img12345.5-project.com/blog/20181102174125.png" alt="img"></p><p>HEAD^ 是还原到上一个版本，HEAD^^ 是还原到上上一个版本。<br>Reset Type 有三种：</p><ul><li>mixed 默认方式，只保留源码，回退commit和index信息</li><li>soft 回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit</li><li>hard 彻底回退，本地源码也会变成上一个版本内容</li></ul><p>一般使用默认的 mixed 或者粗暴的 hard 方式。<br>我们这里是取消合并，所以选择 <strong>Hard</strong> 方式，并且是<strong>HEAD^</strong>还原到上一个版本，回退后恢复了原来 master 的代码。<br><img src="http://img12345.5-project.com/blog/20181102171518.png" alt="img"></p><h2 id="解决合并冲突问题"><a href="#解决合并冲突问题" class="headerlink" title="解决合并冲突问题"></a>解决合并冲突问题</h2><p>接下来演示合并冲突，此时是在 master 分支，我们修改文件，并 commit 以及 push 到远程仓库。<br><img src="http://img12345.5-project.com/blog/20181102174704.png" alt="img"></p><p>此时再把 dev-100 分支合并到 master 分支就会提示冲突。<br><img src="http://img12345.5-project.com/blog/20181102175031.png" alt="img"></p><p>双击冲突文件，处理冲突。<br><img src="http://img12345.5-project.com/blog/20181102175217.png" alt="img"><br>处理完成后，点击 apply 即可，如果有多个冲突文件，都按照这种方式处理，这是我们处理完冲突之后的代码。<br><img src="http://img12345.5-project.com/2018110315412022049329.png" alt="img"></p><p>dev-100 分支已经被成功合并到 master 了，就可以删除了。可以直接删除远程 dev-100 分支，删除时 IDEA 会提示是否同时删除本地的 dev-100 分支，勾选即可。</p><p>现在我们把分支合并的结果 push 到远程仓库。</p><h2 id="代码暂存之git-stash"><a href="#代码暂存之git-stash" class="headerlink" title="代码暂存之git stash"></a>代码暂存之git stash</h2><p>编号 100 的需求完成之后，现在我们又接到一个新的需求，正在 dev-101 分支进行开发，开发还未完成。<br><img src="http://img12345.5-project.com/blog/20181102180114.png" alt="img"></p><p>突然线上出现 bug，需要我们紧急进行修改，于是我们要基于最新的 master 分支新建一个 bug 分支 bug-12，需要先切换到 master 分支，但是当前分支的代码没有commit， 如果直接切换到 master 分支的话，dev-101 分支上的新增代码就会跑到 master 分支，而代码又不能此时 commit ，于是就轮到 stash 出场了。<br><img src="http://img12345.5-project.com/blog/20181102180427.png" alt="img"><br>Stash 会保存当前工作进度，会把暂存区和工作区的改动保存起来。<br><img src="http://img12345.5-project.com/20181103154120204424605.png" alt="img"><br>添加备注，选择 <strong>CREATE STASH</strong>。你会发现当前工作区内的代码被恢复成了原样。<br><img src="http://img12345.5-project.com/2018110315412022049329.png" alt="img"></p><h2 id="代码暂存还原"><a href="#代码暂存还原" class="headerlink" title="代码暂存还原"></a>代码暂存还原</h2><p>此刻切换到 master 分支，并创建 bug-12 分支进行修复 bug，修复完成后合并到 master 分支并 push 到远程仓库，上文已经演示如何合并，在此不再赘述。</p><p>将 bug-12 与 master 合并完成之后，现在要接着写 dev-101 需求代码，首先先切换到 dev-101 分支；<br>但是之前的代码已经被我们放到了 git 的 stash 当中，我们现在要把代码还原到工作区当中。<br>选择 Unstash Changes<br><img src="http://img12345.5-project.com/20181103154120268155941.png" alt="img"><br><img src="http://img12345.5-project.com/20181103154120276883579.png" alt="img"><br>选择之前保存的，同时勾选 Pop stash（还原完成后，会自动删除这个 stash），确定后，工作区之前写的代码就又回来了。<br><img src="http://img12345.5-project.com/blog/20181102180114.png" alt="img"></p><h2 id="Hexo-博客发布流程"><a href="#Hexo-博客发布流程" class="headerlink" title="Hexo 博客发布流程"></a>Hexo 博客发布流程</h2><ol><li>清除缓存<blockquote><p>hexo clean</p></blockquote></li><li>生成静态文件<blockquote><p>hexo g</p></blockquote></li><li>启动本地服务器 （可省略）<blockquote><p>hexo s</p></blockquote></li><li>部署到远程站点<blockquote><p>hexo d</p></blockquote></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch笔记</title>
      <link href="/2019/10/21/2019-04-11-elasticsearch/"/>
      <url>/2019/10/21/2019-04-11-elasticsearch/</url>
      
        <content type="html"><![CDATA[<p>7-2</p><h3 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es8.jpg" alt="image"></p><p><a href="https://my.oschina.net/happyBKs/blog/1798778" target="_blank" rel="noopener">https://my.oschina.net/happyBKs/blog/1798778</a></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>随着业务复杂度的提升以及微服务的兴起，传统单一项目会被按照业务规则进行垂直拆分，另外为了防止单点故障我们也会将重要的服务模块进行集群部署，通过负载均衡进行服务的调用。那么随着节点的增多，各个服务的日志也会散落在各个服务器上。这对于我们进行日志分析带来了巨大的挑战，总不能一台一台的登录去下载日志吧。那么我们需要一种收集日志的工具将散落在各个服务器节点上的日志收集起来，进行统一的查询及管理统计。那么ELK就可以做到这一点。</p><h4 id="Elasticsearch特性"><a href="#Elasticsearch特性" class="headerlink" title="Elasticsearch特性"></a>Elasticsearch特性</h4><ul><li>安装方便：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</li><li>JSON：输入/输出格式为 JSON，意味着不需要定义 Schema，快捷方便</li><li>RESTful：基本所有操作（索引、查询、甚至是配置）都可以通过 HTTP 接口进行</li><li>分布式：节点对外表现对等（每个节点都可以用来做入口）；加入节点自动均衡</li><li>多租户：可根据不同的用途分索引；可以同时操作多个索引</li></ul><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"5i586tn"</span><span class="token punctuation">,</span> // node 名称  <span class="token property">"cluster_name"</span> <span class="token operator">:</span> <span class="token string">"elasticsearch"</span><span class="token punctuation">,</span> // 集群名称  <span class="token property">"cluster_uuid"</span> <span class="token operator">:</span> <span class="token string">"-Ij_g7DrQqeQRYt0BAIY2g"</span><span class="token punctuation">,</span>  <span class="token property">"version"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"number"</span> <span class="token operator">:</span> <span class="token string">"6.6.2"</span><span class="token punctuation">,</span>// es版本号    <span class="token property">"build_flavor"</span> <span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>    <span class="token property">"build_type"</span> <span class="token operator">:</span> <span class="token string">"zip"</span><span class="token punctuation">,</span>    <span class="token property">"build_hash"</span> <span class="token operator">:</span> <span class="token string">"3bd3e59"</span><span class="token punctuation">,</span>    <span class="token property">"build_date"</span> <span class="token operator">:</span> <span class="token string">"2019-03-06T15:16:26.864148Z"</span><span class="token punctuation">,</span>    <span class="token property">"build_snapshot"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"lucene_version"</span> <span class="token operator">:</span> <span class="token string">"7.6.0"</span><span class="token punctuation">,</span>    <span class="token property">"minimum_wire_compatibility_version"</span> <span class="token operator">:</span> <span class="token string">"5.6.0"</span><span class="token punctuation">,</span>    <span class="token property">"minimum_index_compatibility_version"</span> <span class="token operator">:</span> <span class="token string">"5.0.0"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"tagline"</span> <span class="token operator">:</span> <span class="token string">"You Know, for Search"</span><span class="token punctuation">}</span></code></pre><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es1.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es2.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es3.png" alt="image"></p><p>###############################<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es.png" alt="image"></p><p>可以看到，我们成功的创建了一个twitter的节点，当然shard默认是5，我这里设置成了7<br>每一个绿色的小框框代表了一个shard，外面有黑色框框的代表主shard，没有的便是replication，横向的node对应了集群中每一个节点。至此简单的es集群就部署好了。</p><font size="3">Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库--无论是开源还是私有。<p>但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。</p><p>Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p><p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p><ul><li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li><li>一个分布式实时分析搜索引擎</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li></ul><blockquote><p>Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 <strong>RESTful API</strong> 进行通信, 通过端口 9200 和 Elasticsearch 进行通信</p></blockquote><h3 id="es的几个概念："><a href="#es的几个概念：" class="headerlink" title="es的几个概念："></a>es的几个概念：</h3><p>（1） 接近实时（NRT）<br>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒）。</p><p>（2） 集群（cluster）<br>一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。在产品环境中显式地设定这个名字是一个好习惯，但是使用默认值来进行测试/开发也是不错的。</p><p>（3） 节点（node）<br>一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p><p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p><p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p><p>（4） 索引（index）<br>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。索引类似于关系型数据库中Database的概念。在一个集群中，如果你想，可以定义任意多的索引。</p><p>（5） 类型（type）<br>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。类型类似于关系型数据库中Table的概念。<br>         type 在6.0.0已经不赞成使用</p><p>（6）文档（document）<br>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。<br>在一个index/type里面，只要你想，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。文档类似于关系型数据库中Record的概念。实际上一个文档除了用户定义的数据外，还包括_index、_type和_id字段。</p><p>（7） 分片和复制（Primary shards &amp; Primary replicas）<br>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。</p><p>为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。<br>分片之所以重要，主要有两方面的原因：</p><p>允许你水平分割/扩展你的内容容量<br>允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量<br>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p><p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了。这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。复制之所以重要，主要有两方面的原因：</p><p>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。<br>扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行<br>总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制数量，但是不能改变分片的数量。</p><p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。一个索引的多个分片可以存放在集群中的一台主机上，也可以存放在多台主机上，这取决于你的集群机器数量。主分片和复制分片的具体位置是由ES内在的策略所决定的。</p><h3 id="Elasticsearch-存储结构"><a href="#Elasticsearch-存储结构" class="headerlink" title="Elasticsearch 存储结构"></a>Elasticsearch 存储结构</h3><p><strong>es中，存储数据的基本单位就是索引，比如说es中存储了一些订单系统的销售数据，就因该在es中创建一个索引，order—index，所有的销售数据就会都写到这个索引里面去，一个索引就像数据库。而type就相当于每一张表，<br>一个index里面可以有多个type，而mapping就相当于表的结构定义，定义了什么字段类型等，你往index的一个type里添加一行数据就叫做一个document，每一个document有多个filed，每一个filed就代表这个document的一个字段的值。</strong></p><pre><code>在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index)中,和数据库的对比. shards  分片 primary shard 主分片 replica shard 复制分片 document 文档必须包含的三个节点    _index  文档存储的地方    _type  文档代表的对象的类    _id  文档的唯一标识关系数据库 -&gt; 数据库 -&gt; 表 -&gt; 行 -&gt; 列Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields索引相当于数据库，类型相当于表，文档相当于行，字段（Fields）相当于表的列（字段）。</code></pre><p><strong>Mapping 映射</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es10.png" alt="image"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a href="https://www.cnblogs.com/shoufeng/p/10692113.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoufeng/p/10692113.html</a></p><h4 id="1-核心数据类型"><a href="#1-核心数据类型" class="headerlink" title="1 核心数据类型"></a>1 核心数据类型</h4><ul><li><p>字符串类型 - string(不再支持), 用text或keyword类型来代替string</p></li><li><p>文本类型 - text 当一个字段需要用于全文搜索(会被分词), 比如产品名称、产品描述信息, 就应该使用text类型.</p><ul><li><blockquote><p>text的内容会被分词, 可以设置是否需要存储: “index”: “true|false”.<br>  text类型的字段不能用于排序, 也很少用于聚合</p></blockquote></li></ul></li><li><p>关键字类型 - keyword  当一个字段需要按照精确值进行过滤、排序、聚合等操作时, 就应该使用keyword类型.</p><pre><code>  - &gt; keyword的内容不会被分词, 可以设置是否需要存储: "index": "true|false".</code></pre></li><li><p>数字类型 - 8种</p><blockquote></blockquote><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>byte</td><td>有符号的8位整数, 范围: [-128 ~ 127]</td></tr><tr><td>short</td><td>有符号的16位整数, 范围: [-32768 ~ 32767]</td></tr><tr><td>integer</td><td>有符号的32位整数, 范围: [$-2^{31}$ ~ $2^{31}$-1]</td></tr><tr><td>long</td><td>有符号的32位整数, 范围: [$-2^{63}$ ~ $2^{63}$-1]</td></tr><tr><td>float</td><td>32位单精度浮点数</td></tr><tr><td>double</td><td>64位双精度浮点数</td></tr><tr><td>half_float</td><td>16位半精度IEEE 754浮点类型</td></tr><tr><td>scaled_float</td><td>缩放类型的的浮点数, 比如price字段只需精确到分, 57.34缩放因子为100, 存储结果为5734</td></tr></tbody></table></li></ul><p><strong>使用注意事项:</strong></p><blockquote><p>尽可能选择范围小的数据类型, 字段的长度越短, 索引和搜索的效率越高;<br>优先考虑使用带缩放因子的浮点类型.</p></blockquote><ul><li>日期类型 - date</li><li>布尔类型 - boolean</li><li>二进制型 - binary</li><li>范围类型 - range<blockquote></blockquote><table><thead><tr><th>类型</th><th>范围</th></tr></thead><tbody><tr><td>integer_range</td><td>$-2^{31}$ ~ $2^{31}-1$</td></tr><tr><td>long_range</td><td>$-2^{63}$ ~ $2^{63}-1$</td></tr><tr><td>float_range</td><td>32位单精度浮点型</td></tr><tr><td>double_range</td><td>64位双精度浮点型</td></tr><tr><td>date_range</td><td>64位整数, 毫秒计时</td></tr><tr><td>ip_range</td><td>IP值的范围, 支持IPV4和IPV6, 或者这两种同时存在</td></tr></tbody></table></li></ul><h4 id="2-复杂数据类型"><a href="#2-复杂数据类型" class="headerlink" title="2 复杂数据类型"></a>2 复杂数据类型</h4><ul><li>数组类型 - array</li><li>对象类型 - object</li><li>嵌套类型 - nested</li></ul><h4 id="3-地理数据类型"><a href="#3-地理数据类型" class="headerlink" title="3 地理数据类型"></a>3 地理数据类型</h4><ul><li>地理点类型 - geo point</li><li>地理形状类型 - geo_shape</li></ul><h4 id="4-专门数据类型"><a href="#4-专门数据类型" class="headerlink" title="4 专门数据类型"></a>4 专门数据类型</h4><ul><li>IP类型</li><li>计数数据类型 - token_count</li></ul><h4 id="es锁机制"><a href="#es锁机制" class="headerlink" title="es锁机制"></a>es锁机制</h4><h5 id="悲观锁并发控制"><a href="#悲观锁并发控制" class="headerlink" title="悲观锁并发控制"></a>悲观锁并发控制</h5><p>优点：方便<br>缺点：并发能力低每次只有一个</p><h5 id="乐观锁并发控制"><a href="#乐观锁并发控制" class="headerlink" title="乐观锁并发控制"></a>乐观锁并发控制</h5><p>es采用乐观锁</p><p>乐观锁不会加锁，会采用一个版本号</p><p>优点：并发能力高<br>缺点：每次操作都要比对版本号</p><h3 id="ES相关性算分-relevance"><a href="#ES相关性算分-relevance" class="headerlink" title="ES相关性算分 relevance"></a>ES相关性算分 relevance</h3><h3 id="ES节点角色"><a href="#ES节点角色" class="headerlink" title="ES节点角色"></a>ES节点角色</h3><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es13.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es20.png" alt="image"></p><ul><li>倒排索引- -旦生成,不能更改</li><li>其好处如下:<ul><li>不用考虑并发写文件的问题,杜绝了锁机制带来的性能问题</li><li>由于文件不再更改,可以充分利用文件系统缓存,只需载入- -次,只要内存足够,对该文件的读取都会从内存读取,性能高</li><li>利于生成缓存数据</li><li>利于对文件进行压缩存储,节省磁盘和内存存储空间</li></ul></li><li>坏处为需要写入新文档时,必须重新构建倒排索引文件,然后替换老文件后,新文档才<br>能被检索,导致文档实时性差<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es25.png" alt="image"></li></ul><h4 id="新文档搜索实时性"><a href="#新文档搜索实时性" class="headerlink" title="新文档搜索实时性"></a>新文档搜索实时性</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es26.png" alt="image"><br>当有一个新的文档，构建倒排索引文件，对两个新旧索引进行同时查询，最后再进行一个汇总</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es27.png" alt="image"></p><h3 id="Search运行机制"><a href="#Search运行机制" class="headerlink" title="Search运行机制"></a>Search运行机制</h3><ul><li>Search执行的时候实际分为两个步骤运行<ul><li>Query阶段</li><li>Fetch阶段<br>称为：Query-Then-Fetch<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es28.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es29.png" alt="image"></li></ul></li></ul><h4 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h4><p>es排序默认使用相关性算分进行排序</p><h3 id="集群的状态status"><a href="#集群的状态status" class="headerlink" title="集群的状态status"></a>集群的状态status</h3><p>① green: 所有primary shard和replica shard都已成功分配, 集群是100%可用的;</p><p>② yellow: 所有primary shard都已成功分配, 但至少有一个replica shard缺失. 此时集群所有功能都正常使用, 数据不会丢失, 搜索结果依然完整, 但集群的可用性减弱. —— 需要及时处理的警告.</p><p>③ red: 至少有一个primary shard(以及它的全部副本分片)缺失 —— 部分数据不能使用, 搜索只能返回部分数据, 而分配到这个分配上的写入请求会返回一个异常. 此时虽然可以运行部分功能, 但为了索引数据的完整性, 需要尽快修复集群.</p><h3 id="ES元数据"><a href="#ES元数据" class="headerlink" title="ES元数据"></a>ES元数据</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es14.png" alt="image"></p><h3 id="ES分词"><a href="#ES分词" class="headerlink" title="ES分词"></a>ES分词</h3><p><a href="https://www.jianshu.com/p/914f102bc174" target="_blank" rel="noopener">https://www.jianshu.com/p/914f102bc174</a><br>以及自定分词</p><h4 id="ES自带分词器"><a href="#ES自带分词器" class="headerlink" title="ES自带分词器"></a>ES自带分词器</h4><ul><li>Standard</li><li>Simple</li><li>Whitespace</li><li>Stop</li><li>Keyword</li><li>Pattern</li><li>Language</li></ul><h3 id="es查询"><a href="#es查询" class="headerlink" title="es查询"></a>es查询</h3><ul><li><p>URI Search</p><p>  <img src="https://raw.githubusercontent.com/Flyiyu/use/master/es15.png" alt="image"><br>  <img src="https://raw.githubusercontent.com/Flyiyu/use/master/es17.png" alt="image"></p><blockquote><p>GET /lib/_search</p></blockquote><ul><li><p>在url中使用查询参数</p><pre><code>// 泛查询GET /lib/_search?q=tom{"profile": "true"}</code></pre></li></ul></li></ul><pre><code>GET /lib/_search?q=tom&amp;df=name{  "profile": "true"}```</code></pre><ul><li>Request Body<ul><li>使用ElasticSearch提供的，基于json格式的更加完备的Query Domain Specific Language (DSL查询)<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es16.jpg" alt="image"></li></ul></li></ul><h4 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h4><pre><code>GET，对应select:是从服务器查询，可以在服务器通过请求的参数区分查询的方式。POST,对应Create:在服务器新建立一个资源，调用insert操作。PUT，对应update操作:在服务器更新资源，调用update操作。PATCH，对应update操作，在服务器更新资源，客户端提供改变的属性。（目前JDK7没有实现，tomcat7也不行。）DELETE，对应DELETE操作，从服务器删除资源，调用delete语句。</code></pre><h3 id="Mapping参数"><a href="#Mapping参数" class="headerlink" title="Mapping参数"></a>Mapping参数</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es18.png" alt="image"></p><p>在7.0之后一个索引只可以有一个type</p><p>analyzer</p><p>分词器，默认为standard analyzer，当该字段被索引和搜索时对字段进行分词处理</p><p>boost</p><p>字段权重，默认为1.0</p><p>dynamic</p><p>Mapping中的字段类型一旦设定后，禁止直接修改，原因是：Lucene实现的倒排索引生成后不允许修改<br>只能新建一个索引，然后reindex数据<br>默认允许新增字段<br>通过dynamic参数来控制字段的新增：</p><p>true（默认）允许自动新增字段<br>false 不允许自动新增字段，但是文档可以正常写入，但无法对新增字段进行查询等操作<br>strict 文档不能写入，报错</p><p>index<br>控制当前字段是否索引，默认为true，即记录索引，false不记录，即不可搜索</p><pre><code>PUT my_index{  "mappings": {    "_doc": {      "dynamic": false,       "properties": {        "user": {           "properties": {            "name": {              "type": "text"            },            "social_networks": {               "dynamic": true,              "properties": {}            }          }        }      }    }  }}</code></pre><p>定义后my_index这个索引下不能自动新增字段，但是在user.social_networks下可以自动新增子字段</p><h3 id="Java-API编辑"><a href="#Java-API编辑" class="headerlink" title="Java API编辑"></a>Java API编辑</h3><p>可以使用 Elasticsearch 内置的两个客户端：</p><h4 id="节点客户端（Node-client）"><a href="#节点客户端（Node-client）" class="headerlink" title="节点客户端（Node client）"></a>节点客户端（Node client）</h4><p>节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。</p><h4 id="传输客户端（Transport-client）"><a href="#传输客户端（Transport-client）" class="headerlink" title="传输客户端（Transport client）"></a>传输客户端（Transport client）</h4><p>轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。<br>两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。</p><pre><code>对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为： TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。</code></pre><p>提示<br>Java 客户端作为节点必须和 Elasticsearch 有相同的 主要 版本；否则，它们之间将无法互相理解。</p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es6.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es7.png" alt="image"><br></p></font><p></p><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es19.png" alt="image"></p><h3 id="文档分布式存储"><a href="#文档分布式存储" class="headerlink" title="文档分布式存储"></a>文档分布式存储</h3><h4 id="存储一个document是如何选择存储在哪个分片上面"><a href="#存储一个document是如何选择存储在哪个分片上面" class="headerlink" title="存储一个document是如何选择存储在哪个分片上面"></a>存储一个document是如何选择存储在哪个分片上面</h4><p><a href="https://www.cnblogs.com/wangshouchang/p/8049492.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangshouchang/p/8049492.html</a></p><p>.shard = hash(routing) % number_of_primary_shards</p><p>下面将对这个公式每个字段进行分析</p><ul><li>shard 哪个分片， 也就是分片id</li><li>routing 一个可变值，默认是文档的id</li><li>hash 一个哈希函数，对rounting字段进行哈希计算生成一个数字</li><li>number_of_primary_shards 主分片的数量，routing字段经过hash函数计算之后的值，将对 主分片的数量也就是 number_of_primary_shards 进行取与，之后得到的shard就是我们文档所在的分片的位置</li></ul><p>该算法与主分片数相关，这也就是主分片一旦创建就无法修改的原因</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es21.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es22.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es23.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es24.png" alt="image"></p><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>深度分页是分布式存储系统必然会面临的一个问题<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es30.png" alt="image"></p><p>分页方式的应用场景<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es31.png" alt="image"></p><h3 id="ES聚合"><a href="#ES聚合" class="headerlink" title="ES聚合"></a>ES聚合</h3><p>es将聚合分析主要分为4类：</p><ul><li>Bucket 分桶类型，类似sql中的GROUP BY的语法<ul><li>Terms</li><li>Range</li><li>Date Range</li><li>Histogram</li><li>Date Histogram</li></ul></li><li>Metric指标分析类型，计算最大值、最小值、平均值 distinct conunt<ul><li>单值分析，只输出一个分析结果<ul><li>min、max、avg、sum</li><li>cardinality类型distinct count()</li></ul></li><li>多值分析，输出多个分析结果<ul><li>stats,extended stas</li><li>percentile,percentile rank</li><li>top hits</li></ul></li></ul></li><li>Pipeline管道分析类型，基于上一级的聚合分析结果进行再分析</li><li>Matrix矩阵分析类型</li></ul><h3 id="日志监控平台–平台架构ELK"><a href="#日志监控平台–平台架构ELK" class="headerlink" title="日志监控平台–平台架构ELK"></a>日志监控平台–平台架构ELK</h3><p>ElasticSearch是有其自己的套件的，简称ELK，即ElasticSearch，Logstash以及Kibana。ElasticSearch负责存储，Logstash负责收集数据来源，Kibana负责可视化数据，分工明确。</p><p>　　下面，我给大家用一个图来说明日志监控平台的架构，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es9.png" alt="image"></p><p>　　通过上图，我们可以清晰的看到日志平台整个流向过程。首先，多个独立的Agent，这里就是图左边的三个LogStash节点，他们负责收集不同来源的数据，由一个Indexer负责进行汇总和分析数据，在这个当中有一个中间过程，这里我们使用了Broker，用Redis来实现这部分功能，其作用充当一个缓冲区，之后由ElasticSearch负责存储和搜索数据，最后由前段的Kibana可视化我们收集的数据。</p><p>　　这里说明几点需要注意的地方：</p><p>采用LogStash收集各种日志数据，其类型可以是：系统日志、文件、Redis、MQ等等。<br>Broker作为远程代理和中心代理的缓冲区，使用Redis进行实现，原因有二：其一，可以提高系统的性能；其二，可以提高系统的高可用性，当中心代理提取数据失败时，数据保存在Redis中，可以规避数据丢失的风险。<br>中心代理使用LogStash，负责从Broker中获取数据，可以执行相关的分析和处理，它提供有Filter功能。<br>ElasticSearch用于存储最终的数据，并对外提供搜索功能，基于Restful。<br>Kibana提供一个简单、丰富的Web View可视化界面，用于可视化ElasticSearch集群中的数据，支持各种查询、统计和展示。</p><p>ELK介绍<br>需求背景：</p><p>业务发展越来越庞大，服务器越来越多<br>各种访问日志、应用日志、错误日志量越来越多，导致运维人员无法很好的去管理日志<br>开发人员排查问题，需要到服务器上查日志，不方便<br>运营人员需要一些数据，需要我们运维到服务器上分析日志<br>为什么要用到ELK：</p><p>一般我们需要进行日志分析场景：直接在日志文件中 grep、awk 就可以获得自己想要的信息。但在规模较大也就是日志量多而复杂的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p><p>大型系统通常都是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p><p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p><p>收集－能够采集多种来源的日志数据<br>传输－能够稳定的把日志数据传输到中央系统<br>存储－如何存储日志数据<br>分析－可以支持 UI 分析<br>警告－能够提供错误报告，监控机制<br>而ELK则提供了一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用。是目前主流的一种日志系统。</p><p>ELK简介：</p><p>ELK是三个开源软件的缩写，分别为：Elasticsearch 、 Logstash以及Kibana , 它们都是开源软件。不过现在还新增了一个Beats，它是一个轻量级的日志收集处理工具(Agent)，Beats占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具，目前由于原本的ELK Stack成员中加入了 Beats 工具所以已改名为Elastic Stack。</p><p>Elastic Stack包含：</p><p>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。详细可参考Elasticsearch权威指南</p><p>Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。它可以从许多来源接收日志，这些来源包括 syslog、消息传递（例如 RabbitMQ）和JMX，它能够以多种方式输出数据，包括电子邮件、websockets和 Elasticsearch。</p><p>Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</p><p>Beats在这里是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、cpu、io等资源消耗比较高。相比 Logstash，Beats所占系统的CPU和内存几乎可以忽略不计<br>ELK Stack （5.0版本之后）–&gt; Elastic Stack == （ELK Stack + Beats）。目前Beats包含六种工具：</p><p>Packetbeat： 网络数据（收集网络流量数据）<br>Metricbeat： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）<br>Filebeat： 日志文件（收集文件数据）<br>Winlogbeat： windows事件日志（收集 Windows 事件日志数据）<br>Auditbeat：审计数据 （收集审计日志）<br>Heartbeat：运行时间监控 （收集系统运行时的数据）<br>关于x-pack工具：</p><p>x-pack对Elastic Stack提供了安全、警报、监控、报表、图表于一身的扩展包，是收费的</p><p>** Kibana索引用来存储数据，千万不要删除了它。它是将es数据通过kibana进行web展示的关键。这个配置后，在es的web界面里就会看到这个.kibana索引 **</p><h4 id="提高-Elasticsearch-的高可用性"><a href="#提高-Elasticsearch-的高可用性" class="headerlink" title="提高 Elasticsearch 的高可用性"></a>提高 Elasticsearch 的高可用性</h4><p>这时集群的作用就体现出来了。假如 Elasticsearch<br>只放在一台服务器上，即单机运行，假如这台主机突然断网了或者被攻击了，那么整个 Elasticsearch 的服务就不可用了。但如果改成<br>Elasticsearch 集群的话，有一台主机宕机了，还有其他的主机可以支撑，这样就仍然可以保证服务是可用的。</p><p>那假如一台主机宕机了，那么不就无法访问这台主机的数据了吗？那假如我要访问的数据正好存在这台主机上，那不就获取不到了吗？难道其他的主机里面也存了一份一模一样的数据？那这岂不是很浪费吗？</p><p>为了解答这个问题，这里就引出了 Elasticsearch<br>的信息存储机制了。首先解答上面的问题，一台主机宕机了，这台主机里面存的数据依然是可以被访问到的，因为在其他的主机上也有备份，但备份的时候也不是整台主机备份，是分片备份的，那这里就又引出了一个概念——分片。</p><p>分片，英文叫做 Shard，顾名思义，分片就是对数据切分成了多个部分。我们知道 Elasticsearch<br>中一个索引（Index）相当于是一个数据库，如存某网站的用户信息，我们就建一个名为 user<br>的索引。但索引存储的时候并不是整个存一起的，它是被分片存储的，Elasticsearch<br>默认会把一个索引分成五个分片，当然这个数字是可以自定义的。分片是数据的容器，数据保存在分片内，分片又被分配到集群内的各个节点里。当你的集群规模扩大或者缩小时，<br>Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里，所以相当于一份数据被分成了多份并保存在不同的主机上。</p><p>那这还是没解决问题啊，如果一台主机挂掉了，那么这个分片里面的数据不就无法访问了？别的主机都是存储的其他的分片。其实是可以访问的，因为其他主机存储了这个分片的备份，叫做副本，这里就引出了另外一个概念——副本。</p><p>副本，英文叫做 Replica，同样顾名思义，副本就是对原分片的复制，和原分片的内容是一样的，Elasticsearch<br>默认会生成一份副本，所以相当于是五个原分片和五个分片副本，相当于一份数据存了两份，并分了十个分片，当然副本的数量也是可以自定义的。这时我们只需要将某个分片的副本存在另外一台主机上，这样当某台主机宕机了，我们依然还可以从另外一台主机的副本中找到对应的数据。所以从外部来看，数据结果是没有任何区别的。</p><p>一般来说，Elasticsearch 会尽量把一个索引的不同分片存储在不同的主机上，分片的副本也尽可能存在不同的主机上，这样可以提高容错率，从而提高高可用性。</p><p>但这时假如你只有一台主机，那不就没办法了吗？分片和副本其实是没意义的，一台主机挂掉了，就全挂掉了。</p><p>（2）健康状态</p><p>针对一个索引，Elasticsearch 中其实有专门的衡量索引健康状况的标志，分为三个等级：</p><ul><li><p>green，绿色。这代表所有的主分片和副本分片都已分配。你的集群是 100% 可用的。</p></li><li></li></ul><p>yellow，黄色。所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。不过，你的高可用性在某种程度上被弱化。如果更多的分片消失，你就会丢数据了。所以可把<br>yellow 想象成一个需要及时调查的警告。</p><ul><li>red，红色。至少一个主分片以及它的全部副本都在缺失中。这意味着你在缺少数据：搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。</li></ul><p>如果你只有一台主机的话，其实索引的健康状况也是<br>yellow，因为一台主机，集群没有其他的主机可以防止副本，所以说，这就是一个不健康的状态，因此集群也是十分有必要的。</p><p>（3）存储空间</p><p>另外，既然是群集，那么存储空间肯定也是联合起来的，假如一台主机的存储空间是固定的，那么集群它相对于单个主机也有更多的存储空间，可存储的数据量也更大。</p><p>所以综上所述，我们需要一个集群！</p><p>二、详细了解 Elasticsearch 集群</p><p>接下来我们再来了解下集群的结构是怎样的。</p><p>首先我们应该清楚多台主机构成了一个集群，每台主机称作一个节点（Node）。</p><p>如图就是一个三节点的集群：</p><p>在图中，每个 Node 都有三个分片，其中 P 开头的代表 Primary 分片，即主分片，R 开头的代表 Replica 分片，即副本分片。所以图中主分片<br>1、2，副本分片 0 储存在 1 号节点，副本分片 0、1、2 储存在 2 号节点，主分片 0 和副本分片 1、2 储存在 3 号节点，一共是 3 个主分片和<br>6 个副本分片。同时我们还注意到 1 号节点还有个 MASTER<br>的标识，这代表它是一个主节点，它相比其他的节点更加特殊，它有权限控制整个集群，比如资源的分配、节点的修改等等。</p><p>这里就引出了一个概念就是节点的类型，我们可以将节点分为这么四个类型：</p><ul><li><p>主节点：即 Master<br>节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。默认情况下任何一个集群中的节点都有可能被选为主节点。索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择。虽然主节点也可以协调节点，路由搜索和从客户端新增数据到数据节点，但最好不要使用这些专用的主节点。一个重要的原则是，尽可能做尽量少的工作。</p></li><li><p>数据节点：即 Data 节点。数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对 CPU、内存、IO<br>要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</p></li><li><p>负载均衡节点：也称作 Client<br>节点，也称作客户端节点。当一个节点既不配置为主节点，也不配置为数据节点时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。</p></li><li><p>预处理节点：也称作 Ingest 节点，在索引数据之前可以先对数据做预处理操作，所有节点其实默认都是支持 Ingest 操作的，也可以专门将某个节点配置为<br>Ingest 节点。</p></li></ul><p>以上就是节点几种类型，一个节点其实可以对应不同的类型，如一个节点可以同时成为主节点和数据节点和预处理节点，但如果一个节点既不是主节点也不是数据节点，那么它就是负载均衡节点。具体的类型可以通过具体的配置文件来设置。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo笔记</title>
      <link href="/2019/10/21/2019-04-11-dubbo/"/>
      <url>/2019/10/21/2019-04-11-dubbo/</url>
      
        <content type="html"><![CDATA[<h3 id="何为Dubbo"><a href="#何为Dubbo" class="headerlink" title="何为Dubbo"></a>何为Dubbo</h3><font size="4"><p>&nbsp; &nbsp; &nbsp;&nbsp;Dubbo是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。Dubbo采用全spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可。</p><h3 id="其核心部分包含"><a href="#其核心部分包含" class="headerlink" title="其核心部分包含:"></a>其核心部分包含:</h3><p><strong>远程通讯：</strong> 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</p><p><strong>集群容错:</strong> 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p><p><strong>自动发现:</strong> 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p><h3 id="Dubbo的由来"><a href="#Dubbo的由来" class="headerlink" title="Dubbo的由来"></a>Dubbo的由来</h3><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p><ul><li><p>单一应用架构</p><pre><code>  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。  此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</code></pre></li><li><p>垂直应用架构</p><pre><code>  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。  此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</code></pre></li><li><p>分布式服务架构</p><pre><code>  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服  务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</code></pre></li><li><p>流动计算架构</p><pre><code>  当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调  度中心基于访问压力实时管理集群容量，提高集群利用率。  此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</code></pre></li></ul><h3 id="Dubbo解决了哪些问题"><a href="#Dubbo解决了哪些问题" class="headerlink" title="Dubbo解决了哪些问题"></a>Dubbo解决了哪些问题</h3><p>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</p><p>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</p><p>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p><p>Dubbo基于RPC（Remote Procedure Call 远程过程调用）协议，服务提供方和服务消费方之间的调用关系：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/dubbo1.png" alt="dubbo"></p><p><strong>节点角色说明：</strong></p><ul><li>Provider: 暴露服务的服务提供方。</li><li>Consumer: 调用远程服务的服务消费方。</li><li>Registry: 服务注册与发现的注册中心。</li><li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li><li>Container: 服务运行容器。</li></ul><p><strong>调用关系说明：</strong></p><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul></font><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL面试题目</title>
      <link href="/2019/10/21/2019-02-03-sql/"/>
      <url>/2019/10/21/2019-02-03-sql/</url>
      
        <content type="html"><![CDATA[<h3 id="sql执行顺序"><a href="#sql执行顺序" class="headerlink" title="sql执行顺序"></a>sql执行顺序</h3><font size="3"><h3 id="使用命令操作数据库"><a href="#使用命令操作数据库" class="headerlink" title="使用命令操作数据库"></a>使用命令操作数据库</h3><ul><li>mysql -h localhost -u root -p ====连接数据库</li><li>show databases; ====查看数据库</li><li>use 表名 ==== 选择表</li><li>show tables ====查看表</li></ul><hr><h3 id="sql-语法"><a href="#sql-语法" class="headerlink" title="sql 语法"></a>sql 语法</h3><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>查询中用到的关键词主要包含六个，并且他们写的顺序依次为</p><blockquote><p>select–from–where–group by–having–order by</p></blockquote><p>其中select和from是必须的，其他关键词是可选的，<strong>这六个关键词的执行顺序</strong><br>与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</p><blockquote><p>from–where–group by–having–select–order by,</p></blockquote><ul><li>from:需要从哪个数据表检索数据</li><li>where:过滤表中数据的条件</li><li>group by:如何将上面过滤出的数据分组</li><li>having:对上面已经分组的数据进行过滤的条件  </li><li>select:查看结果集中的哪个列，或列的计算结果</li><li>order by :按照什么样的顺序来查看返回的数据</li></ul><p>SELECT - 从数据库中提取数据</p><p>UPDATE - 更新数据库中的数据</p><p>DELETE - 从数据库中删除数据</p><p>INSERT INTO - 向数据库中插入新数据</p><p>CREATE DATABASE - 创建新数据库</p><p>ALTER DATABASE - 修改数据库</p><p>CREATE TABLE - 创建新表</p><p>ALTER TABLE - 变更（改变）数据库表</p><p>DROP TABLE - 删除表</p><p>CREATE INDEX - 创建索引（搜索键）</p><p>DROP INDEX - 删除索引</p><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><p>% 替代一个或多个字符</p><p>_ 仅替代一个字符</p><p>[charlist] 字符列中的任何单一字符</p><p>[^charlist]或者[!charlist] 不在字符列中的任何单一字符</p><p>其中搭配以上通配符可以让LIKE命令实现多种技巧：</p><p>1、LIKE’Mc%’ 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。</p><p>2、LIKE’%inger’ 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。</p><p>3、LIKE’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。</p><p>4、LIKE’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。</p><p>5、LIKE’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。</p><p>6、LIKE’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。</p><p>7、LIKE’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>INNER JOIN：如果表中有至少一个匹配，则返回行</p><p>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</p><p>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</p><p>FULL JOIN：只要其中一个表中存在匹配，则返回行</p><h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>在开发中，有些数据的存储可能涉及到分库分表，查询的时候，可能需要查询所有的分表，这个时候，就需要用到UNION或者UNION ALL</p><h5 id="union-1"><a href="#union-1" class="headerlink" title="union"></a>union</h5><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集，请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列，列也必须拥有相似的数据类型，同时，每条 SELECT 语句中的列的顺序必须相同。</p><p>UNION 语法例句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name2</code></pre><h5 id="union-all"><a href="#union-all" class="headerlink" title="union all"></a>union all</h5><p>UNION all 语法例句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token keyword">union</span> <span class="token keyword">all</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> userc<span class="token punctuation">;</span></code></pre><p><strong>UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。</strong></p><h3 id="SQL-Aggregate-函数"><a href="#SQL-Aggregate-函数" class="headerlink" title="SQL Aggregate 函数"></a>SQL Aggregate 函数</h3><p>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。</p><p>有用的 Aggregate 函数：</p><p>AVG() - 返回平均值</p><p>COUNT() - 返回行数</p><p>FIRST() - 返回第一个记录的值</p><p>LAST() - 返回最后一个记录的值</p><p>MAX() - 返回最大值</p><p>MIN() - 返回最小值</p><p>SUM() - 返回总和</p><h3 id="Mysql-amp-Oracle"><a href="#Mysql-amp-Oracle" class="headerlink" title="Mysql &amp; Oracle"></a>Mysql &amp; Oracle</h3><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>mysql : limit 3,5 从第三条开始，向后查询五条数据</p><p>Oracle: 使用伪列rownum 来做子查询</p><pre><code>    select * from ( select t.*,rownum r from BANK t ) a where a.r &gt;2 and a.r &lt; 6</code></pre><h4 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h4><p>MySql： 创建表时：auto_increment</p><p>创建表格后添加： alter table tablename add id int auto_increment primary key</p><p>Oracle： 使用序列实现</p><pre class=" language-sql"><code class="language-sql">参数说明INCREMENT <span class="token keyword">BY</span> :序列变化的步进，负值表示递减。<span class="token punctuation">(</span>默认<span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">START</span> <span class="token keyword">WITH</span>:序列的初始值 。<span class="token punctuation">(</span>默认<span class="token number">1</span><span class="token punctuation">)</span>MAXvalue:序列可生成的最大值。<span class="token punctuation">(</span>默认不限制最大值，NOMAXVALUE<span class="token punctuation">)</span>MINVALUE:序列可生成的最小值。<span class="token punctuation">(</span>默认不限制最小值，NOMINVALUE<span class="token punctuation">)</span>CYCLE:用于定义当序列产生的值达到限制值后是否循环<span class="token punctuation">(</span><span class="token keyword">NOCYCLE</span>:不循环，CYCLE:循环<span class="token punctuation">)</span>。CACHE:表示缓存序列的个数，数据库异常终止可能会导致序列中断不连续的情况，默认值为<span class="token number">20</span>，如果不使用缓存可设置NOCACHE<span class="token comment" spellcheck="true">-- 序列</span><span class="token keyword">create</span> sequence sequsincrement <span class="token keyword">by</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">-- 每次增加1</span><span class="token keyword">start</span> <span class="token keyword">with</span> <span class="token number">3</span>  <span class="token comment" spellcheck="true">--从3开始</span>minvalue <span class="token number">1</span>    <span class="token comment" spellcheck="true">-- 最小值</span>maxvalue <span class="token number">1000</span> <span class="token comment" spellcheck="true">-- 最大值1000</span>cycle <span class="token comment" spellcheck="true">-- 周而复始</span>nocache<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 使用方法</span><span class="token keyword">insert</span> <span class="token keyword">into</span> bank <span class="token keyword">values</span><span class="token punctuation">(</span>sequ<span class="token punctuation">.</span>nextval<span class="token punctuation">,</span><span class="token string">'jack'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="存储过程简介"><a href="#存储过程简介" class="headerlink" title="存储过程简介"></a>存储过程简介</h4><p>存储过程是数据库的一个重要的功能，MySQL 5.0以前并不支持存储过程，这使得MySQL在应用上大打折扣。好在MySQL 5.0开始支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。<br>SQL语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p><p>存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式。</p><p>存储过程的优点：</p><p>(1).增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p><p>(2).标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</p><p>(3).较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p><p>(4).减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</p><p>(5).作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</p><h4 id="MySQL存储过程的创建"><a href="#MySQL存储过程的创建" class="headerlink" title="MySQL存储过程的创建"></a>MySQL存储过程的创建</h4><p><strong>语法</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span>  过程名<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">IN</span><span class="token operator">|</span><span class="token keyword">OUT</span><span class="token operator">|</span><span class="token keyword">INOUT</span><span class="token punctuation">]</span> 参数名 数据类型<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">IN</span><span class="token operator">|</span><span class="token keyword">OUT</span><span class="token operator">|</span><span class="token keyword">INOUT</span><span class="token punctuation">]</span> 参数名 数据类型…<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>特性 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> 过程体<span class="token keyword">DELIMITER</span> <span class="token comment" spellcheck="true">//</span>  <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> myproc<span class="token punctuation">(</span><span class="token keyword">OUT</span> s <span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token keyword">BEGIN</span>      <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">INTO</span> s <span class="token keyword">FROM</span> students<span class="token punctuation">;</span>    <span class="token keyword">END</span>    <span class="token comment" spellcheck="true">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></code></pre><p>分隔符<br>MySQL默认以”;”为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要事先用“DELIMITER //”声明当前段分隔符，让编译器把两个”//“之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER ;”的意为把分隔符还原。</p><p><strong>过程体</strong></p><p>过程体的开始与结束使用BEGIN与END进行标识。</p><p><strong>参数</strong></p><p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:</p><p>　　存储过程可以有0个或多个参数，用于存储过程的定义。</p><p>3种参数类型：</p><p>　　IN输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）</p><p>　　OUT输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）</p><p>　　INOUT输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）</p><p><strong>定义变量</strong><br>如果希望MySQL执行批量插入的操作，那么至少要有一个计数器来计算当前插入的是第几次。 </p><p>这里的变量是用在存储过程中的SQL语句中的，变量的作用范围在BEGIN …. END 中。</p><p>没有DEFAULT子句，初始值为NULL。</p><p>定义变量的操作</p><pre><code>DECLARE name,address VARCHAR;  -- 发现了吗，SQL中一般都喜欢先定义变量再定义类型，与Java是相反的。DECLARE age INT DEFAULT 20; -- 指定默认值。若没有DEFAULT子句，初始值为NULL。</code></pre><p>为变量赋值</p><pre><code>SET name = 'jay';  -- 为name变量设置值</code></pre><h3 id="sql-优化"><a href="#sql-优化" class="headerlink" title="sql 优化"></a>sql 优化</h3><p>1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><p>select id from t where num is null</p><p>最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.</p><p>3.应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num=10 or Name = ‘admin’<br>可以这样查询：<br>select id from t where num = 10union allselect id from t where Name = ‘admin’</p><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：<br>select id from t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了：<br>select id from t where num between 1 and 3<br>很多时候用 exists 代替 in 是一个好的选择：<br>select num from a where num in(select num from b)<br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num=a.num)</p><p>6.下面的查询也将导致全表扫描：<br>select id from t where name like ‘%abc%’<br>若要提高效率，可以考虑全文检索。</p><p>.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要</p><h3 id="sql-索引"><a href="#sql-索引" class="headerlink" title="sql 索引"></a>sql 索引</h3><p>MySQL官方对索引的定义：索引是帮助MySQL高效获取数据的数据结构。索引是在存储引擎中实现的，所以每种存储引擎中的索引都不一样。如MYISAM和InnoDB存储引擎只支持BTree索引；</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>创建索引<br>在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。</p><p>1.ALTER TABLE ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><pre><code>    ALTER TABLE table_name ADD INDEX index_name (column_list)    ALTER TABLE table_name ADD UNIQUE (column_list)    ALTER TABLE table_name ADD PRIMARY KEY (column_list)</code></pre><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>2.CREATE INDEX可对表增加普通索引或UNIQUE索引</p><pre><code>    CREATE INDEX index_name ON table_name (column_list)    CREATE UNIQUE INDEX index_name ON table_name (column_list)</code></pre><p>table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。</p><ol start="3"><li>索引类型<br>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。</li></ol><p>PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p><p>下面的SQL语句对students表在sid上添加PRIMARY KEY索引。</p><p>ALTER TABLE students ADD PRIMARY KEY (sid)</p><ol start="4"><li>删除索引<br>可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。</li></ol><p>DROP INDEX index_name ON talbe_name</p><p>ALTER TABLE table_name DROP INDEX index_name</p><p>ALTER TABLE table_name DROP PRIMARY KEY</p><p>其中，前两条语句是等价的，删除掉table_name中的索引index_name。</p><p>第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。</p><p>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p><h4 id="什么情况下应不建或少建索引"><a href="#什么情况下应不建或少建索引" class="headerlink" title="什么情况下应不建或少建索引"></a>什么情况下应不建或少建索引</h4><p>1、表记录太少</p><p>2、经常插入、删除、修改的表</p><p>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p><p>3、数据重复且分布平均的表字段</p><p>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p><p>4、经常和主字段一块查询但主字段索引值比较多的表字段</p><p>如gc_dfss（电费实收）表经常按收费序号、户标识编号、抄表日期、电费发生年月、操作 标志来具体查询某一笔收款的情况，如果将所有的字段都建在一个索引里那将会增加数据的修改、插入、删除时间，从实际上分析一笔收款如果按收费序号索引就已 经将记录减少到只有几条，如果再按后面的几个字段索引查询将对性能不产生太大的影响。</p><h4 id="MySQL聚集索引和非聚集索引"><a href="#MySQL聚集索引和非聚集索引" class="headerlink" title="MySQL聚集索引和非聚集索引"></a>MySQL聚集索引和非聚集索引</h4><p>聚集索引<br>　　一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。<br>　　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（联合索引）（不过mysql的innodb只支持主键聚集索引，不支持联合聚集索引），就像电话簿按姓氏和名字进行组织一样。</p><p>非聚集索引<br>　　一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以包含多个非聚集索引。</p><h3 id="mysql-引擎区别"><a href="#mysql-引擎区别" class="headerlink" title="mysql 引擎区别"></a>mysql 引擎区别</h3><p><strong>存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Blackhole, 5. CSV, 6. Performance_Schema, 7. Archive, 8. Federated , 9 Mrg_Myisam<br>但是我们主要分析使用MyIsam 和InnoDB</strong></p><p><font color="#008000">1) 事务支持</font></p><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p><p>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</p><p><font color="#008000">2) 存储结构</font></p><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><p><font color="#008000">3) 存储空间</font></p><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。<br>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><p><font color="#008000">4) 可移植性、备份及恢复</font></p><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><p><font color="#008000">5) 事务支持</font></p><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><p><font color="#008000">6) AUTO_INCREMENT</font></p><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><p><font color="#008000">7) 表锁差异</font></p><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><p><font color="#008000">8) 全文索引</font></p><p>MyISAM：支持(FULLTEXT类型的)全文索引<br>InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><p>全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p><p>另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</p><p><font color="#008000">9) 表主键</font></p><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p><p><font color="#008000">10) 表的具体行数</font></p><p>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><p><font color="#008000">11) CURD操作</font></p><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><p><font color="#008000">12) 外键</font></p><p>MyISAM：不支持<br>InnoDB：支持</p><p><font color="#008000">13) 查询效率</font></p><p>没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(<em>)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(</em>)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><p>MyISAM和InnoDB两者的应用场景：</p><p>1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。<br>2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p><h3 id="什么叫事务？"><a href="#什么叫事务？" class="headerlink" title="什么叫事务？"></a>什么叫事务？</h3><p>简称ACID</p><p>A 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.</p><p>C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.</p><p>I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.</p><p>D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</p></font><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试题目</title>
      <link href="/2019/10/21/2019-02-03-spring-mian-shi-li-jie/"/>
      <url>/2019/10/21/2019-02-03-spring-mian-shi-li-jie/</url>
      
        <content type="html"><![CDATA[<p>1.谈谈你对Spring 的理解（2017-11-13-lyq）</p><p>Spring 是一个开源框架，为简化企业级应用开发而生。Spring 可以是使简单的JavaBean 实现以前只有EJB 才能实现的功能。Spring 是一个 IOC 和 AOP 容器框架。<br>Spring 容器的主要核心是：<br>控制反转（IOC），传统的 java 开发模式中，当需要一个对象时，我们会自己使用 new 或者 getInstance 等直接或者间接调用构造方法创建一个对象。而在 spring 开发模式中，spring 容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring 提供的对象就可以了，这是控制反转的思想。<br>依赖注入（DI），spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。<br>面向切面编程（AOP），在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口采用 JDK 动态代理，如果是类采用<br>CGLIB 方式实现动态代理。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题目</title>
      <link href="/2019/10/21/2019-02-03-redis-mian-shi/"/>
      <url>/2019/10/21/2019-02-03-redis-mian-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>Redis 是一个基于内存的高性能key-value数据库。<br>定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<br>Redis的出色之处不仅仅是性能，Redis是支持保存多种数据结构，此外单个value的最大限制是1GB。 Redis是单进程单线程的.</p><p>Redis提供了多种高可用方案包括：主从复制、哨兵模式的主从复制、以及集群</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><a href="https://www.cnblogs.com/hepingqingfeng/p/7263782.html" target="_blank" rel="noopener">博客</a></p><font face="微软雅黑" size="3"><blockquote><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据<br>。但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。</p></blockquote><blockquote><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库[1] （slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个<br>从数据库，而一个从数据库只能拥有一个主数据库。</p></blockquote><p>一台master主机可以拥有多台slave从机。而一台slave从机又可以拥有多个slave从机。如此下去，形成强大的多级服务器集群架构（高扩展）。可以避免Redis单点故障，实现容灾恢复效果（高可用）。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis5.png" alt=""></p><h5 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h5><blockquote><p>redis复制过程可分为三个阶段：</p></blockquote><ol><li>复制初始化阶段</li><li>数据同步阶段</li><li>命令传播阶段</li></ol><h6 id="复制初始化阶段"><a href="#复制初始化阶段" class="headerlink" title="复制初始化阶段"></a>复制初始化阶段</h6><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><p>具体步骤如下： </p><p>1）从服务器连接主服务器，发送SYNC命令； </p><p>2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </p><p>3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </p><p>　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </p><p>　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </p><p>　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p><h6 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h6><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </p><p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p></font><h4 id="哨兵（Sentinel）"><a href="#哨兵（Sentinel）" class="headerlink" title="哨兵（Sentinel）"></a>哨兵（Sentinel）</h4><font face="微软雅黑" size="3"><p> 哨兵机制存在的意义：</p><p>没有哨兵机制的时候，主从复制结构部署存在的问题是什么？也可以说redis主节点发生故障如何解决？</p><pre><code>如果主节点down调，主从切换需要人工介入为了实现redis故障转移的自动化。自动发现，自动转移。不需要人工参与。</code></pre><h4 id="1、Sentinel（哨兵）进程的作用："><a href="#1、Sentinel（哨兵）进程的作用：" class="headerlink" title="1、Sentinel（哨兵）进程的作用："></a>1、Sentinel（哨兵）进程的作用：</h4><p>  1】、监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</p><p>  2】、提醒(Notification)：当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</p><p>  3】、自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作，它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p><h4 id="2、Sentinel（哨兵）进程的工作方式："><a href="#2、Sentinel（哨兵）进程的工作方式：" class="headerlink" title="2、Sentinel（哨兵）进程的工作方式："></a>2、Sentinel（哨兵）进程的工作方式：</h4><p> 1】、每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</p><p> 2】、如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</p><p> 3】、如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。</p><p> 4】、当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。</p><p> 5】、在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</p><p> 6】、当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p><p> 7】、若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</p></font><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><hr><p>以上三者的关系</p><p>==主从往往是为了读写分离、backup 等目的， 哨兵可以检测主从健康， 主挂了可以把从提升为主， 集群往往是为了数据 sharding， 解决单台机器资源的上限的问题==</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis3.png" alt="redis3"></p><p>在这个图中，每一个蓝色的圈都代表着一个redis的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。</p><p>　　　　那么redis是怎么做到的呢？首先，在redis的每一个节点上，都有这么两个东西，一个是插槽（slot）可以理解为是一个可以存储两个数值的一个变量这个变量的取值范围是：0-16383。还有一个就是cluster我个人把这个cluster理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis4.png" alt="redis4"></p><p>还有就是因为如果集群的话，是有好多个redis一起工作的，那么，就需要这个集群不是那么容易挂掉，所以呢，理论上就应该给集群中的每个节点至少一个备用的redis服务。这个备用的redis称为从节点（slave）。那么这个集群是如何判断是否有某个节点挂掉了呢？</p><p>　　　　首先要说的是，每一个节点都存有这个集群所有主节点以及从节点的信息。</p><p>　　　　它们之间通过互相的ping-pong判断是否节点可以连接上。如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的备用节点。如果某个节点和所有从节点全部挂掉，我们集群就进入faill状态。还有就是如果有一半以上的主节点宕机，那么我们集群同样进入发力了状态。这就是我们的redis的投票机制</p><p>一、常见使用方式<br>Redis 的几种常见使用方式包括：</p><ul><li>Redis 单副本</li><li>Redis 多副本（主从）</li><li>Redis Sentinel（哨兵）</li><li>Redis Cluster</li><li>Redis 自研</li></ul><p>二、各种使用方式的优缺点</p><p><strong>1、Redis 单副本</strong></p><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p><p><strong>优点：</strong></p><p>架构简单，部署方便；</p><p>高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</p><p>高性能。</p><p><strong>缺点：</strong></p><p>不保证数据的可靠性；</p><p>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</p><p>高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</p><p><strong>2、Redis 多副本（主从）</strong></p><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p><p>阿里架构师进阶专题：Redis集群的5种使用方式，各自优缺点分析</p><p><strong>优点：</strong></p><p>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</p><p>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p><p><strong>缺点：</strong></p><p>故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</p><p>主库的写能力受到单机的限制，可以考虑分片；</p><p>主库的存储能力受到单机的限制，可以考虑 Pika；</p><p>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</p><p><strong>3、Redis Sentinel（哨兵）</strong></p><p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p><p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n&gt;=1）的奇数个。</p><p><strong>优点：</strong></p><p>Redis Sentinel 集群部署简单；</p><p>能够解决 Redis 主从模式下的高可用切换问题；</p><p>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；</p><p>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</p><p><strong>缺点：</strong></p><p>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；</p><p>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；</p><p>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</p><p>不能解决读写分离问题，实现起来相对复杂。</p><p><strong>建议：</strong></p><p>如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。</p><p>sentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过（Sentinel 数量 – quorum）。</p><p>合理设置参数，防止误切，控制切换灵敏度控制：</p><p>a. quorum</p><p>b. down-after-milliseconds 30000</p><p>c. failover-timeout 180000</p><p>d. maxclient</p><p>e. timeout</p><p>部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。</p><p>Redis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。</p><p>自行搞定配置中心（zookeeper），方便客户端对实例的链接访问。</p><p><strong>4、Redis Cluster</strong></p><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p><p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p><strong>优点：</strong></p><p>无中心架构；</p><p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</p><p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</p><p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</p><p>降低运维成本，提高系统的扩展性和可用性。</p><p><strong>缺点：</strong></p><p>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p><p>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</p><p>数据通过异步复制，不保证数据的强一致性。</p><p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p><p>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</p><p>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</p><p>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</p><p>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</p><p>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</p><p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p><p>避免产生 hot-key，导致主库节点成为系统的短板。</p><p>避免产生 big-key，导致网卡撑爆、慢查询等。</p><p>重试时间应该大于 cluster-node-time 时间。</p><p>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><font face="微软雅黑" size="3"><ul><li>Redis挂掉了，请求全部走数据库。</li><li>对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。</li><li>由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。</li></ul><h6 id="缓存雪崩的解决方案："><a href="#缓存雪崩的解决方案：" class="headerlink" title="缓存雪崩的解决方案："></a>缓存雪崩的解决方案：</h6></font>对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：<ul><li>事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。</li><li>事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li><li>事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><p>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，伪代码如下：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis1.png?token=AexgHZjCedfwNfJ5BsVbMewryF1mRv7Pks5cRZv0wA%3D%3D" alt="redis1"></p><p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p><p>注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p><p>（2）给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis2.png?token=AexgHewM_sBNhe6ItyHaVdtBy2cVSW17ks5cRZwrwA%3D%3D" alt="redis2"></p><p>解释说明：</p><p>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p><p>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p><p>关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><font face="微软雅黑" size="3"><blockquote><p>缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。</p></blockquote><p>解决缓存穿透也有两种方案：</p><p>由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！<br>当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。<br>这种情况我们一般会将空对象设置一个较短的过期时间。</p></font><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><font face="微软雅黑" size="3">　　缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免，用户请求的时候，再去加载相关的数据。<p>　　解决思路：</p><p>　　　　1，直接写个缓存刷新页面，上线时手工操作下。</p><p>　　　　2，数据量不大，可以在WEB系统启动的时候加载。</p><p>　　　　3，定时刷新缓存，<br>　　　　<br></p></font><p></p><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>　　缓存淘汰的策略有两种：</p><p>　　　　(1) 定时去清理过期的缓存。</p><p>　　　　(2)当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 </p><p>　　两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，大家可以根据自己的应用场景来权衡。1. 预估失效时间 2. 版本号（必须单调递增，时间戳是最好的选择）3. 提供手动清理缓存的接口。</p><h4 id="redis过期策略"><a href="#redis过期策略" class="headerlink" title="redis过期策略"></a>redis过期策略</h4><p>三种过期策略</p><p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong></p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</p><p>优点：保证内存被尽快释放</p><p>缺点：</p><p>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key<br>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重<br>没人用</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</p><p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p><p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>含义：每隔一段时间执行一次删除过期key操作</p><p>优点：<br>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点<br>定期删除过期key–处理”惰性删除”的缺点</p><p>缺点<br>在内存友好方面，不如”定时删除”<br>在CPU时间友好方面，不如”惰性删除”</p><p>难点<br>合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）</p><h4 id="秒杀-抢购技术特点"><a href="#秒杀-抢购技术特点" class="headerlink" title="秒杀/抢购技术特点"></a>秒杀/抢购技术特点</h4><blockquote><p>秒杀会遇到的问题<br>1、超卖 2、</p></blockquote><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>(一)String</p><p>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。</p><p>(二)hash</p><p>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p><p>(三)list</p><p>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。</p><p>(四)set</p><p>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p><p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>(五)sorted set (Zset)</p><p>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。</p><h4 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式</title>
      <link href="/2019/10/21/2019-02-03-java-she-ji-mo-shi/"/>
      <url>/2019/10/21/2019-02-03-java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h2><p>优点：</p><p>(1) 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了</p><p>(2) 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。</p><p>缺点</p><p>(1) 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。</p><p>(2) 单例对象如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context</p><h2 id="恶汉式"><a href="#恶汉式" class="headerlink" title="恶汉式"></a>恶汉式</h2><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h2 id="恶汉式-1"><a href="#恶汉式-1" class="headerlink" title="恶汉式"></a>恶汉式</h2><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>优点：<br>　<br>工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。<br>　<br> 缺点：</p><p> 由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 人类 */</span><span class="token keyword">interface</span> <span class="token class-name">PeopleDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 说话方法     */</span>    <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 男人 */</span><span class="token keyword">class</span> <span class="token class-name">ManaDemo</span> <span class="token keyword">implements</span> <span class="token class-name">PeopleDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男人说话"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 女人 */</span><span class="token keyword">class</span> <span class="token class-name">WamnDemo</span> <span class="token keyword">implements</span> <span class="token class-name">PeopleDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女人说话"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 通过反射实现工厂 */</span><span class="token keyword">class</span> <span class="token class-name">FactoryDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> PeopleDemo <span class="token function">simaple</span><span class="token punctuation">(</span>Class <span class="token class-name">c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// newInstance调用无参构造方法</span>        PeopleDemo peoples <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            peoples <span class="token operator">=</span> <span class="token punctuation">(</span>PeopleDemo<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> peoples<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 实现类 */</span><span class="token keyword">class</span> <span class="token class-name">TestDemo</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        PeopleDemo simaple <span class="token operator">=</span> FactoryDemo<span class="token punctuation">.</span><span class="token function">simaple</span><span class="token punctuation">(</span>WamnDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        simaple<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象产品1 */</span><span class="token keyword">interface</span> <span class="token class-name">IProduct1</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象产品2 */</span><span class="token keyword">interface</span> <span class="token class-name">IProduct2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品1 */</span><span class="token keyword">class</span> <span class="token class-name">Product1</span> <span class="token keyword">implements</span> <span class="token class-name">IProduct1</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是1型产品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品2 */</span><span class="token keyword">class</span> <span class="token class-name">Product2</span> <span class="token keyword">implements</span> <span class="token class-name">IProduct2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是2型产品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象工厂 */</span><span class="token keyword">interface</span> <span class="token class-name">IFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> IProduct1 <span class="token function">createProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> IProduct2 <span class="token function">createProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体工厂 == 生产产品 */</span><span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token keyword">implements</span> <span class="token class-name">IFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> IProduct1 <span class="token function">createProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> IProduct2 <span class="token function">createProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 客户端 */</span><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        IFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">createProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">createProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记</title>
      <link href="/2019/10/21/2019-02-03-java-ji-chu/"/>
      <url>/2019/10/21/2019-02-03-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>包括内容：基础知识点，集合类，队列，线程（基础），io</p><p>网站：<a href="https://blog.csdn.net/topdeveloperr/article/details/81414318" target="_blank" rel="noopener">https://blog.csdn.net/topdeveloperr/article/details/81414318</a></p><h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><h3 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h3><p>答：封装、继承和多态。</p><p>多态分为<strong>编译时多态和运行时多态。</strong></p><ul><li><p>编译时多态：<strong>方法的重载</strong></p></li><li><p>运行时多态：指程序中定义的对象引用所指向的具体类型在运行期间才确定。</p></li></ul><p><strong>运行时多态</strong>有三个<strong>条件</strong>：</p><p>多态的存在有三个前提:</p><ul><li><p>要有继承关系</p></li><li><p>子类要重写父类的方法</p></li><li><p>父类引用指向子类对,</p></li></ul><p>父类Animal</p><pre><code> 1 class Animal { 2    int num = 10; 3    static int age = 20; 4    public void eat() { 5        System.out.println("动物吃饭"); 6        } 7    public static void sleep() { 8        System.out.println("动物在睡觉"); 9        }10    public void run(){11        System.out.println("动物在奔跑");12       }13}</code></pre><p>子类Cat</p><pre><code>1class Cat extends Animal { 2    int num = 80; 3    static int age = 90; 4     String name = "tomCat"; 5    public void eat() { 6        System.out.println("猫吃饭"); 7    } 8    public static void sleep() { 9        System.out.println("猫在睡觉");10    }11    public void catchMouse() {12        System.out.println("猫在抓老鼠");13    }14}</code></pre><p>测试类Demo_Test1</p><pre><code> 1class Demo_Test1 { 2    public static void main(String[] args) { 3    Animal am = new Cat(); 4    am.eat(); 5    am.sleep(); 6    am.run(); 7    //am.catchMouse();这里先注释掉，等会会说明 8     //System.out.println(am.name);//这里先注释，待会说明 9    System.out.println(am.num);10    System.out.println(am.age);11    }12}</code></pre><p>以上的三段代码充分体现了多态的三个前提，即：</p><p>1、存在继承关系Cat类继承了Animal类</p><p>2、子类要重写父类的方法子类重写(override)了父类的两个成员方法eat()，sleep()。其中eat()是非静态的，sleep()是静态的（static）。</p><p>3、父类数据类型的引用指向子类对象。</p><p>如果再深究一点呢，我们可以看看上面测试类的输出结果，或许对多态会有更深层次的认识。猜一猜上面<br>的结果是什么。</p><p>可以看出来</p><p>子类Cat重写了父类Animal的非静态成员方法am.eat();的输出结果为：猫吃饭。</p><p>子类重写了父类(Animal)的静态成员方法am.sleep();的输出结果为：动物在睡觉</p><p>未被子类（Cat）重写的父类（Animal）方法am.run()输出结果为：动物在奔跑</p><p><strong>那么我们可以根据以上情况总结出多态成员访问的特点：</strong></p><pre><code>1成员变量2- 编译看左边(父类),运行看左边(父类)3成员方法4- 编译看左边(父类)，运行看右边(子类)。动态绑定5静态方法6- 编译看左边(父类)，运行看左边(父类)。78(静态和类相关，算不上重写，所以，访问还是左边的)9只有非静态的成员方法,编译看左边,运行看右边</code></pre><p><strong>那么多态有什么弊端呢？</strong></p><p>不能使用子类特有的成员属性和子类特有的成员方法。</p><p>参考：<a href="https://www.zhihu.com/question/30082151" target="_blank" rel="noopener">https://www.zhihu.com/question/30082151</a></p><p>很明显，执行强转语句Cat ct = (Cat)am;之后，ct就指向最开始在堆内存中创建的那个Cat类型的对象了。</p><p><strong>这就是多态的魅力吧，虽然它有缺点，但是它确实十分灵活，减少多余对象的创建，不用说为了使用子类的某个方法又去重新再堆内存中开辟一个新的子类对象。</strong></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><hr><p>String是类类型，不是基本类型。</p><p>基本类型 有八种：整型 （4种）字符型 （1种）浮点型 （2种）布尔型（1种）</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0002.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0003.jpg" alt=""></p><p>缓存池</p><pre><code> 1 public class Main_1 { 2    public static void main(String[] args) { 3        Integer a = 1; 4        Integer b = 2; 5        Integer c = 3; 6        Integer d = 3; 7        Integer e = 321; 8        Integer f = 321; 9        Long g = 3L;10        System.out.println(c == d);//true，缓存池11        System.out.println(e == f);//false，不在缓存池12        System.out.println(c == (a + b));//true13        System.out.println(c.equals(a + b));//true14        System.out.println(g == (a + b));//true15        System.out.println(g.equals(a + b));//false16        System.out.println(g.equals(a + h));//true17    }</code></pre><p><strong>使用==的情况：</strong></p><ul><li><p>如果比较Integer变量，<strong>默认比较的是地址值。</strong></p></li><li><p>特例：如果比较的<strong>某一边有操作表达式(例如a+b)</strong>，那么比较的是<strong>具体数值</strong></p></li></ul><p><strong>使用equals()的情况：</strong></p><ul><li><p>无论是Integer还是Long中的equals()<strong>默认比较的是数值</strong>。</p></li><li><p><strong>特例：Long的equals()方法，JDK的默认实现：会判断是否是Long类型</strong></p></li></ul><p><strong>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</strong></p><ul><li><p>new Integer(123) <strong>每次都会新建一个对象</strong></p></li><li><p>Integer.valueOf(123) <strong>会使用缓存池中的对象</strong>，多次调用会取得同一个对象的引用。</p></li></ul><p><strong>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</strong></p><pre><code>1public static Integer valueOf(int i) {2    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)3        return IntegerCache.cache[i + (-IntegerCache.low)];4    return new Integer(i);5}</code></pre><p><strong>基本类型对应的缓冲池如下：</strong></p><ul><li><p>boolean values true and false</p></li><li><p>all byte values</p></li><li><p>short values between -128 and 127</p></li><li><p>int values between -128 and 127</p></li><li><p>char in the range \u0000 to \u007F</p></li></ul><p><strong>默认IntegerCache.low 是-127，Integer.high是128，如果在这个区间[-128,127]内，他就会把变量i当做一个变量，放到内存中，用比较是会得出true；但如果不在这个范围内，就会去new一个Integer对象，当运用“”时，会比较Integer两个对象地址，得出false。</strong></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>String 被声明为 final，因此它不可被继承。</strong></p><pre><code>首先String不属于8中基本类型，String是一个对象String 由于使用final 修饰存储在常量区（不是new出来的）new出来的存储在对象存储在堆中，栈中存放的为引用地址。</code></pre><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    /** The value is used for character storage. */    private final char value[];}</code></pre><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    /** The value is used for character storage. */    private final byte[] value;    /** The identifier of the encoding used to encode the bytes in {@code value}. */    private final byte coder;}</code></pre><h4 id="String不可变的好处"><a href="#String不可变的好处" class="headerlink" title="String不可变的好处"></a>String不可变的好处</h4><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><strong>注意：不是string创建后就默认进入池的，请看下方intern()</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0004.jpg" alt=""></p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><p>Program Creek : Why String is immutable in Java?</p><h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><pre><code>1String s1 = new String("aaa");2String s2 = new String("aaa");3System.out.println(s1 == s2);           // false4String s3 = s1.intern();5String s4 = s1.intern();6System.out.println(s3 == s4);           // true</code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><pre><code>1String s5 = "bbb";2String s6 = "bbb";3System.out.println(s5 == s6);  // true</code></pre><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li><p>StackOverflow : What is String interning?</p></li><li><p>深入解析 String#intern</p></li></ul><h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li><p>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</p></li><li><p>而使用 new 的方式会在堆中创建一个字符串对象。</p></li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><pre><code>1public class NewStringTest {2    public static void main(String[] args) {3        String s = new String("abc");4    }5}</code></pre><p>使用 javap -verbose 进行反编译，得到以下内容：</p><pre><code> 1// ... 2Constant pool: 3// ... 4   #2 = Class              #18            // java/lang/String 5   #3 = String             #19            // abc 6// ... 7  #18 = Utf8               java/lang/String 8  #19 = Utf8               abc 9// ...1011  public static void main(java.lang.String[]);12    descriptor: ([Ljava/lang/String;)V13    flags: ACC_PUBLIC, ACC_STATIC14    Code:15      stack=3, locals=2, args_size=116         0: new           #2                  // class java/lang/String17         3: dup18         4: ldc           #3                  // String abc19         6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V20         9: astore_121// ...</code></pre><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><pre><code>1public String(String original) {2    this.value = original.value;3    this.hash = original.hash;4}</code></pre><h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p><ul><li><p>String 不可变</p></li><li><p>StringBuffer 和 StringBuilder 可变</p></li></ul><p><strong>2. 线程安全</strong></p><ul><li><p>String 不可变，因此是线程安全的</p></li><li><p>StringBuilder 不是线程安全的</p></li><li><p>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p></li></ul><p><strong>对于三者使用的总结：</strong></p><p>1.如果要操作少量的数据用 String</p><p>2.<strong>单线程</strong>操作字符串缓冲区下操作大量数据 StringBuilder</p><p>3.<strong>多线程</strong>操作字符串缓冲区下操作大量数据 StringBuffer</p><h3 id="String-和StringBuffer的区别？"><a href="#String-和StringBuffer的区别？" class="headerlink" title="String 和StringBuffer的区别？"></a>String 和StringBuffer的区别？</h3><p>String是immutable的,其内容一旦创建好之后，就不可以发生改变。</p><p>StringBuffer 是可以变长的，内容也可以发生改变<br>改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。</p><p><a href="https://blog.csdn.net/yeweiyang16/article/details/51755552" target="_blank" rel="noopener">https://blog.csdn.net/yeweiyang16/article/details/51755552</a></p><p><strong>初始化：可以指定给对象的实体的初始容量为参数字符串s的长度额外再加16个字符</strong></p><p><strong>扩容：尝试将新容量扩为大小变成原容量的1倍+2，然后if判断一下 容量如果不够，直接扩充到需要的容量大小。</strong></p><p>StackOverflow : String, StringBuffer, and StringBuilder</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h2 id="参数传递-1"><a href="#参数传递-1" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li>Java基本数据类型传递参数时是值传递；引用类型传递参数时是引用传递。</li><li>值传递时，将实参的值传递一份给形参；引用传递时，将实参的地址值传递一份给形参。</li><li>值传递时，实参把它的值传递给对应的形参，函数接收的是原始值的一个拷贝，此时内存中存在两个相等的基本类型，即实参和形参，后面方法中的操作都是对形参这个值的修改，不影响实参的值。引用传递时，实参的引用(地址，而不是参数的值)被传递给方法中相对应的形参，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。</li><li>需要特殊考虑String，以及Integer、Double等几个基本类型包装类，它们都是immutable类型，因为没有提供自身修改的函数，每次操作都是新创建一个对象，所以要特殊对待。因为最后的操作不会修改实参，可以认为是和基本数据类型相似，为值传递。</li></ul><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p><pre><code>1public class Dog { 2 3    String name; 4 5    Dog(String name) { 6        this.name = name; 7    } 8 9    String getName() {10        return this.name;11    }1213    void setName(String name) {14        this.name = name;15    }1617    String getObjectAddress() {18        return super.toString();19    }20} 1public class PassByValueExample { 2    public static void main(String[] args) { 3        Dog dog = new Dog("A"); 4        System.out.println(dog.getObjectAddress()); // Dog@4554617c 5        func(dog); 6        System.out.println(dog.getObjectAddress()); // Dog@4554617c 7        System.out.println(dog.getName());          // A 8    } 910    private static void func(Dog dog) {11        System.out.println(dog.getObjectAddress()); // Dog@4554617c12        dog = new Dog("B");13        System.out.println(dog.getObjectAddress()); // Dog@74a1448214        System.out.println(dog.getName());          // B15    }16}</code></pre><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p><pre><code> 1class PassByValueExample { 2    public static void main(String[] args) { 3        Dog dog = new Dog("A"); 4        func(dog); 5        System.out.println(dog.getName());          // B 6    } 7 8    private static void func(Dog dog) { 9        dog.setName("B");10    }11}</code></pre><p>StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</p><h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p><pre><code>1// float f = 1.1;</code></pre><p>1.1f 字面量才是 float 类型。</p><pre><code>1float f = 1.1f;</code></pre><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p><pre><code>1short s1 = 1;2// s1 = s1 + 1;</code></pre><p>但是使用 += 运算符可以执行隐式类型转换。</p><pre><code>1s1 += 1;</code></pre><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><pre><code>1s1 = (short) (s1 + 1);</code></pre><p>StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><pre><code>1String s = "a";2switch (s) {3    case "a":4        System.out.println("aaa");5        break;6    case "b":7        System.out.println("bbb");8        break;9}</code></pre><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong></p><p>抽象类和普通类最大的区别是：</p><p><strong>抽象类不能被实例化，需要继承抽象类才能实例化其子类</strong>。</p><pre><code> 1public abstract class AbstractClassExample { 2 3    protected int x; 4    private int y; 5 6    public abstract void func1(); 7 8    public void func2() { 9        System.out.println("func2");10    }11}1public class AbstractExtendClassExample extends AbstractClassExample {2    @Override3    public void func1() {4        System.out.println("func1");5    }6}</code></pre><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p><strong>从 Java 8 开始，接口也可以拥有默认的方法实现</strong>，这是因为不支持默认方法的接口的维护成本太高了。</p><p><strong>在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</strong></p><p><strong>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</strong></p><p><strong>接口的字段默认都是 static 和 final 的。</strong></p><pre><code> 1public interface InterfaceExample { 2    void func1(); 3 4    default void func2(){ 5        System.out.println("func2"); 6    } 7 8    int x = 123; 9    // int y;               // Variable 'y' might not have been initialized10    public int z = 0;       // Modifier 'public' is redundant for interface fields11    // private int k = 0;   // Modifier 'private' not allowed here12    // protected int l = 0; // Modifier 'protected' not allowed here13    // private void fun3(); // Modifier 'private' not allowed here14}1public class InterfaceImplementExample implements InterfaceExample {2    @Override3    public void func1() {4        System.out.println("func1");5    }6}</code></pre><p><strong>3. 比较</strong></p><ul><li><p><strong>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</strong></p></li><li><p>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</p></li><li><p><strong>接口的字段只能是 static 和 final 类型的</strong>，而抽象类的字段没有这种限制。</p></li><li><p><strong>接口的成员只能是 public 的</strong>，而抽象类的成员可以有多种访问权限。</p></li></ul><p><strong>4. 使用选择</strong></p><p>使用接口：</p><ul><li><p>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</p></li><li><p>需要使用多重继承。</p></li></ul><p>使用抽象类：</p><ul><li><p>需要在几个相关的类中共享代码。</p></li><li><p>需要能控制继承来的成员的访问权限，而不是都为 public。</p></li><li><p>需要继承非静态static和非常量final字段。</p></li></ul><p><strong>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</strong></p><ul><li><p>深入理解 abstract class 和 interface</p></li><li><p>When to Use Abstract Class and Interface</p></li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li><p><strong>访问父类的构造函数</strong>：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</p></li><li><p><strong>访问父类的成员</strong>：如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</p></li></ul><p>Using the Keyword super</p><h3 id="继承相关小问题"><a href="#继承相关小问题" class="headerlink" title="继承相关小问题"></a>继承相关小问题</h3><h4 id="接口是否可继承接口"><a href="#接口是否可继承接口" class="headerlink" title="接口是否可继承接口?"></a>接口是否可继承接口?</h4><p>可以，比如List 就继承了接口Collection</p><h4 id="抽象类是否可实现-implements-接口"><a href="#抽象类是否可实现-implements-接口" class="headerlink" title="抽象类是否可实现(implements)接口?"></a>抽象类是否可实现(implements)接口?</h4><p>可以，比如 MouseAdapter鼠标监听适配器 是一个抽象类，并且实现了MouseListener接口</p><h4 id="抽象类是否可继承实体类（concrete-class）？"><a href="#抽象类是否可继承实体类（concrete-class）？" class="headerlink" title="抽象类是否可继承实体类（concrete class）？"></a>抽象类是否可继承实体类（concrete class）？</h4><p>可以，所有抽象类，都继承了Object</p><h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h2><p>经典：</p><p><a href="https://fangjian0423.github.io/2016/03/12/java-Object-method/" target="_blank" rel="noopener">https://fangjian0423.github.io/2016/03/12/java-Object-method/</a></p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><pre><code> 1public native int hashCode() 2 3public boolean equals(Object obj) 4 5protected native Object clone() throws CloneNotSupportedException 6 7public String toString() 8 9public final native Class&lt;?&gt; getClass()1011protected void finalize() throws Throwable {}1213public final native void notify()1415public final native void notifyAll()1617public final native void wait(long timeout) throws InterruptedException1819public final void wait(long timeout, int nanos) throws InterruptedException2021public final void wait() throws InterruptedException</code></pre><ul><li>getClass方法</li></ul><ul><li>返回当前运行时对象的Class对象</li></ul><ul><li>hashCode方法</li></ul><ul><li>该方法返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。（文章中有对hashcode的详细解释）</li></ul><ul><li>equals方法</li></ul><ul><li>如果重写了equals方法，通常有必要重写hashCode方法，这点已经在hashCode方法中说明了。</li></ul><ul><li>clone方法</li></ul><ul><li><p>创建并返回当前对象的一份拷贝。<strong>Object本身没有实现Cloneable接口</strong>，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</p></li><li><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p></li></ul><ul><li>toString方法</li></ul><ul><li>Object对象的默认实现，即输出类的名字@实例的哈希码的16进制。</li></ul><ul><li>notify方法：</li></ul><ul><li>唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。</li></ul><ul><li>notifyAll方法</li></ul><ul><li>跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</li></ul><ul><li>wait(long timeout) throws InterruptedException方法</li></ul><ul><li>wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。</li></ul><ul><li>wait(long timeout, int nanos) throws InterruptedException方法</li></ul><ul><li>跟wait(long timeout)方法类似，<strong>多了一个nanos参数，这个参数表示额外时间</strong>（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</li></ul><ul><li><p>wait() throws InterruptedException方法</p><p>需要注意的是 wait(0, 0)和wait(0)效果是一样的，即一直等待。</p></li></ul><ul><li>跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念。</li></ul><ul><li>finalize方法</li></ul><ul><li>该方法的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。</li></ul><p><strong>补充：什么是Native Method</strong></p><p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ul><li><p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</p></li><li><p>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p></li></ul><pre><code>Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y);      // false</code></pre><ul><li>== 是java提供的等于比较运算符,用来比较两个变量指向的内存地址是否相同.</li><li>所以用”==”判断两个引用数据类型是否相等的时候，<strong>实际上是在判断两个引用是否指向同一个对象</strong></li><li>而equals()是Object提供的一个方法.Object中equals()方法的默认实现就是返回两个对象==的比较结果.但是equals()可以被重写,所以我们在具体使用的时候需要关注equals()方法有没有被重写.</li></ul><pre><code>public boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String)anObject;        int n = value.length;        if (n == anotherString.value.length) {            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) {                if (v1[i] != v2[i])                    return false;                i++;            }            return true;        }    }    return false;}</code></pre><blockquote><p>当调用 String 类型数据的 equals() 方法时，首先会判断两个字符串的引用是否相等，也就是说两个字符串引用是否指向同一个对象，是则返回true。</p></blockquote><blockquote><p>如果不是指向同一个对象，则把两个字符串中的字符挨个进行比较。由于 s1 和 s3 字符串都是 “hello”，是可以匹配成功的，所以最终返回 true。</p></blockquote><pre><code>由于Java程序员们会创建各种满足它们业务需求的对象，系统无法提前知道两个对象在什么条件下算相等，Java干脆把判断对象是否相等的权力交给编程人员。具体的措施是：所有的类都必须继承 Object 类，而 Object 类中写有equals()方法。编程人员可以通过重写 equals() 方法来实现自己的比较策略，也可以不重写，使用Object类的equals()比较策略。</code></pre><p><strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?</strong></p><p><strong>因为hashCode()方法和equals()方法都可以通过自定义类重写</strong>，是可以做到equals相同，但是hashCode不同的</p><p>但是，在Object类的equals()方法中有这么一段话</p><p>翻译如下：</p><p>通常来讲，在重写这个方法的时候，也需要对hashCode方法进行重写，<br>以此来保证这两个方法的一致性——<br>当equals返回true的时候，这两个对象一定有相同的hashcode.</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><pre><code>public native int hashCode();</code></pre><blockquote><p>集合Set中的元素是无序不可重复的，那判断两个元素是否重复的依据是什么呢？ “比较对象是否相等当然用Object.equal()了”，某猿如是说。但是，Set中存在大量对象，后添加到集合Set中的对象元素比较次数会逐渐增多，大大降低了程序运行效率。 Java中采用哈希算法(也叫散列算法)来解决这个问题，将对象(或数据)依特定算法直接映射到一个地址上，对象的存取效率大大提高。这样一来，当含有海量元素的集合Set需要添加某元素(对象)时，先调用这个元素的hashCode()，就能一下子定位到此元素实际存储位置，如果这个位置没有元素，说明此对象时第一次存储到集合Set, 直接将此对象存储在此位置上；若此位置有对象存在，调用equal()看看这两个对象是否相等，相等就舍弃此元素不存，不等则散列到其他地址。</p></blockquote><h3 id="hashCode-amp-amp-equals"><a href="#hashCode-amp-amp-equals" class="headerlink" title="hashCode() &amp;&amp; equals()"></a>hashCode() &amp;&amp; equals()</h3><p>重写 equals 方法的同时也需要重写 hashCode 方法，有没有想过为什么？</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc32.png" alt="image"></p><p>假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。</p><p>然而重写了equals，且s1.equals(s2)返回true，根据hashcode的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。</p><p>以下是关于hashcode的一些规定：</p><ul><li>两个对象相等，hashcode一定相等</li><li>两个对象不等，hashcode不一定不等</li><li>hashcode相等，两个对象不一定相等</li><li>hashcode不等，两个对象一定不等</li></ul><p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><pre><code>public class ToStringExample {    private int number;    public ToStringExample(int number) {        this.number = number;    }}ToStringExample example = new ToStringExample(123);System.out.println(example.toString());ToStringExample@4554617c</code></pre><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><pre><code>public class CloneExample {2    private int a;3    private int b;4}1CloneExample e1 = new CloneExample();2// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</code></pre><p>重写 clone() 得到以下实现：</p><pre><code>1public class CloneExample {2    private int a;3    private int b;45    @Override6    public CloneExample clone() throws CloneNotSupportedException {7        return (CloneExample)super.clone();8    }9}1CloneExample e1 = new CloneExample();2try {3    CloneExample e2 = e1.clone();4} catch (CloneNotSupportedException e) {5    e.printStackTrace();6}1java.lang.CloneNotSupportedException: CloneExample</code></pre><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><pre><code>1public class CloneExample implements Cloneable {2    private int a;3    private int b;45    @Override6    public Object clone() throws CloneNotSupportedException {7        return super.clone();8    }9}</code></pre><p><strong>2. 浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><pre><code>1public class ShallowCloneExample implements Cloneable { 2 3    private int[] arr; 4 5    public ShallowCloneExample() { 6        arr = new int[10]; 7        for (int i = 0; i &lt; arr.length; i++) { 8            arr[i] = i; 9        }10    }1112    public void set(int index, int value) {13        arr[index] = value;14    }1516    public int get(int index) {17        return arr[index];18    }1920    @Override21    protected ShallowCloneExample clone() throws CloneNotSupportedException {22        return (ShallowCloneExample) super.clone();23    }24}1ShallowCloneExample e1 = new ShallowCloneExample();2ShallowCloneExample e2 = null;3try {4    e2 = e1.clone();5} catch (CloneNotSupportedException e) {6    e.printStackTrace();7}8e1.set(2, 222);9System.out.println(e2.get(2)); // 222</code></pre><p><strong>3. 深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><pre><code> 1public class DeepCloneExample implements Cloneable { 2 3    private int[] arr; 4 5    public DeepCloneExample() { 6        arr = new int[10]; 7        for (int i = 0; i &lt; arr.length; i++) { 8            arr[i] = i; 9        }10    }1112    public void set(int index, int value) {13        arr[index] = value;14    }1516    public int get(int index) {17        return arr[index];18    }1920    @Override21    protected DeepCloneExample clone() throws CloneNotSupportedException {22        DeepCloneExample result = (DeepCloneExample) super.clone();23        result.arr = new int[arr.length];24        for (int i = 0; i &lt; arr.length; i++) {25            result.arr[i] = arr[i];26        }27        return result;28    }29}1DeepCloneExample e1 = new DeepCloneExample();2DeepCloneExample e2 = null;3try {4    e2 = e1.clone();5} catch (CloneNotSupportedException e) {6    e.printStackTrace();7}8e1.set(2, 222);9System.out.println(e2.get(2)); // 2</code></pre><p><strong>4. clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><pre><code> 1public class CloneConstructorExample { 2 3    private int[] arr; 4 5    public CloneConstructorExample() { 6        arr = new int[10]; 7        for (int i = 0; i &lt; arr.length; i++) { 8            arr[i] = i; 9        }10    }1112    public CloneConstructorExample(CloneConstructorExample original) {13        arr = new int[original.arr.length];14        for (int i = 0; i &lt; original.arr.length; i++) {15            arr[i] = original.arr[i];16        }17    }1819    public void set(int index, int value) {20        arr[index] = value;21    }2223    public int get(int index) {24        return arr[index];25    }26}1CloneConstructorExample e1 = new CloneConstructorExample();2CloneConstructorExample e2 = new CloneConstructorExample(e1);3e1.set(2, 222);4System.out.println(e2.get(2)); // 2</code></pre><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li><p>修饰类：表示该类不能被继承</p></li><li><p>修饰方法：表示该方法不能被重写</p></li><li><p>修饰变量：表示该变量只能被赋值一次</p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p></li></ul><ul><li><p>对于基本类型，final 使数值不变；</p></li><li><p>对于引用类型，final 使引用不变，表示该引用只有一次指向对象的机会，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</p></li></ul><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally 是用于异常处理的场面，无论是否有异常抛出，都会执行</p><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p>finalize是Object的方法，所有类都继承了该方法。 当一个对象满足垃圾回收的条件，并且被回收的时候，其finalize()方法就会被调用</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p><ul><li><p>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</p></li><li><p>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p></li></ul><pre><code> 1public class A { 2    private int x;         // 实例变量 3    private static int y;  // 静态变量 4 5    public static void main(String[] args) { 6        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context 7        A a = new A(); 8        int x = a.x; 9        int y = A.y;10    }11}</code></pre><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。<strong>所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。</strong></p><pre><code>1public abstract class A {2    public static void func1(){3    }4    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'5}</code></pre><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><pre><code> 1public class A { 2    private static int x; 3    private int y; 4 5    public static void func1(){ 6        int a = x; 7        // int b = y;  // Non-static field 'y' cannot be referenced from a static context 8        // int b = this.y;     // 'A.this' cannot be referenced from a static context 9    }10}</code></pre><p><strong>3. 静态语句块</strong></p><p><strong>静态语句块在类初始化时运行一次。</strong></p><pre><code> 1public class A { 2    static { 3        System.out.println("123"); 4    } 5 6    public static void main(String[] args) { 7        A a1 = new A(); 8        A a2 = new A(); 9    }10}1123</code></pre><p><strong>4. 静态内部类</strong></p><p><strong>非静态内部类依赖于外部类的实例，而静态内部类不需要。</strong></p><p>当一个内部类没有使用static修饰的时候，是不能直接使用内部类创建对象，须要先使用外部类对象.new内部类对象及(外部类对象.new 内部类（）)</p><p>而静态内部类只需要<code>new OuterClass.InnerClass();</code></p><pre><code> 1public class OuterClass { 2    class InnerClass { 3    } 4 5    static class StaticInnerClass { 6    } 7 8    public static void main(String[] args) { 9        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context10        OuterClass outerClass = new OuterClass();11        InnerClass innerClass = outerClass.new InnerClass();12        StaticInnerClass staticInnerClass = new StaticInnerClass();13    }14}</code></pre><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><pre><code>1import static com.xxx.ClassName.*</code></pre><p><strong>6. 初始化顺序</strong></p><p>存在继承的情况下，初始化顺序为：</p><ul><li><p>父类（静态变量、静态语句块）</p></li><li><p>子类（静态变量、静态语句块）</p></li><li><p>父类（实例变量、普通语句块）</p></li><li><p>父类（构造函数）</p></li><li><p>子类（实例变量、普通语句块）</p></li><li><p>子类（构造函数）</p></li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>每个类都有一个  <strong>Class</strong>  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName("com.mysql.jdbc.Driver")</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><p><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</p></li><li><p><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</p></li><li><p><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</p></li></ul><p><strong>反射的优点：</strong></p><ul><li><p><strong>可扩展性</strong>  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p></li><li><p><strong>类浏览器和可视化开发环境</strong>  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</p></li><li><p><strong>调试器和测试工具</strong>  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</p></li></ul><p><strong>反射的缺点：</strong></p><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><p><strong>性能开销</strong>  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p></li><li><p><strong>安全限制</strong>  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p></li><li><p><strong>内部暴露</strong>  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p></li><li><p>Trail: The Reflection API</p></li><li><p>深入解析 Java 反射（1）- 基础</p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>运行时异常：</p><pre><code>1NullPointerException 空指针异常2ArithmeticException 算术异常，比如除数为零3ClassCastException 类型转换异常4ConcurrentModificationException同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常 5IndexOutOfBoundsException 数组下标越界异常6NegativeArraySizeException 为数组分配的空间是负数异常</code></pre><p><strong>一般异常又叫做可查异常（受检异常），在编译过程中，必须进行处理，要么捕捉，要么通过throws 抛出去.</strong></p><pre><code>1比如FileNotFoundException</code></pre><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0005.jpg" alt=""></p><h3 id="Error和Exception有什么区别"><a href="#Error和Exception有什么区别" class="headerlink" title="Error和Exception有什么区别?"></a>Error和Exception有什么区别?</h3><p>Error和Exception都实现了Throwable接口</p><p>Error指的是JVM层面的错误，比如内存不足OutOfMemoryError</p><p>Exception 指的是代码逻辑的异常，比如下标越界OutOfIndexException</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><pre><code>1public class Box&lt;T&gt; {2    // T stands for "Type"3    private T t;4    public void set(T t) { this.t = t; }5    public T get() { return t; }6}</code></pre><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><p>&amp; 有两个作用，分别是 位与 和 逻辑与</p><p>&amp;&amp; 就是逻辑与</p><p><strong>长路与&amp;</strong>：两侧，都会被运算</p><p><strong>短路与&amp;&amp;</strong>：只要第一个是false，第二个就不进行运算了</p><h3 id="heap和stack有什么区别"><a href="#heap和stack有什么区别" class="headerlink" title="heap和stack有什么区别"></a>heap和stack有什么区别</h3><p>heap: 堆</p><p>stack: 栈</p><ul><li>存放的内容不一样：<ul><li>heap: 是存放对象的</li><li>stack: 是存放基本类型(int, float, boolean 等等)、引用(对象地址)、方法调用</li></ul></li><li>存取方式不一样：<ul><li>heap: 是自动增加大小的，所以不需要指定大小，但是存取相对较慢</li><li>stack: 先入后出的顺序，并且存取速度比较快</li></ul></li></ul><h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><p>数组获取长度的手段是 .length 属性</p><p>String获取长度的手段是 length()方法</p><p>集合获取长度的手段是 size()方法</p><p>文件获取长度的手段是 length()方法</p><h3 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢</h3><p>以HashSet为例，判断重复的逻辑是：</p><ol><li><p>首先看hashcode是否相同，如果不同，就是不重复的</p></li><li><p>如果hashcode一样，再比较equals，如果不同，就是不重复的，否则就是重复的。</p></li></ol><p><a href="http://how2j.cn/k/collection/collection-hashcode/371.html#step2530" target="_blank" rel="noopener">http://how2j.cn/k/collection/collection-hashcode/371.html#step2530</a></p><h3 id="构造函数器-Constructor是否可被override-是否可以继承String类"><a href="#构造函数器-Constructor是否可被override-是否可以继承String类" class="headerlink" title="构造函数器/Constructor是否可被override?是否可以继承String类?"></a>构造函数器/Constructor是否可被override?是否可以继承String类?</h3><p>子类不能继承父类的构造方法，所以就不存在重写父类的构造方法。</p><p>String是final修饰的，所以不能够被继承</p><h3 id="try-catch-finally-执行顺序"><a href="#try-catch-finally-执行顺序" class="headerlink" title="try catch finally 执行顺序"></a>try catch finally 执行顺序</h3><p>try里的return和finally里的return 都会支持，但是当前方法<strong>只会采纳finally中return的值</strong></p><p><a href="https://www.cnblogs.com/superFish2016/p/6687549.html" target="_blank" rel="noopener">https://www.cnblogs.com/superFish2016/p/6687549.html</a></p><p><strong>总结以上测试：</strong></p><p>1、finally语句总会执行</p><p>2、如果try、catch中有return语句，finally中没有return，那么<strong>在finally中去修改除了包装类型和静态变量、全局变量以外的数据</strong>都不会对try、catch中返回的变量有任何的影响（包装类型、静态变量会改变、全局变量）。<strong>但是修改包装类型和静态变量、全局变量，会改变变量的值。</strong></p><p>3、尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生。</p><p>4、finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略。</p><p><strong>所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。</strong></p><h3 id="char型变量中能不能存贮一个中文汉字-为什么"><a href="#char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char型变量中能不能存贮一个中文汉字?为什么?"></a>char型变量中能不能存贮一个中文汉字?为什么?</h3><p>char是16位的，占两个字节</p><p>汉字通常使用GBK或者UNICODE编码，也是使用两个字节</p><p>所以可以存放汉字</p><h3 id="一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h3><p>可以包括多个类，但是只能出现一个public修饰的类，但是可以出现多个非public修饰的类。</p><h3 id="java中有几种类型的流？"><a href="#java中有几种类型的流？" class="headerlink" title="java中有几种类型的流？"></a>java中有几种类型的流？</h3><p>Java中所有的流都是基于字节流，所以最基本的流是</p><pre><code> 1输入输出字节流 2 3InputStream 4 5OutputStream 6 7在字节流的基础上，封装了字符流 8 9Reader1011Writer1213进一步，又封装了缓存流1415BufferedReader1617PrintWriter1819以及数据流2021DataInputStream2223DataOutputStream2425对象流2627ObjectInputStream2829ObjectOutputStream3031以及一些其他的奇奇怪怪的流 ~~~</code></pre><h3 id="什么是java序列化，如何实现java序列化？"><a href="#什么是java序列化，如何实现java序列化？" class="headerlink" title="什么是java序列化，如何实现java序列化？"></a>什么是java序列化，如何实现java序列化？</h3><p>序列化指的是把一个Java对象，通过某种介质进行传输，比如Socket输入输出流，或者保存在一个文件里。</p><p>实现java序列化的手段是让该类实现接口 Serializable，这个接口是一个标识性接口，没有任何方法，仅仅用于表示该类可以序列化。</p><p><strong>JAVA序列化ID问题</strong></p><p><a href="https://blog.csdn.net/qq_35370263/article/details/79482993" target="_blank" rel="noopener">https://blog.csdn.net/qq_35370263/article/details/79482993</a></p><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单 1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p><h3 id="在JAVA中，如何跳出当前的多重嵌套循环？"><a href="#在JAVA中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在JAVA中，如何跳出当前的多重嵌套循环？"></a>在JAVA中，如何跳出当前的多重嵌套循环？</h3><pre><code> 1public class HelloWorld { 2    public static void main(String[] args) { 3 4        //打印单数     5        outloop: //outloop这个标示是可以自定义的比如outloop1,ol2,out5 6        for (int i = 0; i &lt; 10; i++) { 7 8            for (int j = 0; j &lt; 10; j++) { 9                System.out.println(i+":"+j);10                if(0==j%2) 11                    break outloop; //如果是双数，结束外部循环12            }1314        }1516    }17}</code></pre><h3 id="Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以-implements-实现-interface-接口"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以-implements-实现-interface-接口" class="headerlink" title="Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以 implements(实现)interface(接口)?"></a>Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以 implements(实现)interface(接口)?</h3><p>匿名内部类本质上就是在继承其他类，实现其他接口</p><p>如例:<br>匿名类1，就是继承了Thread<br>匿名类2 ，就是实现了Runnable接口</p><pre><code> 1package j2se; 2 3public class HelloWorld { 4 5    public static void main(String[] args) { 6 7        // 匿名类1 8        new Thread() { 9            public void run() {1011            }12        };1314        // 匿名类215        new Runnable() {16            public void run() {1718            }19        };2021    }22}</code></pre><h3 id="内部类可以引用外部类的成员吗？有没有什么限制？"><a href="#内部类可以引用外部类的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用外部类的成员吗？有没有什么限制？"></a>内部类可以引用外部类的成员吗？有没有什么限制？</h3><p>可以使用</p><p>如果是非静态内部类，可是使用外部类的所有成员</p><p>如果是静态内部类，只能使用外部类的静态成员</p><h3 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h3><p>Class.forName常见的场景是在数据库驱动初始化的时候调用。</p><p><strong>Class.forName本身的意义是加载类到JVM中。 一旦一个类被加载到JVM中，它的静态属性就会被初始化，在初始化的过程中就会执行相关代码，从而达到”加载驱动的效果”</strong></p><h3 id="JDK-中常用的包有哪些？"><a href="#JDK-中常用的包有哪些？" class="headerlink" title="JDK 中常用的包有哪些？"></a>JDK 中常用的包有哪些？</h3><p>答：java.lang、java.util、java.io、java.net、java.sql。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0006.jpg" alt=""></p><p>容器主要包括 Collection 和 Map 两种，Collection 又包含了 List、Set 以及 Queue。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><strong>Set</strong></p><ul><li><p>HashSet：基于哈希实现，支持快速查找，但不支持有序性操作，例如根据一个范围查找元素的操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的；</p></li><li><p>TreeSet：基于红黑树实现，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logN)；</p></li><li><p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。</p></li></ul><p><strong>List</strong></p><ul><li><p>ArrayList：基于动态数组实现，支持随机访问；</p></li><li><p>Vector：和 ArrayList 类似，但它是线程安全的；</p></li><li><p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p></li></ul><p><strong>Queue</strong></p><ul><li><p>LinkedList：可以用它来支持双向队列；</p></li><li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</p></li></ul><blockquote><p>　优先队列是一种用来维护一组元素构成的结合S的数据结构，其中每个元素都有一个关键字key，元素之间的比较都是通过key来比较的。优先队列包括最大优先队列和最小优先队列，优先队列的应用比较广泛，比如作业系统中的调度程序，当一个作业完成后，需要在所有等待调度的作业中选择一个优先级最高的作业来执行，并且也可以添加一个新的作业到作业的优先队列中。Java中，PriorityQueue的底层数据结构就是堆（默认是小堆）。</p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><p>HashMap：基于哈希实现；</p></li><li><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p></li><li><p>LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p></li><li><p>TreeMap：基于红黑树实现。</p></li></ul><h2 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h2><p>Collection是接口，是List和Set的父接口</p><p>Collections是工具类，提供了排序，混淆等等很多实用方法</p><h2 id="List、Set-和-Map-的初始容量和加载因子"><a href="#List、Set-和-Map-的初始容量和加载因子" class="headerlink" title="List、Set 和 Map 的初始容量和加载因子"></a>List、Set 和 Map 的初始容量和加载因子</h2><p>答：<br>加载因子的系数小于等于1，意指  即当 元素个数 超过 容量长度*加载因子的系数 时，进行扩容。</p><ol><li>List</li></ol><p>ArrayList 的初始容量是 10；加载因子为 0.5； 扩容增量：<strong>原容量的 0.5 倍 +1</strong>；一次扩容后长度为 16。</p><p>Vector 初始容量为 10，加载因子是 1。扩容增量：<strong>原容量的 1 倍</strong>，如 Vector 的容量为 10，一次扩容后是容量为 20。</p><ol start="2"><li>Set</li></ol><p>HashSet，初始容量为 16，加载因子为 0.75； 扩容增量：<strong>原容量的 1 倍</strong>； 如 HashSet 的容量为 16，一次扩容后容量为 32</p><ol start="3"><li>Map</li></ol><p>HashMap，初始容量 16，加载因子为 0.75； 扩容增量：<strong>原容量的 1 倍</strong>； 如 HashMap 的容量为 16，一次扩容后容量为 32</p><h2 id="Comparable-接口和-Comparator-接口有什么区别？"><a href="#Comparable-接口和-Comparator-接口有什么区别？" class="headerlink" title="Comparable 接口和 Comparator 接口有什么区别？"></a>Comparable 接口和 Comparator 接口有什么区别？</h2><p>答：<br>详细可以看：<a href="https://blog.csdn.net/u011240877/article/details/53399019" target="_blank" rel="noopener">https://blog.csdn.net/u011240877/article/details/53399019</a></p><ul><li><p>对于一些普通的数据类型（比如 String, Integer, Double…），<strong>它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。</strong></p></li><li><p>而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。</p></li></ul><p><strong>对比：</strong></p><ul><li><p>Comparable简单，但是如果需要重新定义比较类型时，需要修改源代码。</p></li><li><p>Comparator不需要修改源代码，自定义一个比较器，实现自定义的比较方法。</p></li></ul><h2 id="Java-集合的快速失败机制-“fail-fast”"><a href="#Java-集合的快速失败机制-“fail-fast”" class="headerlink" title="Java 集合的快速失败机制 “fail-fast”"></a>Java 集合的快速失败机制 “fail-fast”</h2><p>答：</p><p>它是 java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p><p>可以知道<strong>在进行add，remove，clear等涉及到修改集合中的元素个数的操作时</strong>，modCount就会发生改变(modCount ++),所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化</p><p>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>解决办法：</p><ol><li><p>在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized；</p></li><li><p>使用 CopyOnWriteArrayList 来替换 ArrayList。</p></li></ol><p><strong>java.util.concurrent包中包含的并发集合类如下：</strong></p><p>详细：<a href="http://raychase.iteye.com/blog/1998965" target="_blank" rel="noopener">http://raychase.iteye.com/blog/1998965</a></p><pre><code>1ConcurrentHashMap23CopyOnWriteArrayList45CopyOnWriteArraySet</code></pre><h3 id="1、java-包访问权限"><a href="#1、java-包访问权限" class="headerlink" title="1、java 包访问权限"></a>1、java 包访问权限</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc1.gif" alt=""></p><h3 id="2、Java中的面向接口编程"><a href="#2、Java中的面向接口编程" class="headerlink" title="2、Java中的面向接口编程"></a>2、Java中的面向接口编程</h3><p> 面向接口编程是很多软件架构设计理论都倡导的编程方式，学习Java自然少不了这一部分，下面是我在学习过程中整理出来的关于如何在Java中实现面向接口编程的知识。</p><p>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，通常推荐“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p><h3 id="3、main方法"><a href="#3、main方法" class="headerlink" title="3、main方法"></a>3、main方法</h3><pre><code>/*** Java中的main()方法详解*/public class HelloWorld {    public static void main(String args[]) {        System.out.println("Hello World!");    }}</code></pre><p>一、先说类：<br>HelloWorld 类中有main()方法，说明这是个java应用程序，通过JVM直接启动运行的程序。<br>既然是类，java允许类不加public关键字约束，当然类的定义只能限制为public或者无限制关键字（默认的）。</p><p>二、再说main()方法</p><blockquote><p>这个main()方法的声明为：public static void main(String args[])。必须这么定义，这是Java的规范。<br>为什么要这么定义，和JVM的运行有关系。<br>当一个类中有main()方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法。<br>由于JVM在运行这个Java应用程序的时候，首先会调用main方法，调用时不实例化这个类的对象，而是通过类名直接调用因此需要是限制为public static。(类名.main())<br>对于java中的main方法，jvm有限制，不能有返回值，因此返回值类型为void。<br>main方法中还有一个输入参数，类型为String[]，这个也是java的规范，main()方法中必须有一个入参，类型必须String[]，至于字符串数组的名字，这个是可以自己设定的，根据习惯，这个字符串数组的名字一般和sun java规范范例中mian参数名保持一致，取名为args。因此，main()方法定义必须是：“public static void main(String 字符串数组参数名[])”。</p></blockquote><p>三、main()方法中可以throw Exception<br>因此main()方法中可以抛出异常，main()方法上也可以声明抛出异常。</p><p>四、main()方法中字符串参数数组作用<br>main()方法中字符串参数数组作用是接收命令行输入参数的，命令行的参数之间用空格隔开。</p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p><p>编译</p><p>运行</p><p>编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。</p><p>运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。</p><p>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p><p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p><p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。</p><h3 id="4、java类的初始化顺序"><a href="#4、java类的初始化顺序" class="headerlink" title="4、java类的初始化顺序"></a>4、java类的初始化顺序</h3><h4 id="本类的初始化顺序"><a href="#本类的初始化顺序" class="headerlink" title="本类的初始化顺序"></a>本类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitialOrderTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变量</span>    <span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"变量"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 静态初始化块</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticField<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化块</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>运行结果：<br><br>    静态变量<br><br>    静态初始化块<br>a<br>    变量<br><br>    初始化块<br><br>    构造器<br></p><h4 id="含有父类的初始化顺序"><a href="#含有父类的初始化顺序" class="headerlink" title="含有父类的初始化顺序"></a>含有父类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String p_StaticField <span class="token operator">=</span> <span class="token string">"父类--静态变量"</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变量</span>    <span class="token keyword">public</span> String p_Field <span class="token operator">=</span> <span class="token string">"父类--变量"</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 静态初始化块</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 初始化块</span>    <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">", j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        j <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String s_StaticField <span class="token operator">=</span> <span class="token string">"子类--静态变量"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变量</span>    <span class="token keyword">public</span> String s_Field <span class="token operator">=</span> <span class="token string">"子类--变量"</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 静态初始化块</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 初始化块</span>    <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">",j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 程序入口</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>  </code></pre><p>运行结果：<br>父类–静态变量<br>父类–静态初始化块<br>子类–静态变量<br>子类–静态初始化块<br>父类–变量<br>父类–初始化块<br>父类–构造器<br>子类–变量<br>子类–初始化块<br>子类–构造器</p><h3 id="5、Java中如何进行异常处理"><a href="#5、Java中如何进行异常处理" class="headerlink" title="5、Java中如何进行异常处理"></a>5、Java中如何进行异常处理</h3><h4 id="Java异常的分类和类结构图"><a href="#Java异常的分类和类结构图" class="headerlink" title="Java异常的分类和类结构图"></a>Java异常的分类和类结构图</h4><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p><p>Throwable又派生出Error类和Exception类。</p><p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p><p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc3.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc7.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc4.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc6.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc5.png" alt=""></p><p>在Java中异常的继承主要有两个： Error和Exception 这两个，而Error就是jvm出现错误，以及系统奔溃等现象这些错误没办法通过程序来处理，所以在程序中不能使用catch来捕捉处理这类的异常。</p><p>对于Exception 又可以分为checkedException 和RuntimeException 这两种异常，checkedException异常在进行编译运行之前就可以知道会不会发生异常，如果不对这些异常进行抛出、捕获的话就不能通过编译。而RuntimeException就是运行的时候出现的异常在之前你是没办法确定是不是会出现异常。</p><blockquote><p>Java的异常处理是通过5个关键字来实现的：try、catch、 finally、throw、throws</p></blockquote><h4 id="try…catch…finally语句块"><a href="#try…catch…finally语句块" class="headerlink" title="try…catch…finally语句块"></a>try…catch…finally语句块</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//try块中放可能发生异常的代码。</span>     <span class="token comment" spellcheck="true">//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span>     <span class="token comment" spellcheck="true">//如果发生异常，则尝试去匹配catch块。</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span>    <span class="token comment" spellcheck="true">//catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span>    <span class="token comment" spellcheck="true">//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span>    <span class="token comment" spellcheck="true">//如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span>    <span class="token comment" spellcheck="true">//如果try中没有发生异常，则所有的catch块将被忽略。</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//finally块通常是可选的。</span>   <span class="token comment" spellcheck="true">//无论异常是否发生，异常是否匹配被处理，finally都会执行。</span>   <span class="token comment" spellcheck="true">//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span>  <span class="token comment" spellcheck="true">//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span><span class="token punctuation">}</span></code></pre><p><strong>需要注意的地方</strong></p><p>1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p><p>2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。</p><p>3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。<br>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）<br>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol><li>不管有没有出现异常，finally块中代码都会执行；</li><li>当try和catch中有return时，finally仍然会执行；</li><li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li><li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li></ol><p><strong>举例：</strong></p><p>情况1. try{} catch(){}finally{} return;<br>显然程序按顺序执行。</p><p>情况2. :try{ return; }catch(){} finally{} return;<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，最后执行try中return;</p><p>finally块之后的语句return，因为程序在try中已经return所以不再执行。</p><p>情况3. :try{ } catch(){return;} finally{} return;<br>程序先执行try，如果遇到异常执行catch块，<br>有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，<br>最后执行catch块中return. finally之后也就是4处的代码不再执行。<br>无异常：执行完try再finally再return.</p><p>情况4:try{ return; }catch(){} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p><p>情况5:try{} catch(){return;}finally{return;}<br>程序执行catch块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p><p>情况6:try{ return;}catch(){return;} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；<br>则再执行finally块，因为finally块中有return所以提前退出。<br>无异常：则再执行finally块，因为finally块中有return所以提前退出。</p><p>最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。<br>如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，<br>编译器把finally中的return实现为一个warning。</p><p>也就是说，如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）</p><p>下面是个测试程序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            x<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>            <span class="token operator">++</span>x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果是2。<br>    在try语句中，在执行return语句时，要返回的结果已经准备好了，就在此时，程序转到finally执行了。<br>在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，<br>因此，即使finally中对变量x进行了改变，但是不会影响返回结果。<br>它应该使用栈保存返回值。<br><strong>finally中的return 会覆盖 try 或者catch中的返回值。</strong></p><h4 id="throws-函数声明"><a href="#throws-函数声明" class="headerlink" title="throws 函数声明"></a>throws 函数声明</h4><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p><p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p><p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ExceptionType1<span class="token punctuation">,</span> ExceptionType2<span class="token punctuation">,</span> ExceptionTypeN <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span><span class="token punctuation">}</span></code></pre><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        String s <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NumberFormatException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h4><p>通过上面的两个demo可以得知：</p><p>1、throw用在方法体内，上面代码显示了，是直接在main方法体内</p><p>   throws用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。这个看上面的代码就理解了</p><p>2、throw是具体向外抛异常的，抛出的是一个异常实例</p><p>   throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常</p><p>3、throw，如果执行了，那么一定是抛出了某种异常了，安生throws表示可能出现，但不一定。</p><p>4、同时出现的时候，throws出现在函数头、throw出现在函数体，两种不会由函数去处理，真正的处理由函数的上层调用处理</p><h4 id="for-中try还是for外try"><a href="#for-中try还是for外try" class="headerlink" title="for 中try还是for外try"></a>for 中try还是for外try</h4><p>try放在for循环的里面所有的for循环都会执行，当遇到异常时，抛出异常继续执行；放在外面，当遇到异常时，抛出异常，后面的循环就会终止，并不会执行。</p><h3 id="6、-变量命名规范"><a href="#6、-变量命名规范" class="headerlink" title="6、 变量命名规范"></a>6、 变量命名规范</h3><p>首字母：字母、$和下划线。变量名：由$、字母、数字和下划线组成。</p><h3 id="7、方法重载与方法重写"><a href="#7、方法重载与方法重写" class="headerlink" title="7、方法重载与方法重写"></a>7、方法重载与方法重写</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc2.png" alt=""></p><h3 id="8、继承-封装-多态-抽象"><a href="#8、继承-封装-多态-抽象" class="headerlink" title="8、继承 封装 多态 抽象"></a>8、继承 封装 多态 抽象</h3><p>1、请描述一下java</p><p>java是一个面向对象的编程语言，有继承 封装 多态的特性，同时java也是一开源的语言，一次编译到处运行，有很完善的生态系统，包括各种各样的企业级框架。</p><p>2、抽象</p><p>抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。</p><p>3、封装</p><blockquote><p> 1）将实例变量标记为私有的（private），表示只能在类的内部使用。 <br><br>   2）提供公有（public）的get和set方法，用来控制对实例变量的存取动作。</p></blockquote><p>   封装的目的是：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。</p><p>4、继承</p><p>目的：实现代码的复用。</p><p>继承是从已有的类得到继承信息创建新的类的过程，继承可以表示为 is-a 关系 。父类的私有属性和构造方法并不能被继承。另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。</p><p>5、多态</p><p>多态可以大概分为两种方式：方法重载与方法重写。</p><ul><li>方法重载（Overload）:编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致。</li><li>方法重写（Override）:运行时的多态（也称为后绑定）。<br>要实现方法重写需要做：1.方法重写，也就是子类继承父类并重写了父类已经有的方法。 2.用父类型引用来引用子类型对象，这样可以实现调用同样的方法会根据子类对象的不同表示出不一样的行为。</li></ul><h3 id="9、接口-amp-amp-抽象类"><a href="#9、接口-amp-amp-抽象类" class="headerlink" title="9、接口 &amp;&amp; 抽象类"></a>9、接口 &amp;&amp; 抽象类</h3><p>接口<br>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。<br>抽象类</p><p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：<br>abstract void fun() 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法</p><p>接口和抽象类的区别</p><p>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p><p>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p><p>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p><p>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>5）抽象类中的方法子类必须全部实现,不然子类也是抽象类,而接口中的抽象方法子类必须全部实现。</p><p>6）抽象类是一种模板设计模式,而接口是一种行为规范。</p><h3 id="10、自动类型转换和强制类型转换规则"><a href="#10、自动类型转换和强制类型转换规则" class="headerlink" title="10、自动类型转换和强制类型转换规则"></a>10、自动类型转换和强制类型转换规则</h3><ul><li>自动类型转换也叫隐式类型转换</li><li>表达式的数据类型自动提升</li><li>从低位类型到高位类型自动转换；从高位类型到低位类型需要强制类型转换：</li><li>boolean类型与其他基本类型不能进行类型的转换（既不能进行自动类型的提升，也不能强制类型转换）</li></ul><h3 id="11、选择结构"><a href="#11、选择结构" class="headerlink" title="11、选择结构"></a>11、选择结构</h3><ul><li>if</li><li>switch<blockquote><p>在switch 中可以使用的类型 Java支持的数据类型有五种<br>  他们分别是：<br>  byte、char、short、int、enum；<br>  以上是JDK1.6以前的版本。<br>  JDK1.7时，又增加了String</p></blockquote></li></ul><p>语法</p><pre><code>int is = 0;switch (is) {    case 1:        System.out.println("**");        break;    case 2:        break;    default:        System.out.println();        break;}</code></pre><ul><li>while</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先判断再执行</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"好好学习，天天向上！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 先执行再判断</span><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>for</li></ul><pre><code> for (int is = 0; is &lt; 100; is++) {     System.out.println("好好学习！"); }</code></pre><h3 id="12、break-amp-amp-continue"><a href="#12、break-amp-amp-continue" class="headerlink" title="12、break &amp;&amp; continue"></a>12、break &amp;&amp; continue</h3><pre><code>continue 作用：跳过循环体中剩余的语句而执行下一次循环break语句终止某个循环，程序跳转到循环块外的下一条语句</code></pre><h3 id="13、数组"><a href="#13、数组" class="headerlink" title="13、数组"></a>13、数组</h3><pre><code>public static void main(String[] args) {    //声明数组    String [] arr;    int arr1[];    //初始化数组    int arr2[]=new int[]{1,2,3,4,5};    String[] array1={"马超","马云","关羽","刘备","张飞"};    String[] array2=new String[]{"黄渤","张艺兴","孙红雷","小猪","牙哥","黄磊"};    String[] array=new String[5];    //查看数组的长度    int length=array1.length;    System.out.println("length：  "+array1.length);    //输出数组//      System.out.println(array1);     //结果：[Ljava.lang.String;@32f22097    System.out.println("arr2:  "+Arrays.toString(arr2));    //遍历数组    for (int i = 0; i &lt; array1.length; i++) {//          System.out.println(array1[i]);    }    //int数组转成string数组    int[]  array3={1,2,3,4,5,6,7,8,9,0};    String arrStrings=Arrays.toString(array3);//      System.out.println(arrStrings);    //从array中创建arraylist    ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;(Arrays.asList(array1));    System.out.println(arrayList);    //数组中是否包含某一个值    String a="马超";    if (Arrays.asList(array1).contains(a)) {        System.out.println("马超在这里");    }    //将数组转成set集合    Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(array2));    System.out.println(set);    //将数组转成list集合    List&lt;String&gt; list=new ArrayList&lt;String&gt;();    for (int i = 0; i &lt; array2.length; i++) {        list.add(array2[i]);    }    String[] arrStrings2={"1","2","3"};    List&lt;String &gt; list2=java.util.Arrays.asList(arrStrings2);    System.out.println(list2);    //Arrays.fill()填充数组    int[] arr3=new int[5];    Arrays.fill(arr3, 10);  //将数组全部填充10    for (int i = 0; i &lt; arr3.length; i++) {        System.out.println(arr3[i]);    }    //数组排序    int[] arr4 = {3, 7, 2, 1, 9};    Arrays.sort(arr4);    for (int i = 0; i &lt; arr4.length; i++) {        System.out.println(arr4[i]);    }    int[] arr5 = {3, 7, 2, 1, 9,3,45,7,8,8,3,2,65,34,5};    Arrays.sort(arr5, 1, 4);  //从第几个到第几个之间的进行排序    for (int i = 0; i &lt; arr5.length; i++) {        System.out.println(arr5[i]);    }    //复制数组    int[] arr6 = {3, 7, 2, 1};    int[] arr7=Arrays.copyOf(arr6, 10);  //指定新数组的长度    int[] arr8=Arrays.copyOfRange(arr6, 1, 3); //只复制从索引[1]到索引[3]之间的元素（不包括索引[3]的元素）    for (int i = 0; i &lt; arr8.length; i++) {        System.out.println(arr8[i]);    }    //比较两个数组    int[] arr9 = {1, 2, 3, 4,5,6,7,8,9,0};    boolean arr10=Arrays.equals(arr6, arr9);    System.out.println(arr10);    //去重复    //利用set的特性    int[] arr11 = {1, 2, 3, 4,5,6,7,8,9,0,3,2,4,5,6,7,4,32,2,1,1,4,6,3};    Set&lt;Integer&gt; set2=new HashSet&lt;Integer&gt;();    for (int i = 0; i &lt; arr11.length; i++) {        set2.add(arr11[i]);    }        System.out.println(set2);    int[] arr12 = new int[set2.size()];    int j=0;    for (Integer i:set2) {        arr12[j++]=i;    }    System.out.println(Arrays.toString(arr12));}</code></pre><h3 id="14、String-StringBuffer-StringBuilder"><a href="#14、String-StringBuffer-StringBuilder" class="headerlink" title="14、String StringBuffer StringBuilder"></a>14、String StringBuffer StringBuilder</h3><ul><li>String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</li><li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li><li>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li></ul><p><strong>String，StingBuffer，StringBuilder效率如何呢</strong></p><p>从高到底的顺序依次是：StringBuilder  &gt;  StingBuffer &gt; String</p><p>&nbsp; &nbsp; &nbsp; &nbsp;String是字符串常量，所以他的效率自然而然是最低的。对于StringBuffer和StringBuilder它们属于变量，是可以改变的对象，每次对字符串的操作，实际上实在一个对象上操作，所以效率更高一些。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;StringBuffer是线程安全的，考虑到安全问题，相对他的性能会更低一点。由此知道了从效率的角度看，StringBuilder最高，其次是StringBuffer，最后是String字符串常量。</p><p><strong>String 类的常用方法都有那些？</strong></p><ul><li>indexOf()：返回指定字符的索引</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h3 id="15、基本数据类型-amp-amp-包装类型"><a href="#15、基本数据类型-amp-amp-包装类型" class="headerlink" title="15、基本数据类型 &amp;&amp; 包装类型"></a>15、基本数据类型 &amp;&amp; 包装类型</h3><table><thead><tr><th>基本类型</th><th>包装器类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc8.png" alt=""></p><p>拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc9.png" alt=""></p><h4 id="2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"><a href="#2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆" class="headerlink" title="2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"></a>2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆</h4><ul><li>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</li><li>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</li><li>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</li><li>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</li></ul><h4 id="3、基本类型出现的原因"><a href="#3、基本类型出现的原因" class="headerlink" title="3、基本类型出现的原因"></a>3、基本类型出现的原因</h4><p>在Java编程思想的第一章就讲到：万物皆对象，new一个对象存储在堆中，我们通过堆栈的引用来使用这些对象，但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在堆栈中，因此更加高效。</p><h4 id="4、包装类型出现的原因"><a href="#4、包装类型出现的原因" class="headerlink" title="4、包装类型出现的原因"></a>4、包装类型出现的原因</h4><p>Java是一个面向对象的语言，基本类型并不具有对象的性质，为了与其他对象“接轨”就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p><h3 id="16、java日期处理"><a href="#16、java日期处理" class="headerlink" title="16、java日期处理"></a>16、java日期处理</h3><h4 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h4><blockquote><p>Date类用来指定日期和时间，其构造函数及常用方法如下：<br><br>public Date()从当前时间构造日期时间对象。<br><br>public String toString()转换成字符串。<br><br>public long getTime()它包含的是一个长整型数据long, 表示的是从GMT(格林尼治标准时间)1970年, 1 月 1日00:00:00这一刻之前或者是之后经历的毫秒数.</p></blockquote><h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><blockquote><p>通过向SimpleDateFormat 的构造函数传递格式字符串“yyyy-MM-dd”,<br>yyyy是年,MM是月,dd是日. 字符的个数决定了日期是如何格式化的.传递“yy-MM-dd”会显示 13-2-22</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc11.png" alt=""></p><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><blockquote><p>Calendar类主要用于完成日期字段之间的相互操作的功能 <br><br>Calendar类是一个抽象基类,不能new，我们可以通过Calendar.getInstance得到其实例，下面列出Calendar的一些常用方法：<br><br>set(int year, int month, int date)设置日历字段 <br><br>set(int field, int value) 将给定的日历字段设置为给定值 <br><br>get(int field)返回给定日历字段的值 <br><br>getTime()返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的 Date 对象。</p></blockquote><p>如果是1则代表的是对年份操作，2是对月份操作，3是对星期操作，5是对日期操作，11是对小时操作，12是对分钟操作，13是对秒操作，14是对毫秒操作。例如：Calendar calendar = Calendar.getInstance(); calendar .add(5,1);则表示对日期进行加一天操作</p><h5 id="Calendar示例"><a href="#Calendar示例" class="headerlink" title="Calendar示例"></a>Calendar示例</h5><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc10.png" alt=""></p><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul><li>abs()返回某数字的绝对值.</li><li>ceil()会找到下一个最大整数。</li><li>floor()返回紧邻的最小整数。</li><li>max()返回两个值中的最大值。</li><li>min()返回两个值中的最小值。</li><li>random()返回一个随机数，在0.0到1.0之间的双精度数。</li><li>round()返回与某浮点数值最接近的整数值。</li><li>sqrt()返回某数值的平方根。</li></ul><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><blockquote><p>Random类 伪随机数产生器。</p></blockquote><p>常用方法:</p><ul><li>public boolean nextBoolean()<br>该方法的作用是生成一个随机的boolean值。</li><li>public double nextDouble()<br>该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。</li><li>public int nextInt()<br>该方法的作用是生成一个随机的int值。</li><li>public int nextInt(int n)<br>该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 将日期解析为指定格式的字符串     */</span>    Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 将字符串解析为日期对象     */</span>    SimpleDateFormat sim <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String ss <span class="token operator">=</span> <span class="token string">"2020-01-01"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Date parse <span class="token operator">=</span> sim<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parse<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sim<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ParseException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Calendar使用     */</span>    Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Date time <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 设置日期     */</span>    calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Random随机数     */</span>    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc12.png" alt=""></p><h3 id="17-集合框架"><a href="#17-集合框架" class="headerlink" title="17.集合框架"></a>17.集合框架</h3><p>** 什么是集合 **</p><blockquote><p>通常情况下，把具有相同性质的一类东西，汇聚成一个整体，就可以称为集合。</p></blockquote><p>** 什么是集合框架 **</p><blockquote><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p></blockquote><ul><li>接口：即表示集合的抽象数据类型。</li><li>实现：也就是集合框架中接口的具体实现。</li><li>算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。</li></ul><h4 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h4><p>Java集合框架图。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc14.png" alt=""></p><p>1) 首先查看jdk中Collection类的源码后:</p><pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {</code></pre><p>通过查看可以发现Collection是一个接口类，其继承了java迭代接口Iterable</p><p><strong>Collection接口中的方法如下:</strong><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc13.png" alt=""></p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul><li><p>ArrayList底层其实就是一个Object类型的数组，非线程安全的集合。查询元素快，插入，删除中间元素慢，初始化的长度为10，每次扩容为原大小的1.5倍，可以通过构造方法改变初始容量大小。</p></li><li><p>ArrayList快在下标定位，慢在数组复制。</p></li><li><p>由于每次添加的时候，通过扩容机制判断原数组是否还有空间，若没有则重新实例化一个空间更大的新数组，把旧数组的数据拷贝到新数组中，耗费时间和性能</p></li></ul><p><strong>Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0，JDK差异，每次约按1.5倍扩容。 JDK8 中ArrayList扩容的实现是通过grow()方法里使用语句newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)（即1.5倍扩容）计算容量，然后调用Arrays.copyof()方法进行对原数组进行复制。</strong></p><p><strong>若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</strong></p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote><p><font size="3"> 基于数组实现的线程安全的集合。线程同步（方法被synchronized修饰），性能比ArrayList差。 </font></p></blockquote><font size="4">Vector 的数据结构和使用方法与ArrayList差不多。最大的不同就是Vector是线程安全的。几乎所有的对数据操作的方法都被synchronized关键字修饰。synchronized是线程同步的，当一个线程已经获得Vector对象的锁时，其他线程必须等待直到该锁被释放。从这里就可以得知Vector的性能要比ArrayList低。若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</font><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>基于双向循环链表实现的非线程安全的集合。查询元素慢，插入，删除中间元素快。</p><h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</p><h4 id="几种集合的区别"><a href="#几种集合的区别" class="headerlink" title="几种集合的区别"></a>几种集合的区别</h4><p>ArrayList查询快，写数据慢；LinkedList查询慢，写数据快<br>ArrayList查询快是因为底层是由数组实现，通过下标定位数据快。写数据慢是因为复制数组耗时。LinkedList底层是双向循环链表，查询数据依次遍历慢。写数据只需修改指针引用。<br>ArrayList和LinkedList都不是线程安全的，小并发量的情况下可以使用Vector，若并发量很多，且读多写少可以考虑使用CopyOnWriteArrayList。</p><h4 id="遍历list集合"><a href="#遍历list集合" class="headerlink" title="遍历list集合"></a>遍历list集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * for循环遍历     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * foreach遍历     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过迭代器遍历     */</span>    Iterator<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>[set][1]</p><blockquote><p>在选择的时候，如果顺序很重要，则可以选择TreeSet，如果操作性能和时间效率很重要的话，则可以选择HashSet</p></blockquote><ul><li><p>HashSet集合</p><blockquote><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置，存取速度比较快。</p></blockquote><ul><li>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树，底层实际上是一个HashMap。</li><li>所以可以直接总结出：HashSet实际上就是封装了HashMap，操作HashSet元素实际上就是操作HashMap。这也是面向对象的一种体现，重用性贼高！</li><li>无序，允许为null，，有且仅有一个元素为null！</li><li>线程不安全的。</li><li>HashSet还有一个子类LinkedHashSet</li></ul></li><li><p>TreeSet集合</p><ul><li>底层数据结构是红黑树(是一个自平衡的二叉树)</li><li>有排序功能，支持两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</li><li>有序，不允许为null</li><li>线程不安全的。</li></ul></li><li><p>LinkedHashSet集合</p><ul><li>迭代是有序的</li><li>允许为null，有且仅有一个元素为null！</li><li>底层实际上是一个HashMap+双向链表实例(其实就是LinkedHashMap)</li><li>线程不安全的。</li><li>性能比HashSet差一丢丢，因为要维护一个双向链表</li><li>初始容量与迭代无关，LinkedHashSet迭代的是双向链表</li></ul></li></ul><h4 id="遍历set集合"><a href="#遍历set集合" class="headerlink" title="遍历set集合"></a>遍历set集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 迭代器遍历方式     */</span>    Iterator<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> iterator <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 遍历     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str<span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="set-和list的区别"><a href="#set-和list的区别" class="headerlink" title="set 和list的区别"></a>set 和list的区别</h4><ul><li>List接口：存储一组不唯一，有序的对象</li><li>Set接口：存储一组唯一，无序的对象</li></ul><h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><p>*<em>Map接口不是继承Collection接口；Map接口用于维护键／值对（key/value pairs），他的实现类有: *</em><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc15.png" alt=""></p><h4 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc16.png" alt=""></p><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p><strong>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</strong></p><h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><p>! 从Hashtable的命名规范就可以看出，t没有大写，并不是我写错了</p><p>底层是哈希表数据结构，不可以存入null键null值。该集合是线程同步的。</p><h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。</p><h5 id="LinkedHashMap："><a href="#LinkedHashMap：" class="headerlink" title="LinkedHashMap："></a>LinkedHashMap：</h5><p>该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>该类是线程安全的 Map 实现。与 Hashtable 相似，但 Hashtable 的 synchronized 是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对 hash 表的不同部分进行的修改。ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p><h4 id="遍历map集合"><a href="#遍历map集合" class="headerlink" title="遍历map集合"></a>遍历map集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">&gt;</span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 第二种     */</span>    <span class="token comment" spellcheck="true">//遍历map中的键</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历map中的值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 迭代器     */</span>    Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">&gt;&gt;</span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">&gt;</span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过键找值遍历（效率低）     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="三种集合在实际工作用到的地方"><a href="#三种集合在实际工作用到的地方" class="headerlink" title="三种集合在实际工作用到的地方"></a>三种集合在实际工作用到的地方</h4><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>容器指的是集合框架</p><p>同步容器是通过syncrhoized关键字对线程不安全的操作进行加锁来保证线程安全的，其原理是使得多线程轮流获取同步锁进行对集合的操作，所以性能有所下降。，像Vector、Hashtable、Stack。</p><p> 为此，java.util.concurrent提供了多种并发容器，以：在原有集合的拷贝上进行操作，用修改后的集合替换原集合  的方式来达到并发且安全地使用集合类的目的。</p><pre><code>根据接口的类型，主要有以下四种接口，其他具体的容器均是对这些接口的实现类：</code></pre><p>Queue类型：阻塞队列BlockingQueue、非阻塞队列ConcurrentLinkedQueue</p><p>Map类型：ConcurrentMap</p><p>Set类型：ConcurrentSkipListSet、CopyOnWriteArraySet</p><p>List类型：CopyOnWriteArrayList</p><h4 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h4><font size="3"><p>　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>　　<br>　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p></font><h3 id="hascode"><a href="#hascode" class="headerlink" title="hascode"></a>hascode</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>根据这个方法的声明可知，它是一个本地方法，它的实现与本地机器有关，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p><p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及Hashtable，如果没有很好的覆写键的hashcode()和equals()方法，那么将无法正确的处理键。</p><p>　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）—–HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。</p><p>所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。</p><h3 id="18、泛形"><a href="#18、泛形" class="headerlink" title="18、泛形"></a>18、泛形</h3><p><strong>什么是泛型</strong></p><pre><code>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</code></pre><h4 id="泛形方法"><a href="#泛形方法" class="headerlink" title="泛形方法"></a>泛形方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 说明： * 1）&lt;E&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;E&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;E&gt;表明该方法将使用泛型类型E，此时才可以在方法中使用泛型类型E。 * 4）与泛型类的定义一样，此处E可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 * * @param inputArray * @param &lt;E&gt; */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 输出数组元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>E element <span class="token operator">:</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="泛形类"><a href="#泛形类" class="headerlink" title="泛形类"></a>泛形类</h4><h4 id="泛形接口"><a href="#泛形接口" class="headerlink" title="泛形接口"></a>泛形接口</h4><h4 id="泛形通配符：？"><a href="#泛形通配符：？" class="headerlink" title="泛形通配符：？"></a>泛形通配符：？</h4><h4 id="泛形的限定"><a href="#泛形的限定" class="headerlink" title="泛形的限定"></a>泛形的限定</h4><p>我们知道使用泛型类时：如果明确参数类型，那么泛型就代表一种类型；如果使用通配符？，那么泛型就代表任意类型。但有时候我们希望指定某些类型(不是一个，也不要所有)能作为参数类型，这应该怎么办呢？</p><pre><code>    Java中利用泛型的限定解决了这个问题，即泛型的限定。我们只需要按这样的格式书写：   上限：&lt;？ extends E&gt;表示参数类型是E及其所有子类。   下限：&lt;? super E&gt;表示参数类型是E及其所有超类(即父类)。</code></pre><h4 id="Java泛型中E、T、K、V等的含义"><a href="#Java泛型中E、T、K、V等的含义" class="headerlink" title="Java泛型中E、T、K、V等的含义"></a>Java泛型中E、T、K、V等的含义</h4><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)（集合泛形）</li><li>T - Type（Java 类）（接口）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ -  表示不确定的java类型</li></ul><h3 id="19、枚举"><a href="#19、枚举" class="headerlink" title="19、枚举"></a>19、枚举</h3><p>enum 的全称为 enumeration， 是 JDK 1.5  中引入的新特性，存放在 java.lang 包中，另外到了JDK1.6后switch语句支持枚举类型。</p><p><a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71333103</a></p><h3 id="20、io流"><a href="#20、io流" class="headerlink" title="20、io流"></a>20、io流</h3><p>Java中使用IO(输入输出）来读取和写入，读写设备上的数据、硬盘文件、内存、键盘……，根据数据的走向可分为输入流和输出流，这个走向是以内存为基准的，即往内存中读数据是输入流，从内存中往外写是输出流。</p><p><strong>根据处理的数据类型可分为字节流和字符流</strong></p><p>  1.字节流可以处理所有数据类型的数据，在java中以Stream结尾</p><p>  2.字符流处理文本数据，在java中以Reader和Writer结尾。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc17.png" alt=""></p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="输入流-InputStream"><a href="#输入流-InputStream" class="headerlink" title="输入流 InputStream"></a>输入流 InputStream</h5><p><strong>API</strong></p><ul><li>int read( )    读取一个字节，返回值为所读的字节</li><li>int read( byte b[ ] )   读取多个字节，放置到字节数组b中，通常读取的字节数量为b的长度，返回值为实际读取的字节的数量</li><li>int read( byte b[ ], int off, int len )   读取len个字节，放置到以下标off开始字节数组b中，返回值为实际读取的字节的数量</li><li>int available( )   返回值为流中尚未读取的字节的数量</li><li>long skip( long n )   读指针跳过n个字节不读，返回值为实际跳过的字节数量</li><li>close( )   流操作完毕后必须关闭</li></ul><p>代码</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    InputStream inputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将读取到的一个字节给i，中文占两个字节</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 关闭流</span>            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="输出流-OutputStream"><a href="#输出流-OutputStream" class="headerlink" title="输出流 OutputStream"></a>输出流 OutputStream</h5><p><strong>API</strong></p><ul><li>void write( int b ); 　　//往流中写一个字节b</li><li>void write( byte b[ ] ); //往流中写一个字节数组b</li><li>void write( byte b[ ], int off, int len );  把字节数组b中从下标off开始，长度为len的字节写入流中</li><li>flush( )  刷空输出流，并输出所有被缓存的字节由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li><li>close( ) 流操作完毕后必须关闭 </li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 没有则会创建文件</span>    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    OutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>        os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"超哥"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 关闭流</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="输入流-Reader"><a href="#输入流-Reader" class="headerlink" title="输入流 Reader"></a>输入流 Reader</h5><p><strong>API</strong></p><ul><li>int read() throws IOException;  读取一个字符，返回值为读取的字符</li><li>int read(char cbuf [  ]) throws IOException; 读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</li><li>abstract int read( char cbuf[ ] , int off , int len) throws IOException;   读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</li><li>boolean markSupported( ); 判断当前流是否支持做标记</li><li>void mark ( int readAheadLimit ) throws IOException;   给当前流作标记，最多支持readAheadLimit个字符的回溯。</li><li>void reset( ) throws IOException;    将当前流重置到做标记处</li><li>abstract void close( ) throws IOException;   关闭</li></ul><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Reader os <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 关闭流</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="输出流-Writer"><a href="#输出流-Writer" class="headerlink" title="输出流 Writer"></a>输出流 Writer</h5><p><strong>API</strong></p><ul><li>void write (int c) throws IOException； 将整型值c的低16位写入输出流</li><li>void write ( String str ) throws IOException； 将字符串str中的字符写入输出流</li><li>void write( char cbuf[ ] )  throws IOException；  将字符数组cbuf[]写入输出流</li><li>abstract void write( char cbuf[ ] , int off , int len) throws IOException； 将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流</li><li>void write( String str , int off , int len) throws IOException；  将字符串str 中从索引off开始处的len个字符写入输出流</li><li>flush( )   刷空输出流，并输出所有被缓存的字节。</li><li>close( )  关闭流</li></ul><h4 id="字节、字符流转换类"><a href="#字节、字符流转换类" class="headerlink" title="字节、字符流转换类"></a>字节、字符流转换类</h4><p>字节转为字符流</p><blockquote><p>字符 不需要转为字节流，字节流可以读取任意数据，而字符读取内容有限。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将字节流转换为字符流</span>        InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h5 id="缓冲流介绍"><a href="#缓冲流介绍" class="headerlink" title="缓冲流介绍"></a>缓冲流介绍</h5><blockquote><p>普通的字节、字符流都是一个字节一个字符这样读取的,而缓冲流则是将数据先缓冲起来,然后一起写入或者读取出来。<br>缓冲流为I/O流增加了内存缓冲区，使用缓冲流的好处是，能够更高效的读写信息。缓冲流要“套接”在相应的节点流(低级流)之上，对读写的数据提供了缓冲的功能。<br>缓冲输入流支持其父类的mark()和reset()方法：mark()用于“标记”当前位置，就像加入了一个书签，可以使用reset()方法返回这个标记重新读取数据</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 字节缓冲流</span>        BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>J2SDK提供了四种缓存流：<br><font size="4"><br><strong>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter</strong> </font></p><h5 id="缓冲流字节流"><a href="#缓冲流字节流" class="headerlink" title="缓冲流字节流"></a>缓冲流字节流</h5><pre><code>java.io.BufferedInputStream类可以对任何的InputStream流进行带缓冲的封装以达到性能的改善。该类在已定义输入流上再定义一个具有缓冲的输入流，可以从此流中成批地读取字符而不会每次都引起直接对数据源的读操作。数据输入时，首先被放入缓冲区，随后的读操作就是对缓冲区中的内容进行访问java.io.BufferedOutputStream不直接写入输出流，先写入缓冲区，当缓冲区满时，字节数据才会写到BufferedOutputStream所连接的流，调用该类的flush()将缓冲区全部写入输出流</code></pre><h3 id="21、序列化"><a href="#21、序列化" class="headerlink" title="21、序列化"></a>21、序列化</h3><h4 id="对象序列化概述"><a href="#对象序列化概述" class="headerlink" title="对象序列化概述"></a>对象序列化概述</h4><blockquote><p>一般地，对象不能脱离应用程序。但有时候，需要将对象的状态保存下来，在需要时再将对象恢复，即对象持久化（Persistence）。对象序列化（Object Serialization）可以将对象存储到外存中或以二进制形式通过网络传输。对象反串行化可以从这些数据中重构一个与原始对象状态相同的对象<br>为了实现对象系列化，对应的类必须实现下面的两种接口之一：<br>Serializable<br>Externalizable</p></blockquote><h4 id="将对象保存到磁盘文件"><a href="#将对象保存到磁盘文件" class="headerlink" title="将对象保存到磁盘文件"></a>将对象保存到磁盘文件</h4><ul><li>通过java.io.ObjectOutputStream可以将对象输出到磁盘文件、网络等设备</li><li>调用这个类的writeObject()方法，可以向特定的文件或网络输出对象</li><li>writeObject()方法序列化指定的对象，并遍历该对象对其它对象的引用，递归的序列化所有被引用到的其它对象，从而建立一个完整的序列化流</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        OutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Student需要序列化</span>        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setI</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="从磁盘读出保存的对象"><a href="#从磁盘读出保存的对象" class="headerlink" title="从磁盘读出保存的对象"></a>从磁盘读出保存的对象</h4><ul><li>通过java.io.ObjectInputStream对象可以从磁盘文件中读出保存的对象（或从网络中读出传递的对象）</li><li>调用这个类的readObject()方法，从特定的设备读出对象readObject()方法反序列化输入流中的对象，遍历该对象中所有对其它对象的引用，并递归的反序列化这些引用对象</li><li>readObject()方法返回的是Object对象，所以，需要对它进行必要的（向下）造型操作。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><ul><li>通过在属性前面加上transient关键字，限制属性写入到文件或网络中</li><li>还可以在未实现系列化接口的引用类型属性前面加上transient关键字，避免对此类属性进行递归系列化时出现java.io.NotSerializableException异常</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> String name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加一个transient修饰的属性</span></code></pre><p>什么被序列化<br>属性（包括基本数据类型、数组、对其它对象的引用）<br>类名<br>什么不被序列化<br>static的属性<br>方法<br>加了transient修饰符的属性</p><h3 id="22、多线程"><a href="#22、多线程" class="headerlink" title="22、多线程"></a>22、多线程</h3><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7526608.html</a></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt="image"></p><h4 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h4><table><thead><tr><th>术语</th><th>英文单词</th><th>描述</th></tr></thead><tbody><tr><td>共享变量</td><td></td><td>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。</td></tr><tr><td>内存屏障</td><td>Memory Barriers</td><td>是一组处理器指令，用于实现对内存操作的顺序限制。</td></tr><tr><td>缓冲行</td><td>Cache line</td><td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td></tr><tr><td>原子操作</td><td>Atomic operations</td><td>不可中断的一个或一系列操作。</td></tr><tr><td>缓存行填充</td><td>cache line fill</td><td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有）</td></tr><tr><td>缓存命中</td><td>cache hit</td><td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。</td></tr><tr><td>写命中</td><td>write hit</td><td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td></tr><tr><td>写缺失</td><td>write misses the cache</td><td>一个有效的缓存行被写入到不存在的内存区域。</td></tr></tbody></table><p><strong>什么是进程</strong></p><p>进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例。</p><p><strong>进程时间片的概念</strong></p><p>一个操作系统中，如果同时运行着多个进程，他们是一定交替运行的。每个进程不管有没有运行完毕，都只占据一段时间的CPU。<br>这个运行时间就是进程时间片。它非常短促，所以感觉不到他们是交替占用CPU。</p><p><strong>什么是线程</strong></p><ul><li><p>线程：进程内部的控制流。它也是一段可运行的指令。</p></li><li><p>特点：资源占用小，线程间通信容易。</p></li><li><p>多进程是指操作系统能同时运行多个任务（程序）。</p></li></ul><p>多线程：</p><pre><code>指的是这个程序（一个进程）运行时产生了不止一个线程</code></pre><h4 id="线程进程的区别体现在几个方面："><a href="#线程进程的区别体现在几个方面：" class="headerlink" title="线程进程的区别体现在几个方面："></a>线程进程的区别体现在几个方面：</h4><p>第一：  因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p><p>第二：  体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p><p>3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p><p>4.线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；</p><p>5.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p><p>第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p><p>并行与并发：</p><pre><code>1.    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。2.    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。并发性（concurrency）和并行性（parallel）</code></pre><p><strong>线程的特点</strong></p><ul><li>线程的运行方式和进程一样，在同一个进程内部，线程也是交替占用CPU。每个线程的运行时间，称为线程时间片。</li><li>线程有开始、中间和结束部分，即有一定的生命周期。</li><li>同一个进程中的多个线程是共享一块内存空间和一组系统资源。</li><li>线程不能作为具体的可执行命令体存在。最终用户不能直接执行线程，线程只能运行在进程中。</li></ul><p><strong>如何创建线程</strong></p><pre><code>两种方法来创建线程：继承java.lang.Thread类，并覆盖run( )方法。 class mythread extends Thread {     public void run( ) {         /* 覆盖该方法*/      } }实现java.lang.Runnable接口，并实现run( )方法。class mythread implements Runnable{      @Override      public void run( ) {          /* 实现该方法*/      } }一个线程的对象只能执行一次start()方法</code></pre><p><strong>线程的启动</strong></p><ul><li><p>新建的线程不会自动开始运行，必须通过start( )方法启动线程。如果不调用这个方法，线程将不会运行。</p></li><li><p>也就是说可以事先创建线程，并在需要的时候才启动他们。如：</p><pre class=" language-java"><code class="language-java">  继承Thread的线程：Typer  t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Typer</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>实现Runnable接口的线程：<br>Runnable  mt =   new Typer ( );<br>Thread    t  =   new Thread(mt);// 父类的类型子类的对象<br>t.start( );</p><pre><code>**线程执行过程**- 调用start( )方法时，将创建一个新的线程，并为线程分配系统资源，如内存。接着它将调用 run( ) 方法。- run( ) 方法中的代码定义执行线程所需的功能。    - run()方法能够调用其他方法，引用其他的类，申明变量。    - run()方法在程序中确定另一个并发线程的执行入口。- 当run()方法中的任务完成返回时，该线程也将结束。**注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。从程序运行的结果可以发现，多线程程序是乱序执行。**#### Thread和Runnable的区别实现Runnable接口比继承Thread类所具有的优势：- 适合多个相同的程序代码的线程去处理同一个资源- 可以避免java中的单继承的限制- 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立- 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类#### 线程状态下面的这个图非常重要!![](https://raw.githubusercontent.com/Flyiyu/use/master/jc18.jpg)1. 新建状态（New）：新创建了一个线程对象。2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：    - 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持    有的锁)    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。    - 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。#### 线程调度线程的调度1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：static int MAX_PRIORITY    线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY    线程可以具有的最低优先级，取值为1。static int NORM_PRIORITY          分配给线程的默认优先级，取值为5。Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。#### 守护线程1. 定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。2. 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。3. 设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。4. 在 Daemon 线程中产生的新线程也是 Daemon 的。5. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。6. example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。7. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。##### yield()、sleep()、join()和interrupt()方法   1、yield()　　　&amp;ensp;&amp;ensp;yield()是Thread类的静态方法。它能让当前线程暂停，但不会阻塞该线程，而是由“运行状态”进入到“就绪状态”，从而让 其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是 当前线程又进入到“运行状态”继续运行！　　值得注意的是，yield()方法不会释放锁。2、sleep()　　&amp;ensp;&amp;ensp;sleep()是Thread类的静态方法。该方法声明抛出了InterrupedException异常。所以使用时，要么捕捉，要么声明抛出。　　有2种重载方式：——static void sleep(long millis)　　:　　让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。——static void sleep(long millis , int nanos)　　：　　让当前正在执行的线程暂停millis毫秒加nanos微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。　　sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。常用来暂停程序的运行。　　　　同时注意，sleep()方法不会释放锁。3、join()　　join() 是Thread的一个实例方法。表示，当某个程序执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join的线程执行完毕。有3种重载的形式：——join()　　:　　等待被join的线程执行完成——join(long millis)　　：　　等待被join的线程的时间最长为millis毫秒，若在millis毫秒内，被join的线程还未执行结束，则不等待。——join(long millis , int nanos)　　:　　等待被join的线程的时间最长为millis毫秒加nanos微秒，若在此时间内，被join的线程还未执行结束，则不等待。&amp;ensp;&amp;ensp;即当前线程内，用某个线程对象调用join()后，会使当前线程等待，直到该线程对象的线程运行完毕，原线程才会继续运行。4、interrupt()　　　　　我们经常通过判断线程的中断标记来控制线程。　 　　　&amp;ensp;&amp;ensp;interrupt()是Thread类的一个实例方法，用于中断本线程。这个方法被调用时，会立即将线程的中断标志设置为“true”。所以当中断处于“阻塞状态”的线程时，由于处于阻塞状态，中断标记会被设置为“false”，抛出一个 InterruptedException。所以我们在线程的循环外捕获这个异常，就可以退出线程了。　&amp;ensp;&amp;ensp;interrupt()并不会中断处于“运行状态”的线程，它会把线程的“中断标记”设置为true，所以我们可以不断通过isInterrupted()来检测中断标记，从而在调用了interrupt()后终止线程，这也是通常我们对interrupt()的用法。　　&amp;ensp;&amp;ensp;Interrupted()是Thread类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，isInterrupted()是Thread类的实例方法，返回一个布尔类型来判断线程是否已经被中断。它们都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。　　　　　　#### start 与 run 区别1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。2. 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。3. 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。#### Synchronized关键字synchronized是一个重量级锁，相对于Lock，它会显得那么笨重 诚然，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。  1、同步和异步的区别和联系 　　&amp;ensp;&amp;ensp;所谓同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其它的命令。&amp;ensp;&amp;ensp;异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 &amp;ensp;&amp;ensp;同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行(死心眼)。异步在一定程度上可以看做是多线程的，请求一个方法后，就不管了，继续执行其他的方法。1、原理**在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。**　　&amp;ensp;&amp;ensp;当当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。　　&amp;ensp;&amp;ensp;不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。例如，现在有个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。2、基本规则　　&amp;ensp;&amp;ensp;第一条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。　　&amp;ensp;&amp;ensp;第二条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。　&amp;ensp;&amp;ensp;第三条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。1、普通同步方法，锁是当前实例对象2、静态同步方法，锁是当前类的class对象3、同步方法块，锁是括号里面的对象3、实例锁和全局锁&amp;ensp;&amp;ensp;实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。               实例锁对应的就是synchronized关键字。&amp;ensp;&amp;ensp;全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。               全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。&amp;ensp;&amp;ensp;就是说，一个非静态方法上的synchronized关键字，代表该方法依赖其所属对象。一个静态方法上synchronized关键字，代表该方法依赖这个类本身。#### synchronized, wait, notify结合:典型场景生产者消费者问题```java/**   * 生产者生产出来的产品交给店员   */  public synchronized void produce()  {      if(this.product &gt;= MAX_PRODUCT)      {          try          {              wait();                System.out.println("产品已满,请稍候再生产");          }          catch(InterruptedException e)          {              e.printStackTrace();          }          return;      }      this.product++;      System.out.println("生产者生产第" + this.product + "个产品.");      notifyAll();   //通知等待区的消费者可以取出产品了  }  /**   * 消费者从店员取产品   */  public synchronized void consume()  {      if(this.product &lt;= MIN_PRODUCT)      {          try           {              wait();               System.out.println("缺货,稍候再取");          }           catch (InterruptedException e)           {              e.printStackTrace();          }          return;      }      System.out.println("消费者取走了第" + this.product + "个产品.");      this.product--;      notifyAll();   //通知等待去的生产者可以生产产品了  }</code></pre><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="Volatile的官方定义"><a href="#Volatile的官方定义" class="headerlink" title="Volatile的官方定义"></a>Volatile的官方定义</h5><p>  Java语言规范第三版中对volatile的定义如下：<br>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>  volatile这个关键字。其实这个关键字有两层语义。第一层语义就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化。我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。</p><p><strong>Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</strong></p><h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><p>　　为什么出现这种情况呢，我们需要先了解一下JMM（java内存模型）</p><p>　　java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><p>　　JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc31.png" alt=""></p><p>　需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p><p>  那么这种共享变量在多线程模型中的不可见性如何解决呢？比较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，有点炮打蚊子的意思。比较合理的方式其实就是volatile</p><h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><h5 id="ThreadLocal概念"><a href="#ThreadLocal概念" class="headerlink" title="ThreadLocal概念"></a>ThreadLocal概念</h5><p>ThreadLocal 是线程的局部变量， 是每一个线程所单独持有的，其他线程不能对其进行访问。</p><p>  ThreadLocal，直译为“线程本地”或“本地线程”，如果你真的这么认为，那就错了！其实，它就是一个容器，用于存放线程的局部变量，我认为应该叫做 ThreadLocalVariable（线程局部变量）才对，真不理解为什么当初 Sun 公司的工程师这样命名。</p><p>  当使用ThreadLocal维护变量的时候 为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。</p><p>  但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p><p><strong>跳出误区</strong></p><p>  需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p><h5 id="ThreadLocal常用方法介绍"><a href="#ThreadLocal常用方法介绍" class="headerlink" title="ThreadLocal常用方法介绍"></a>ThreadLocal常用方法介绍</h5><p>public void set(T value)：将值放入线程局部变量中</p><p>public T get()：从线程局部变量中获取值</p><p>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</p><p>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </p><p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要自己来实现的，给这个线程局部变量一个初始值吧。</p><h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><pre><code>Runnable r[] = new Runnable[2];</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc25.jpg" alt=""></p><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>  如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>  那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？  在Java中可以通过线程池来达到这样的效果.</p><p>  合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p><p>下为常见的四种：</p><ol><li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li><li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li><li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li><li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li></ol><h4 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h4><blockquote><p>阻塞队列提供了可阻塞的入队和出对操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用；</p></blockquote><p>在Java中，主要有以下类型的阻塞队列：</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个支持延时获取元素的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 </li></ul><h4 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h4><h3 id="JAVA-锁"><a href="#JAVA-锁" class="headerlink" title="JAVA 锁"></a>JAVA 锁</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>  乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为<br>别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数<br>据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），<br>如果失败则要重复读-比较-写的操作。</p><p>  java 中的乐观锁基本都是通过 CAS 操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>  悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人<br>会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。<br>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，<br>才会转换为悲观锁，如 RetreenLock。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>  自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁<br>的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>  线程自旋是需要消耗 cpu 的，说白了就是让 cpu 在做无用功，如果一直获取不到锁，那线程<br>也不能一直占用 cpu 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁<br>的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><p><strong>自旋锁的优缺点</strong></p><p>  自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来<br>说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p><p>  但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合<br>使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p><p><strong>自旋锁时间阈值（1.6 引入了适应性自旋锁）</strong></p><p>  自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择<br>自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p><h5 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h5><p>  synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重<br>入锁</p><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>  ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完<br>成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等<br>避免多线程死锁的方法。</p><h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><p>  首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有<br>AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，<br>区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所<br>有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。</v></p><p>  通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些<br>同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger<br>的性能是 ReentantLock 的好几倍。</p><h5 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h5><p>  本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫<br>做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受<br>影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p><h5 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h5><p>  为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如<br>果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写<br>锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p><p>读锁<br>  如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p><p>写锁<br>  如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。<br>总之，读的时候上读锁，写的时候上写锁！<br>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现<br>ReentrantReadWriteLock。</p><h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>公平锁（Fair）</p><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁（Nonfair）<br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p><ol><li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li><li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li></ol><h5 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h5><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p><p>独占锁</p><p>  独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。<br>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线<br>程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p>共享锁</p><p>  共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种<br>乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等<br>待线程的锁获取模式。</li><li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，<br>或者被一个 写操作访问，但两者不能同时进行。</li></ol><h5 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（Mutex Lock）</h5><p>  Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又<br>是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用<br>户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么<br>Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为<br>“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。<br>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和<br>“偏向锁”。</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>  锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。<br>锁升级<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，<br>也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，<br>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量<br>级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场<br>景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀<br>为重量级锁。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>  Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线<br>程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起<br>来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级<br>锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换<br>ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所<br>以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻<br>量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进<br>一步提高性能</p><h5 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h5><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul><li>减少锁持有时间</li></ul><p>只用在有线程安全要求的程序上加锁</p><ul><li>减小锁粒度</li></ul><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。<br>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是<br>ConcurrentHashMap。</p><ul><li>锁分离</li></ul><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互<br>斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]<br>JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如<br>LinkedBlockingQueue 从头部取出，从尾部放数据</p><ul><li>锁粗化</li></ul><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完<br>公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步<br>和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p><ul><li>锁消除<br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这<br>些对象的锁操作，多数是因为程序员编码不规范引起</li></ul><h3 id="虚拟机常用命令"><a href="#虚拟机常用命令" class="headerlink" title="虚拟机常用命令"></a>虚拟机常用命令</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>数组</strong></p><ul><li>数组作为数据存储结构的缺陷</li><li>在无序数组中，搜索是低效的</li><li>而在有序数组中插入效率又很低</li><li>不管在哪一种数组中删除效率都很低</li><li>创建一个数组之后，它的大小又是不可变的</li></ul><p><strong>链表</strong></p><ul><li>链表是一种有序的列表</li><li>链表的内容通常存储与内存中分散的位置上</li><li>链表由节点组成，每一个节点的结构都相同</li><li>节点分为数据域和链域，数据域是存放节点的内容，链域存放的是下一个节点的指针</li></ul><h4 id="单向链表（Single-Linked-List）"><a href="#单向链表（Single-Linked-List）" class="headerlink" title="单向链表（Single-Linked List）"></a>单向链表（Single-Linked List）</h4><p>　　单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。</p><p>　　单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc20.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc21.png" alt=""></p><h3 id="栈-stack-与堆-heap"><a href="#栈-stack-与堆-heap" class="headerlink" title="栈(stack)与堆(heap)"></a>栈(stack)与堆(heap)</h3><p>1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制；</p><ol><li><p>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中(对象可能在常量池里)（字符串常量对象存放在常量池中。）；</p></li><li><p>堆：存放所有new出来的对象；</p></li><li><p>静态域：存放静态成员（static定义的）；</p></li><li><p>常量池：存放字符串常量和基本类型常量（public static final）。有时，在嵌入式系统中，常量本身会和其他部分分割离开(由于版权等其他原因)，所以在这种情况下，可以选择将其放在ROM中 ；</p></li><li><p>非RAM存储：硬盘等永久存储空间</p></li></ol><p>堆栈是一种有序表。</p><p>堆栈只允许数据自有序列表（前端）作输入、输出操作。<br>堆栈的存取顺序就像手枪的弹夹一样，最先压进去的子弹会被最后打出来<br>具有先进后出FILO（First In Last Out）的特性</p><p>堆栈的典型操作</p><p>入栈：又称压栈，是指将数据放入堆栈</p><p>出栈：将数据从堆栈中取出来</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> obj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 指向标     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> pointer<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 数组的长度     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 给定一个默认的长度     */</span>    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法的重载     *     * @param size     */</span>    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断堆栈是否已经满了     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 由于指向标的位置是从-1开始的，数组的下标是从0开始的         */</span>        <span class="token keyword">return</span> pointer <span class="token operator">==</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 入栈</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * // isFull满的         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空间已满！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 对堆进行扩容</span>            obj <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * // 每次加一             */</span>            pointer<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * 循环给数组赋值             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            pointer<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 出栈     *     * @return     */</span>    <span class="token keyword">public</span> Object <span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"栈空间已空！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Object o <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            pointer<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> o<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断堆栈是否为空     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * isEmpty空的         * 如果pointer==-1就返回true         */</span>        <span class="token keyword">return</span> pointer <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 出栈         */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>主要是两个：队头，队尾</p><p>入队：队尾指针向后移动</p><p>出队：队头指针向后移动</p><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><h4 id="1-形参与实参"><a href="#1-形参与实参" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h4><h3 id="1-形参与实参-1"><a href="#1-形参与实参-1" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h3><p>我们先来重温一组语法：</p><blockquote><ol><li><p>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</p></li><li><p>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p></li></ol></blockquote><p>举个栗子：</p><pre><code>public static void func(int a){ a=20; System.out.println(a);}public static void main(String[] args) { int a=10;//变量 func(a);}</code></pre><p>例子中<br>int a=10;中的a在被调用之前就已经创建并初始化，在调用func方法时，他被当做参数传入，所以这个a是实参。<br>而func(int a)中的a只有在func被调用时它的生命周期才开始，而在func调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p><h3 id="2-Java的数据类型"><a href="#2-Java的数据类型" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h3><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p><blockquote><p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p></blockquote><p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p><blockquote><ol><li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：</li></ol><blockquote><p>4种整数类型：byte、short、int、long<br>2种浮点数类型：float、double<br>1种字符类型：char<br>1种布尔类型：boolean</p></blockquote><ol start="2"><li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：</li></ol><blockquote><p>类<br>接口<br>数组</p></blockquote></blockquote><p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p><h3 id="3-JVM内存的划分及职能"><a href="#3-JVM内存的划分及职能" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h3><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznUXxpugnTGGCB8eWHmcg9sjc88CMjoWuagmLTgibGKIJchE6JkC1Plw.jpg" alt=""></p><p>有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</p><h5 id="1-虚拟机栈"><a href="#1-虚拟机栈" class="headerlink" title="1. 虚拟机栈"></a>1. 虚拟机栈</h5><h5 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h5><h5 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h5><h5 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h5><h5 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h5><p>我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。</p><hr><blockquote><p><strong>1. 虚拟机栈</strong></p></blockquote><p>虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</p><p>栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p><p>下图表示了一个Java栈的模型以及栈帧的组成：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzhafOtSl5zaWYfOCzicibCgWQRISwTlEr0Kd1TJj3ibia5mQvb7sTUyVq5A.jpg" alt=""></p><p><strong>栈帧</strong>:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p><p>每个栈帧中包括：</p><ol><li><p><strong>局部变量表</strong>:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</p></li><li><p><strong>操作数栈</strong>:Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指操作数栈。</p></li><li><p><strong>指向运行时常量池的引用</strong>:存储程序执行时可能用到常量的引用。</p></li><li><p><strong>方法返回地址</strong>:存储方法执行完成后的返回地址。</p></li></ol><hr><blockquote><p><strong>2. 堆：</strong></p></blockquote><p>堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</p><hr><blockquote><p><strong>3. 方法区：</strong></p></blockquote><p>方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</p><p>方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</p><hr><blockquote><p><strong>4. 本地方法栈：</strong></p></blockquote><p>本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</p><p><strong>有人会疑惑：什么是本地方法？为什么Java还要调用本地方法？</strong></p><hr><blockquote><p><strong>5. 程序计数器：</strong></p></blockquote><p>线程私有的。<br>记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p><hr><h3 id="4-数据如何在内存中存储？"><a href="#4-数据如何在内存中存储？" class="headerlink" title="4. 数据如何在内存中存储？"></a>4. 数据如何在内存中存储？</h3><p>从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有三个地方：</p><ul><li><p>堆</p></li><li><p>栈</p></li><li><p>静态方法区</p></li><li><p>常量区</p></li></ul><p>相应地，每个存储区域都有自己的内存分配策略：</p><ul><li><p>堆式：</p></li><li><p>栈式</p></li><li><p>静态</p></li></ul><p>我们已经知道：Java中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？<br>这里要分以下的情况进行探究：</p><blockquote><p><strong>1. 基本数据类型的存储：</strong></p><ul><li><p>A. 基本数据类型的局部变量</p></li><li><p>B. 基本数据类型的成员变量</p></li><li><p>C. 基本数据类型的静态变量</p></li></ul><p><strong>2. 引用数据类型的存储</strong></p></blockquote><hr><blockquote><p><strong>1. 基本数据类型的存储</strong></p></blockquote><hr><p>我们分别来研究一下：</p><h5 id="A-基本数据类型的局部变量"><a href="#A-基本数据类型的局部变量" class="headerlink" title="A.基本数据类型的局部变量"></a><strong>A.基本数据类型的局部变量</strong></h5><ol><li><p>定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的<strong>“虚拟机栈”</strong>，数据本身的值就是存储在栈空间里面。  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznNuHDLtNxibO1b1yN7wV4HPSno4CHZWXaEicootMFec7t31G38HzFpSQ.png" alt=""></p></li></ol><pre><code>如上图，在方法内定义的变量直接存储在栈中，如</code></pre><pre><code>    int age=50;    int weight=50;    int grade=6;</code></pre><p>当我们写“int age=50；”，其实是分为两步的：</p><pre><code>    int age;//定义变量    age=50;//赋值</code></pre><p>首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。因此我们可以知道：<br><strong>我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</strong></p><p>我们再来看“int weight=50；”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：<strong>栈中的数据在当前线程下是共享的</strong>。</p><p>那么如果再执行下面的代码呢？</p><pre><code>    weight=40；</code></pre><p>当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。由此可知：</p><p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p><hr><h5 id="B-基本数据类型的成员变量"><a href="#B-基本数据类型的成员变量" class="headerlink" title="B. 基本数据类型的成员变量"></a><strong>B. 基本数据类型的成员变量</strong></h5><p>成员变量：顾名思义，就是在类体中定义的变量。<br>看下图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozziaY24epYoPoM45SJiajF9qCXtupO2539ia0NMKIYUo3yjhFibJ1ZgTvIWg.jpg" alt=""></p><p>我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码：</p><pre><code>     public class Person{ 2  private int age; 3  private String name; 4  private int grade; 5//篇幅较长，省略setter getter方法 6  static void run(){ 7     System.out.println("run....");  8   }; 9}1011//调用12Person per=new Person();</code></pre><p>同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：<strong>基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</strong></p><hr><h5 id="C-基本数据类型的静态变量"><a href="#C-基本数据类型的静态变量" class="headerlink" title="C. 基本数据类型的静态变量"></a><strong>C. 基本数据类型的静态变量</strong></h5><p>前面提到<strong>方法区</strong>用来存储一些共享数据，因此<strong>基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</strong></p><hr><blockquote><p><strong>2. 引用数据类型的存储:</strong></p></blockquote><p>上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</p><pre><code>1Person per=new Person();</code></pre><p>实际上，它也是有两个过程：</p><pre><code>1Person per;//定义变量2per=new Person();//赋值</code></pre><p>在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：<br><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p><h3 id="6-值传递和引用传递"><a href="#6-值传递和引用传递" class="headerlink" title="6. 值传递和引用传递"></a>6. 值传递和引用传递</h3><p>前面已经介绍过形参和实参，也介绍了数据类型以及数据在内存中的存储形式，接下来，就是文章的主题：值传递和引用的传递。</p><blockquote><p><strong>值传递：</strong><br>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p></blockquote><p>来看个例子：</p><pre><code> 1public static void valueCrossTest(int age,float weight){ 2    System.out.println("传入的age："+age); 3    System.out.println("传入的weight："+weight); 4    age=33; 5    weight=89.5f; 6    System.out.println("方法内重新赋值后的age："+age); 7    System.out.println("方法内重新赋值后的weight："+weight); 8    } 910//测试11public static void main(String[] args) {12        int a=25;13        float w=77.5f;14        valueCrossTest(a,w);15        System.out.println("方法执行后的age："+a);16        System.out.println("方法执行后的weight："+w);17}</code></pre><p>输出结果：</p><pre><code>1传入的age：252传入的weight：77.534方法内重新赋值后的age：335方法内重新赋值后的weight：89.567方法执行后的age：258方法执行后的weight：77.5</code></pre><p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p><p>这是什么造型呢？！！</p><p>下面我们根据上面学到的知识点，进行详细的分析：</p><p>首先程序运行时，调用mian()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是mian()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozz8YSBg6NLka2h6iamHia5566dpw4dXrpCnfwicnWE0hAADoicyb3dBWWBeg.png" alt=""></p><p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzicu2h4XZlxSVE3ynyB1pIxaplvHibiazgvFiaFYuvVe8IrRK9U3dk1vxCA.jpg" alt=""></p><p>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzf8EMVLtiaMibiaaTxM4aV8ibUZphsG0oHs4qWj3QDHPK6Wia8NBiaQZqXTLQ.jpg" alt=""></p><p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p><blockquote><p><strong>引用传递：</strong><br>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</p></blockquote><p>举个栗子：<br>先定义一个对象：</p><pre><code> 1public class Person { 2        private String name; 3        private int age; 4 5        public String getName() { 6            return name; 7        } 8        public void setName(String name) { 9            this.name = name;10        }11        public int getAge() {12            return age;13        }14        public void setAge(int age) {15            this.age = age;16        }17}</code></pre><p>我们写个函数测试一下：</p><pre><code> 1public static void PersonCrossTest(Person person){ 2        System.out.println("传入的person的name："+person.getName()); 3        person.setName("我是张小龙"); 4        System.out.println("方法内重新赋值后的name："+person.getName()); 5    } 6//测试 7public static void main(String[] args) { 8        Person p=new Person(); 9        p.setName("我是马化腾");10        p.setAge(45);11        PersonCrossTest(p);12        System.out.println("方法执行后的name："+p.getName());13}</code></pre><p>输出结果：</p><pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是张小龙</code></pre><p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p><p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p><p>下面我们对上面的例子稍作修改，加上一行代码，</p><pre><code>1public static void PersonCrossTest(Person person){2        System.out.println("传入的person的name："+person.getName());3        person=new Person();//加多此行代码4        person.setName("我是张小龙");5        System.out.println("方法内重新赋值后的name："+person.getName());6    }</code></pre><p>输出结果：</p><pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是马化腾</code></pre><p>`<br>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p><p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p><pre><code>1Person p=new Person();2        p.setName("我是马化腾");3        p.setAge(45);4        PersonCrossTest(p);</code></pre><p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozztCU4pWxX96C9qiaDiaYSHOjV1Okfm6FIF3H1iciaKvqBTjibGeGnHP0VlsA.jpg" alt=""></p><p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p><pre><code>1person=new Person();</code></pre><p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p><p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p><p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p><p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p><p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p><p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong>  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzRTVdZIvztpofveECo4HxchhGmtHX4J6WZLRGcLiatiaDEMHwkyRpwtKg.jpg" alt=""></p><p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p><p><strong>p和person都是指向同一个对象</strong>。</p><p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p><p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p><p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p><p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p><p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p><h4 id="2-Java的数据类型-1"><a href="#2-Java的数据类型-1" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h4><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p><blockquote><p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p></blockquote><p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p><blockquote><ol><li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：<br>4种整数类型：byte、short、int、long<br> 2种浮点数类型：float、double<br> 1种字符类型：char<br> 1种布尔类型：boolean</li><li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：<br>类<br> 接口<br> 数组</li></ol></blockquote><p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p><h4 id="3-JVM内存的划分及职能-1"><a href="#3-JVM内存的划分及职能-1" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h4><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：</p><h3 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h3><h4 id="transient-1"><a href="#transient-1" class="headerlink" title="transient"></a>transient</h4><p>先解释下Java中的对象序列化</p><p>在讨论transient之前，有必要先搞清楚Java中序列化的含义；</p><blockquote><p>Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</p></blockquote><p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p><p><strong>关于transient关键字</strong></p><p>Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化，这一看好像很好理解，就是不被序列化，那么什么情况下，一个对象的某些字段不需要被序列化呢？如果有如下情况，可以考虑使用关键字transient修饰：</p><p>1、类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p><p>2、其它，看具体业务需求吧，哪些字段不想被序列化；</p><p>PS，记得之前看HashMap源码的时候，发现有个字段是用transient修饰的，我觉得还是有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增），对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p><h3 id="System-currentTimeMillis"><a href="#System-currentTimeMillis" class="headerlink" title="System.currentTimeMillis()"></a>System.currentTimeMillis()</h3><p>System位于java.lang包下，有很多可以获取到系统底层的东西：</p><p>System类本意就代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p><p>currentTimeMillis方法</p><pre><code>public static long currentTimeMillis()</code></pre><p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p><p>可以直接把这个方法强制转换成date类型。</p><p>代码如下：</p><pre><code>long currentTime = System.currentTimeMillis();SimpleDateFormat formatter = new SimpleDateFormat("yyyy年-MM月dd日-HH时mm分ss秒");Date date = new Date(currentTime);System.out.println(formatter.format(date));</code></pre><p>运行结果如下：</p><pre><code>当前时间:2017年-12月19日-10时14分28秒</code></pre><p>另：</p><p>可获得当前的系统和用户属性：</p><pre><code>String osName = System.getProperty(“os.name”);String user = System.getProperty(“user.name”);System.out.println(“当前操作系统是：” + osName);System.out.println(“当前用户是：” + user);</code></pre><p>System.getProperty 这个方法可以得到很多系统的属性。</p><h3 id="jdk1-8新特性学习"><a href="#jdk1-8新特性学习" class="headerlink" title="jdk1.8新特性学习"></a>jdk1.8新特性学习</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是一种运行于服务器端的Java应用程序，具有独立于平台和协议的特性，可以生成动态的Web页面</p><p>担当客户请求与服务器响应的中间层 </p><p>有特殊的技术规范</p><p>必须继承某个特定父类</p><p>必须配置之后才能执行</p><p>有特定的生命周期</p><h3 id="、时间复杂度-amp-amp-空间复杂度"><a href="#、时间复杂度-amp-amp-空间复杂度" class="headerlink" title="、时间复杂度&amp;&amp;空间复杂度"></a>、时间复杂度&amp;&amp;空间复杂度</h3><h3 id="、算法"><a href="#、算法" class="headerlink" title="、算法"></a>、算法</h3><h3 id="、Gc"><a href="#、Gc" class="headerlink" title="、Gc"></a>、Gc</h3><h3 id="各种树"><a href="#各种树" class="headerlink" title="各种树"></a>各种树</h3><h3 id="Map-2"><a href="#Map-2" class="headerlink" title="Map"></a>Map</h3><p><a href="https://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis笔记</title>
      <link href="/2019/10/21/2019-01-23-mybatis/"/>
      <url>/2019/10/21/2019-01-23-mybatis/</url>
      
        <content type="html"><![CDATA[<h3 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h3><blockquote><p>MyBatis 本是apache的一个开源项目iBatis, MyBatis 是一个高级<br>映射的优秀的持久层orm框架。<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设<br>置参数以及获取结果集。<br>MyBatis可以使用简单的XML或注解用于配置和原<br>始映射，将接口和Java的POJO（Plain Old Java<br>Objects，普通的Java对象）映射成数据库中的记<br>录.</p></blockquote><h3 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h3><blockquote><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。<br>iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（sDAO）<br>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p></blockquote><p>Mybatis的架构<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mybatis3.png?token=AexgHdHBH0caqaCOim6-m7vOOHulfMt7ks5cPxMWwA%3D%3D" alt=""></p><p>实现功能<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mybatis1.png?token=AexgHZThrRM9vGnIUzPFPYGE3tuxMZcYks5cPxNpwA%3D%3D" alt="image"></p><h3 id="MyBatis的实现原理"><a href="#MyBatis的实现原理" class="headerlink" title="MyBatis的实现原理"></a>MyBatis的实现原理</h3><font face="微软雅黑" size="3"><p>&nbsp; &nbsp; &nbsp; &nbsp;</p><p>mybatis底层还是采用原生jdbc来对数据库进行操作的，只是通过 SqlSessionFactory，SqlSession Executor,StatementHandler，ParameterHandler,ResultHandler和TypeHandler等几个处理器封装了这些过程</p></font><h3 id="为什么要使用MyBatis？"><a href="#为什么要使用MyBatis？" class="headerlink" title="为什么要使用MyBatis？"></a>为什么要使用MyBatis？</h3><ul><li>MyBatis是一个半自动化的持久化层框架。</li><li>JDBC<br>– SQL写在Java代码块里，耦合度高导致硬编码内伤<br>– 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见<br></li><li>Hibernate和JPA<ol><li>长难复杂SQL，对于Hibernate而言处理也不容易</li><li>内部自动生产的SQL，不容易做特殊优化。</li><li>基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。<br>导致数据库性能下降。</li></ol></li><li>对开发人员而言，核心sql还是需要自己优化</li><li>sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3></li><li>SqlSession 的实例不是线程安全的，因此是不能<br>被共享的。</li><li>SqlSession每次使用完成后需要正确关闭，这个<br>关闭操作是必须的</li><li>SqlSession可以直接调用方法的id进行数据库操<br>作，但是我们一般还是推荐使用SqlSession获取<br>到Dao接口的代理类，执行代理对象的方法，可<br>以更安全的进行类型检查操作</li></ul><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><font face="微软雅黑" size="3"><p>①、一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的，一级缓存默认是开启的</p><p>②、</p><ul><li>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，二级缓存是跨SqlSession的。</li><li>二级缓存的原理和一级缓存原理一样，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去缓存中取。但是一级缓存是基于 sqlSession 的，而 二级缓存是基于 mapper文件的namespace的，也就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果两个mapper的namespace相同，即使是两个mapper，那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域中。</li><li>开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中，如果我们要再取这个缓存的话，就需要反序列化了。所以mybatis中的pojo都去实现Serializable接口。　</li></ul></font><p><strong>我们可以看到 mapper.xml 文件中就这么一个空标签<cache>，其实这里可以配置<cache type="org.apache.ibatis.cache.impl.PerpetualCache">,PerpetualCache这个类是mybatis默认实现缓存功能的类。我们不写type就使用mybatis默认的缓存，也可以去实现 Cache 接口来自定义缓存。</cache></cache></strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mybatis2.png?token=AexgHbOqd1GWn9Tx_j6McMag6Z-VP-n2ks5cPqAvwA%3D%3D" alt="image"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token comment" spellcheck="true">/**      * 返回一行数据       * 测试一级缓存     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用类加载器加载mybatis的配置文件（它也加载关联的映射文件）</span>        <span class="token comment" spellcheck="true">// 1.加载配置文件</span>        Reader reader <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsReader</span><span class="token punctuation">(</span><span class="token string">"mybatis.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建sqlsessionfactory 二级缓存 通过配置信息构建一个sqlSessionFactory</span>        SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.获取链接 一级缓存 通过sqlSessionFactory打开一个数据库会话</span>        SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.获得mapper</span>        <span class="token comment" spellcheck="true">// 把接口和sql映射文件对应，对应之后就可以通过接口找到具体的sql位置</span>        ProductDaoMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>ProductDaoMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product pro <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pro<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第二次查询</span>        ProductDaoMapper mapper2 <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>ProductDaoMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product pro2 <span class="token operator">=</span> mapper2<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pro2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><font size="6px">二级缓存</font><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTwoCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//根据 sqlSessionFactory 产生 session</span>    SqlSession sqlSession1 <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SqlSession sqlSession2 <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String statement <span class="token operator">=</span> <span class="token string">"com.ys.twocache.UserMapper.selectUserByUserId"</span><span class="token punctuation">;</span>    UserMapper userMapper1 <span class="token operator">=</span> sqlSession1<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UserMapper userMapper2 <span class="token operator">=</span> sqlSession2<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第一次查询，发出sql语句，并将查询的结果放入缓存中</span>    User u1 <span class="token operator">=</span> userMapper1<span class="token punctuation">.</span><span class="token function">selectUserByUserId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u1<span class="token punctuation">)</span><span class="token punctuation">;</span>    sqlSession1<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一次查询完后关闭sqlSession</span>    <span class="token comment" spellcheck="true">//第二次查询，即使sqlSession1已经关闭了，这次查询依然不发出sql语句</span>    User u2 <span class="token operator">=</span> userMapper2<span class="token punctuation">.</span><span class="token function">selectUserByUserId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u2<span class="token punctuation">)</span><span class="token punctuation">;</span>    sqlSession2<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="二级缓存的应用场景"><a href="#二级缓存的应用场景" class="headerlink" title="二级缓存的应用场景"></a>二级缓存的应用场景</h3><font face="微软雅黑" size="3"><p>　　对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分的，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题可能需要在业务层根据需求对数据有针对性缓存。</p></font><h3 id="二级缓存整合其他缓存框架"><a href="#二级缓存整合其他缓存框架" class="headerlink" title="二级缓存整合其他缓存框架"></a>二级缓存整合其他缓存框架</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mybatis自带的二级缓存，但是这个缓存是单服务器工作，无法实现分布式缓存。那么什么是分布式缓存呢？假设现在有两个服务器1和2，用户访问的时候访问了1服务器，查询后的缓存就会放在1服务器上，假设现在有个用户访问的是2服务器，那么他在2服务器上就无法获取刚刚那个缓存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，就得找一个分布式的缓存，专门用来存储缓存数据的，这样不同的服务器要缓存数据都往它那里存，取缓存数据也从它那里取</p><p>二级缓存如：Ehcache，Redis</p><h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><h4 id="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h4><font face="微软雅黑" size="3">答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、、、标签，都会被解析为一个MappedStatement对象。</select></font><p><strong>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</strong></p><p><strong>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</strong></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>  （1）一级缓存（SqlSession级别）</p><pre><code>  MyBatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行     相同的sql语句，第一次执行后会将查询到的数据存储到缓存当中，第二次会从缓     存中进行查找，从而提高查询效率，当一个SqlSession结束之后，一级缓存也将不     存在，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认开启一级缓存。</code></pre><p>  （2）二级缓存（Mapper级别）</p><pre><code>     二级缓存的作用域是mapper的同一个namespace，执行两次相同的SQL语句，     第一次执行后会将查询到的数据存储到缓存当中，第二次会从缓存中进行查找，从而提高查询效率，默认不开启</code></pre><p>（3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h4 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h4><p>① 创建SqlSessionFactory</p><p>② 通过SqlSessionFactory创建SqlSession</p><p>③ 通过sqlsession执行数据库操作</p><p>④ 调用session.commit()提交事务</p><p>⑤ 调用session.close()关闭会话</p><h3 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h3><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 </p><p>（2）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。</p><p>使用Hibernate查询关联对象或者关联集合对象时，</p><p>可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，</p><p>需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一份简明的 Markdown 笔记与教程</title>
      <link href="/2018/12/17/2018-09-06-markdown-intro/"/>
      <url>/2018/12/17/2018-09-06-markdown-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>专注于文字内容；</p></li><li><p>纯文本，易读易写，可以方便地纳入版本控制；</p></li><li><p>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。</p></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>各类代码托管平台</p><p>  主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。</p></li><li><p>技术社区和写作平台</p><p>  StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记</p></li><li><p>论坛</p><p>  V2EX、光谷社区</p></li></ul><p>个人感觉比较遗憾的一点是各平台可能采用不同语言实现的 Markdown 解析引擎，或采用同一解析引擎的不同版本，而且可能有不同程度的定制与扩展，这导致在不同平台上使用 Markdown 写作时体验并不完全一致。不过幸好对于大家公认的一些标准语法，各家都是支持的。</p><h3 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h3><p>理论上任何一款文本编辑器都能用于编辑 Markdown 文档，它们分别提供了不同程度的语法高亮、预览等功能，以下只是列举其中一部分，选择自己称手的即可。</p><ul><li><p>现代编辑器</p><p>  VSCode / Atom</p></li><li><p>传统编辑器</p><p>  Vim / Emacs / Sublime Text / Notepad++</p></li><li><p>IDE 自带编辑器</p><p>  IntelliJ IDEA / Android Studio / WebStorm</p></li><li><p>专用编辑器</p><p>  Ulysses / Mou / Typora / Markpad</p></li><li><p>在线编辑器</p><p>  各种支持 Markdown 的网站都提供了在线编辑器</p></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>Markdown：</strong></p><pre><code># atx-style 一级标题## 二级标题###### 六级标题Setext-style 一级标题===二级标题---</code></pre><p><strong>预览效果：</strong></p><blockquote><h1 id="atx-style-一级标题"><a href="#atx-style-一级标题" class="headerlink" title="atx-style 一级标题"></a>atx-style 一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="Setext-style-一级标题"><a href="#Setext-style-一级标题" class="headerlink" title="Setext-style 一级标题"></a>Setext-style 一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>atx-style 一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">&gt;</span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Setext-style 一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>中间没有空行的连续不断的几行文字被视为一个段落。</p><p><strong>Markdown：</strong></p><pre><code>白日依山尽，黄河入海流。（句号后面没空格）欲穷千里目，更上一层楼。  （句号后面有俩空格）</code></pre><p><strong>预览效果：</strong></p><p>白日依山尽，</p><p>黄河入海流。<br>（句号后面没空格）</p><p>欲穷千里目，</p><p>更上一层楼。<br>（句号后面有俩空格）</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>白日依山尽，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>黄河入海流。（句号后面没有空格）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>欲穷千里目，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>  更上一层楼。  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">&gt;</span></span>  （句号后面有俩空格）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="行内格式"><a href="#行内格式" class="headerlink" title="行内格式"></a>行内格式</h3><p>对段落或者部分文本的强调效果。</p><p><strong>Markdown：</strong></p><pre><code>后面俩字**加黑**后面俩字*斜体*</code></pre><p><strong>预览效果：</strong></p><p>后面俩字<strong>加黑</strong></p><p>后面俩字<em>斜体</em></p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>  后面俩字  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">&gt;</span></span>加黑<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>  后面俩字  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>斜体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p><strong>Markdown：</strong></p><pre><code>&gt; 引用块段落一。&gt;&gt; 引用块段落二。&gt;&gt; 内嵌引用块段落一。&gt;&gt; ### 引用块内的标题</code></pre><p><strong>预览效果：</strong></p><blockquote><p>引用块段落一。</p><p>引用块段落二。</p><blockquote><p>内嵌引用块段落一。</p></blockquote><h3 id="引用块内的标题"><a href="#引用块内的标题" class="headerlink" title="引用块内的标题"></a>引用块内的标题</h3></blockquote><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blockquote</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>引用块段落一。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>引用块段落二。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blockquote</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>内嵌引用块段落一。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blockquote</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>引用块内的标题<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>引用块内的标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blockquote</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>Markdown 支持行内式链接和引用式链接。</p><p><strong>Markdown：</strong></p><pre><code>行内式 [博客](https://mazhuang.org "我的个人博客") 链接，带 title。行内式 [GitHub](https://github.com/mzlogin) 链接。引用式 [博客][1] 链接。引用式 [GitHub][2] 链接，带 title。[1]: https://mazhuang.org[2]: https://github.com/mzlogin "我的 GitHub 主页"</code></pre><p><strong>预览效果：</strong></p><p>行内式 <a href="https://mazhuang.org" title="我的个人博客" target="_blank" rel="noopener">博客</a> 链接，带 title。</p><p>行内式 <a href="https://github.com/mzlogin" target="_blank" rel="noopener">GitHub</a> 链接。</p><p>引用式 <a href="https://mazhuang.org" target="_blank" rel="noopener">博客</a> 链接。</p><p>引用式 <a href="https://github.com/mzlogin" title="我的 GitHub 主页" target="_blank" rel="noopener">GitHub</a> 链接，带 title。</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>行内式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://mazhuang.org<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>我的个人博客<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>博客<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> 链接，带 title。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>行内式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/mzlogin<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>GitHub<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> 链接。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>引用式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://mazhuang.org<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>博客<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> 链接。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>引用式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/mzlogin<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>我的 GitHub 主页<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>GitHub<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span> 链接，带 title。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>在超链接的写法前加一个 <code>!</code>，就是引用图片的方法。</p><p><strong>Markdown：</strong></p><pre><code>![Alt text](https://mazhuang.org/favicon.ico "favicon")</code></pre><p><strong>预览效果：</strong></p><p><img src="https://mazhuang.org/favicon.ico" alt="Alt text" title="favicon"></p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://mazhuang.org/favicon.ico<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Alt text<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>favicon<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>包括有序列表和无序列表。</p><p><strong>Markdown：</strong></p><pre><code>- 苹果- 葡萄- 榴莲1. 苹果2. 葡萄3. 榴莲</code></pre><p><strong>预览效果：</strong></p><ul><li>苹果</li><li>葡萄</li><li>榴莲</li></ul><ol><li>苹果</li><li>葡萄</li><li>榴莲</li></ol><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>葡萄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>榴莲<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>葡萄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>榴莲<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">&gt;</span></span></code></pre><p>其中无序列表的标记可以使用 <code>+</code>、<code>-</code> 或 <code>*</code>，有序列表前的数字可以是乱序的。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>支持行内代码和代码块。</p><p><strong>Markdown：</strong></p><pre><code>Android 里使用 `TextUtils` 类的 `isEmpty` 方法来判断字符串是否为空。```javaif (TextUtils.isEmpty(text)) {    return null;}```</code></pre><p><strong>预览效果：</strong></p><p>Android 里使用 <code>TextUtils</code> 类的 <code>isEmpty</code> 方法来判断字符串是否为空。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>TextUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Android 里使用 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">&gt;</span></span>TextUtils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">&gt;</span></span> 类的 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">&gt;</span></span>isEmpty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">&gt;</span></span> 方法来判断字符串是否为空。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>highlight highlight-source-java<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-k<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>if<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> (<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-smi<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>TextUtils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-k<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>isEmpty(text)) {    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-k<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>return<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-c1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>null<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>;}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre><p>上例中的语言标记 <code>java</code> 可选填，可用于在编辑器和渲染后的效果里添加语法高亮。</p><p>块式代码也可以对整个代码段缩进四个空格，或一个 Tab 来实现。</p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>使用一个单独行里的三个或以上 <code>*</code>、<code>-</code> 来生产一条水平分割线，它们之间可以有空格。</p><p><strong>Markdown：</strong></p><pre><code>***------ - -</code></pre><p><strong>预览效果：</strong></p><hr><hr><hr><p><strong>对应 HTML：</strong></p><pre><code>&lt;hr /&gt;&lt;hr /&gt;&lt;hr /&gt;</code></pre><h3 id="嵌入-HTML"><a href="#嵌入-HTML" class="headerlink" title="嵌入 HTML"></a>嵌入 HTML</h3><p>Markdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML 标签的方式。它对应的只是 HTML 标签的一个很小的子集。</p><p>对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML 来写就好了。</p><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>本节的内容是介绍一些受到广泛支持的 Markdown 扩展语法。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown：</strong></p><pre><code>| 编号  | 姓名（左） | 年龄（右） | 性别（中） || ----- | :--------  | ---------: | :------:   || 0     | 张三       | 28         | 男         || 1     | 李四       | 29         | 男         |</code></pre><p><strong>预览效果：</strong></p><table><thead><tr><th>编号</th><th align="left">姓名（左）</th><th align="right">年龄（右）</th><th align="center">性别（中）</th></tr></thead><tbody><tr><td>0</td><td align="left">张三</td><td align="right">28</td><td align="center">男</td></tr><tr><td>1</td><td align="left">李四</td><td align="right">29</td><td align="center">男</td></tr></tbody></table><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thead</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">&gt;</span></span>编号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>姓名（左）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>年龄（右）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>性别（中）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thead</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tbody</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>28<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>李四<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>29<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tbody</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>在 GitHub / GitLab 里有较好的支持。</p><p><strong>Markdown：</strong></p><pre><code>- [x] 洗碗- [ ] 清洗油烟机- [ ] 拖地</code></pre><p><strong>预览效果：</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 洗碗</li><li><input disabled="" type="checkbox"> 清洗油烟机</li><li><input disabled="" type="checkbox"> 拖地</li></ul><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>contains-task-list<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item-checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> 洗碗<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item-checkbox<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> 清洗油烟机<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item-checkbox<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> 拖地<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span></code></pre><p>如果是在 GitHub / GitLab 的 Issue 里，会附赠任务完成比例提示效果：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-1.png" alt="task list 1"></p><p>还可以直接在网页上拖动调整顺序，勾选和取消勾选。</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-2.png" alt="task list 2"></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><strong>Markdown：</strong></p><pre><code>后面三个字打上~~删除线~~。</code></pre><p><strong>预览效果：</strong></p><p>后面三个字打上<del>删除线</del>。</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>后面三个字打上<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">&gt;</span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">&gt;</span></span>。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>自动链接扩展，即：当识别到 URL，或用 <code>&lt;</code>、<code>&gt;</code> 包括的 URL 时，会自动为其生成 <code>a</code> 标签。</p><p><strong>Markdown：</strong></p><pre><code>https://github.com&lt;example@gmail.com&gt;</code></pre><p><strong>预览效果：</strong></p><p><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><p><a href="mailto:example@gmail.com" target="_blank" rel="noopener">example@gmail.com</a></p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>https://github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mailto:example@gmail.com<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>example@gmail.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></code></pre><h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><p>以 GitHub Pages 为例。</p><p><strong>Markdown：</strong></p><pre><code>:camel: :blush: :smile:</code></pre><p><strong>预览效果：</strong></p><p>:camel: :blush: :smile:</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emoji<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:camel:<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:camel:<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://assets-cdn.github.com/images/icons/emoji/unicode/1f42b.png<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emoji<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:blush:<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:blush:<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emoji<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:smile:<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:smile:<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></code></pre><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>脑洞清奇的工程师们还发掘了很多使用 Markdown 的方法，大部分都是引入第三方 JavaScript 插件来实现。对这部分我只做简述，对其中的部分功能比如作图等，还是推荐用专门的可视化工具去做。</p><h3 id="画流程图和时序图"><a href="#画流程图和时序图" class="headerlink" title="画流程图和时序图"></a>画流程图和时序图</h3><p>有部分网站和编辑器实现了对 Markdown 里流程图和时序图的支持，比如我们使用的项目管理工具 TAPD 的在线编辑器，还有 VSCode + 插件 Markdown Preview Enhanced 等。</p><p>以我们使用的项目管理工具 TAPD 的在线编辑器为例：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-flowchart.png" alt="流程图"></p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-seq.png" alt="时序图"></p><h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><p>仍然以 TAPD 为例：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-math.png" alt="数学公式"></p><p>应该是利用 JavaScript 支持了 LaTeX 公式语法。</p><h3 id="用-Markdown-做-PPT"><a href="#用-Markdown-做-PPT" class="headerlink" title="用 Markdown 做 PPT"></a>用 Markdown 做 PPT</h3><p>有专门的工具 <a href="https://github.com/yhatt/marp" target="_blank" rel="noopener">Marp</a>，另外使用 VSCode + 插件 Markdown Preview Enhanced 也可以实现。</p><h3 id="用-Markdown-写微信公众号"><a href="#用-Markdown-写微信公众号" class="headerlink" title="用 Markdown 写微信公众号"></a>用 Markdown 写微信公众号</h3><p>可以将公众号素材用 Markdown 编辑好后，贴到在线排版工具以后，复制到公众号编辑器里即可。有多种页面主题和代码主题可选择。</p><p>我维护的工具地址：<a href="https://md.mazhuang.org" target="_blank" rel="noopener">https://md.mazhuang.org</a></p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/wechat-markdown.png" alt="微信公众号"></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>想象力丰富的工程师们还扩展了很多基于 Markdown 的玩法，包括但不限于：</p><ul><li>自动生成 / 更新 Table of Contents</li><li>流程图 / 时序图</li><li>制作幻灯片</li><li>集成 PlantUML / GraphViz 的能力</li><li>导出 HTML / PDF / 电子书</li><li>…</li></ul><p>以上功能基本都可以用 VSCode + 插件 Markdown Preview Enhanced 实现。</p><p>另外可以参考我以前的一篇博客 <a href="https://mazhuang.org/2017/09/01/markdown-odd-skills/" target="_blank" rel="noopener">关于 Markdown 的一些奇技淫巧</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">Markdown: Syntax - DARING FIREBALL</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown - 维基百科</a></li><li><a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GitHub Flavored Markdown Spec</a></li><li><a href="https://mazhuang.org/2017/09/01/markdown-odd-skills/" target="_blank" rel="noopener">关于 Markdown 的一些奇技淫巧</a></li></ul><hr><p>欢迎关注我的微信公众号，接收 markdown-intro 最新动态。</p><div align="center"><img width="192px" height="192px" src="https://mazhuang.org/assets/images/qrcode.jpg"></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
