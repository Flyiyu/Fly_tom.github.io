<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java多线程基础读书</title>
      <link href="/2019/10/21/2019-07-21-java-duo-xian-cheng-ji-chu-bi-ji/"/>
      <url>/2019/10/21/2019-07-21-java-duo-xian-cheng-ji-chu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="关于线程的文章"><a href="#关于线程的文章" class="headerlink" title="关于线程的文章"></a>关于线程的文章</h3><p><a href="https://www.javazhiyin.com/32391.html" target="_blank" rel="noopener">https://www.javazhiyin.com/32391.html</a></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/thread2.png" alt=""></p><h3 id="单核-CPU-和多核-CPU"><a href="#单核-CPU-和多核-CPU" class="headerlink" title="单核 CPU 和多核 CPU"></a>单核 CPU 和多核 CPU</h3><p>来思考一个问题吧。假如 CPU 只有一个，核数也只有一个，多线程还会有优势吗？</p><p>闭上眼，让思维旋转跳跃会。</p><p>来看答案吧。</p><p>单核 CPU 上运行的多线程程序，同一时间只有一个线程在跑，系统帮忙进行线程切换；系统给每个线程分配时间片（大概 10ms）来执行，看起来像是在同时跑，但实际上是每个线程跑一点点就换到其它线程继续跑。所以效率不会有所提高，线程的切换反到增加了系统开销。</p><p>那多核 CPU 呢？</p><p>当然有优势了！多核需要多线程才能发挥优势（不然巧妇难为无米之炊啊），同样，多线程要在多核上才能有所发挥（好马配好鞍啊）。</p><p>多核 CPU 多线程不仅善于处理 IO 密集型的任务（减少阻塞时间），还善于处理计算密集型的任务，比如加密解密、数据压缩解压缩（视频、音频、普通数据等），让每个核心都物尽其用。</p><h3 id="应该了解的概念"><a href="#应该了解的概念" class="headerlink" title="应该了解的概念"></a>应该了解的概念</h3><ol><li>同步VS异步<blockquote><p>同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。</p></blockquote></li></ol><ol start="2"><li><p>并发与并行</p><blockquote><p>并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。</p></blockquote></li><li><p>阻塞和非阻塞</p><blockquote><p>阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。</p></blockquote></li><li><p>临界区</p><blockquote><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。</p></blockquote></li></ol><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程 线程"></a>进程 线程</h3><p><strong>什么是进程</strong></p><p>进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例。</p><p><strong>进程时间片的概念</strong></p><pre><code>一个操作系统中，如果同时运行着多个进程，他们是一定交替运行的。每个进程不管有没有运行完毕，都只占据一段时间的CPU。这个运行时间就是进程时间片。它非常短促，所以感觉不到他们是交替占用CPU。</code></pre><p><strong>什么是线程</strong></p><ul><li><p>线程：进程内部的控制流。它也是一段可运行的指令。</p></li><li><p>特点：资源占用小，线程间通信容易。</p></li><li><p>多进程是指操作系统能同时运行多个任务（程序）。</p></li></ul><p>多线程：</p><pre><code>指的是这个程序（一个进程）运行时产生了不止一个线程</code></pre><p><strong>线程进程的区别体现在几个方面：</strong></p><ol><li><p>因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p></li><li><p>体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p></li><li><p>属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p></li><li><p>线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；</p></li><li><p>线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p></li><li><p>体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p></li></ol><h3 id="高并发与多线程的关系"><a href="#高并发与多线程的关系" class="headerlink" title="高并发与多线程的关系"></a>高并发与多线程的关系</h3><ol><li>什么是高并发</li></ol><p>高并发（High Concurrency）是一种系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，主要发生在web系统集中大量访问收到大量请求（例如：12306的抢票情况；天猫双十一活动）。</p><p>该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。</p><ol start="2"><li>高并发关注哪些指标</li></ol><pre><code>1. 响应时间（Response Time）响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间2. 吞吐量（Throughput）吞吐量：单位时间内处理的请求数量。3. 每秒查询率QPS（Query Per Second）QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。4. 并发用户数并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</code></pre><ol start="3"><li>高并发与多线程的关系</li></ol><p><strong>“高并发和多线程”总是被一起提起，给人感觉两者好像相等，实则 高并发 ≠ 多线程。</strong></p><p><strong>多线程可以这么理解：多线程是处理高并发的一种编程方法。</strong></p><p>高并发不是Java专有的东西，是语言无关的，为提供更好互联网服务而提出的概念。如果要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等……而多线程只是其中解决方法之一。</p><p><strong>并行与并发：</strong></p><pre><code>1.    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。2.    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。并发性（concurrency）和并行性（parallel）</code></pre><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc25.png" alt=""></p><p>java中的线程的生命周期大体可分为5种状态。</p><ol><li><p>新建(NEW)：新创建了一个线程对象。</p></li><li><p>可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p></li><li><p>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p></li><li><p>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><p> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p><p> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p><p> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p></li><li><p>死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>对于单核CPU来说（对于多核CPU，此处就理解为一个核），CPU在一个时刻只能运行一个线程，当在运行一个线程的过程中转去运行另外一个线程，这个叫做线程上下文切换（对于进程也是类似）。</p><p>由于可能当前线程的任务并没有执行完毕，所以在切换时需要保存线程的运行状态，以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子：比如一个线程A正在读取一个文件的内容，正读到文件的一半，此时需要暂停线程A，转去执行线程B，当再次切换回来执行线程A的时候，我们不希望线程A又从文件的开头来读取。</p><p>因此需要记录线程A的运行状态，那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了，所以需要记录程序计数器的值，另外比如说线程正在进行某个计算的时候被挂起了，那么下次继续执行的时候需要知道之前挂起时变量的值时多少，因此需要记录CPU寄存器的状态。所以一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p><p>说简单点的：对于线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。</p><p>虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>　　在java中如果要创建线程的话，一般有两种方式：1）继承Thread类；2）实现Runnable接口。</p><p><strong>三种方法来创建线程：</strong></p><p>继承Thread类创建</p><p>继承Thread创建并启动多线程有三个步骤：</p><ol><li>定义类并继承Thread,重写run()方法,run()方法中为需要多线程执行的任务。</li><li>创建该类的实例，即创建了线程对象。</li><li>调用实例的start()方法启动线程。</li></ol><pre><code>继承java.lang.Thread类，并覆盖run( )方法。 class Mythread extends Thread {     public void run( ) {         /* 覆盖该方法*/      } } // 调用方式： Mythread  m = new Mythread(); m.start();</code></pre><p>第二种方式： </p><p>实现Runnable接口创建并启动多线程也有以下步骤：</p><ol><li>定义类并继承Runnable接口,重写run()方法,run()方法中为需要多线程执行的任务。</li><li>创建该类的实例，并以此实例作为target为参数来创建Thread对象，这个Thread对象才是真正的多线程对象。</li></ol><pre><code>// 实现java.lang.Runnable接口，并实现run( )方法。// 推荐此方式   // a. 覆写Runnable接口实现多线程可以避免单继承局限   // b. 当子类实现Runnable接口，此时子类和Thread的代理模式（子类负责真是业务的操作，thread负责资源调度与线程创建辅助真实业务。class Mythread implements Runnable{      @Override      public void run( ) {          /* 实现该方法*/      } } // 调用 Thread thread = new Thread(new Mythread()); thread.start();</code></pre><p>第三种：</p><p>Callable是Runnable的增加版，主要是接口中的call()方法可以有返回值，并且可以申明抛出异常，使用Callable创建的步骤如下：</p><ol><li>定义类并继承Callable接口,重写call()方法,run()方法中为需要多线程执行的任务。</li><li>创建类实例，使用FutureTask来包装对象实例，</li><li>使用FutureTask对象作为Thread的target来创建多线程，并启动线程。</li><li>调用FutureTask对象的get()方法来获取子线程结束后的返回值。</li></ol><pre><code>class CallableTest{    public static void main(String[] args) {        Callss callss = new Callss();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callss);        Thread thread = new Thread(futureTask);        thread.start();        // 接收线程运算后的结果        try {            // FutureTask 可用于 闭锁 类似于CountDownLatch的作用，在所有的线程没有执行完成之后这里是不会执行的            Integer sum = futureTask.get();            System.out.println(sum);        } catch (InterruptedException | ExecutionException e) {            e.printStackTrace();        }    }}/** * 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。 * 执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类 * 运行Callable任务可拿到一个Future对象， Future表示异步计算的结果。  * 它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。  * 通过Future对象可了解任务执行情况，可取消任务的执行，还可获取任务执行的结果。  */class Callss implements Callable&lt;Integer&gt; {    @Override    public Integer call() throws Exception {        int a = 0;        for (int i = 0; i &lt; 5; i++) {            a++;        }        return a;    }}</code></pre><p><strong>一个线程的对象只能执行一次start()方法</strong></p><p><strong>*注</strong> 多次调用start()方法，会出现异常 java.lang.IllegalThreadStateException</p><p><strong>线程执行过程</strong></p><ul><li><p>调用start( )方法时，将创建一个新的线程，并为线程分配系统资源，如内存。接着它将调用 run( ) 方法。</p></li><li><p>run( ) 方法中的代码定义执行线程所需的功能。</p><ul><li>run()方法能够调用其他方法，引用其他的类，申明变量。</li><li>run()方法在程序中确定另一个并发线程的执行入口。</li></ul></li><li><p>当run()方法中的任务完成返回时，该线程也将结束。</p></li></ul><p><strong>注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。<br>从程序运行的结果可以发现，多线程程序是乱序执行。</strong></p><p>另外需要注意的是：</p><blockquote><p>执行start()方法的顺序不代表线程启动的执行顺序</p></blockquote><h3 id="实例变量与线程安全"><a href="#实例变量与线程安全" class="headerlink" title="实例变量与线程安全"></a>实例变量与线程安全</h3><blockquote><p>自定义的线程类中实例变量针对其他线程可以有共享和不共享之分</p></blockquote><ul><li>不共享数据：每个线程访问各自的实例变量。</li><li>共享数据：多个线程访问同一个变量。</li></ul><p>首先来分析下，在JVM中，i–的操作</p><ul><li>取得原有i值。</li><li>计算i-1。</li><li>对i进行赋值。</li></ul><p>非线程安全：是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。</p><p>在run方法中加上synchronized关键字，使多个线程在执行run方法的时候，以队列的方式进行处理，当一个线程调用run方法前，先判断run方法有没有被上锁，如果上锁，说明有其他线程在调用run方法，必须等待其他线程对run方法调用结束才能执行run方法，这样实现了排队调用的目的，也就实现了对count依次–，synchronized可以对任意对象及方法加上锁，而枷锁的这段代码叫做 “互斥区”或“临界区”。</p><h3 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h3><p>属于Thread的方法</p><p>0 . </p><ul><li><p>getName和setName</p><p>  用来得到或者设置线程名称。</p></li><li><p>getPriority和setPriority</p><p>  用来获取和设置线程优先级。</p></li><li><p>setDaemon和isDaemon</p><p>  用来设置线程是否成为守护线程和判断线程是否是守护线程。</p><p>  守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p></li></ul><h4 id="1．start-："><a href="#1．start-：" class="headerlink" title="　　1．start() ："></a>　　1．start() ：</h4><p>线程调用该方法将启动线程，使之从新建状态进入就绪队列排队，一旦轮到它来享用CPU资源时，就可以脱离创建它的线程独立开始自己的生命周期了。</p><p>####　　2．run():<br>Thread类的run()方法与Runnable接口中的run()方法的功能和作用相同，都用来定义线程对象被调度之后所执行的操作，都是系统自动调用而用户程序不得引用的方法。</p><h4 id="3．线程休眠——sleep-int-millsecond"><a href="#3．线程休眠——sleep-int-millsecond" class="headerlink" title="　　3．线程休眠——sleep(int millsecond):"></a>　　3．线程休眠——sleep(int millsecond):</h4><p>（1）线程休眠会交出CPU，让CPU去执行其他的任务。</p><p>（2）调用sleep()方法让线程进入休眠状态后，sleep()方法并不会释放锁，即当前线程持有某个对象锁时，即使调用sleep()方法其他线程也无法访问这个对象。</p><p>（3）调用sleep()方法让线程从运行状态转换为阻塞状态；sleep()方法调用结束后，线程从阻塞状态转换为可执行状态。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><h4 id="4．isAlive"><a href="#4．isAlive" class="headerlink" title="　　　　4．isAlive():"></a>　　　　4．isAlive():</h4><p>判断当前线程是否处于活动状态，线程处于“新建”状态时，线程调用isAlive()方法返回false。在线程的run()方法结束之前，即没有进入死亡状态之前，线程调用isAlive()方法返回true.</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="5．currentThread"><a href="#5．currentThread" class="headerlink" title="　　5．currentThread():"></a>　　5．currentThread():</h4><p>该方法是Thread类中的类方法，可以用类名调用，该方法返回当前正在使用CPU资源的线程。</p><h4 id="6．interrupt-："><a href="#6．interrupt-：" class="headerlink" title="6．interrupt() ："></a>6．interrupt() ：</h4><p>一个占有CPU资源的线程可以让休眠的线程调用interrupt()方法“吵醒”自己，即导致休眠的线程发生InterruptedException异常，同时会清除中断标志，从而结束休眠，重新排队等待CPU资源。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>blockerLock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Interruptible b <span class="token operator">=</span> blocker<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">interrupt0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// Just to set the interrupt flag</span>                b<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">interrupt0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="7-getId-："><a href="#7-getId-：" class="headerlink" title="　　7. getId()："></a>　　7. getId()：</h4><p>获得线程的唯一标识</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> tid<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="8-线程让步——yield"><a href="#8-线程让步——yield" class="headerlink" title="　　8.  线程让步——yield():"></a>　　8.  线程让步——yield():</h4><p>线程让步：暂停当前正在执行的线程对象，并执行其他线程。</p><p>（1）调用yield()方法让当前线程交出CPU权限，让CPU去执行其他线程。</p><p>（2）yield()方法和sleep()方法类似，不会释放锁，但yield()方法不能控制具体交出CPU的时间,不能由用户指定暂停多长时间。</p><p>（3）yield()方法只能让拥有相同优先级的线程获取CPU执行的机会。</p><p>（4）使用yield()方法不会让线程进入阻塞状态，而是让线程从运行状态转换为就绪状态，只需要等待重新获取CPU执行的机会。</p><p>（5）实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="9-suspend"><a href="#9-suspend" class="headerlink" title="　　9. suspend():"></a>　　9. suspend():</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">suspend0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="10-resume-："><a href="#10-resume-：" class="headerlink" title="　　10. resume()："></a>　　10. resume()：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resume0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="11-线程加入——join"><a href="#11-线程加入——join" class="headerlink" title="　　11. 线程加入——join():"></a>　　11. 线程加入——join():</h4><blockquote><p>假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。 </p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 源码</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">join</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//join()等同于join(0)</span><span class="token punctuation">}</span></code></pre><h4 id="12-wait"><a href="#12-wait" class="headerlink" title="　　12. wait() :"></a>　　12. wait() :</h4><p>调用该方法的线程进入WATTING状态，只有等待另外线程的通知或中断才会返回，调用wait()方法后，会释放对象的锁。</p><ul><li>wait(long):超时等待最多long毫秒，如果没有通知就超时返回。</li></ul><h4 id="14-notify"><a href="#14-notify" class="headerlink" title="　　14. notify() :"></a>　　14. notify() :</h4><p>通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁。</p><h4 id="15-notifyAll-："><a href="#15-notifyAll-：" class="headerlink" title="　　15. notifyAll()："></a>　　15. notifyAll()：</h4><p>通知所有等待在该对象上的线程。</p><h4 id="守护线程Daemon"><a href="#守护线程Daemon" class="headerlink" title="　　守护线程Daemon"></a>　　守护线程Daemon</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT线程就可以理解守护线程。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。下面以一个简单的例子来表述Daemon线程的使用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DaemonDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread daemonThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i am alive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finally block"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        daemonThread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        daemonThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//确保main线程结束前能给daemonThread能够分到时间片</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果为：</p><pre class=" language-java"><code class="language-java"><span class="token operator">></span> i am alive<span class="token operator">></span> <span class="token keyword">finally</span> block<span class="token operator">></span> i am alive</code></pre><p>上面的例子中daemodThread run方法中是一个while死循环，会一直打印,但是当main线程结束后daemonThread就会退出所以不会出现死循环的情况。main线程先睡眠800ms保证daemonThread能够拥有一次时间片的机会，也就是说可以正常执行一次打印“i am alive”操作和一次finally块中”finally block”操作。紧接着main 线程结束后，daemonThread退出，这个时候只打印了”i am alive”并没有打印finnal块中的。因此，这里需要注意的是<strong>守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的</strong></p><p><strong>线程可以通过setDaemon(true)的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于start()方法，否则会报</strong></p><pre class=" language-java"><code class="language-java"><span class="token operator">></span> Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>IllegalThreadStateException<span class="token operator">></span> at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">1365</span><span class="token punctuation">)</span><span class="token operator">></span> at learn<span class="token punctuation">.</span>DaemonDemo<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>DaemonDemo<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">19</span><span class="token punctuation">)</span></code></pre><h4 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run() 和start()的区别"></a>run() 和start()的区别</h4><ol><li><p>start() 方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码；通过调用 Thread 类的 start() 方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行操作的， 这里方法 run() 称为线程体，它包含了要执行的这个线程的内容， run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p></li><li><p>run() 方法当作普通方法的方式调用。程序还是要顺序执行，要等待 run 方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</p></li></ol><p>run()，实质上是方法，作用是运行线程，无法开启新的线程</p><p>start()，创建启动新的线程，可以实现多线程工作。通过start()使得线程处于就绪状态，在获得CPU时间片后通过run()开始运行</p><h4 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep() 和wait()的区别"></a>sleep() 和wait()的区别</h4><ol><li>sleep()方法是Thread的静态方法，而wait是Object实例方法</li><li>wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。另外，wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；</li><li>sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。</li></ol><h4 id="线程调度——优先级"><a href="#线程调度——优先级" class="headerlink" title="线程调度——优先级"></a>线程调度——优先级</h4><p>void setPriority(int newPriority)函数设置线程优先级<br>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p><p>线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。<br>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</p><p>setPriority()代码实例</p><h4 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h4><p> 方法isAlive()功能是判断当前线程是否处于活动状态。</p><p>活动状态就是线程启动且尚未终止，比如正在运行或准备开始运行。</p><h4 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep()"></a>Sleep()</h4><p>Thread.sleep()是Thread类的一个静态方法，使当前线程休眠，进入阻塞状态（暂停执行），如果线程在睡眠状态被中断，将会抛出IterruptedException中断异常。把cpu的时间片交给其他线程，但是并没有指定把CPU的时间片接下来到底交给哪个线程，而是让这些线程自己去竞争</p><p>。主要方法如下：</p><p>【a】sleep(long millis)  线程睡眠 millis 毫秒</p><p>【b】sleep(long millis, int nanos)  线程睡眠 millis 毫秒 + nanos 纳秒</p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><ul><li>本线程中断自身是被允许的，且”中断标记”设置为true</li><li>其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。 <ul><li>若线程在阻塞状态时，调用了它的interrupt()方法，那么它的<strong>“中断状态”会被清除</strong>并且会收到一个InterruptedException异常。 <ul><li>例如，如果线程由于调用Object类的wait()方法、Thread类的join()实例方法以及Thread.sleep()静态方法而被挂起，此时其他线程调用了这个线程的interrupt方法，那么这个线程的中断状态会被清除为“false”，并会抛出一个InterruptedException异常。 </li></ul></li><li>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。<br>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。</li></ul></li></ul><p>可以得出两点结论：</p><p>　　1 即便调用了interrupt方法，之后用isInterrupted()方法检查它的中断状态时也不一定能得到true。</p><p>　　2 如果线程当前运行处的代码块不对InterruptedException异常进行合适的处理，那么interrupt方法就没有任何效果。</p><p>interrupted并不是马上停止线程，而是给线程打一个停止标记，将线程的中断状态设置为true,这类似老板让你好好工作，但是到底好不好工作要看你自己。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            MyThread myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            myThread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果显示还是会打印5万行数据。</p><p>Thread提供了两个方法来判断线程是否终止</p><p>interrupt() 当抛出异常时，会清除中断状态</p><p>static boolean interrupted()：判断当前线程是否中断，清除中断标志。</p><p>boolean isInterrupted()：判断线程是否中断，不清除中断标志。</p><pre><code>Thread.currentThread().interrupt();System.out.println("是否停止1？=" + Thread.interrupted());//true，执行方法后清除了标记System.out.println("是否停止2？=" + Thread.interrupted());//false当调用了interrupted后线程未真正的停止，但已经有了标志状态，也就是说我们可以通过标志状态来对我们的多线程执行的方法进行处理。</code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FiveThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经是停止状态了!退出!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        FiveThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FiveThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main catch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>异常法停止线程</p><p>这样虽然可以实现退出for循环，但是在for循环之外的代码依然会被执行，很明显这样没有达到效果，这个时候我们可以抛出异常：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">500000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经是停止状态了!退出!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抛出了错误！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然我们也可以使用return方式进行处理，但还是抛出异常处理比较好，可以让线程中断事件得到传播。</p><h4 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h4><p>判断的是当前线程是否处于中断状态。是类的静态方法，同时会清除线程的中断状态。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　<span class="token keyword">return</span> <span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h4><p>判断调用线程是否处于中断状态，不清除中断标志。<br>例如:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>　　Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个线程，伪代码没有具体实现</span>　　thread<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断thread是否处于中断状态，而不是主线程是否处于中断状态</span>　　Thread<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//判断主线程是否处于中断状态</span><span class="token punctuation">}</span></code></pre><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>Object.wait（） - 挂起一个线程</li><li>Object.notify（） -唤醒线程</li></ul><p>wait（）方法带有三个重载。</p><h4 id="wait（）"><a href="#wait（）" class="headerlink" title="wait（）"></a>wait（）</h4><ol><li>该wait（）方法导致当前线程无限期地等待，直到另一个线程要么调用notify（）此对象或notifyAll的（） 。</li><li>wait（long timeout）<br> 使用此方法，我们可以指定一个超时，在该超时之后将自动唤醒线程。可以使用notify（）或notifyAll（）在达到超时之前唤醒线程。<br>请注意，调用wait（0）与调用wait（）相同。</li><li>wait（long timeout，int nanos）<br>这是另一个提供相同功能的签名，唯一的区别是这个可以提供更高的精度。<br>总超时时间（以纳秒为单位）计算为1_000_000 *timeout+ nanos。</li></ol><h4 id="notify（）和notifyAll（）"><a href="#notify（）和notifyAll（）" class="headerlink" title="notify（）和notifyAll（）"></a>notify（）和notifyAll（）</h4><p>该notify（）方法用于唤醒正在等待到该对象的监视器接入线程。<br>有两种方法可以通知等待线程。</p><ol><li>notify（）<br>对于在此对象的监视器上等待的所有线程（通过使用任何一个wait（）方法），方法notify（）通知任何一个线程任意唤醒。确切唤醒哪个线程的选择是非确定性的 ，取决于实现。<br>由于notify（）唤醒了一个随机线程，因此它可用于实现线程执行类似任务的互斥锁定，但在大多数情况下，实现notifyAll（）会更可行。</li><li>notifyAll（）<br>此方法只是唤醒正在此对象的监视器上等待的所有线程。<br>唤醒的线程将以通常的方式完成 - 就像任何其他线程一样。<br>但是在我们允许它们继续执行之前，总是要定义快速检查继续执行线程所需的条件 - 因为可能存在某些情况下线程被唤醒而没有收到通知</li></ol><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><ol><li>首先，wait获取对象锁，然后调用wait()方法，此时，<strong>wait线程会放弃对象锁</strong>，同时进入对象的等待队列WaitQueue中;</li><li>notify线程抢占到对象锁，执行一些操作后，调用notify()方法，此时会将等待线程waitThread从等待队列WaitQueue中移到同步队列SynchronizedQueue中，wait由waitting状态变为blocked状态。需要注意的时，<strong>notify此时并不会立即释放锁</strong>，它继续运行，把自己剩余的事儿干完之后才会释放锁;</li><li>wait再次获取到对象锁，从wait()方法返回继续执行后续的操作;</li><li>一个基于等待/通知机制的线程间通信的过程结束。</li></ol><p>至于notifyAll则是在第二步中将等待队列中的所有线程移到同步队列中去。</p><p><strong>避免踩坑</strong></p><p>　　在使用wait/notify/notifyAll时有一些特别留意的，在此再总结一下：</p><ol><li>一定在synchronized中使用wait()/notify()/notifyAll()，也就是说一定要先获取锁，这个前面我们讲过，因为只有加锁后，才能获得监视器。否则jvm也会抛出IllegalMonitorStateException异常。</li><li>使用wait()时，判断线程是否进入wait状态的条件一定要使用while而不要使用if，因为等待线程可能会被错误地唤醒，所以应该使用while循环在等待前等待后都检查唤醒条件是否被满足，保证安全性。</li><li>notify()或notifyAll()方法调用后，线程不会立即释放锁。调用只会将wait中的线程从等待队列移到同步队列，也就是线程状态从waitting变为blocked;</li><li>从wait()方法返回的前提是线程重新获得了调用对象的锁。　　　　　　　　<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3></li></ol><p>停止一个线程的执行有三种办法：</p><ol><li>调用Thread对象的stop()方法，stop()和supend和resume已经被弃用</li><li>interrupt()配合isInterrupt()使用 上面的代码</li><li>使用volatile型共享变量</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 但是使用标志位这种方法有个很大的局限性，那就是通过循环来使每次的操作都需要检查一下标志位。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BestPractice</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> finished <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// ① volatile条件变量</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stopMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        finished <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ② 发出停止信号</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>finished<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ③ 检测条件变量</span>            <span class="token comment" spellcheck="true">// do dirty work   // ④业务代码</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="stop不推荐"><a href="#stop不推荐" class="headerlink" title="stop不推荐"></a>stop不推荐</h5><p>不少开发者用过Thread的stop去停止线程，当然此函数确实能停止线程，不过Java官方早已将它废弃，不推荐使用，这是为什么？</p><p>stop是通过立即抛出ThreadDeath异常，来达到停止线程的目的，此异常抛出有可能发生在任何一时间点，包括在catch、finally等语句块中，但是此异常并不会引起程序退出(笔者只测试了Java8)。<br>由于有异常抛出，导致线程会释放全部所持有的锁，极可能引起线程安全问题。</p><p>由于以上2点，stop这种方式停止线程是不安全的。</p><h3 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h3><ol><li><p>存在死锁的可能性 </p></li><li><p>有可能出现数据不一致的情况，因为数据可能被其他运行的线程更改．</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 暂停线程的方式 suspend() 已经不推荐使用这种方式* 恢复暂停线程的方式 resume()*/</span><span class="token keyword">class</span> <span class="token class-name">SuspendThreadTest</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Thread th3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">th</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>th3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     th3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">}</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>th3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"暂停"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 暂停线程</span>     th3<span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">}</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>th3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"恢复执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 恢复暂停线程</span>     th3<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 静态内部类</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">th</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"执行！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">try</span> <span class="token punctuation">{</span>                 Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抛出异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。</p><p><strong>java的内置锁：</strong> 每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><p>java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p><p><strong>java的对象锁和类锁：</strong> java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的</p><h4 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h4><p>synchronized关键字最主要有以下3种应用方式</p><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h5 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h5><p>当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><ul><li>内存可见性</li><li>留意复合类操作</li><li>解决num++操作的原子性问题</li><li>禁止指令重排序</li></ul><h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>　　volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。同synchronized相比（synchronized通常称为重量级锁），volatile更轻量级，相比使用synchronized所带来的庞大开销，倘若能恰当的合理的使用volatile，自然是美事一桩。</p><p><strong>所谓可见性，是指当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。</strong></p><h4 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h4><p>volatile还有一个特性：禁止指令重排序优化。</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则：</p><ol><li>重排序操作不会对存在数据依赖关系的操作进行重排序。</li></ol><p>　　　　比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><ol start="2"><li>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</li></ol><p>　　　　比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>　　重排序在单线程模式下是一定会保证最终结果的正确性，但是在多线程环境下，问题就出来了</p><p><strong>简单总结下，volatile是一种轻量级的同步机制，它主要有两个特性：一是保证共享变量对所有线程的可见性；二是禁止指令重排序优化。同时需要注意的是，volatile对于单个的共享变量的读/写具有原子性，但是像num++这种复合操作，volatile无法保证其原子性</strong></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><a href="https://www.cnblogs.com/xzwblog/p/7227509.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzwblog/p/7227509.html</a></p><p><a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="noopener">https://www.jianshu.com/p/98b68c97df9b</a></p><p>变量值的共享可以使用public static的形式，所有线程都使用同一个变量，如果想实现每一个线程都有自己的共享变量该如何实现呢？JDK中的ThreadLocal类正是为了解决这样的问题。</p><p>ThreadLocal底层相当于一个map数组，key用来存储当前线程，value用来存储当前线程下共享的数据。它里面有一些方法需要说明一下。</p><ul><li>get()方法用于获取当前线程的副本变量值。</li><li>set()方法用于保存当前线程的副本变量值。</li><li>initialValue()为当前线程初始副本变量值。</li><li>remove()方法移除当前前程的副本变量值。</li></ul><h4 id="ThreadLocal介绍-amp-跳出误区"><a href="#ThreadLocal介绍-amp-跳出误区" class="headerlink" title="ThreadLocal介绍&amp;跳出误区"></a>ThreadLocal介绍&amp;跳出误区</h4><p>　　ThreadLocal一般称为线程本地变量，它是一种特殊的线程绑定机制，将变量与线程绑定在一起，为每一个线程维护一个独立的变量副本。通过ThreadLocal可以将对象的可见范围限制在同一个线程内。</p><p><strong>跳出误区</strong></p><blockquote><p>需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p></blockquote><blockquote><p>没有ThreadLocal的时候，一个线程在其声明周期内，可能穿过多个层级，多个方法，如果有个对象需要在此线程周期内多次调用，且是跨层级的（线程内共享），通常的做法是通过参数进行传递；而ThreadLocal将变量绑定在线程上，在一个线程周期内，无论“你身处何地”，只需通过其提供的get方法就可轻松获取到对象。极大地提高了对于“线程级变量”的访问便利性。</p></blockquote><h4 id="解决第一个get-返回null"><a href="#解决第一个get-返回null" class="headerlink" title="解决第一个get()返回null"></a>解决第一个get()返回null</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" threadLocal.get() = "</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyThread myThreadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadA<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"ThreadA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MyThread myThreadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadB<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"ThreadB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        myThreadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre><code>ThreadA threadLocal.get() = 0ThreadB threadLocal.get() = 0ThreadA threadLocal.get() = 1ThreadB threadLocal.get() = 1ThreadA threadLocal.get() = 2ThreadB threadLocal.get() = 2</code></pre><h4 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h4><p>&nbsp; &nbsp; &nbsp; &nbsp;根据上面Entry方法的源码，我们知道ThreadLocalMap是使用ThreadLocal的弱引用作为Key的。下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/xc1.png" alt="xc"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value<br>永远无法回收，造成内存泄露。<br>　　<br>&nbsp; &nbsp; &nbsp; &nbsp;ThreadLocalMap设计时的对上面问题的对策：<br>ThreadLocalMap的getEntry函数的流程大概为：</p><p>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (table.length-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；<br>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry。否则，如果key值为null，则擦除该位置的Entry，并继续向下一个位置查询。在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的getEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。<br>关于ThreadLocalMap内部类的简单介绍</p><p><strong>初始容量16，负载因子2/3，解决冲突的方法是再hash法，也就是：在当前hash的基础上再自增一个常量。</strong></p><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p><a href="https://www.cnblogs.com/lucky_dai/p/5498295.html" target="_blank" rel="noopener">https://www.cnblogs.com/lucky_dai/p/5498295.html</a></p><p>从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。</p><p>既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。</p><h4 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h4><p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><p>1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p><p>2）线程执行发生异常，此时JVM会让线程自动释放锁。</p><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。</p><p>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>但是采用synchronized关键字来实现同步的话，就会导致一个问题：</p><p>如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。</p><p>因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><p>1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p><p>2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p><pre class=" language-java"><code class="language-java">通过查看Lock的源码可知，Lock是一个接口<span class="token punctuation">,</span> 位于：<span class="token keyword">package</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取锁，获取不到lock就不罢休,不可被打断,即使当前线程被中断,线程也一直阻塞,直到拿到锁, 比较无赖的做法</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/***获取锁，可中断，如果获取锁之前当前线程被interrupt了，*获取锁之后会抛出InterruptedException，并且停止当前线程；*优先响应中断*/</span><span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//立即返回结果；尝试获得锁,如果获得锁立即返回ture,失败立即返回false</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//尝试拿锁，可设置超时时间，超时返回false，即过时不候</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放锁</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回当前线程的Condition ，可多次调用</span>Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><pre class=" language-java"><code class="language-java">Lock lock <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//处理任务</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//释放锁</span><span class="token punctuation">}</span></code></pre><h4 id="Lock接口方法"><a href="#Lock接口方法" class="headerlink" title="Lock接口方法"></a>Lock接口方法</h4><h5 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h5><p>先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><h5 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h5><p>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//.....</span>    <span class="token punctuation">}</span>    <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。</p><p>因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p><p>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><h5 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h5><p>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><p>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁</p><pre class=" language-java"><code class="language-java">Lock lock <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">try</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//处理任务</span>     <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//释放锁</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果不能获取锁，则直接做其他事情</span><span class="token punctuation">}</span></code></pre><h5 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h5><p>解锁 一旦产生异常，没有解锁就会造成当前无法解锁，其他线程一直等待获取锁，<br>所以：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//处理任务</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span> lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//释放锁</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//如果不能获取锁，则直接做其他事情</span></code></pre><h5 id="newCondition"><a href="#newCondition" class="headerlink" title="newCondition()"></a>newCondition()</h5><pre class=" language-java"><code class="language-java">Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock中除了实现Lock中定义的一些标准函数外，同时提供其他的用于管理锁的public方法：</p><p><strong>默认是非公平锁的</strong></p><p><strong>ReentrantLock锁是完全排他锁,同一时间只有一个线程能执行lock.lock()和lock.unlock()之间的代码.</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//传入boolean值,true时create一个公平锁，false为非公平锁</span><span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//查看有多少线程等待锁</span><span class="token keyword">int</span> <span class="token function">getQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//是否有线程等待抢锁</span><span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//是否有指定线程等待抢锁</span><span class="token keyword">boolean</span> <span class="token function">hasQueuedThread</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//当前线程是否抢到锁。返回0代表没有</span><span class="token keyword">int</span> <span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//查询此锁是否由任何线程持有</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//是否为公平锁</span><span class="token keyword">boolean</span> <span class="token function">isFair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </code></pre><h5 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h5><p>ReentrantLock中另一个重要的应用就是Condition，Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒，而且在粒度和性能上都优于Object的通信方法（wait、notify 和 notifyAll）；</p><p>Condition 接口的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    *Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，    *允许中断如果在阻塞时锁持有线程中断，会抛出异常；    *重要一点是：在当前持有Lock的线程中，当外部调用会await()后，    *ReentrantLock就允许其他线程来抢夺锁当前锁，    *注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁    */</span>    <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span>    <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span>    <span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span>    <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//类似await(long time, TimeUnit unit) </span>    <span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span>Date deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//唤醒指定线程</span>    <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//唤醒全部线程</span>    <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>ReentrantLock.Condition的线程通信：</strong><br>ReentrantLock.Condition是在粒度和性能上都优于Object的notify()、wait()、notifyAll()线程通信的方式。</p><p>Condition中通信方法相对Object的通信在粒度上是粒度更细化，表现在一个Lock对象上引入多个Condition监视器、通信方法中除了和Object对应的三个基本函数外，更是新增了线程中断、阻塞超时的函数；<br>Condition中通信方法相对Object的通信在性能上更高效，性能的优化表现在ReentrantLock比较synchronized的优化 ；</p><blockquote><p>ReentrantLock.Condition线程通信注意点：<br>1.使用<strong>ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作</strong>[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；<br>2.注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;</p></blockquote><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>概述</p><p>&nbsp; &nbsp; &nbsp; &nbsp;ReentrantReadWriteLock是Lock的另一种实现方式，ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><p><strong>ReentrantReadWriteLock支持以下功能：</strong></p><p>　　　　1）支持公平和非公平的获取锁的方式；</p><p>　　　　2）支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁；</p><p>　　　　3）还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的；</p><p>　　　　4）读取锁和写入锁都支持锁获取期间的中断；</p><p>　　　　5）Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException。 </p><h4 id="Lock和synchronized的选择"><a href="#Lock和synchronized的选择" class="headerlink" title="Lock和synchronized的选择"></a>Lock和synchronized的选择</h4><p>总结来说，Lock和synchronized有以下几点不同：</p><p>1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>1.可重入性<br>ReentrantLock和synchronized都具有可重入性，写代码synchronized更简单，ReentrantLock需要将lock()和unlock()进行一一对应否则有死锁的风险；</p><p>2.锁的实现方式<br>Synchronized作为Java关键字是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</p><p>3.公平性<br>ReentrantLock提供了公平锁和非公平锁两种API，开发人员完全可以根据应用场景选择锁的公平性；<br>synchronized是作为Java关键字是依赖于JVM实现，Java团队应该是优先考虑性能问题，因此synchronized是非公平锁。</p><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><h4 id="ReentrantLock实际开发中的应用场景"><a href="#ReentrantLock实际开发中的应用场景" class="headerlink" title="ReentrantLock实际开发中的应用场景"></a>ReentrantLock实际开发中的应用场景</h4><ol><li><p>公平锁，线程排序执行，防饿死应用场景；<br>公平锁原则必须按照锁申请时间上先到先得的原则分配机制场景；</p><p> 1）. 实现逻辑 上(包括：软件中函数计算、业务先后流程；硬件中操作实现中顺序逻辑)的顺序排队机制的场景；<br> 软件场景：用户交互View中对用户输入结果分析类，分析过程后面算法依赖上一步结果的场景，例如：推荐算法实现[根据性别、年龄筛选]、阻塞队列的实现；<br> 硬件场景：需要先分析确认用户操作类型硬件版本或者厂家，然后发出操作指令；例如：自动售货机；</p><p> 2）.现实 生活中 时间排序的 公平原则：例如：客服分配，必须是先到先服务，不能出现饿死现象；</p></li><li><p>非公平锁,效率的体现者；<br>实际开发中最常用的的场景就是非公平锁，ReentrantLock无参构造默认就时候非公平锁；<br>适应场景除了上面公平锁中提到的其他都是非公平锁的使用场景；</p></li></ol><ol start="3"><li>ReentrantLock.Condition线程通信<br>ReentrantLock.Condition线程通信是最长见的面试题，这里以最简单例子：两个线程之间交替打印 26英文字母和阿拉伯数字为demo：</li></ol><pre><code>private void alternateTask() {    ReentrantLock lock = new ReentrantLock();    Condition condition1 = lock.newCondition();    Condition condition2 = lock.newCondition();    Thread thread1 = new Thread(() -&gt; {        try {            lock.lock();            for (int i = 65; i &lt; 91; i++) {                System.out.println("----------thread1------- " + (char) i);                condition2.signal();                condition1.await();            }            condition2.signal();        } catch (Exception e) {        } finally {            lock.unlock();        }    });    Thread thread2 = new Thread(() -&gt; {        try {            lock.lock();            for (int i = 0; i &lt; 26; i++) {                System.out.println("----------thread2------- " + i);                condition1.signal();                condition2.await();            }            condition1.signal();        } catch (Exception e) {        } finally {            lock.unlock();        }    });    thread1.start();    thread2.start();}</code></pre><p>4.同步功能的使用<br>实现线程同步锁synchronized 功能【单例为例】</p><pre><code>private Singleton() {}private static Singleton instance;private static Lock lock = new ReentrantLock();public static Singleton getInstance() {    lock.lock();    try {        if (instance == null) {            instance = new Singleton();        }    } finally {        lock.unlock();    }    return instance;}</code></pre><p>6.中断杀器应用<br>ReentrantLock中lockInterruptibly()和lock()最大的区别就是中断相应问题：<br>lock()是支持中断相应的阻塞试的获取方式，因此即使主动中断了锁的持有者，但是它不能立即unlock(),仍然要机械版执行完所有操作才会释放锁。<br>lockInterruptibly()是 优先响应中断的，这样有个优势就是可以通过tryLock()、tryLock(timeout, TimeUnit.SECONDS)方法，中断优先级低的Task，及时释放资源给优先级更高的Task，甚至看到网上有人说可以做防止死锁的优化；</p><p>实例代码：</p><pre><code>ReentrantLock lock = new ReentrantLock();    try {        lock.lockInterruptibly();        if (lock.tryLock(timeout, TimeUnit.SECONDS)) {            //TODO        }else{            //超时直接中断优先级低的Task            Thread.currentThread().interrupt();            lock.lock();            //TODO        }    } catch (InterruptedException e) {        e.printStackTrace();    } finally {</code></pre><p>7.非重要任务Lock使用<br>优先级较低的操作让步给优先级更高的操作，提示代码效率/用户体验；<br>忽略重复触发<br>1）.用在定时任务时，如果任务执行时间可能超过下次计划执行时间，确保该有状态任务只有一个正在执行，忽略重复触发。<br>2）.用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）。<br>以上两种情况多用于进行非重要任务防止重复执行，（如：清除无用临时文件，检查某些资源的可用性，数据备份操作等）<br>tryLock()功能：如果已经获得锁立即返回fale，起到防止重复而忽略的效果</p><pre><code>ReentrantLock lock = new ReentrantLock();//防止重复执行，执行耗时操作，例如用户重复点击if (lock.tryLock()) {   try {    //TO DO   } finally {     lock.unlock();   }}</code></pre><p>超时放弃<br>定时操作的例如：错误日志、定时过期缓存清理的操作，遇到优先级更高的操作占用资源时，暂时放弃本次操作下次再处理，可以起到让出CPU，提升用户体验；</p><pre><code>ReentrantLock lock = new ReentrantLock();try {    if (lock.tryLock(timeout, TimeUnit.SECONDS)) {        //TO DO    }} catch (InterruptedException e) {    e.printStackTrace();} finally {    lock.unlock();}</code></pre><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p><strong>公平锁：</strong> 是指多个线程竞争同一资源时[等待同一个锁时]，获取资源的顺序是按照申请锁的先后顺序的；公平锁保障了多线程下各线程获取锁的顺序，先到的线程优先获取锁，有点像早年买火车票一样排队早的人先买到火车票；<br>基本特点： 线程执行会严格按照顺序执行，等待锁的线程不会饿死，但 整体效率相对比较低；</p><p><strong>非公平锁：</strong> 是指多个线程竞争同一资源时，获取资源的顺序是不确定的，一般是抢占式的；非公平锁相对公平锁是增加了获取资源的不确定性，但是整体效率得以提升；<br>基本特点： 整体效率高，线程等待时间片具有不确定性；</p><p>公平锁与非公平锁的测试demo：<br>重入锁ReentrantLock实现公平锁和非公平锁很简单的，因为ReentrantLock构造函数中可以直接传入一个boolean值fair，对公平性进行设置。当fair为true时，表示此锁是公平的，当fair为false时，表示此锁是非公平的锁；<br>来个简单的demo；</p><pre><code>public static void main(String[] args) {    ExecutorService threadPool = Executors.newCachedThreadPool();    ReentrantLock fairLock = new ReentrantLock(true);    ReentrantLock unFairLock = new ReentrantLock();    for (int i = 0; i &lt; 10; i++) {        threadPool.submit(new TestThread(fairLock,i," fairLock"));        threadPool.submit(new TestThread(unFairLock, i, "unFairLock"));    }}</code></pre><h3 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h3><p><a href="https://www.cnblogs.com/liun1994/p/7396026.html" target="_blank" rel="noopener">https://www.cnblogs.com/liun1994/p/7396026.html</a></p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><a href="https://segmentfault.com/a/1190000014741369" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014741369</a><br><a href="https://blog.csdn.net/u013541140/article/details/95225769" target="_blank" rel="noopener">https://blog.csdn.net/u013541140/article/details/95225769</a></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc30.png" alt=""></p><h4 id="1-线程池的优势"><a href="#1-线程池的优势" class="headerlink" title="1 线程池的优势"></a>1 线程池的优势</h4><p>总体来说，线程池有如下的优势：</p><p>（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>（2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>（3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h3 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h3><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）</p><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><ul><li>线程池作用就是限制系统中执行线程的数量。 </li><li>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果。 </li><li>少了浪费了系统资源，多了造成系统拥挤效率不高。 </li><li>用线程池控制线程数量，其他线程排 队等候。 </li><li>一个任务执行完毕，再从队列的中取最前面的任务开始执行。 </li><li>若队列中没有等待进程，线程池的这一资源处于等待。 </li><li>当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。 </li></ul><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a>为什么要用线程池?</h3><ol><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 </li><li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<br>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 </li></ol><h3 id="比较重要的几个类"><a href="#比较重要的几个类" class="headerlink" title="比较重要的几个类"></a>比较重要的几个类</h3><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>ExecutorService</td><td>真正的线程池接口。</td></tr><tr><td>ScheduledExecutorService</td><td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td></tr><tr><td>ThreadPoolExecutor</td><td>ExecutorService的默认实现。</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td></tr></tbody></table><h3 id="Executor和Executors的区别？"><a href="#Executor和Executors的区别？" class="headerlink" title="Executor和Executors的区别？"></a>Executor和Executors的区别？</h3><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 </p><p>Executor 接口对象能执行我们的线程任务。 </p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p><p>使用ThreadPoolExecutor 可以创建自定义线程池。 </p><p>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。</p><h3 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h3><pre><code>public class TestNewThread {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println("start");            }        }).start();    }}</code></pre><p>执行一个异步任务你还只是如下new Thread吗？ </p><p>那你就out太多了，new Thread的弊端如下： </p><ol><li>每次new Thread新建对象性能差。 </li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li><li>缺乏更多功能，如定时执行、定期执行、线程中断。 </li></ol><p>相比new Thread，Java提供的四种线程池的好处在于： </p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 </li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h3 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h3><p>Java通过Executors提供四种线程池，分别为： </p><ol><li>newCachedThreadPoo<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </li><li>newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 </li><li>newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。 </li><li>newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><h3 id="Executors创建线程池"><a href="#Executors创建线程池" class="headerlink" title="Executors创建线程池"></a>Executors创建线程池</h3><p>Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可，比如Executors.newFixedThreadPool(int nThreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。</p><h4 id="线程池中的几种重要的参数"><a href="#线程池中的几种重要的参数" class="headerlink" title="线程池中的几种重要的参数"></a>线程池中的几种重要的参数</h4><p>corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收</p><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p><p>keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，</p><p>util，就是计算这个时间的一个单位。</p><p>workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。</p><p>threadFactory，就是创建线程的线程工厂。</p><p>handler,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</p><p>Executors创建线程池便捷方法列表：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>newFixedThreadPool(int nThreads)</td><td>创建固定大小的线程池</td></tr><tr><td>newSingleThreadExecutor()</td><td>创建只有一个线程的线程池</td></tr><tr><td>newCachedThreadPool()</td><td>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</td></tr></tbody></table><p><strong>小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用ThreadPoolExecutor的构造方法。没错，上述Executors方法创建的线程池就是ThreadPoolExecutor。</strong></p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法（定时任务使用的是ScheduledThreadPoolExecutor），该类构造方法参数列表如下：</p><pre><code>// Java线程池的完整构造函数public ThreadPoolExecutor(  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。  int maximumPoolSize, // 线程数的上限  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，                                     // 超过这个时间，多余的线程会被回收。  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列  ThreadFactory threadFactory, // 新线程的产生方式  RejectedExecutionHandler handler) // 拒绝策略</code></pre><p>竟然有7个参数，很无奈，构造一个线程池确实需要这么多参数。这些参数中，比较容易引起问题的有corePoolSize, maximumPoolSize, workQueue以及handler：</p><p>corePoolSize和maximumPoolSize设置不当会影响效率，甚至耗尽线程；<br>workQueue设置不当容易导致OOM；<br>handler设置不当会导致提交任务时抛出异常。<br>正确的参数设置方式会在下文给出。</p><p>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略</p><h5 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h5><p>当队列满时，此时便是饱和策略发挥作用的时候了，JDK中定义了四种饱和策略：</p><p>1、AbortPolicy：终止策略是默认的饱和策略，当队列满时，会抛出一个RejectExecutionException异常（第一段代码就是例子），客户可以捕获这个异常，根据需求编写自己的处理代码</p><p>2、DiscardPolicy：策略会悄悄抛弃该任务。</p><p>3、DiscardOldestPolicy：策略将会抛弃下一个将要执行的任务，如果此策略配合优先队列PriorityBlockingQueue，该策略将会抛弃优先级最高的任务</p><p>4、CallerRunsPolicy：调用者运行策略，该策略不会抛出异常，不会抛弃任务，而是将任务回退给调用者线程执行（调用execute方法的线程），由于任务需要执行一段时间，所以在此期间不能提交任务，从而使工作线程有时间执行正在执行的任务。</p><h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p><h4 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h4><p>可以向线程池提交的任务有两种：Runnable和Callable，二者的区别如下：</p><ol><li>方法签名不同，void Runnable.run(), V Callable.call() throws Exception</li><li>是否允许有返回值，Callable允许有返回值</li><li>是否允许抛出异常，Callable允许抛出异常。</li></ol><p>Callable是JDK1.5时加入的接口，作为Runnable的一种补充，允许有返回值，允许抛出异常。</p><p>三种提交任务的方式：<br>提交方式 |    是否关心返回结果<br>—|—<br>Future<t> submit(Callable<t> task) |    是<br>void execute(Runnable command) |    否<br>Future&lt;?&gt; submit(Runnable task)    | 否，虽然返回Future，但是其get()方法总是返回null</t></t></p><h4 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a>线程池都有哪几种工作队列</h4><p>1、ArrayBlockingQueue</p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、LinkedBlockingQueue</p><p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p><p>3、SynchronousQueue</p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、PriorityBlockingQueue</p><p>一个具有优先级的无限阻塞队列。</p><h3 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h3><p><strong>避免使用无界队列</strong></p><p>不要使用Executors.newXXXThreadPool()快捷方法创建线程池，因为这种方式会使用无界的任务队列，为避免OOM，我们应该使用ThreadPoolExecutor的构造方法手动指定队列的最大长度：</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512), // 使用有界队列，避免OOM                new ThreadPoolExecutor.DiscardPolicy());</code></pre><p>明确拒绝任务时的行为<br>任务队列总有占满的时候，这是再submit()提交新的任务会怎么样呢？RejectedExecutionHandler接口为我们提供了控制方式，接口定义如下：</p><pre><code>public interface RejectedExecutionHandler {    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);}</code></pre><table><thead><tr><th>拒绝策略</th><th>拒绝行为</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>抛出RejectedExecutionException</td></tr><tr><td>DiscardPolicy</td><td>什么也不做，直接忽略</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置</td></tr><tr><td>CallerRunsPolicy</td><td>直接由提交任务者执行这个任务</td></tr></tbody></table><p>线程池默认的拒绝行为是AbortPolicy，也就是抛出RejectedExecutionHandler异常，该异常是非受检异常，很容易忘记捕获。如果不关心任务被拒绝的事件，可以将拒绝策略设置成DiscardPolicy，这样多余的任务会悄悄的被忽略。</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512),                 new ThreadPoolExecutor.DiscardPolicy());// 指定拒绝策略</code></pre><h3 id="submit-和execute-的以及shutdown-和shutdownNow-的区别"><a href="#submit-和execute-的以及shutdown-和shutdownNow-的区别" class="headerlink" title="submit()和execute()的以及shutdown()和shutdownNow()的区别"></a>submit()和execute()的以及shutdown()和shutdownNow()的区别</h3><ul><li>submit()，提交一个线程任务，可以接受回调函数的返回值吗，适用于需要处理返回着或者异常的业务场景 </li><li>execute()，执行一个任务，没有返回值 </li><li>shutdown()，表示不再接受新任务，但不会强行终止已经提交或者正在执行中的任务 </li><li>shutdownNow()，对于尚未执行的任务全部取消，正在执行的任务全部发出interrupt()，停止执行 </li></ul><h3 id="五种线程池的适应场景"><a href="#五种线程池的适应场景" class="headerlink" title="五种线程池的适应场景"></a>五种线程池的适应场景</h3><ul><li>newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于服务器负载较轻，执行很多短期异步任务。 </li><li>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于可以预测线程数量的业务中，或者服务器负载较重，对当前线程数量进行限制。 </li><li>newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。 </li><li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。 </li><li>newWorkStealingPool：创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，适用于大耗时的操作，可以并行来执行</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池队列</title>
      <link href="/2019/10/21/2019-06-16-xian-cheng-chi-dui-lie/"/>
      <url>/2019/10/21/2019-06-16-xian-cheng-chi-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构</p><p>Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口。</p><h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><p>Java中对于队列的实现分为非阻塞和阻塞两种。</p><h4 id="非阻塞队列分为如下："><a href="#非阻塞队列分为如下：" class="headerlink" title="非阻塞队列分为如下："></a>非阻塞队列分为如下：</h4><ul><li>LinkedList</li></ul><p>LinkedList是双相链表结构，在添加和删除元素时具有比ArrayList更好的性能。但在 Get 与 Set 方面弱于ArrayList。当然，这些对比都是指数据量很大或者操作很频繁的情况下的对比。</p><ul><li>PriorityQueue</li></ul><p>PriorityQueue维护了一个有序列表，存储到队列中的元素会按照自然顺序排列。当然，我们也可以给它指定一个实现了 java.util.Comparator 接口的排序类来指定元素排列的顺序。</p><ul><li>ConcurrentLinkedQueue</li></ul><p>ConcurrentLinkedQueue 是基于链接节点的并且线程安全的队列。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大小 ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。</p><h4 id="阻塞队列分为如下："><a href="#阻塞队列分为如下：" class="headerlink" title="阻塞队列分为如下："></a>阻塞队列分为如下：</h4><p>阻塞队列定义在了java.util.concurrent包中，java.util.concurrent.BlockingQueue 继承了Queue接口，它有 5 个实现类，分别是：</p><ul><li>ArrayBlockingQueue </li></ul><p>一个内部由数组支持的有界队列。初始化时必须指定队列的容量，还可以设置内部的ReentrantLock是否使用公平锁。但是公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>它的思想就是如果BlockQueue是空的，那么从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒。同样,如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间才会被唤醒继续操作。</p><ul><li>LinkedBlockingQueue </li></ul><p>一个内部由链接节点支持的可选有界队列。初始化时不需要指定队列的容量，默认是Integer.MAX_VALUE，也可以看成容量无限大。此队列按 FIFO（先进先出）排序元素 。</p><ul><li>PriorityBlockingQueue </li></ul><p>一个内部由优先级堆支持的无界优先级队列。PriorityBlockingQueue是对 PriorityQueue的再次包装，队列中的元素按优先级顺序被移除。</p><ul><li>DelayQueue </li></ul><p>一个内部由优先级堆支持的、基于时间的调度队列。队列中存放Delayed元素，只有在延迟期满后才能从队列中提取元素。当一个元素的getDelay()方法返回值小于等于0时才能从队列中poll中元素，否则poll()方法会返回null。　　</p><ul><li>SynchronousQueue </li></ul><p>一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。</p><h4 id="队列常用方法"><a href="#队列常用方法" class="headerlink" title="队列常用方法"></a>队列常用方法</h4><p>add　　　　添加一个元素　　　　　　　　如果队列已满，抛出一个IllegalStateException（“Queue full”）异常</p><p>offer　　　  添加一个元素并返回true　　    如果队列已满，则返回false</p><p>put　　　　添加一个元素　　　　　　　　 如果队列已满，则阻塞</p><p>remove　　 移除并返回队列头部的元素　　如果队列为空，则抛出一个NoSuchElementException异常</p><p>element　　返回队列头部的元素　　　　　如果队列为空，则抛出一个NoSuchElementException异常</p><p>take　　　　移除并返回队列头部的元素　　如果队列为空，则阻塞　　</p><p>peek　　　  返回队列头部的元素　　　　   如果队列为空，则返回null</p><p>poll　　　　移除并返回队列头部的元素　　如果队列为空，则返回null</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><a href="https://www.cnblogs.com/CarpenterLee/p/9558026.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/9558026.html</a><br><a href="https://blog.csdn.net/achuo/article/details/80623893" target="_blank" rel="noopener">https://blog.csdn.net/achuo/article/details/80623893</a></p><h3 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h3><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>如果每个请求都创建一个线程去处理，那么服务器的资源很快就会被耗尽，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><h3 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h3><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）</p><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><ul><li>线程池作用就是限制系统中执行线程的数量。 </li><li>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果。 </li><li>少了浪费了系统资源，多了造成系统拥挤效率不高。 </li><li>用线程池控制线程数量，其他线程排 队等候。 </li><li>一个任务执行完毕，再从队列的中取最前面的任务开始执行。 </li><li>若队列中没有等待进程，线程池的这一资源处于等待。 </li><li>当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。 </li></ul><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池?"></a>为什么要用线程池?</h3><ol><li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 </li><li>可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<br>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 </li></ol><h3 id="比较重要的几个类"><a href="#比较重要的几个类" class="headerlink" title="比较重要的几个类"></a>比较重要的几个类</h3><table><thead><tr><th>类</th><th>描述</th></tr></thead><tbody><tr><td>ExecutorService</td><td>真正的线程池接口。</td></tr><tr><td>ScheduledExecutorService</td><td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td></tr><tr><td>ThreadPoolExecutor</td><td>ExecutorService的默认实现。</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td></tr></tbody></table><h3 id="Executor和Executors的区别？"><a href="#Executor和Executors的区别？" class="headerlink" title="Executor和Executors的区别？"></a>Executor和Executors的区别？</h3><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 </p><p>Executor 接口对象能执行我们的线程任务。 </p><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 </p><p>使用ThreadPoolExecutor 可以创建自定义线程池。 </p><p>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。</p><h3 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h3><pre><code>public class TestNewThread {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println("start");            }        }).start();    }}</code></pre><p>执行一个异步任务你还只是如下new Thread吗？ </p><p>那你就out太多了，new Thread的弊端如下： </p><ol><li>每次new Thread新建对象性能差。 </li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 </li><li>缺乏更多功能，如定时执行、定期执行、线程中断。 </li></ol><p>相比new Thread，Java提供的四种线程池的好处在于： </p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。 </li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 </li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h3 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h3><p>Java通过Executors提供四种线程池，分别为： </p><ol><li>newCachedThreadPoo<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 </li><li>newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 </li><li>newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。 </li><li>newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><h3 id="Executors创建线程池"><a href="#Executors创建线程池" class="headerlink" title="Executors创建线程池"></a>Executors创建线程池</h3><p>Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可，比如Executors.newFixedThreadPool(int nThreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。</p><h4 id="线程池中的几种重要的参数"><a href="#线程池中的几种重要的参数" class="headerlink" title="线程池中的几种重要的参数"></a>线程池中的几种重要的参数</h4><p>corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收</p><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p><p>keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，</p><p>util，就是计算这个时间的一个单位。</p><p>workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。</p><p>threadFactory，就是创建线程的线程工厂。</p><p>handler,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</p><p>Executors创建线程池便捷方法列表：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>newFixedThreadPool(int nThreads)</td><td>创建固定大小的线程池</td></tr><tr><td>newSingleThreadExecutor()</td><td>创建只有一个线程的线程池</td></tr><tr><td>newCachedThreadPool()</td><td>创建一个不限线程数上限的线程池，任何提交的任务都将立即执行</td></tr></tbody></table><p><strong>小程序使用这些快捷方法没什么问题，对于服务端需要长期运行的程序，创建线程池应该直接使用ThreadPoolExecutor的构造方法。没错，上述Executors方法创建的线程池就是ThreadPoolExecutor。</strong></p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法（定时任务使用的是ScheduledThreadPoolExecutor），该类构造方法参数列表如下：</p><pre><code>// Java线程池的完整构造函数public ThreadPoolExecutor(  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。  int maximumPoolSize, // 线程数的上限  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，                                     // 超过这个时间，多余的线程会被回收。  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列  ThreadFactory threadFactory, // 新线程的产生方式  RejectedExecutionHandler handler) // 拒绝策略</code></pre><p>竟然有7个参数，很无奈，构造一个线程池确实需要这么多参数。这些参数中，比较容易引起问题的有corePoolSize, maximumPoolSize, workQueue以及handler：</p><p>corePoolSize和maximumPoolSize设置不当会影响效率，甚至耗尽线程；<br>workQueue设置不当容易导致OOM；<br>handler设置不当会导致提交任务时抛出异常。<br>正确的参数设置方式会在下文给出。</p><p>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略</p><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>当队列满时，此时便是饱和策略发挥作用的时候了，JDK中定义了四种饱和策略：</p><p>1、AbortPolicy：终止策略是默认的饱和策略，当队列满时，会抛出一个RejectExecutionException异常（第一段代码就是例子），客户可以捕获这个异常，根据需求编写自己的处理代码</p><p>AbortPolicy（中止策略）</p><pre><code>    public static class AbortPolicy implements RejectedExecutionHandler {        public AbortPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            throw new RejectedExecutionException("Task " + r.toString() +                                                 " rejected from " +                                                 e.toString());        }    }</code></pre><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程<br>使用场景：这个就没有特殊的场景了，但是一点要正确处理抛出的异常。ThreadPoolExecutor 中默认的策略就是AbortPolicy，ExecutorService 接口的系列 ThreadPoolExecutor 因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService 中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><p>2、DiscardPolicy：策略会悄悄抛弃该任务。</p><p>DiscardPolicy（丢弃策略）</p><pre><code>    public static class DiscardPolicy implements RejectedExecutionHandler {        public DiscardPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        }    }</code></pre><p>功能：直接静悄悄的丢弃这个任务，不触发任何动作<br>使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了</p><p>3、DiscardOldestPolicy：策略将会抛弃下一个将要执行的任务，如果此策略配合优先队列PriorityBlockingQueue，该策略将会抛弃优先级最高的任务</p><p>DiscardOldestPolicy（弃老策略）</p><pre><code>    public static class DiscardOldestPolicy implements RejectedExecutionHandler {        public DiscardOldestPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            if (!e.isShutdown()) {                e.getQueue().poll();                e.execute(r);            }        }    }</code></pre><p>功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行<br>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，我能想到的场景就是，发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较</p><p>4、CallerRunsPolicy：调用者运行策略，该策略不会抛出异常，不会抛弃任务，而是将任务回退给调用者线程执行（调用execute方法的线程），由于任务需要执行一段时间，所以在此期间不能提交任务，从而使工作线程有时间执行正在执行的任务。</p><p>CallerRunsPolicy（调用者运行策略）</p><pre><code>    public static class CallerRunsPolicy implements RejectedExecutionHandler {        public CallerRunsPolicy() { }        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {            if (!e.isShutdown()) {                r.run();            }        }    }</code></pre><p>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。<br>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p><p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程<br>使用场景：这个就没有特殊的场景了，但是一点要正确处理抛出的异常。ThreadPoolExecutor 中默认的策略就是AbortPolicy，ExecutorService 接口的系列 ThreadPoolExecutor 因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService 中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><h4 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h4><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p><h4 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h4><p>可以向线程池提交的任务有两种：Runnable和Callable，二者的区别如下：</p><ol><li>方法签名不同，void Runnable.run(), V Callable.call() throws Exception</li><li>是否允许有返回值，Callable允许有返回值</li><li>是否允许抛出异常，Callable允许抛出异常。</li></ol><p>Callable是JDK1.5时加入的接口，作为Runnable的一种补充，允许有返回值，允许抛出异常。</p><p>三种提交任务的方式：<br>提交方式 |    是否关心返回结果<br>—|—<br>Future<t> submit(Callable<t> task) |    是<br>void execute(Runnable command) |    否<br>Future&lt;?&gt; submit(Runnable task)    | 否，虽然返回Future，但是其get()方法总是返回null</t></t></p><h4 id="线程池都有哪几种工作队列"><a href="#线程池都有哪几种工作队列" class="headerlink" title="线程池都有哪几种工作队列"></a>线程池都有哪几种工作队列</h4><p>1、ArrayBlockingQueue</p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、LinkedBlockingQueue</p><p>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p><p>3、SynchronousQueue</p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、PriorityBlockingQueue</p><p>一个具有优先级的无限阻塞队列。</p><h3 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h3><p><strong>避免使用无界队列</strong></p><p>不要使用Executors.newXXXThreadPool()快捷方法创建线程池，因为这种方式会使用无界的任务队列，为避免OOM，我们应该使用ThreadPoolExecutor的构造方法手动指定队列的最大长度：</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512), // 使用有界队列，避免OOM                new ThreadPoolExecutor.DiscardPolicy());</code></pre><p>明确拒绝任务时的行为<br>任务队列总有占满的时候，这是再submit()提交新的任务会怎么样呢？RejectedExecutionHandler接口为我们提供了控制方式，接口定义如下：</p><pre><code>public interface RejectedExecutionHandler {    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);}</code></pre><table><thead><tr><th>拒绝策略</th><th>拒绝行为</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>抛出RejectedExecutionException</td></tr><tr><td>DiscardPolicy</td><td>什么也不做，直接忽略</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置</td></tr><tr><td>CallerRunsPolicy</td><td>直接由提交任务者执行这个任务</td></tr></tbody></table><p>线程池默认的拒绝行为是AbortPolicy，也就是抛出RejectedExecutionHandler异常，该异常是非受检异常，很容易忘记捕获。如果不关心任务被拒绝的事件，可以将拒绝策略设置成DiscardPolicy，这样多余的任务会悄悄的被忽略。</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512),                 new ThreadPoolExecutor.DiscardPolicy());// 指定拒绝策略</code></pre><h3 id="submit-和execute-的以及shutdown-和shutdownNow-的区别"><a href="#submit-和execute-的以及shutdown-和shutdownNow-的区别" class="headerlink" title="submit()和execute()的以及shutdown()和shutdownNow()的区别"></a>submit()和execute()的以及shutdown()和shutdownNow()的区别</h3><ul><li>submit()，提交一个线程任务，可以接受回调函数的返回值吗，适用于需要处理返回着或者异常的业务场景 </li><li>execute()，执行一个任务，没有返回值 </li><li>shutdown()，表示不再接受新任务，但不会强行终止已经提交或者正在执行中的任务 </li><li>shutdownNow()，对于尚未执行的任务全部取消，正在执行的任务全部发出interrupt()，停止执行 </li></ul><h3 id="五种线程池的适应场景"><a href="#五种线程池的适应场景" class="headerlink" title="五种线程池的适应场景"></a>五种线程池的适应场景</h3><ul><li>newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于服务器负载较轻，执行很多短期异步任务。 </li><li>newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于可以预测线程数量的业务中，或者服务器负载较重，对当前线程数量进行限制。 </li><li>newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。 </li><li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。 </li><li>newWorkStealingPool：创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，适用于大耗时的操作，可以并行来执行</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 线程池队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引</title>
      <link href="/2019/10/21/2019-06-16-mysql-suo-yin/"/>
      <url>/2019/10/21/2019-06-16-mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<p>看了很多关于索引的博客，讲的大同小异。但是始终没有让我明白关于索引的一些概念，如B-Tree索引，Hash索引，唯一索引….或许有很多人和我一样，没搞清楚概念就开始研究B-Tree，B+Tree等结构，导致在面试的时候答非所问！</p><h3 id="一、索引是什么"><a href="#一、索引是什么" class="headerlink" title="一、索引是什么?"></a>一、索引是什么?</h3><p>索引是帮助MySQL高效获取数据的数据结构。</p><h3 id="二、索引能干什么"><a href="#二、索引能干什么" class="headerlink" title="二、索引能干什么?"></a>二、索引能干什么?</h3><p>索引非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。 索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。</p><h3 id="三、索引的分类"><a href="#三、索引的分类" class="headerlink" title="三、索引的分类?"></a>三、索引的分类?</h3><p>1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，</p><p>2、从应用层次来分：普通索引，唯一索引，复合索引</p><p>3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</p><p>平时讲的索引类型一般是指在应用层次的划分。</p><p>就像手机分类：安卓手机，IOS手机 与 华为手机，苹果手机，OPPO手机一样。</p><p><strong>普通索引**</strong>：**即一个索引只包含单个列，一个表可以有多个单列索引</p><p><strong>唯一索引</strong>：****索引列的值必须唯一，但允许有空值</p><p><strong>复合索引</strong>：****多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p><p><strong>聚簇索引(聚集索引)</strong>：****并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</p><p><strong>非聚簇索引</strong>：****不是聚簇索引，就是非聚簇索引</p><h3 id="四、索引的底层实现"><a href="#四、索引的底层实现" class="headerlink" title="四、索引的底层实现"></a>四、索引的底层实现</h3><p>mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引，对于频繁访问的表，innodb会透明建立自适应hash索引，即在B树索引基础上建立hash索引，可以显著提高查找效率，对于客户端是透明的，不可控制的，隐式的。</p><blockquote><p>不谈存储引擎，只讨论实现(抽象)</p></blockquote><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql1.png" alt=""></p><h4 id="B-Tree索引（MySQL使用B-Tree）"><a href="#B-Tree索引（MySQL使用B-Tree）" class="headerlink" title="B-Tree索引（MySQL使用B+Tree）"></a>B-Tree索引（MySQL使用B+Tree）</h4><p>B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql2.png" alt=""></p><p>B+Tree索引</p><p>是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql3.png" alt=""></p><blockquote><p>结合存储引擎来讨论（一般默认使用B+Tree）</p></blockquote><p>案例：假设有一张学生表，id为主键</p><table><thead><tr><th>id</th><th>name</th><th>birthday</th></tr></thead><tbody><tr><td>1</td><td>Tom</td><td>1996-01-01</td></tr><tr><td>2</td><td>Jann</td><td>1996-01-04</td></tr><tr><td>3</td><td>Ray</td><td>1996-01-08</td></tr><tr><td>4</td><td>Michael</td><td>1996-01-10</td></tr><tr><td>5</td><td>Jack</td><td>1996-01-13</td></tr><tr><td>6</td><td>Steven</td><td>1996-01-23</td></tr><tr><td>7</td><td>Lily</td><td>1996-01-25</td></tr></tbody></table><p><strong>在MyISAM引擎中的实现</strong>（二级索引也是这样实现的）</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql4.jpg" alt=""></p><p>在InnoDB中的实现</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql5.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql6.jpg" alt=""></p><h3 id="五、为什么索引结构默认使用B-Tree，而不是Hash，二叉树，红黑树？"><a href="#五、为什么索引结构默认使用B-Tree，而不是Hash，二叉树，红黑树？" class="headerlink" title="五、为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？"></a>五、为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？</h3><p>B+tree：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p><p>Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。</p><p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p><p>红黑树：树的高度随着数据量增加而增加，IO代价高。</p><h3 id="六、为什么官方建议使用自增长主键作为索引？"><a href="#六、为什么官方建议使用自增长主键作为索引？" class="headerlink" title="六、为什么官方建议使用自增长主键作为索引？"></a>六、为什么官方建议使用自增长主键作为索引？</h3><p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。</p><p>插入连续的数据：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql7.gif" alt=""></p><p>插入非连续的数据</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mysql8.gif" alt=""></p><h3 id="七、简单总结下"><a href="#七、简单总结下" class="headerlink" title="七、简单总结下"></a>七、简单总结下</h3><p>1、MySQL使用B+Tree作为索引数据结构。 2、B+Tree在新增数据时，会根据索引指定列的值对旧的B+Tree做调整。 4、从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。 5、影响MySQL查找性能的主要还是磁盘IO次数，大部分是磁头移动到指定磁道的时间花费。 6、MyISAM存储引擎下索引和数据存储是分离的，InnoDB索引和数据存储在一起。 7、InnoDB存储引擎下索引的实现，(辅助索引)全部是依赖于主索引建立的(辅助索引中叶子结点存储的并不是数据的地址，还是主索引的值，因此，所有依赖于辅助索引的都是先根据辅助索引查到主索引，再根据主索引查数据的地址)。 8、由于InnoDB索引的特性，因此如果主索引不是自增的(id作主键)，那么每次插入新的数据，都很可能对B+Tree的主索引进行重整，影响性能。因此，尽量以自增id作为InnoDB的主索引。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven笔记</title>
      <link href="/2019/10/21/2019-06-16-maven-bi-ji/"/>
      <url>/2019/10/21/2019-06-16-maven-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h3 id="一、为什么使用-Maven-这样的构建工具【why】"><a href="#一、为什么使用-Maven-这样的构建工具【why】" class="headerlink" title="一、为什么使用 Maven 这样的构建工具【why】"></a>一、为什么使用 Maven 这样的构建工具【why】</h3><p><strong>① 一个项目就是一个工程</strong></p><p>如果项目非常庞大，就不适合使用 package 来划分模块，最好是每一个模块对应一个工程，利于分工协作。借助于 maven 就可以将一个项目拆分成多个工程</p><p><strong>② 项目中使用 jar 包，需要“复制”、“粘贴”项目的 lib 中</strong></p><p>同样的 jar 包重复的出现在不同的项目工程中，你需要做不停的复制粘贴的重复工作。借助于 maven，可以将 jar 包保存在“仓库”中，不管在哪个项目只要使用引用即可就行。</p><p><strong>③ jar 包需要的时候每次都要自己准备好或到官网下载</strong></p><p>借助于 maven 我们可以使用统一的规范方式下载 jar 包，规范</p><p><strong>④ jar 包版本不一致的风险</strong></p><p>不同的项目在使用 jar 包的时候，有可能会导致各个项目的 jar 包版本不一致，导致未执行错误。借助于 maven，所有的 jar 包都放在“仓库”中，所有的项目都使用仓库的一份 jar 包。</p><p><strong>⑤ 一个 jar 包依赖其他的 jar 包需要自己手动的加入到项目中</strong></p><p>FileUpload 组件-&gt;IO 组件，commons-fileupload-1.3.jar 依赖于 commons-io-2.0.1.jar</p><p>极大的浪费了我们导入包的时间成本，也极大的增加了学习成本。借助于 maven，它会自动的将依赖的 jar 包导入进来。</p><h3 id="二、maven-是什么【what】"><a href="#二、maven-是什么【what】" class="headerlink" title="二、maven 是什么【what】"></a>二、maven 是什么【what】</h3><p><strong>① maven 是一款服务于 java 平台的自动化构建工具</strong></p><p>make-&gt;Ant-&gt;Maven-&gt;Gradle</p><p>名字叫法：我们可以叫妹文也可以叫麦文，但是没有叫妈文的。</p><p><strong>② 构建</strong></p><p>构建定义：把动态的 Web 工程经过编译得到的编译结果部署到服务器上的整个过程。</p><p>编译：java 源文件[.java]-&gt;编译-&gt;Classz 字节码文件[.class]</p><p>部署：最终在 sevlet 容器中部署的不是动态 web 工程，而是编译后的文件</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv1.png" alt="image"></p><p><strong>③ 构建的各个环节</strong></p><ul><li><p>清理 clean：将以前编译得到的旧文件 class 字节码文件删除</p></li><li><p>编译 compile：将 java 源程序编译成 class 字节码文件</p></li><li><p>测试 test：自动测试，自动调用 junit 程序</p></li><li><p>报告 report：测试程序执行的结果</p></li><li><p>打包 package：动态 Web 工程打 War 包，java 工程打 jar 包</p></li><li><p>安装 install：Maven 特定的概念—–将打包得到的文件复制到“仓库”中的指定位置</p></li><li><p>部署 deploy：将动态 Web 工程生成的 war 包复制到 Servlet 容器下，使其可以运行</p></li></ul><h3 id="三、安装-maven"><a href="#三、安装-maven" class="headerlink" title="三、安装 maven"></a>三、安装 maven</h3><p>① 当前系统是否配置 JAVA_HOME 的环境变量</p><p>② 下载 maven，解压 maven 放在一个非中文无空格的路径下</p><p>③ 配置 maven 的相关环境变量</p><ul><li><p>在环境变量增加 M2_HOME，路径是 maven 解压后的根目录</p></li><li><p>在环境变量里的 path 中增加 maven/bin 的目录</p></li></ul><p>④ 验证：maven -v 查看 maven 版本</p><p>看到版本信息，恭喜你已经 OK 了。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv2.png" alt="image"></p><h3 id="四、第一个-maven"><a href="#四、第一个-maven" class="headerlink" title="四、第一个 maven"></a>四、第一个 maven</h3><p><strong>① 创建约定的目录结构</strong>（maven 工程必须按照约定的目录结构创建）</p><blockquote><p>根目录：工程名<br>|—src：源码<br>|—|—main:存放主程序<br>|—|—|—java：java 源码文件<br>|—|—|—resource：存放框架的配置文件<br>|—|—test：存放测试程序<br>|—pop.xml：maven 的核心配置文件</p></blockquote><p>我们按照上面的文件夹目录结构手动创建一下，不用任何 IDE 环境（手动的其实最有助于我们理解 maven）</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv3.png" alt="image"></p><h4 id="文件内容如下"><a href="#文件内容如下" class="headerlink" title="文件内容如下"></a>文件内容如下</h4><p>在 src/main/java/com/hzg/maven 目录下新建文件 Hello.java，内容如下</p><pre><code>package com.hzg.maven;public class Hello {　　public String sayHello(String name){　　　　return "Hello "+name+"!";　　}}</code></pre><p>POM 文件内容：</p><pre><code>&lt;?xml version="1.0" ?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.hzg.maven&lt;/groupId&gt;    &lt;artifactId&gt;Hello&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;Hello&lt;/name&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.0&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p><strong>②  常用 maven 命令</strong></p><ul><li><p>mvn clean：清理</p></li><li><p>mvn compile：编译主程序</p></li><li><p>mvn test-compile：编译测试程序</p></li><li><p>mvn test：执行测试</p></li><li><p>mvn package：打包</p></li><li><p>mvn install：安装</p></li></ul><p><strong>执行 maven 命令必须进入到 pom.xml 的目录中进行执行</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv4.png" alt="image"></p><p>进入到项目的 pom.xml 目录之后，就可以执行啦。</p><p><strong>1、运行 mvn compile</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv5.png" alt="image"></p><p>OK，运行完毕，你在 pom.xml 配置的依赖的包已经导入到仓库了，问题来了，<strong>仓库默认的位置在哪？</strong></p><p><strong>仓库的默认位置：</strong>c:\Usrs[登录当前系统的用户名].m2\repository</p><p>刚才执行完 compile 之后，之前的文件夹发生了变化</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv6.png" alt="image"></p><p>我们发现 Hello 项目里里多了一个 target 文件夹。文件夹的内容为：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv7.png" alt="image"></p><p>发现 target 里主要存放的就是编译后的字节码文件</p><p><strong>2、运行 mvn test-compile</strong>，target 文件夹下面除了 classes 之外多了 test-classes 文件夹</p><p><strong>3、运行 mvn package</strong>，target 文件夹下面又多了一个打好的 jar 包</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv8.png" alt="image"></p><p>4、运行 mvn clean，发现整个 target 文件夹都没了。又回到了编译之前我们手动创建的文件夹</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv9.png" alt="image"></p><h3 id="五、仓库和坐标"><a href="#五、仓库和坐标" class="headerlink" title="五、仓库和坐标"></a>五、仓库和坐标</h3><p><strong>①pom.xml：</strong><br>Project Object Model 项目对象模型。它是 maven 的核心配置文件，所有的构建的配置都在这里设置。</p><p><strong>② 坐标：</strong> 使用下面的三个向量在仓库中唯一的定位一个 maven 工程</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv10.png" alt="image"></p><p><strong>③ maven 工程的坐标与仓库中路径的关系：</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv11.png" alt="image"></p><p>maven 坐标和仓库对应的映射关系：[groupId][artifactId][version][artifactId]-[version].jar</p><p>去本地仓库看一下此目录：org\springframework\spring-core\4.3.4.RELEASE\spring-core-4.3.4.RELEASE.jar</p><p>果然是完全对应的（默认仓库地址上面说过了哦，不要说不知道在哪，没事下面我们再说一下仓库）</p><p><strong>④ 仓库</strong></p><p>仓库的分类：</p><p><strong>1、本地仓库：</strong> 当前电脑上的仓库，路径上已经说过了哦</p><p><strong>2、远程仓库：</strong></p><ul><li><p>私服：搭建在局域网中，一般公司都会有私服，私服一般使用 nexus 来搭建。具体搭建过程可以查询其他资料</p></li><li><p>中央仓库：架设在 Internet 上，像刚才的 springframework 就是在中央仓库上</p></li></ul><h3 id="六、依赖"><a href="#六、依赖" class="headerlink" title="六、依赖"></a>六、依赖</h3><p><strong>① maven 解析依赖信息时会到本地仓库中取查找被依赖的 jar 包</strong></p><ul><li><p>对于本地仓库中没有的会去中央仓库去查找 maven 坐标来获取 jar 包，获取到 jar 之后会下载到本地仓库</p></li><li><p>对于中央仓库也找不到依赖的 jar 包的时候，就会编译失败了</p></li></ul><p><strong>② 如果依赖的是自己或者团队开发的 maven 工程，需要先使用 install 命令把被依赖的 maven 工程的 jar 包导入到本地仓库中</strong></p><p>举例：现在我再创建第二个 maven 工程 HelloFriend，其中用到了第一个 Hello 工程里类的 sayHello(String name)方法。我们在给 HelloFriend 项目使用 mvn compile 命令进行编译的时候，会提示缺少依赖 Hello 的 jar 包。怎么办呢？</p><p>到第一个 maven 工程中执行 mvn install 后，你再去看一下本地仓库，你会发现有了 Hello 项目的 jar 包。一旦本地仓库有了依赖的 maven 工程的 jar 包后，你再到 HelloFriend 项目中使用 mvn compile 命令的时候，可以成功编译</p><p><strong>③ 依赖范围</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv12.png" alt="image"></p><p><em>scope 就是依赖的范围</em></p><p><strong>1、compile，</strong> 默认值，适用于所有阶段（开发、测试、部署、运行），本 jar 会一直存在所有阶段。</p><p><strong>2、provided，</strong> 只在开发、测试阶段使用，目的是不让 Servlet 容器和你本地仓库的 jar 包冲突 。如 servlet.jar。</p><p><strong>3、runtime，</strong> 只在运行时使用，如 JDBC 驱动，适用运行和测试阶段。</p><p><strong>4、test，</strong> 只在测试时使用，用于编译和运行测试代码。不会随项目发布。</p><p><strong>5、system，</strong> 类似 provided，需要显式提供包含依赖的 jar，Maven 不会在 Repository 中查找它。</p><h3 id="七、生命周期"><a href="#七、生命周期" class="headerlink" title="七、生命周期　　"></a>七、生命周期　　</h3><p>Maven 有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，初学者容易将 Maven 的生命周期看成一个整体，其实不然。这三套生命周期分别是：</p><p><strong>① Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</strong> Clean 生命周期一共包含了三个阶段：</p><ul><li><p>pre-clean 执行一些需要在 clean 之前完成的工作</p></li><li><p>clean 移除所有上一次构建生成的文件</p></li><li><p>post-clean 执行一些需要在 clean 之后立刻完成的工作</p></li></ul><p><strong>② Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。</strong></p><ul><li><p>validate</p></li><li><p>generate-sources</p></li><li><p>process-sources</p></li><li><p>generate-resources</p></li><li><p>process-resources 复制并处理资源文件，至目标目录，准备打包</p></li><li><p>compile 编译项目的源代码</p></li><li><p>process-classes</p></li><li><p>generate-test-sources</p></li><li><p>process-test-sources</p></li><li><p>generate-test-resources</p></li><li><p>process-test-resources 复制并处理资源文件，至目标测试目录</p></li><li><p>test-compile 编译测试源代码</p></li><li><p>process-test-classes</p></li><li><p>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署</p></li><li><p>prepare-package</p></li><li><p>package 接受编译好的代码，打包成可发布的格式，如 JAR</p></li><li><p>pre-integration-test</p></li><li><p>integration-test</p></li><li><p>post-integration-test</p></li><li><p>verify</p></li><li><p>install 将包安装至本地仓库，以让其它项目依赖。</p></li><li><p>deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享</p></li></ul><p>那我们在 Hello 的项目中执行 mvn install 命令，通过日志看看中间经历了什么？</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv13.png" alt="image"></p><p>通过日志我们发现，其实执行 mvn install，其中已经执行了 compile 和 test 。</p><p><strong>总结：</strong> 不论你要执行生命周期的哪一个阶段，maven 都是从这个生命周期的开始执行</p><p><strong>插件：</strong> 每个阶段都有插件（plugin），看上面标红的。插件的职责就是执行它对应的命令。</p><p><strong>③ Site Lifecycle 生成项目报告，站点，发布站点。</strong></p><ul><li><p>pre-site 执行一些需要在生成站点文档之前完成的工作</p></li><li><p>site 生成项目的站点文档</p></li><li><p>post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p></li><li><p>site-deploy 将生成的站点文档部署到特定的服务器上</p></li></ul><h3 id="八、maven-工程的依赖高级特性"><a href="#八、maven-工程的依赖高级特性" class="headerlink" title="八、maven 工程的依赖高级特性"></a>八、maven 工程的依赖高级特性</h3><p><strong>① 依赖的传递性</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv14.png" alt="image"></p><p>WebMavenDemo 项目依赖 JavaMavenService1 JavaMavenService1 项目依赖 JavaMavenService2</p><p>pom.xml 文件配置好依赖关系后，必须首先 mvn install 后，依赖的 jar 包才能使用。</p><ul><li><p>WebMavenDemo 的 pom.xml 文件想能编译通过，JavaMavenService1 必须 mvn install</p></li><li><p>JavaMavenService 的 pom.xml 文件想能编译通过，JavaMavenService2 必须 mvn install</p></li></ul><p><strong>传递性：</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv15.png" alt="image"></p><p>在 Eclipse 中，为 JavaMavenService2 中增加了一个 spring-core.jar 包后，会惊喜的发现依赖的两个项目都自动的增加了这个 jar 包，这就是依赖的传递性。</p><blockquote><p>注意：非 compile 范围的依赖是不能传递的。</p></blockquote><p><strong>② 依赖版本的原则：</strong></p><p><strong>1、路径最短者优先原则</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv16.png" alt="image"></p><p>Service2 的 log4j 的版本是 1.2.7 版本，Service1 排除了此包的依赖，自己加了一个 Log4j 的 1.2.9 的版本，那么 WebMavenDemo 项目遵守路径最短优先原则，Log4j 的版本和 Sercive1 的版本一致。</p><p><strong>2、路径相同先声明优先原则</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv17.png" alt="image"></p><p>这种场景依赖关系发生了变化，WebMavenDemo 项目依赖 Sercive1 和 Service2，它俩是同一个路径，那么谁在 WebMavenDemo 的 pom.xml 中先声明的依赖就用谁的版本。</p><p><strong>③ 统一管理依赖的版本：</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv18.png" alt="image"></p><p>为了统一管理版本号，可以使用 properties 标签，里面可以自定义版本的标签名。在使用的地方使用${自定义标签名}</p><h3 id="十、build-配置"><a href="#十、build-配置" class="headerlink" title="十、build 配置"></a>十、build 配置</h3><pre><code>&lt;build&gt;　　&lt;!-- 项目的名字 --&gt;　　&lt;finalName&gt;WebMavenDemo&lt;/finalName&gt;　　&lt;!-- 描述项目中资源的位置 --&gt;　　&lt;resources&gt;　　　　&lt;!-- 自定义资源1 --&gt;　　　　&lt;resource&gt;　　　　　　&lt;!-- 资源目录 --&gt;　　　　　　&lt;directory&gt;src/main/java&lt;/directory&gt;　　　　　　&lt;!-- 包括哪些文件参与打包 --&gt;　　　　　　&lt;includes&gt;　　　　　　　　&lt;include&gt;**/*.xml&lt;/include&gt;　　　　　　&lt;/includes&gt;　　　　　　&lt;!-- 排除哪些文件不参与打包 --&gt;　　　　　　&lt;excludes&gt;　　　　　　　　&lt;exclude&gt;**/*.txt&lt;/exclude&gt;　　　　　　　　　　&lt;exclude&gt;**/*.doc&lt;/exclude&gt;　　　　　　&lt;/excludes&gt;　　　　&lt;/resource&gt;　　&lt;/resources&gt;　　&lt;!-- 设置构建时候的插件 --&gt;　　&lt;plugins&gt;　　　　&lt;plugin&gt;　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;　　　　　　&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;　　　　　　&lt;version&gt;2.1&lt;/version&gt;　　　　　　&lt;configuration&gt;　　　　　　　　&lt;!-- 源代码编译版本 --&gt;　　　　　　　　&lt;source&gt;1.8&lt;/source&gt;　　　　　　　　&lt;!-- 目标平台编译版本 --&gt;　　　　　　　　&lt;target&gt;1.8&lt;/target&gt;　　　　　　&lt;/configuration&gt;　　　　&lt;/plugin&gt;　　　　&lt;!-- 资源插件（资源的插件） --&gt;  　　　　&lt;plugin&gt;  　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  　　　　　　&lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;  　　　　　　&lt;version&gt;2.1&lt;/version&gt;  　　　　　　&lt;executions&gt;  　　　　　　　　&lt;execution&gt;  　　　　　　　　　　&lt;phase&gt;compile&lt;/phase&gt;  　　　　　　　　&lt;/execution&gt;  　　　　　　&lt;/executions&gt;  　　　　　　&lt;configuration&gt;  　　　　　　　　&lt;encoding&gt;UTF-8&lt;/encoding&gt;  　　　　　　&lt;/configuration&gt; 　　　　&lt;/plugin&gt;　　　　&lt;!-- war插件(将项目打成war包) --&gt;  　　　　&lt;plugin&gt;  　　　　　　&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  　　　　　　&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;  　　　　　　&lt;version&gt;2.1&lt;/version&gt;  　　　　　　&lt;configuration&gt;　　　　　　　　&lt;!-- war包名字 --&gt;  　　　　　　　　&lt;warName&gt;WebMavenDemo1&lt;/warName&gt;　　　　　　&lt;/configuration&gt;  　　　　&lt;/plugin&gt;  　　&lt;/plugins&gt;&lt;/build&gt;</code></pre><p>配置好 build 后，执行 mvn package 之后，在 maven 工程指定的 target 目录里 war 包和文件都按照配置的生成了</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mv19.png" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka配置信息</title>
      <link href="/2019/10/21/2019-06-16-kafka-pei-zhi-xin-xi/"/>
      <url>/2019/10/21/2019-06-16-kafka-pei-zhi-xin-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>  Kafka是分布式发布-订阅消息系统，最初由LinkedIn公司开发，之后成为之后成为Apache基金会的一部分，由Scala和Java编写。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。</p></blockquote><h4 id="Kafka的特性"><a href="#Kafka的特性" class="headerlink" title="Kafka的特性:"></a>Kafka的特性:</h4><ul><li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li><li>可扩展性：kafka集群支持热扩展</li><li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li>高并发：支持数千个客户端同时读写</li></ul><h4 id="Kafka的使用场景："><a href="#Kafka的使用场景：" class="headerlink" title="Kafka的使用场景："></a>Kafka的使用场景：</h4><ul><li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。</li><li>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li><li>运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li><li>流式处理：比如spark streaming和storm</li><li>事件源</li></ul><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>Kafka支持两种模式的集群搭建：</p><ol><li>单机多broker集群配置；</li><li>多机多broker集群配置。</li></ol><h4 id="单机多breoker"><a href="#单机多breoker" class="headerlink" title="单机多breoker"></a>单机多breoker</h4><p>利用单节点部署多个broker。不同的broker不同的id，监听端口以及日志目录，如：</p><p>将配置文件复制两份</p><pre><code>cp config/server.properties config/server-1.propertiescp config/server.properties config/server-2.properties </code></pre><p>修改配置文件信息</p><pre><code>vim config/server-1.properties#修改内容broker.id=2listeners=PLAINTEXT://your.host.name:9093log.dirs=/data/kafka-logs-1vim config/server-2.properties#修改内容broker.id=3listeners=PLAINTEXT://your.host.name:9094log.dirs=/data/kafka-logs-2</code></pre><p>启动多个kafka服务</p><pre><code>in/kafka-server-start.sh config/server-1.properties bin/kafka-server-start.sh config/server-2.properties </code></pre><p>最后按照上面方法产生和消费信息。</p><h4 id="多机多broker"><a href="#多机多broker" class="headerlink" title="多机多broker"></a>多机多broker</h4><p>分别在多个节点按上述方式安装Kafka，配置启动多个Zookeeper 实例。如：192.168.18.130、192.168.18.131、192.168.18.132三台机器</p><p>分别配置多个机器上的Kafka服务 设置不同的broke id，zookeeper.connect设置如下:</p><pre><code>zookeeper.connect=192.168.18.130:2181,192.168.18.131:2181,192.168.18.132:2181</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code>broker.id=0     #当前机器在集群中的唯一标识，和zookeeper的myid性质一样port=9092      #当前kafka对外提供服务的端口默认是9092host.name=10.181.65.180       #这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。num.network.threads=3         #这个是borker进行网络处理的线程数num.io.threads=8              #这个是borker进行I/O处理的线程数log.dirs=/opt/kafka/kafkalogs/       #消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数这个目录，如果配置多个目录，新创建的topic他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个socket.send.buffer.bytes=102400      #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能socket.receive.buffer.bytes=102400   #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘socket.request.max.bytes=104857600   #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小num.partitions=1                     #默认的分区数，一个topic默认1个分区数log.retention.hours=168              #默认消息的最大持久化时间，168小时，7天message.max.byte=5242880             #消息保存的最大值5Mdefault.replication.factor=2         #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务replica.fetch.max.bytes=5242880      #取消息的最大直接数log.segment.bytes=1073741824         #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件log.retention.check.interval.ms=300000         #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除log.cleaner.enable=false                       #是否启用log压缩，一般不用启用，启用的话可以提高性能zookeeper.connect=10.181.65.180:2181,0.181.65.181:2181,0.181.65.182:2181             #设置zookeeper的连接端口</code></pre><h4 id="Kafka的特性-1"><a href="#Kafka的特性-1" class="headerlink" title="Kafka的特性:"></a>Kafka的特性:</h4><ul><li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li><li>可扩展性：kafka集群支持热扩展</li><li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li>高并发：支持数千个客户端同时读写</li></ul><h3 id="springboot整合"><a href="#springboot整合" class="headerlink" title="springboot整合"></a>springboot整合</h3><p><a href="https://blog.csdn.net/qq_26869339/article/details/88324980" target="_blank" rel="noopener">https://blog.csdn.net/qq_26869339/article/details/88324980</a></p><pre><code>#kafka配置信息kafka:  producer:    bootstrap-servers: 10.161.11.222:6667,10.161.11.223:6667,10.161.11.224:6667    batch-size: 16785                                   #一次最多发送数据量    retries: 1                                          #发送失败后的重复发送次数    buffer-memory: 33554432                             #32M批处理缓冲区    linger: 1  consumer:    bootstrap-servers: 10.161.11.222:6667,10.161.11.223:6667,10.161.11.224:6667    auto-offset-reset: earliest                         #最早未被消费的offset    group-id: log-hs-grou20    max-poll-records: 4639                              #批量消费一次最大拉取的数据量    enable-auto-commit: false                           #是否开启自动提交    auto-commit-interval: 1000                          #自动提交的间隔时间    session-timeout: 6000                               #连接超时时间    max-poll-interval: 2000                             #手动提交设置与poll的心跳数  listener:    batch-listener: true                                #是否开启批量消费，true表示批量消费    concurrency: 3                                      #设置消费的线程数    poll-timeout: 1500                                  #自动提交设置，如果消息队列中没有消息，等待timeout毫秒后，调用poll()方法。如果队列中有消息，立即消费消息，每次消费的消息的多少可以通过max.poll.records配置。    topics: hs-test,hs-test1</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka学习笔记</title>
      <link href="/2019/10/21/2019-06-16-kafka-xue-xi-bi-ji/"/>
      <url>/2019/10/21/2019-06-16-kafka-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="kafka学习笔记：知识点整理"><a href="#kafka学习笔记：知识点整理" class="headerlink" title="kafka学习笔记：知识点整理"></a>kafka学习笔记：知识点整理</h2><h2 id="一、为什么需要消息系统"><a href="#一、为什么需要消息系统" class="headerlink" title="一、为什么需要消息系统"></a><strong>一、为什么需要消息系统</strong></h2><p><strong>1.解耦：</strong><br>允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。<br><strong>2.冗余：</strong><br>　　消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。<br><strong>3.扩展性：</strong><br>　　因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。<br><strong>4.灵活性 &amp; 峰值处理能力：</strong><br>　　在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。<br><strong>5.可恢复性：</strong><br>　　系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。<br><strong>6.顺序保证：</strong><br>　　在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性）<br><strong>7.缓冲：</strong><br>　　有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。<br><strong>8.异步通信：</strong><br>　　很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h2 id="二、kafka-架构"><a href="#二、kafka-架构" class="headerlink" title="二、kafka 架构"></a><strong>二、kafka 架构</strong></h2><h3 id="2-1-拓扑结构"><a href="#2-1-拓扑结构" class="headerlink" title="2.1 拓扑结构"></a>2.1 拓扑结构</h3><p>如下图：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka1.png" alt="image"></p><p>图.1</p><h3 id="2-2-相关概念"><a href="#2-2-相关概念" class="headerlink" title="2.2 相关概念"></a>2.2 相关概念</h3><ul><li><p><strong>Topic</strong>：Topic在逻辑上可以被认为是一个queue。每条消费都必须指定它的topic，可以简单理解为必须指明把这条消息放进哪个queue里。</p><ul><li>Partition:topic物理上的分区，一个topic可以分为多个partition，每个partition是一个有序的队列。</li><li>offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息.</li></ul></li><li><p><strong>Partition</strong>：是物理概念上的分区，为了提供系统吞吐率，在物理上每个Topic会分成一个或多个Partition，每个Partition对应一个文件夹，通过partition实现了并行处理和水平扩展</p><ul><li>Segment：<ul><li>partition物理上由多个segment组成，每个Segment存着message信息</li><li>一个Segment对应一个文件</li><li>Segment由一个个不可变记录组成</li><li>记录只会被append到Segment中，不会被单独修改或删除</li><li>清除过期日志时，直接删除一个或多个Segment</li></ul></li></ul></li><li><p><strong>ISR</strong></p></li><li><p><strong>Producer</strong>：消息产生者，负责生产消息并发送到Kafka Broker</p></li><li><p><strong>Consumer</strong>：消息消费者，向kafka broker读取消息并处理的客户端。</p><ul><li><p>消费者就是消息的使用者，在消费者端也有几个名词需要区分一下。</p><blockquote><p>一般消息队列有两种模式的消费方式，分别是 队列模式 和 订阅模式。</p></blockquote><ul><li>队列模式：一对一，就是一个消息只能被一个消费者消费，不能重复消费。一般情况队列支持存在多个消费者，但是对于一个消息，只会有一个消费者可以消费它。</li><li>订阅模式：一对多，一个消息可能被多次消费，消息生产者将消息发布到Topic中，只要是订阅改Topic的消费者都可以消费。</li></ul></li></ul></li><li><p><strong>Consumer Group</strong>：各个consumer（consumer 线程）可以组成一个组（Consumer group ），partition中的每个message只能被组（Consumer group ）中的一个consumer（consumer 线程）消费，如果一个message可以被多个consumer（consumer 线程）消费的话，那么这些consumer必须在不同的组。Kafka不支持一个partition中的message由两个或两个以上的同一个consumer group下的consumer thread来处理，除非再启动一个新的consumer group。所以如果想同时对一个topic做消费的话，启动多个consumer group就可以了，但是要注意的是，这里的多个consumer的消费都必须是顺序读取partition里面的message，新启动的consumer默认从partition队列最头端最新的地方开始阻塞的读message。</p></li><li><p><strong>Broker</strong>：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</p><ul><li>Controller：中央控制器Control，负责管理分区和副本状态并执行管理着这些分区的重新分配。（里面涉及到partition leader 选举）</li><li>ISR：同步副本组</li></ul></li><li><p><strong>controller</strong>：kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover。</p></li><li><p><strong>删除</strong></p><ul><li>对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka集群会保留所有的消息，无论其被消费与否。当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此Kafka提供两种策略去删除旧数据。一是基于时间，二是基于partition文件大小。例如可以通过配置$KAFKA_HOME/config/server.properties，让Kafka删除一周前的数据，也可通过配置让Kafka在partition文件超过1GB时删除旧数据</li></ul></li></ul><h3 id="2-3-zookeeper-节点"><a href="#2-3-zookeeper-节点" class="headerlink" title="2.3 zookeeper 节点"></a>2.3 zookeeper 节点</h3><p>kafka 在 zookeeper 中的存储结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka2.png" alt="image"></p><p>图.2</p><h2 id="三、producer-发布消息"><a href="#三、producer-发布消息" class="headerlink" title="三、producer 发布消息"></a><strong>三、producer 发布消息</strong></h2><h3 id="3-1-写入方式"><a href="#3-1-写入方式" class="headerlink" title="3.1 写入方式"></a>3.1 写入方式</h3><p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。</p><h3 id="3-2-消息路由"><a href="#3-2-消息路由" class="headerlink" title="3.2 消息路由"></a>3.2 消息路由</h3><p>producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。其路由机制为：</p><p>1. 指定了 patition，则直接使用；<br>2. 未指定 patition 但指定 key，通过对 key 的 value 进行hash 选出一个 patition<br>3. patition 和 key 都未指定，使用轮询选出一个 patition。</p><p> 附上 java 客户端分区源码，一目了然：</p><pre><code>//创建消息实例  public ProducerRecord(String topic, Integer partition, Long timestamp, K key, V value) {       if (topic == null)            throw new IllegalArgumentException("Topic cannot be null");       if (timestamp != null &amp;&amp; timestamp &lt; 0)            throw new IllegalArgumentException("Invalid timestamp " + timestamp);       this.topic = topic;       this.partition = partition;       this.key = key;       this.value = value;       this.timestamp = timestamp;  }  //计算 patition，如果指定了 patition 则直接使用，否则使用 key 计算  private int partition(ProducerRecord&lt;K, V&gt; record, byte\[\] serializedKey , byte\[\] serializedValue, Cluster cluster) {       Integer partition = record.partition();       if (partition != null) {            List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(record.topic());            int lastPartition = partitions.size() - 1;            if (partition &lt; 0 || partition &gt; lastPartition) {                 throw new IllegalArgumentException(String.format("Invalid partition given with record: %d is not in the range \[0...%d\].", partition, lastPartition));            }            return partition;       }       return this.partitioner.partition(record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);  }  // 使用 key 选取 patition  public int partition(String topic, Object key, byte\[\] keyBytes, Object value, byte\[\] valueBytes, Cluster cluster) {       List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);       int numPartitions = partitions.size();       if (keyBytes == null) {            int nextValue = counter.getAndIncrement();            List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);            if (availablePartitions.size() &gt; 0) {                 int part = DefaultPartitioner.toPositive(nextValue) % availablePartitions.size();                 return availablePartitions.get(part).partition();            } else {                 return DefaultPartitioner.toPositive(nextValue) % numPartitions;            }       } else {            //对 keyBytes 进行 hash 选出一个 patition            return DefaultPartitioner.toPositive(Utils.murmur2(keyBytes)) % numPartitions;       }  }</code></pre><h3 id="3-3-写入流程"><a href="#3-3-写入流程" class="headerlink" title="3.3 写入流程"></a>3.3 写入流程</h3><p> producer 写入消息序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka3.png" alt="image"></p><p>图.3</p><p>流程说明：</p><p>1. producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader<br>2. producer 将消息发送给该 leader<br>3. leader 将消息写入本地 log<br>4. followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK<br>5. leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK</p><h3 id="3-4-producer-delivery-guarantee"><a href="#3-4-producer-delivery-guarantee" class="headerlink" title="3.4 producer delivery guarantee"></a>3.4 producer delivery guarantee</h3><p> 一般情况下存在三种情况：</p><p>1. At most once 消息可能会丢，但绝不会重复传输<br>2. At least one 消息绝不会丢，但可能会重复传输<br>3. Exactly once 每条消息肯定会被传输一次且仅传输一次</p><p>当 producer 向 broker 发送消息时，一旦这条消息被 commit，由于 replication 的存在，它就不会丢。但是如果 producer 发送数据给 broker 后，遇到网络问题而造成通信中断，那 Producer 就无法判断该条消息是否已经 commit。虽然 Kafka 无法确定网络故障期间发生了什么，但是 producer 可以生成一种类似于主键的东西，发生故障时幂等性的重试多次，这样就做到了 Exactly once，但目前还并未实现。所以目前默认情况下一条消息从 producer 到 broker 是确保了 At least once，可通过设置 producer 异步发送实现At most once。</p><h2 id="四、broker-保存消息"><a href="#四、broker-保存消息" class="headerlink" title="四、broker 保存消息"></a><strong>四、broker 保存消息</strong></h2><h3 id="4-1-存储方式"><a href="#4-1-存储方式" class="headerlink" title="4.1 存储方式"></a>4.1 存储方式</h3><p>物理上把 topic 分成一个或多个 patition（对应 server.properties 中的 num.partitions=3 配置），每个 patition 物理上对应一个文件夹（该文件夹存储该 patition 的所有消息和索引文件），如下：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka4.png" alt="image"></p><p>图.4</p><h3 id="4-2-存储策略"><a href="#4-2-存储策略" class="headerlink" title="4.2 存储策略"></a>4.2 存储策略</h3><p>无论消息是否被消费，kafka 都会保留所有消息。有两种策略可以删除旧数据：</p><p>1. 基于时间：log.retention.hours=168<br>2. 基于大小：log.retention.bytes=1073741824</p><p>需要注意的是，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。</p><h3 id="4-3-topic-创建与删除"><a href="#4-3-topic-创建与删除" class="headerlink" title="4.3 topic 创建与删除"></a>4.3 topic 创建与删除</h3><h4 id="4-3-1-创建-topic"><a href="#4-3-1-创建-topic" class="headerlink" title="4.3.1 创建 topic"></a>4.3.1 创建 topic</h4><p>创建 topic 的序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka5.png" alt="image"></p><p>图.5</p><p>流程说明：</p><p>1. controller 在 ZooKeeper 的 /brokers/topics 节点上注册 watcher，当 topic 被创建，则 controller 会通过 watch 得到该 topic 的 partition/replica 分配。<br>2. controller从 /brokers/ids 读取当前所有可用的 broker 列表，对于 set_p 中的每一个 partition：<br>    2.1 从分配给该 partition 的所有 replica（称为AR）中任选一个可用的 broker 作为新的 leader，并将AR设置为新的 ISR<br>    2.2 将新的 leader 和 ISR 写入 /brokers/topics/[topic]/partitions/[partition]/state<br>3. controller 通过 RPC 向相关的 broker 发送 LeaderAndISRRequest。</p><h4 id="4-3-2-删除-topic"><a href="#4-3-2-删除-topic" class="headerlink" title="4.3.2 删除 topic"></a>4.3.2 删除 topic</h4><p>删除 topic 的序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka6.png" alt="image"></p><p>图.6</p><p>流程说明：</p><p>1. controller 在 zooKeeper 的 /brokers/topics 节点上注册 watcher，当 topic 被删除，则 controller 会通过 watch 得到该 topic 的 partition/replica 分配。<br>2. 若 delete.topic.enable=false，结束；否则 controller 注册在 /admin/delete_topics 上的 watch 被 fire，controller 通过回调向对应的 broker 发送 StopReplicaRequest。</p><h2 id="五、kafka-HA"><a href="#五、kafka-HA" class="headerlink" title="五、kafka HA"></a><strong>五、kafka HA</strong></h2><h3 id="5-1-replication"><a href="#5-1-replication" class="headerlink" title="5.1 replication"></a>5.1 replication</h3><p>如图.1所示，同一个 partition 可能会有多个 replica（对应 server.properties 配置中的 default.replication.factor=N）。没有 replica 的情况下，一旦 broker 宕机，其上所有 patition 的数据都不可被消费，同时 producer 也不能再将数据存于其上的 patition。引入replication 之后，同一个 partition 可能会有多个 replica，而这时需要在这些 replica 之间选出一个 leader，producer 和 consumer 只与这个 leader 交互，其它 replica 作为 follower 从 leader 中复制数据。</p><p>Kafka 分配 Replica 的算法如下：</p><p>1. 将所有 broker（假设共 n 个 broker）和待分配的 partition 排序<br>2. 将第 i 个 partition 分配到第（i mod n）个 broker 上<br>3. 将第 i 个 partition 的第 j 个 replica 分配到第（(i + j) mode n）个 broker上</p><h3 id="5-2-leader-failover"><a href="#5-2-leader-failover" class="headerlink" title="5.2 leader failover"></a>5.2 leader failover</h3><p>当 partition 对应的 leader 宕机时，需要从 follower 中选举出新 leader。在选举新leader时，一个基本的原则是，新的 leader 必须拥有旧 leader commit 过的所有消息。</p><p>kafka 在 zookeeper 中（/brokers/…/state）动态维护了一个 ISR（in-sync replicas），由3.3节的写入流程可知 ISR 里面的所有 replica 都跟上了 leader，只有 ISR 里面的成员才能选为 leader。对于 f+1 个 replica，一个 partition 可以在容忍 f 个 replica 失效的情况下保证消息不丢失。</p><p>当所有 replica 都不工作时，有两种可行的方案：</p><p>1. 等待 ISR 中的任一个 replica 活过来，并选它作为 leader。可保障数据不丢失，但时间可能相对较长。<br>2. 选择第一个活过来的 replica（不一定是 ISR 成员）作为 leader。无法保障数据不丢失，但相对不可用时间较短。</p><p>kafka 0.8.* 使用第二种方式。</p><p>kafka 通过 Controller 来选举 leader，流程请参考5.3节。</p><h3 id="5-3-broker-failover"><a href="#5-3-broker-failover" class="headerlink" title="5.3 broker failover"></a>5.3 broker failover</h3><p>kafka broker failover 序列图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka7.png" alt="image"></p><p>图.7</p><p>流程说明： </p><p>1. controller 在 zookeeper 的 /brokers/ids/[brokerId] 节点注册 Watcher，当 broker 宕机时 zookeeper 会 fire watch<br>2. controller 从 /brokers/ids 节点读取可用broker<br>3. controller决定set_p，该集合包含宕机 broker 上的所有 partition<br>4. 对 set_p 中的每一个 partition<br>    4.1 从/brokers/topics/[topic]/partitions/[partition]/state 节点读取 ISR<br>    4.2 决定新 leader（如4.3节所描述）<br>    4.3 将新 leader、ISR、controller_epoch 和 leader_epoch 等信息写入 state 节点<br>5. 通过 RPC 向相关 broker 发送 leaderAndISRRequest 命令</p><h3 id="5-4-controller-failover"><a href="#5-4-controller-failover" class="headerlink" title="5.4 controller failover"></a>5.4 controller failover</h3><p> 当 controller 宕机时会触发 controller failover。每个 broker 都会在 zookeeper 的 “/controller” 节点注册 watcher，当 controller 宕机时 zookeeper 中的临时节点消失，所有存活的 broker 收到 fire 的通知，每个 broker 都尝试创建新的 controller path，只有一个竞选成功并当选为 controller。</p><p>当新的 controller 当选时，会触发 KafkaController.onControllerFailover 方法，在该方法中完成如下操作：</p><p>1. 读取并增加 Controller Epoch。<br>2. 在 reassignedPartitions Patch(/admin/reassign_partitions) 上注册 watcher。<br>3. 在 preferredReplicaElection Path(/admin/preferred_replica_election) 上注册 watcher。<br>4. 通过 partitionStateMachine 在 broker Topics Patch(/brokers/topics) 上注册 watcher。<br>5. 若 delete.topic.enable=true（默认值是 false），则 partitionStateMachine 在 Delete Topic Patch(/admin/delete_topics) 上注册 watcher。<br>6. 通过 replicaStateMachine在 Broker Ids Patch(/brokers/ids)上注册Watch。<br>7. 初始化 ControllerContext 对象，设置当前所有 topic，“活”着的 broker 列表，所有 partition 的 leader 及 ISR等。<br>8. 启动 replicaStateMachine 和 partitionStateMachine。<br>9. 将 brokerState 状态设置为 RunningAsController。<br>10. 将每个 partition 的 Leadership 信息发送给所有“活”着的 broker。<br>11. 若 auto.leader.rebalance.enable=true（默认值是true），则启动 partition-rebalance 线程。<br>12. 若 delete.topic.enable=true 且Delete Topic Patch(/admin/delete_topics)中有值，则删除相应的Topic。</p><h2 id="6-consumer-消费消息"><a href="#6-consumer-消费消息" class="headerlink" title="6. consumer 消费消息"></a><strong>6. consumer 消费消息</strong></h2><h3 id="6-1-consumer-API"><a href="#6-1-consumer-API" class="headerlink" title="6.1 consumer API"></a>6.1 consumer API</h3><p>kafka 提供了两套 consumer API：</p><p>1. The high-level Consumer API<br>2. The SimpleConsumer API</p><p> 其中 high-level consumer API 提供了一个从 kafka 消费数据的高层抽象，而 SimpleConsumer API 则需要开发人员更多地关注细节。</p><h4 id="6-1-1-The-high-level-consumer-API"><a href="#6-1-1-The-high-level-consumer-API" class="headerlink" title="6.1.1 The high-level consumer API"></a>6.1.1 The high-level consumer API</h4><p>high-level consumer API 提供了 consumer group 的语义，一个消息只能被 group 内的一个 consumer 所消费，且 consumer 消费消息时不关注 offset，最后一个 offset 由 zookeeper 保存。</p><p>使用 high-level consumer API 可以是多线程的应用，应当注意：</p><p>1. 如果消费线程大于 patition 数量，则有些线程将收不到消息<br>2. 如果 patition 数量大于线程数，则有些线程多收到多个 patition 的消息<br>3. 如果一个线程消费多个 patition，则无法保证你收到的消息的顺序，而一个 patition 内的消息是有序的</p><h4 id="6-1-2-The-SimpleConsumer-API"><a href="#6-1-2-The-SimpleConsumer-API" class="headerlink" title="6.1.2 The SimpleConsumer API"></a>6.1.2 The SimpleConsumer API</h4><p>如果你想要对 patition 有更多的控制权，那就应该使用 SimpleConsumer API，比如：</p><p>1. 多次读取一个消息<br>2. 只消费一个 patition 中的部分消息<br>3. 使用事务来保证一个消息仅被消费一次</p><p> 但是使用此 API 时，partition、offset、broker、leader 等对你不再透明，需要自己去管理。你需要做大量的额外工作：</p><p>1. 必须在应用程序中跟踪 offset，从而确定下一条应该消费哪条消息<br>2. 应用程序需要通过程序获知每个 Partition 的 leader 是谁<br>3. 需要处理 leader 的变更</p><p> 使用 SimpleConsumer API 的一般流程如下：</p><p>1. 查找到一个“活着”的 broker，并且找出每个 partition 的 leader<br>2. 找出每个 partition 的 follower<br>3. 定义好请求，该请求应该能描述应用程序需要哪些数据<br>4. fetch 数据<br>5. 识别 leader 的变化，并对之作出必要的响应</p><blockquote><p>以下针对 high-level Consumer API 进行说明。</p></blockquote><h3 id="6-2-consumer-group"><a href="#6-2-consumer-group" class="headerlink" title="6.2 consumer group"></a>6.2 consumer group</h3><p>如 2.2 节所说， kafka 的分配单位是 patition。每个 consumer 都属于一个 group，一个 partition 只能被同一个 group 内的一个 consumer 所消费（也就保障了一个消息只能被 group 内的一个 consuemr 所消费），但是多个 group 可以同时消费这个 partition。</p><p>kafka 的设计目标之一就是同时实现离线处理和实时处理，根据这一特性，可以使用 spark/Storm 这些实时处理系统对消息在线处理，同时使用 Hadoop 批处理系统进行离线处理，还可以将数据备份到另一个数据中心，只需要保证这三者属于不同的 consumer group。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ka9.jpg" alt="image"></p><h2 id="6-3-消费方式"><a href="#6-3-消费方式" class="headerlink" title="6.3 消费方式"></a><strong>6.3 消费方式</strong></h2><p>consumer 采用 pull 模式从 broker 中读取数据。</p><p>push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p><p>对于 Kafka 而言，pull 模式更合适，它可简化 broker 的设计，consumer 可自主控制消费消息的速率，同时 consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p><h3 id="6-4-consumer-delivery-guarantee"><a href="#6-4-consumer-delivery-guarantee" class="headerlink" title="6.4 consumer delivery guarantee"></a>6.4 consumer delivery guarantee</h3><p>如果将 consumer 设置为 autocommit，consumer 一旦读到数据立即自动 commit。如果只讨论这一读取消息的过程，那 Kafka 确保了 Exactly once。</p><p>但实际使用中应用程序并非在 consumer 读取完数据就结束了，而是要进行进一步处理，而数据处理与 commit 的顺序在很大程度上决定了consumer delivery guarantee：</p><p><strong>1.读完消息先 commit 再处理消息。</strong><br>    这种模式下，如果 consumer 在 commit 后还没来得及处理消息就 crash 了，下次重新开始工作后就无法读到刚刚已提交而未处理的消息，这就对应于 At most once<br><strong>2.读完消息先处理再 commit。</strong><br>    这种模式下，如果在处理完消息之后 commit 之前 consumer crash 了，下次重新开始工作时还会处理刚刚未 commit 的消息，实际上该消息已经被处理过了。这就对应于 At least once。<br><strong>3.如果一定要做到 Exactly once，就需要协调 offset 和实际操作的输出。</strong><br>    精典的做法是引入两阶段提交。如果能让 offset 和操作输入存在同一个地方，会更简洁和通用。这种方式可能更好，因为许多输出系统可能不支持两阶段提交。比如，consumer 拿到数据后可能把数据放到 HDFS，如果把最新的 offset 和数据本身一起写到 HDFS，那就可以保证数据的输出和 offset 的更新要么都完成，要么都不完成，间接实现 Exactly once。（目前就 high-level API而言，offset 是存于Zookeeper 中的，无法存于HDFS，而SimpleConsuemr API的 offset 是由自己去维护的，可以将之存于 HDFS 中）</p><p>总之，Kafka 默认保证 At least once，并且允许通过设置 producer 异步提交来实现 At most once（见文章《kafka consumer防止数据丢失》）。而 Exactly once 要求与外部存储系统协作，幸运的是 kafka 提供的 offset 可以非常直接非常容易得使用这种方式。</p><p>更多关于 kafka 传输语义的信息请参考《Message Delivery Semantics》。</p><h3 id="6-5-consumer-rebalance"><a href="#6-5-consumer-rebalance" class="headerlink" title="6.5 consumer rebalance"></a>6.5 consumer rebalance</h3><p>当有 consumer 加入或退出、以及 partition 的改变（如 broker 加入或退出）时会触发 rebalance。consumer rebalance算法如下：</p><p>1. 将目标 topic 下的所有 partirtion 排序，存于PT<br>2. 对某 consumer group 下所有 consumer 排序，存于 CG，第 i 个consumer 记为 Ci<br>3. N=size(PT)/size(CG)，向上取整<br>4. 解除 Ci 对原来分配的 partition 的消费权（i从0开始）<br>5. 将第i*N到（i+1）*N-1个 partition 分配给 Ci</p><p>在 0.8.*版本，每个 consumer 都只负责调整自己所消费的 partition，为了保证整个consumer group 的一致性，当一个 consumer 触发了 rebalance 时，该 consumer group 内的其它所有其它 consumer 也应该同时触发 rebalance。这会导致以下几个问题：</p><p><strong>1.Herd effect</strong><br>　　任何 broker 或者 consumer 的增减都会触发所有的 consumer 的 rebalance<br><strong>2.Split Brain</strong><br>　　每个 consumer 分别单独通过 zookeeper 判断哪些 broker 和 consumer 宕机了，那么不同 consumer 在同一时刻从 zookeeper 看到的 view 就可能不一样，这是由 zookeeper 的特性决定的，这就会造成不正确的 reblance 尝试。<br><strong>3. 调整结果不可控</strong><br>　　所有的 consumer 都并不知道其它 consumer 的 rebalance 是否成功，这可能会导致 kafka 工作在一个不正确的状态。</p><p>基于以上问题，kafka 设计者考虑在0.9.*版本开始使用中心 coordinator 来控制 consumer rebalance，然后又从简便性和验证要求两方面考虑，计划在 consumer 客户端实现分配方案。（见文章《Kafka Detailed Consumer Coordinator Design》和《Kafka Client-side Assignment Proposal》），此处不再赘述。</p><h2 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a><strong>七、注意事项</strong></h2><h3 id="7-1-producer-无法发送消息的问题"><a href="#7-1-producer-无法发送消息的问题" class="headerlink" title="7.1 producer 无法发送消息的问题"></a>7.1 producer 无法发送消息的问题</h3><p>最开始在本机搭建了kafka伪集群，本地 producer 客户端成功发布消息至 broker。随后在服务器上搭建了 kafka 集群，在本机连接该集群，producer 却无法发布消息到 broker（奇怪也没有抛错）。最开始怀疑是 iptables 没开放，于是开放端口，结果还不行（又开始是代码问题、版本问题等等，倒腾了很久）。最后没办法，一项一项查看 server.properties 配置，发现以下两个配置：</p><pre><code>\# The address the socket server listens on. It will get the value returned from   \# java.net.InetAddress.getCanonicalHostName() if not configured.  \#   FORMAT:  \#     listeners = security\_protocol://host\_name:port  \#   EXAMPLE:  \#     listeners = PLAINTEXT://your.host.name:9092  listeners=PLAINTEXT://:9092　# Hostname and port the broker will advertise to producers and consumers. If not set,   　# it uses the value for "listeners" if configured. Otherwise, it will use the value  　# returned from java.net.InetAddress.getCanonicalHostName().  　#advertised.listeners=PLAINTEXT://your.host.name:9092</code></pre><p>以上说的就是 advertised.listeners 是 broker 给 producer 和 consumer 连接使用的，如果没有设置，就使用 listeners，而如果 host_name 没有设置的话，就使用 java.net.InetAddress.getCanonicalHostName() 方法返回的主机名。</p><p>修改方法：</p><p>1. listeners=PLAINTEXT://121.10.26.XXX:9092<br>2. advertised.listeners=PLAINTEXT://121.10.26.XXX:9092</p><p>修改后重启服务，正常工作。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ笔记</title>
      <link href="/2019/10/21/2019-05-12-rabbitmq/"/>
      <url>/2019/10/21/2019-05-12-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h3 id="什么叫消息队列"><a href="#什么叫消息队列" class="headerlink" title="什么叫消息队列"></a>什么叫消息队列</h3><p>  消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。<br>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p><h3 id="为何用消息队列"><a href="#为何用消息队列" class="headerlink" title="为何用消息队列"></a>为何用消息队列</h3><p>  从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用 MQ 呢？</p><p>  以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。<br>以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。</p><h3 id="RabbitMQ-特点"><a href="#RabbitMQ-特点" class="headerlink" title="RabbitMQ 特点"></a>RabbitMQ 特点</h3><p>  RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。<br>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability）</li><li>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由（Flexible Routing）</li></ol><p>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。<br>3. 消息集群（Clustering）</p><p>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。<br>4. 高可用（Highly Available Queues）<br>  队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。<br>5. 多种协议（Multi-protocol）</p><p>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。<br>6. 多语言客户端（Many Clients）</p><p>RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。<br>7. 管理界面（Management UI）</p><p>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。<br>8. 跟踪机制（Tracing）</p><p>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。<br>9. 插件机制（Plugin System）</p><p>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p><h3 id="RabbitMQ-中的概念模型"><a href="#RabbitMQ-中的概念模型" class="headerlink" title="RabbitMQ 中的概念模型"></a>RabbitMQ 中的概念模型</h3><h4 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h4><p>所有 MQ 产品从模型抽象上来说都是一样的过程：</p><p>  消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq1.png" alt="image"></p><h4 id="RabbitMQ-基本概念"><a href="#RabbitMQ-基本概念" class="headerlink" title="RabbitMQ 基本概念"></a>RabbitMQ 基本概念</h4><p>  上面只是最简单抽象的描述，具体到 RabbitMQ 则有更详细的概念需要解释。上面介绍过 RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq2.png" alt="image"></p><ol><li>Message<br>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</li><li>Publisher<br>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li><li>Binding<br>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li><li>Queue<br>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li><li>Connection<br>网络连接，比如一个TCP连接。</li><li>Channel<br>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li><li>Consumer<br>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li><li>Virtual Host<br>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</li><li>Exchange<br>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li><li>Broker<br>表示消息队列服务器实体。</li></ol><h4 id="RabbitMQ的基本原理"><a href="#RabbitMQ的基本原理" class="headerlink" title="RabbitMQ的基本原理"></a>RabbitMQ的基本原理</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq3.png" alt="image"></p><p>  通过上面这张应用相结合的结构图既能够清晰的看清楚整体的send Message到Receive Message的一个大致的流程。</p><p>　<strong>Queue</strong><br>　<br>  Queue（队列）RabbitMQ的作用是存储消息，队列的特性是先进先出。上图可以清晰地看到Client A和Client B是生产者，生产者生产消息最终被送到RabbitMQ的内部对象Queue中去，而消费者则是从Queue队列中取出数据。可以简化成表示为：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq4.png" alt="image"></p><p>   生产者Send Message “A”被传送到Queue中，消费者发现消息队列Queue中有订阅的消息，就会将这条消息A读取出来进行一些列的业务操作。这里只是一个消费正对应一个队列Queue，也可以多个消费者订阅同一个队列Queue，当然这里就会将Queue里面的消息平分给其他的消费者，但是会存在一个一个问题就是如果每个消息的处理时间不同，就会导致某些消费者一直在忙碌中，而有的消费者处理完了消息后一直处于空闲状态，因为前面已经提及到了Queue会平分这些消息给相应的消费者。这里我们就可以使用prefetchCount来限制每次发送给消费者消息的个数。详情见下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq5.png" alt="image"></p><p>  这里的prefetchCount=1是指每次从Queue中发送一条消息来。等消费者处理完这条消息后Queue会再发送一条消息给消费者。<br><strong>Exchange</strong><br>  我们在开篇的时候就留了一个坑，就是那个应用结构图里面，消费者Client A和消费者Client B是如何知道我发送的消息是给Queue1还是给Queue2，有没有过这个问题，那么我们就来解开这个面纱，看看到底是个什么构造。首先明确一点就是生产者产生的消息并不是直接发送给消息队列Queue的，而是要经过Exchange（交换器），由Exchange再将消息路由到一个或多个Queue，当然这里还会对不符合路由规则的消息进行丢弃掉，这里指的是后续要谈到的Exchange Type。那么Exchange是怎样将消息准确的推送到对应的Queue的呢？那么这里的功劳最大的当属Binding，RabbitMQ是通过Binding将Exchange和Queue链接在一起，这样Exchange就知道如何将消息准确的推送到Queue中去。简单示意图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq6.png" alt="image"></p><p>   <strong>在绑定（Binding）Exchange和Queue的同时，一般会指定一个Binding Key，生产者将消息发送给Exchange的时候，一般会产生一个Routing Key，当Routing Key和Binding Key对应上的时候，消息就会发送到对应的Queue中去</strong>。那么Exchange有四种类型，不同的类型有着不同的策略。也就是表明不同的类型将决定绑定的Queue不同，换言之就是说生产者发送了一个消息，Routing Key的规则是A，那么生产者会将Routing Key=A的消息推送到Exchange中，这时候Exchange中会有自己的规则，对应的规则去筛选生产者发来的消息，如果能够对应上Exchange的内部规则就将消息推送到对应的Queue中去。那么接下来就来详细讲解下Exchange里面类型。</p><h5 id="Exchange-Type"><a href="#Exchange-Type" class="headerlink" title="Exchange Type"></a>Exchange Type</h5><ul><li>fanout</li></ul><p>  fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq7.png" alt="image"></p><p>上图所示，生产者（P）生产消息1将消息1推送到Exchange，由于Exchange Type=fanout这时候会遵循fanout的规则将消息推送到所有与它绑定Queue，也就是图上的两个Queue最后两个消费者消费。</p><ul><li>direct</li></ul><p>  direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq8.png" alt="image"></p><p>当生产者（P）发送消息时Rotuing key=booking时，这时候将消息传送给Exchange，Exchange获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的Queue，这时发现Queue1和Queue2都符合，就会将消息传送给这两个队列，如果我们以Rotuing key=create和Rotuing key=confirm发送消息时，这时消息只会被推送到Queue2队列中，其他Routing Key的消息将会被丢弃。</p><ul><li>topic</li></ul><p>  前面提到的direct规则是严格意义上的匹配，换言之Routing Key必须与Binding Key相匹配的时候才将消息传送给Queue，那么topic这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。它的约定是：</p><ol><li>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</li><li>binding key与routing key一样也是句点号“. ”分隔的字符串</li><li>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</li><li><img src="https://raw.githubusercontent.com/Flyiyu/use/master/rabbitmq9.png" alt="image"></li></ol><p>  当生产者发送消息Routing Key=F.C.E的时候，这时候只满足Queue1，所以会被路由到Queue中，如果Routing Key=A.C.E这时候会被同是路由到Queue1和Queue2中，如果Routing Key=A.F.B时，这里只会发送一条消息到Queue2中。</p><ul><li>headers</li></ul><p>  headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><p>该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。<br>这里在对其进行简要的表格整理：</p><table><thead><tr><th>类型名称</th><th>类型描述</th></tr></thead><tbody><tr><td>fanout</td><td>把所有发送到该Exchange的消息路由到所有与它绑定的Queue中</td></tr><tr><td>direct</td><td>Routing Key==Binding Key</td></tr><tr><td>topic</td><td>我这里自己总结的简称模糊匹配</td></tr><tr><td>headers</td><td>Exchange不依赖于routingkey与bindingkey的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。</td></tr></tbody></table><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><p><strong>ConnectionFactory、Connection、Channel</strong></p><p>　　  ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。ConnectionFactory为Connection的制造工厂。</p><p>　  Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。<br>　　Connection就是建立一个TCP连接，生产者和消费者的都是通过TCP的连接到RabbitMQ Server中的，这个后续会再程序中体现出来。</p><p>　　  Channel虚拟连接，建立在上面TCP连接的基础上，数据流动都是通过Channel来进行的。为什么不是直接建立在TCP的基础上进行数据流动呢？如果建立在TCP的基础上进行数据流动，建立和关闭TCP连接有代价。频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。<br>AMQP 中的消息路由</p><p>  AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2019/10/21/2019-04-18-springboot/"/>
      <url>/2019/10/21/2019-04-18-springboot/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><h5 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h5><pre class=" language-java"><code class="language-java"> 微服务架构就是将单一程序开发成一个微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信，通常是HTTP RESTFUL API。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</code></pre><h5 id="微服务由来"><a href="#微服务由来" class="headerlink" title="微服务由来"></a>微服务由来</h5><p> 微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。</p><h5 id="为什么需要微服务？"><a href="#为什么需要微服务？" class="headerlink" title="为什么需要微服务？"></a>为什么需要微服务？</h5><p> 在传统的IT行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了SOA服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。最终 SOA 看起来很美，但却成为了企业级奢侈品，中小公司都望而生畏。</p><h5 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h5><ol><li>将复杂的业务拆分成多个小的业务，每个业务拆分成一个服务，将复杂的问题简单化。利于分工，降低新人的学习成本。 </li><li>微服务系统是分布式系统，业务与业务之间完全解耦，随着业务的增加可以根据业务再拆分，具有极强的横向扩展能力。面对搞并发的场景可以将服务集群化部署，加强系统负载能力。 </li><li>服务间采用HTTP协议通信，服务与服务之间完全独立。每个服务可以根据业务场景选取合适的编程语言和数据库。 </li><li>微服务每个服务都是独立部署的，每个服务的修改和部署对其他服务没有影响。</li></ol><h5 id="微服务和SOA的关系"><a href="#微服务和SOA的关系" class="headerlink" title="微服务和SOA的关系"></a>微服务和SOA的关系</h5><p>SOA即面向服务的架构，SOA是根据企业服务总线（ESB）模式来整合集成大量单一庞大的系统，微服务可以说是SOA的一种实现，将复杂的业务组件化。但它比ESB实现的SOA更加的轻便敏捷和简单。</p><h3 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h3><p>随着使用 Spring 进行开发的个人和企业越来越多，Spring 也慢慢从一个单一简洁的小框架变成一个大而全的开源软件，Spring 的边界不断进行扩充，到了后来 Spring 几乎可以做任何事情，市面上主流的开源软件、中间件都有 Spring 对应组件支持，人们在享用 Spring 的便利之后，也遇到了一些问题。</p><p>2013 年，微服务的概念也慢慢兴起，快速开发微小独立的应用变得更为急迫，Spring刚好处在这样一个交叉点上，于 2013 年初启动了 Spring Boot 项目的研发。2014 年，Spring Boot 伴随着 Spring 4.0 诞生发布了第一个正式版本。</p><p>Spring Boot 并不是要成为 Spring 平台里面众多“Foundation”层项目的替代者。Spring Boot 的目标不在于为已解决的问题域提供新的解决方案，而是为平台带来另一种开发体验，从而简化对这些已有技术的使用。对于已经熟悉 Spring 生态系统的开发人员来说，Spring Boot 是一个很理想的选择；对于采用 Spring 技术的新人来说，Spring Boot 提供一种更简洁的方式来使用这些技术。</p><h4 id="Spring-Boot-的主要优点："><a href="#Spring-Boot-的主要优点：" class="headerlink" title="Spring Boot 的主要优点："></a>Spring Boot 的主要优点：</h4><ul><li><p>为所有 Spring 开发者更快的入门</p></li><li><p>开箱即用，提供各种默认配置来简化项目配置</p></li><li><p>内嵌式容器简化 Web 项目</p></li><li><p>没有冗余代码生成和 XML 配置的要求</p><p>简言之，Spring Boot 是一个快速开发的框架,能够快速的整合第三方框架，简化 XML 配置，全部采用注解形式，内置 Tomcat 容器,帮助开发者能够实现快速开发，简化了应用系统的初始搭建以及开发过程。</p></li></ul><h3 id="与其他框架的区别"><a href="#与其他框架的区别" class="headerlink" title="与其他框架的区别"></a>与其他框架的区别</h3><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring，因此该框架所具备的功能，是为了让人们更容易的使用 Spring。所以说没有 Spring 强大的功能和生态，就不会有后期 Spring Boot 的火热，Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。</p><h4 id="SpringBoot-和-SpringMVC-区别"><a href="#SpringBoot-和-SpringMVC-区别" class="headerlink" title="SpringBoot 和 SpringMVC 区别"></a>SpringBoot 和 SpringMVC 区别</h4><p>SpringBoot 是一个快速开发的框架,能够快速的整合第三方框架，简化 XML 配置，全部采用注解形式，内<br>嵌 Tomcat 容器,帮助开发者能够实现快速开发。SpringMVC 是一个封装了 Servlet API 的 MVC 框架，就像<br>其它的 MVC 框架，比如 Struts 一样负责处理 web 请求。SpringBoot 的 Web 组件默认集成的是 SpringMVC<br>框架。SpringMVC 通常被叫做控制层框架。</p><h4 id="SpringBoot-和-SpringCloud-区别"><a href="#SpringBoot-和-SpringCloud-区别" class="headerlink" title="SpringBoot 和 SpringCloud 区别"></a>SpringBoot 和 SpringCloud 区别</h4><p>SpringCloud 依赖于 SpringBoot 组件，或者说 Spring Cloud 构建于 Spring Boot 之上。它为微服务中涉及的<br>配置管理、服务治理、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理通<br>常我们使用 SpringMVC 编写 http 协议接口，同时使用 SpringCloud 作为一套完整的微服务解决框架。</p><h4 id="Spring-Boot-的核心：约定优于配置"><a href="#Spring-Boot-的核心：约定优于配置" class="headerlink" title="Spring Boot 的核心：约定优于配置"></a>Spring Boot 的核心：约定优于配置</h4><p>那么什么是约定优于配置呢？</p><p>约定优于配置（Convention Over Configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量、获得简单的好处，而又不失灵活性。</p><p>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为“user_info”，才需写有关这个名字的配置。</p><p>我们可以按照这个思路来设想，我们约定 Controller 层就是 Web 请求层可以省略 MVC 的配置；我们约定在 Service 结尾的类自动注入事务，就可以省略了 Spring 的切面事务配置。</p><p>在 Spring 体系中，Spring Boot JPA 就是约定优于配置最佳实现之一，不需要关注表结构，我们约定类名即是表名，属性名即是表的字段，String 对应 varchar，long 对应 bigint，只有需要一些特殊要求的属性，我们再单独进行配置，按照这个约定我们可以将以前的工作大大简化。</p><p>Spring Boot 体系将约定优于配置的思想展现得淋漓尽致，小到配置文件、中间件的默认配置，大到内置容器、生态中的各种 Starters 无不遵循此设计规则。Spring Boot 鼓励各软件组织方创建自己的 Starter，创建 Starter 的核心组件之一就是 autoconfigure 模块，也是 Starter 的核心功能，在启动的时候进行自动装配，属性默认化配置。</p><p>可以说正是因为 Spring Boot 简化的配置和众多的 Starters 才让 Spring Boot 变得简单、易用、快速上手，也可以说正是约定优于配置的思想彻底落地才让 Spring Boot 走向辉煌。Spring Boot 约定优于配置的思想让 Spring Boot 项目非常容易上手，让编程变得更简单，其实编程本该很简单，简单才是编程的美。</p><h4 id="Spring-Boot-2-0-都更新了什么"><a href="#Spring-Boot-2-0-都更新了什么" class="headerlink" title="Spring Boot 2.0 都更新了什么"></a>Spring Boot 2.0 都更新了什么</h4><p>2018 年 3 月 1 号 Spring Boot 2.0.0.RELEASE 正式发布，这是 Spring Boot 1.0 发布 4 年之后第一次重大修订，因此有多新功能和特性值得关注！在 Spring Boot 官方博客中我们了解到：Spring Boot 2.0 版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。</p><p>我们将 Spring Boot 2.0 更新的技术分为三类进行解读：</p><p>第一类，基础环境升级；<br><br>第二类，默认软件替换和优化；<br><br>第三类，新技术的引入。<br><br>基础环境升级<br><br>最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7<br><br>Spring Boot 2.0 要求 Java 8 作为最低版本，许多现有的 API 已更新，以利用 Java 8 的特性。例如，接口上的默认方法，函数回调以及新的 API，如 javax.time。如果你正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，需要升级你的 JDK。</p><p>Spring Boot 2.0 通过测试可以在 JDK 9 下正常运行，同时 Spring Boot 2.0 宣布不再支持 Java 6 和 7，据我了解国内绝大部分互联网公司的基本环境还在 JDK 7 或者 6 环境下运行，考虑升级 Spring Boot 2.0 的团队需要考虑这个因素。</p><p>依赖组件升级<br><br>Spring Boot 2.0 基于 Spring Framework 5 构建，本次 Spring Boot 的升级，同时也升级了部分其依赖的第三方组件，主要有以下几个：</p><ul><li>Jetty 9.4，Jetty 是一个开源的 Servlet 容器，它为基于 Java 的 Web 内容，例如 JSP 和 Servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。</li><li>Tomcat 8.5，Apache Tomcat 8.5.x 旨在取代 8.0.x，完全支持 Java 9。</li><li>Flyway 5，Flyway 是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway 可以像 SVN 管理不同人的代码那样，管理不同人的 SQL 脚本，从而做到数据库同步。</li><li>Hibernate 5.2，Hibernate 是一款非常流行的 ORM 框架。</li><li>Gradle 3.4，Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。</li><li>Thymeleaf 3.0，Thymeleaf 3 相对于 Thymeleaf 2 有非常大的性能提升。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quartz</title>
      <link href="/2019/10/21/2019-04-11-quartz/"/>
      <url>/2019/10/21/2019-04-11-quartz/</url>
      
        <content type="html"><![CDATA[<p><img src="http://www.quartz-scheduler.org/images/favicon.ico" alt="quartz.ico"></p><h3 id="一、什么是Quartz"><a href="#一、什么是Quartz" class="headerlink" title="一、什么是Quartz?"></a>一、什么是Quartz?</h3><p>Quartz是一个完全由Java编写的开源作业调度框架，为在Java应用程序中进行作业调度提供了简单却强大的机制。Quartz允许开发人员根据时间间隔来调度作业。它实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。简单地创建一个org.quarz.Job接口的Java类。</p><h4 id="Quartz的特点；"><a href="#Quartz的特点；" class="headerlink" title="Quartz的特点；"></a>Quartz的特点；</h4><p>作为一个优秀的开源调度框架，Quartz具有以下特点：</p><p>① 强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；</p><p>②   灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；</p><p>③ 分布式和集群能力，Terracotta 收购后在原来功能基础上作了进一步提升。</p><p>④ Quartz 很容易与 Spring 集成实现灵活可配置的调度功能。</p><h4 id="Quartz专用词汇说明；"><a href="#Quartz专用词汇说明；" class="headerlink" title="Quartz专用词汇说明；"></a>Quartz专用词汇说明；</h4><p>下面是本文中用到的一些专用词汇，在此声明：</p><p>scheduler：</p><p>任务调度器</p><p>trigger：</p><p>触发器，用于定义任务调度时间规则</p><p>job：</p><p>任务，即被调度的任务</p><p>misfire：</p><p>错过的，指本来应该被执行但实际没有被执行的任务调度</p><h4 id="Quartz任务调度基本实现原理；"><a href="#Quartz任务调度基本实现原理；" class="headerlink" title="Quartz任务调度基本实现原理；"></a>Quartz任务调度基本实现原理；</h4><p>Quartz任务调度的核心元素是 scheduler, trigger 和 job，其中 trigger 和 job 是任务调度的元数据， scheduler 是实际执行调度的控制器。</p><p>在 Quartz 中，trigger 是用于定义调度时间的元素，即按照什么时间规则去执行任务。Quartz 中主要提供了四种类型的 trigger：SimpleTrigger，CronTirgger，DateIntervalTrigger，和 NthIncludedDayTrigger。这四种 trigger 可以满足企业应用中的绝大部分需求。</p><p>在 Quartz 中，job 用于表示被调度的任务。主要有两种类型的 job：无状态的（stateless）和有状态的（stateful）。对于同一个 trigger 来说，有状态的 job 不能被并行执行，只有上一次触发的任务被执行完之后，才能触发下一次执行。Job 主要有两种属性：volatility 和 durability，其中 volatility 表示任务是否被持久化到数据库存储，而 durability 表示在没有 trigger 关联的时候任务是否被保留。两者都是在值为 true 的时候任务被持久化或保留。一个 job 可以被多个 trigger 关联，但是一个 trigger 只能关联一个 job。</p><p>在 Quartz 中， scheduler 由 scheduler 工厂创建：DirectSchedulerFactory 或者 StdSchedulerFactory。 第二种工厂StdSchedulerFactory 使用较多，因为 DirectSchedulerFactory 使用起来不够方便，需要作许多详细的手工编码设置。 Scheduler 主要有三种：RemoteMBeanScheduler， RemoteScheduler 和 StdScheduler。</p><h3 id="Cron表达式详解"><a href="#Cron表达式详解" class="headerlink" title="Cron表达式详解"></a>Cron表达式详解</h3><p>【1】cron表达式至少要有6个(最多有7个)以空格分割的事件元素。按照从左到右的顺序，它们分别为：</p><table><thead><tr><th>位置</th><th>时间域</th><th>允许值</th><th>特殊值</th></tr></thead><tbody><tr><td>1</td><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>2</td><td>分钟</td><td>0-59</td><td>, - * /</td></tr><tr><td>3</td><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>4</td><td>日期</td><td>1-31</td><td>, - * ? / L W C</td></tr><tr><td>5</td><td>月份</td><td>1-12</td><td>, - * /</td></tr><tr><td>6</td><td>星期</td><td>1-7</td><td>, - * ? / L C #</td></tr><tr><td>7</td><td>年份（可选）</td><td>1-31</td><td>, - * /</td></tr></tbody></table><p>星号(*)：可用在所有字段中，表示对应时间域的每一个时刻，例如， 在分钟字段时，表示“每分钟”；</p><p>问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符；</p><p>减号(-)：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；</p><p>逗号(,)：表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；</p><p>斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；</p><p>L：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；如果L用在星期中，则表示星期六，等同于7。但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后X天”，例如，6L表示该月的最后星期五；</p><p>W：该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如15W表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意关联的匹配日期不能够跨月，如你指定1W，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天。W字符串只能指定单一日期，而不能指定日期范围；</p><p>LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日；</p><p>井号(#)：该字符只能在星期字段中使用，表示当月某个工作日。如6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发；</p><p>C：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。</p><p><strong>Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> quartz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2019/10/21/2019-04-11-idea-git-de-shi-yong-fly-tom/"/>
      <url>/2019/10/21/2019-04-11-idea-git-de-shi-yong-fly-tom/</url>
      
        <content type="html"><![CDATA[<h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><h2 id="git的基本工作流程："><a href="#git的基本工作流程：" class="headerlink" title="git的基本工作流程："></a>git的基本工作流程：</h2><p><a href="http://img2.tbcdn.cn/L1/461/1/ac6d9422c3f843017b2441b212f39ebc00697e4c" target="_blank" rel="noopener"><img src="http://img2.tbcdn.cn/L1/461/1/ac6d9422c3f843017b2441b212f39ebc00697e4c" alt="git_status"></a></p><ul><li>git clone：将远程的Master分支代码克隆到本地仓库</li><li>git checkout：切出分支出来开发</li><li>git add：将文件加入库跟踪区</li><li>git commit：将库跟踪区改变的代码提交到本地代码库中</li><li>git push： 将本地仓库中的代码提交到远程仓库</li></ul><h3 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h3><ul><li>主分支<ul><li>master分支：存放随时可供生产环境中的部署的代码</li><li>develop分支：存放当前最新开发成果的分支，当代码足够稳定时可以合并到master分支上去。</li></ul></li><li>辅助分支<ul><li>feature分支：开发新功能使用，最终合并到develop分支或抛弃掉</li><li>release分支：做小的缺陷修正、准备发布版本所需的各项说明信息</li><li>hotfix分支：代码的紧急修复工作</li></ul></li></ul><ul><li><p>Git与提交有关的三个命令对应的操作，Add命令是把文件从IDE的工作目录添加到本地仓库的stage区，Commit命令把stage区的暂存文件提交到当前分支的仓库，并清空stage区。Push命令把本地仓库的提交同步到远程仓库。</p></li><li><p>获取更新有两个命令：Fetch和Pull，Fetch是从远程仓库下载文件到本地的origin/master，然后可以手动对比修改决定是否合并到本地的master库。Push则是直接下载并合并。</p></li><li><p>创建分支</p><p><img src="https://img-blog.csdn.net/20160912171844429" alt="图片"></p><p>选择New Branch并输入一个分支的名称</p><p>   <img src="https://img-blog.csdn.net/20160912171858663" alt="图片2"></p></li></ul><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>现在我们要把 dev-100 分支上的代码合并到 master 主分支上<br>先切换到 master 分支<br><img src="http://img12345.5-project.com/blog/20181102172230.png" alt="img"></p><p>合并 dev-100 分支到 master 分支之前，建议先对 master 代码进行 pull 更新操作，然后再执行 Merge into Current</p><p><img src="http://img12345.5-project.com/blog/20181102172650.png" alt="img"></p><pre><code>【new branch】新建分支【local branches】本地分支【master】表示当前是主分支【remote branches】远程仓库分支。我在这里配置了两个远程仓库，所以这里显示2个。</code></pre><p>如果没有冲突，dev-100 中的代码就会被合并到 master 分支上了，合并成功后，需要 <code>push</code> 才能推送到远程仓库,一般情况下只需要将分支提交到本地仓库，不需要将分支提交远程仓库。如果将所有的分支都提交到远程仓库，会让远程仓库杂乱无章。<br><img src="http://img12345.5-project.com/blog/20181102171807.png" alt="img"></p><h2 id="取消分支合并"><a href="#取消分支合并" class="headerlink" title="取消分支合并"></a>取消分支合并</h2><p>合并完成后，但是由于一些问题，我们想要取消本次合并，右键 git，选择 Reset HEAD<br><img src="http://img12345.5-project.com/blog/20181102173946.png" alt="img"><br><img src="http://img12345.5-project.com/blog/20181102174125.png" alt="img"></p><p>HEAD^ 是还原到上一个版本，HEAD^^ 是还原到上上一个版本。<br>Reset Type 有三种：</p><ul><li>mixed 默认方式，只保留源码，回退commit和index信息</li><li>soft 回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit</li><li>hard 彻底回退，本地源码也会变成上一个版本内容</li></ul><p>一般使用默认的 mixed 或者粗暴的 hard 方式。<br>我们这里是取消合并，所以选择 <strong>Hard</strong> 方式，并且是<strong>HEAD^</strong>还原到上一个版本，回退后恢复了原来 master 的代码。<br><img src="http://img12345.5-project.com/blog/20181102171518.png" alt="img"></p><h2 id="解决合并冲突问题"><a href="#解决合并冲突问题" class="headerlink" title="解决合并冲突问题"></a>解决合并冲突问题</h2><p>接下来演示合并冲突，此时是在 master 分支，我们修改文件，并 commit 以及 push 到远程仓库。<br><img src="http://img12345.5-project.com/blog/20181102174704.png" alt="img"></p><p>此时再把 dev-100 分支合并到 master 分支就会提示冲突。<br><img src="http://img12345.5-project.com/blog/20181102175031.png" alt="img"></p><p>双击冲突文件，处理冲突。<br><img src="http://img12345.5-project.com/blog/20181102175217.png" alt="img"><br>处理完成后，点击 apply 即可，如果有多个冲突文件，都按照这种方式处理，这是我们处理完冲突之后的代码。<br><img src="http://img12345.5-project.com/2018110315412022049329.png" alt="img"></p><p>dev-100 分支已经被成功合并到 master 了，就可以删除了。可以直接删除远程 dev-100 分支，删除时 IDEA 会提示是否同时删除本地的 dev-100 分支，勾选即可。</p><p>现在我们把分支合并的结果 push 到远程仓库。</p><h2 id="代码暂存之git-stash"><a href="#代码暂存之git-stash" class="headerlink" title="代码暂存之git stash"></a>代码暂存之git stash</h2><p>编号 100 的需求完成之后，现在我们又接到一个新的需求，正在 dev-101 分支进行开发，开发还未完成。<br><img src="http://img12345.5-project.com/blog/20181102180114.png" alt="img"></p><p>突然线上出现 bug，需要我们紧急进行修改，于是我们要基于最新的 master 分支新建一个 bug 分支 bug-12，需要先切换到 master 分支，但是当前分支的代码没有commit， 如果直接切换到 master 分支的话，dev-101 分支上的新增代码就会跑到 master 分支，而代码又不能此时 commit ，于是就轮到 stash 出场了。<br><img src="http://img12345.5-project.com/blog/20181102180427.png" alt="img"><br>Stash 会保存当前工作进度，会把暂存区和工作区的改动保存起来。<br><img src="http://img12345.5-project.com/20181103154120204424605.png" alt="img"><br>添加备注，选择 <strong>CREATE STASH</strong>。你会发现当前工作区内的代码被恢复成了原样。<br><img src="http://img12345.5-project.com/2018110315412022049329.png" alt="img"></p><h2 id="代码暂存还原"><a href="#代码暂存还原" class="headerlink" title="代码暂存还原"></a>代码暂存还原</h2><p>此刻切换到 master 分支，并创建 bug-12 分支进行修复 bug，修复完成后合并到 master 分支并 push 到远程仓库，上文已经演示如何合并，在此不再赘述。</p><p>将 bug-12 与 master 合并完成之后，现在要接着写 dev-101 需求代码，首先先切换到 dev-101 分支；<br>但是之前的代码已经被我们放到了 git 的 stash 当中，我们现在要把代码还原到工作区当中。<br>选择 Unstash Changes<br><img src="http://img12345.5-project.com/20181103154120268155941.png" alt="img"><br><img src="http://img12345.5-project.com/20181103154120276883579.png" alt="img"><br>选择之前保存的，同时勾选 Pop stash（还原完成后，会自动删除这个 stash），确定后，工作区之前写的代码就又回来了。<br><img src="http://img12345.5-project.com/blog/20181102180114.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch笔记</title>
      <link href="/2019/10/21/2019-04-11-elasticsearch/"/>
      <url>/2019/10/21/2019-04-11-elasticsearch/</url>
      
        <content type="html"><![CDATA[<p>7-2</p><h3 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es8.jpg" alt="image"></p><p><a href="https://my.oschina.net/happyBKs/blog/1798778" target="_blank" rel="noopener">https://my.oschina.net/happyBKs/blog/1798778</a></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>随着业务复杂度的提升以及微服务的兴起，传统单一项目会被按照业务规则进行垂直拆分，另外为了防止单点故障我们也会将重要的服务模块进行集群部署，通过负载均衡进行服务的调用。那么随着节点的增多，各个服务的日志也会散落在各个服务器上。这对于我们进行日志分析带来了巨大的挑战，总不能一台一台的登录去下载日志吧。那么我们需要一种收集日志的工具将散落在各个服务器节点上的日志收集起来，进行统一的查询及管理统计。那么ELK就可以做到这一点。</p><h4 id="Elasticsearch特性"><a href="#Elasticsearch特性" class="headerlink" title="Elasticsearch特性"></a>Elasticsearch特性</h4><ul><li>安装方便：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</li><li>JSON：输入/输出格式为 JSON，意味着不需要定义 Schema，快捷方便</li><li>RESTful：基本所有操作（索引、查询、甚至是配置）都可以通过 HTTP 接口进行</li><li>分布式：节点对外表现对等（每个节点都可以用来做入口）；加入节点自动均衡</li><li>多租户：可根据不同的用途分索引；可以同时操作多个索引</li></ul><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"5i586tn"</span><span class="token punctuation">,</span> // node 名称  <span class="token property">"cluster_name"</span> <span class="token operator">:</span> <span class="token string">"elasticsearch"</span><span class="token punctuation">,</span> // 集群名称  <span class="token property">"cluster_uuid"</span> <span class="token operator">:</span> <span class="token string">"-Ij_g7DrQqeQRYt0BAIY2g"</span><span class="token punctuation">,</span>  <span class="token property">"version"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"number"</span> <span class="token operator">:</span> <span class="token string">"6.6.2"</span><span class="token punctuation">,</span>// es版本号    <span class="token property">"build_flavor"</span> <span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>    <span class="token property">"build_type"</span> <span class="token operator">:</span> <span class="token string">"zip"</span><span class="token punctuation">,</span>    <span class="token property">"build_hash"</span> <span class="token operator">:</span> <span class="token string">"3bd3e59"</span><span class="token punctuation">,</span>    <span class="token property">"build_date"</span> <span class="token operator">:</span> <span class="token string">"2019-03-06T15:16:26.864148Z"</span><span class="token punctuation">,</span>    <span class="token property">"build_snapshot"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"lucene_version"</span> <span class="token operator">:</span> <span class="token string">"7.6.0"</span><span class="token punctuation">,</span>    <span class="token property">"minimum_wire_compatibility_version"</span> <span class="token operator">:</span> <span class="token string">"5.6.0"</span><span class="token punctuation">,</span>    <span class="token property">"minimum_index_compatibility_version"</span> <span class="token operator">:</span> <span class="token string">"5.0.0"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"tagline"</span> <span class="token operator">:</span> <span class="token string">"You Know, for Search"</span><span class="token punctuation">}</span></code></pre><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es1.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es2.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es3.png" alt="image"></p><p>###############################<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es.png" alt="image"></p><p>可以看到，我们成功的创建了一个twitter的节点，当然shard默认是5，我这里设置成了7<br>每一个绿色的小框框代表了一个shard，外面有黑色框框的代表主shard，没有的便是replication，横向的node对应了集群中每一个节点。至此简单的es集群就部署好了。</p><font size="3">Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库--无论是开源还是私有。<p>但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。</p><p>Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p><p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p><ul><li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li><li>一个分布式实时分析搜索引擎</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li></ul><blockquote><p>Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 <strong>RESTful API</strong> 进行通信, 通过端口 9200 和 Elasticsearch 进行通信</p></blockquote><h3 id="es的几个概念："><a href="#es的几个概念：" class="headerlink" title="es的几个概念："></a>es的几个概念：</h3><p>（1） 接近实时（NRT）<br>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒）。</p><p>（2） 集群（cluster）<br>一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。在产品环境中显式地设定这个名字是一个好习惯，但是使用默认值来进行测试/开发也是不错的。</p><p>（3） 节点（node）<br>一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p><p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p><p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p><p>（4） 索引（index）<br>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。索引类似于关系型数据库中Database的概念。在一个集群中，如果你想，可以定义任意多的索引。</p><p>（5） 类型（type）<br>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。类型类似于关系型数据库中Table的概念。<br>         type 在6.0.0已经不赞成使用</p><p>（6）文档（document）<br>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。<br>在一个index/type里面，只要你想，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。文档类似于关系型数据库中Record的概念。实际上一个文档除了用户定义的数据外，还包括_index、_type和_id字段。</p><p>（7） 分片和复制（Primary shards &amp; Primary replicas）<br>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。</p><p>为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。<br>分片之所以重要，主要有两方面的原因：</p><p>允许你水平分割/扩展你的内容容量<br>允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量<br>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p><p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了。这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。复制之所以重要，主要有两方面的原因：</p><p>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。<br>扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行<br>总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制数量，但是不能改变分片的数量。</p><p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。一个索引的多个分片可以存放在集群中的一台主机上，也可以存放在多台主机上，这取决于你的集群机器数量。主分片和复制分片的具体位置是由ES内在的策略所决定的。</p><h3 id="Elasticsearch-存储结构"><a href="#Elasticsearch-存储结构" class="headerlink" title="Elasticsearch 存储结构"></a>Elasticsearch 存储结构</h3><p><strong>es中，存储数据的基本单位就是索引，比如说es中存储了一些订单系统的销售数据，就因该在es中创建一个索引，order—index，所有的销售数据就会都写到这个索引里面去，一个索引就像数据库。而type就相当于每一张表，<br>一个index里面可以有多个type，而mapping就相当于表的结构定义，定义了什么字段类型等，你往index的一个type里添加一行数据就叫做一个document，每一个document有多个filed，每一个filed就代表这个document的一个字段的值。</strong></p><pre><code>在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index)中,和数据库的对比. shards  分片 primary shard 主分片 replica shard 复制分片 document 文档必须包含的三个节点    _index  文档存储的地方    _type  文档代表的对象的类    _id  文档的唯一标识关系数据库 -&gt; 数据库 -&gt; 表 -&gt; 行 -&gt; 列Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields索引相当于数据库，类型相当于表，文档相当于行，字段（Fields）相当于表的列（字段）。</code></pre><p><strong>Mapping 映射</strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es10.png" alt="image"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a href="https://www.cnblogs.com/shoufeng/p/10692113.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoufeng/p/10692113.html</a></p><h4 id="1-核心数据类型"><a href="#1-核心数据类型" class="headerlink" title="1 核心数据类型"></a>1 核心数据类型</h4><ul><li><p>字符串类型 - string(不再支持), 用text或keyword类型来代替string</p></li><li><p>文本类型 - text 当一个字段需要用于全文搜索(会被分词), 比如产品名称、产品描述信息, 就应该使用text类型.</p><ul><li><blockquote><p>text的内容会被分词, 可以设置是否需要存储: “index”: “true|false”.<br>  text类型的字段不能用于排序, 也很少用于聚合</p></blockquote></li></ul></li><li><p>关键字类型 - keyword  当一个字段需要按照精确值进行过滤、排序、聚合等操作时, 就应该使用keyword类型.</p><pre><code>  - &gt; keyword的内容不会被分词, 可以设置是否需要存储: "index": "true|false".</code></pre></li><li><p>数字类型 - 8种</p><blockquote></blockquote><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>byte</td><td>有符号的8位整数, 范围: [-128 ~ 127]</td></tr><tr><td>short</td><td>有符号的16位整数, 范围: [-32768 ~ 32767]</td></tr><tr><td>integer</td><td>有符号的32位整数, 范围: [$-2^{31}$ ~ $2^{31}$-1]</td></tr><tr><td>long</td><td>有符号的32位整数, 范围: [$-2^{63}$ ~ $2^{63}$-1]</td></tr><tr><td>float</td><td>32位单精度浮点数</td></tr><tr><td>double</td><td>64位双精度浮点数</td></tr><tr><td>half_float</td><td>16位半精度IEEE 754浮点类型</td></tr><tr><td>scaled_float</td><td>缩放类型的的浮点数, 比如price字段只需精确到分, 57.34缩放因子为100, 存储结果为5734</td></tr></tbody></table></li></ul><p><strong>使用注意事项:</strong></p><blockquote><p>尽可能选择范围小的数据类型, 字段的长度越短, 索引和搜索的效率越高;<br>优先考虑使用带缩放因子的浮点类型.</p></blockquote><ul><li>日期类型 - date</li><li>布尔类型 - boolean</li><li>二进制型 - binary</li><li>范围类型 - range<blockquote></blockquote><table><thead><tr><th>类型</th><th>范围</th></tr></thead><tbody><tr><td>integer_range</td><td>$-2^{31}$ ~ $2^{31}-1$</td></tr><tr><td>long_range</td><td>$-2^{63}$ ~ $2^{63}-1$</td></tr><tr><td>float_range</td><td>32位单精度浮点型</td></tr><tr><td>double_range</td><td>64位双精度浮点型</td></tr><tr><td>date_range</td><td>64位整数, 毫秒计时</td></tr><tr><td>ip_range</td><td>IP值的范围, 支持IPV4和IPV6, 或者这两种同时存在</td></tr></tbody></table></li></ul><h4 id="2-复杂数据类型"><a href="#2-复杂数据类型" class="headerlink" title="2 复杂数据类型"></a>2 复杂数据类型</h4><ul><li>数组类型 - array</li><li>对象类型 - object</li><li>嵌套类型 - nested</li></ul><h4 id="3-地理数据类型"><a href="#3-地理数据类型" class="headerlink" title="3 地理数据类型"></a>3 地理数据类型</h4><ul><li>地理点类型 - geo point</li><li>地理形状类型 - geo_shape</li></ul><h4 id="4-专门数据类型"><a href="#4-专门数据类型" class="headerlink" title="4 专门数据类型"></a>4 专门数据类型</h4><ul><li>IP类型</li><li>计数数据类型 - token_count</li></ul><h4 id="es锁机制"><a href="#es锁机制" class="headerlink" title="es锁机制"></a>es锁机制</h4><h5 id="悲观锁并发控制"><a href="#悲观锁并发控制" class="headerlink" title="悲观锁并发控制"></a>悲观锁并发控制</h5><p>优点：方便<br>缺点：并发能力低每次只有一个</p><h5 id="乐观锁并发控制"><a href="#乐观锁并发控制" class="headerlink" title="乐观锁并发控制"></a>乐观锁并发控制</h5><p>es采用乐观锁</p><p>乐观锁不会加锁，会采用一个版本号</p><p>优点：并发能力高<br>缺点：每次操作都要比对版本号</p><h3 id="ES相关性算分-relevance"><a href="#ES相关性算分-relevance" class="headerlink" title="ES相关性算分 relevance"></a>ES相关性算分 relevance</h3><h3 id="ES节点角色"><a href="#ES节点角色" class="headerlink" title="ES节点角色"></a>ES节点角色</h3><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es13.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es20.png" alt="image"></p><ul><li>倒排索引- -旦生成,不能更改</li><li>其好处如下:<ul><li>不用考虑并发写文件的问题,杜绝了锁机制带来的性能问题</li><li>由于文件不再更改,可以充分利用文件系统缓存,只需载入- -次,只要内存足够,对该文件的读取都会从内存读取,性能高</li><li>利于生成缓存数据</li><li>利于对文件进行压缩存储,节省磁盘和内存存储空间</li></ul></li><li>坏处为需要写入新文档时,必须重新构建倒排索引文件,然后替换老文件后,新文档才<br>能被检索,导致文档实时性差<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es25.png" alt="image"></li></ul><h4 id="新文档搜索实时性"><a href="#新文档搜索实时性" class="headerlink" title="新文档搜索实时性"></a>新文档搜索实时性</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es26.png" alt="image"><br>当有一个新的文档，构建倒排索引文件，对两个新旧索引进行同时查询，最后再进行一个汇总</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es27.png" alt="image"></p><h3 id="Search运行机制"><a href="#Search运行机制" class="headerlink" title="Search运行机制"></a>Search运行机制</h3><ul><li>Search执行的时候实际分为两个步骤运行<ul><li>Query阶段</li><li>Fetch阶段<br>称为：Query-Then-Fetch<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es28.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es29.png" alt="image"></li></ul></li></ul><h4 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h4><p>es排序默认使用相关性算分进行排序</p><h3 id="集群的状态status"><a href="#集群的状态status" class="headerlink" title="集群的状态status"></a>集群的状态status</h3><p>① green: 所有primary shard和replica shard都已成功分配, 集群是100%可用的;</p><p>② yellow: 所有primary shard都已成功分配, 但至少有一个replica shard缺失. 此时集群所有功能都正常使用, 数据不会丢失, 搜索结果依然完整, 但集群的可用性减弱. —— 需要及时处理的警告.</p><p>③ red: 至少有一个primary shard(以及它的全部副本分片)缺失 —— 部分数据不能使用, 搜索只能返回部分数据, 而分配到这个分配上的写入请求会返回一个异常. 此时虽然可以运行部分功能, 但为了索引数据的完整性, 需要尽快修复集群.</p><h3 id="ES元数据"><a href="#ES元数据" class="headerlink" title="ES元数据"></a>ES元数据</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es14.png" alt="image"></p><h3 id="ES分词"><a href="#ES分词" class="headerlink" title="ES分词"></a>ES分词</h3><p><a href="https://www.jianshu.com/p/914f102bc174" target="_blank" rel="noopener">https://www.jianshu.com/p/914f102bc174</a><br>以及自定分词</p><h4 id="ES自带分词器"><a href="#ES自带分词器" class="headerlink" title="ES自带分词器"></a>ES自带分词器</h4><ul><li>Standard</li><li>Simple</li><li>Whitespace</li><li>Stop</li><li>Keyword</li><li>Pattern</li><li>Language</li></ul><h3 id="es查询"><a href="#es查询" class="headerlink" title="es查询"></a>es查询</h3><ul><li><p>URI Search</p><p>  <img src="https://raw.githubusercontent.com/Flyiyu/use/master/es15.png" alt="image"><br>  <img src="https://raw.githubusercontent.com/Flyiyu/use/master/es17.png" alt="image"></p><blockquote><p>GET /lib/_search</p></blockquote><ul><li><p>在url中使用查询参数</p><pre><code>// 泛查询GET /lib/_search?q=tom{"profile": "true"}</code></pre></li></ul></li></ul><pre><code>GET /lib/_search?q=tom&amp;df=name{  "profile": "true"}```</code></pre><ul><li>Request Body<ul><li>使用ElasticSearch提供的，基于json格式的更加完备的Query Domain Specific Language (DSL查询)<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es16.jpg" alt="image"></li></ul></li></ul><h4 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h4><pre><code>GET，对应select:是从服务器查询，可以在服务器通过请求的参数区分查询的方式。POST,对应Create:在服务器新建立一个资源，调用insert操作。PUT，对应update操作:在服务器更新资源，调用update操作。PATCH，对应update操作，在服务器更新资源，客户端提供改变的属性。（目前JDK7没有实现，tomcat7也不行。）DELETE，对应DELETE操作，从服务器删除资源，调用delete语句。</code></pre><h3 id="Mapping参数"><a href="#Mapping参数" class="headerlink" title="Mapping参数"></a>Mapping参数</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es18.png" alt="image"></p><p>在7.0之后一个索引只可以有一个type</p><p>analyzer</p><p>分词器，默认为standard analyzer，当该字段被索引和搜索时对字段进行分词处理</p><p>boost</p><p>字段权重，默认为1.0</p><p>dynamic</p><p>Mapping中的字段类型一旦设定后，禁止直接修改，原因是：Lucene实现的倒排索引生成后不允许修改<br>只能新建一个索引，然后reindex数据<br>默认允许新增字段<br>通过dynamic参数来控制字段的新增：</p><p>true（默认）允许自动新增字段<br>false 不允许自动新增字段，但是文档可以正常写入，但无法对新增字段进行查询等操作<br>strict 文档不能写入，报错</p><p>index<br>控制当前字段是否索引，默认为true，即记录索引，false不记录，即不可搜索</p><pre><code>PUT my_index{  "mappings": {    "_doc": {      "dynamic": false,       "properties": {        "user": {           "properties": {            "name": {              "type": "text"            },            "social_networks": {               "dynamic": true,              "properties": {}            }          }        }      }    }  }}</code></pre><p>定义后my_index这个索引下不能自动新增字段，但是在user.social_networks下可以自动新增子字段</p><h3 id="Java-API编辑"><a href="#Java-API编辑" class="headerlink" title="Java API编辑"></a>Java API编辑</h3><p>可以使用 Elasticsearch 内置的两个客户端：</p><h4 id="节点客户端（Node-client）"><a href="#节点客户端（Node-client）" class="headerlink" title="节点客户端（Node client）"></a>节点客户端（Node client）</h4><p>节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。</p><h4 id="传输客户端（Transport-client）"><a href="#传输客户端（Transport-client）" class="headerlink" title="传输客户端（Transport client）"></a>传输客户端（Transport client）</h4><p>轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。<br>两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。</p><pre><code>对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。两个的区别为： TransportClient作为一个外部访问者，通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。</code></pre><p>提示<br>Java 客户端作为节点必须和 Elasticsearch 有相同的 主要 版本；否则，它们之间将无法互相理解。</p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es6.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es7.png" alt="image"><br></p></font><p></p><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es19.png" alt="image"></p><h3 id="文档分布式存储"><a href="#文档分布式存储" class="headerlink" title="文档分布式存储"></a>文档分布式存储</h3><h4 id="存储一个document是如何选择存储在哪个分片上面"><a href="#存储一个document是如何选择存储在哪个分片上面" class="headerlink" title="存储一个document是如何选择存储在哪个分片上面"></a>存储一个document是如何选择存储在哪个分片上面</h4><p><a href="https://www.cnblogs.com/wangshouchang/p/8049492.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangshouchang/p/8049492.html</a></p><p>.shard = hash(routing) % number_of_primary_shards</p><p>下面将对这个公式每个字段进行分析</p><ul><li>shard 哪个分片， 也就是分片id</li><li>routing 一个可变值，默认是文档的id</li><li>hash 一个哈希函数，对rounting字段进行哈希计算生成一个数字</li><li>number_of_primary_shards 主分片的数量，routing字段经过hash函数计算之后的值，将对 主分片的数量也就是 number_of_primary_shards 进行取与，之后得到的shard就是我们文档所在的分片的位置</li></ul><p>该算法与主分片数相关，这也就是主分片一旦创建就无法修改的原因</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es21.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es22.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es23.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es24.png" alt="image"></p><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>深度分页是分布式存储系统必然会面临的一个问题<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es30.png" alt="image"></p><p>分页方式的应用场景<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es31.png" alt="image"></p><h3 id="ES聚合"><a href="#ES聚合" class="headerlink" title="ES聚合"></a>ES聚合</h3><p>es将聚合分析主要分为4类：</p><ul><li>Bucket 分桶类型，类似sql中的GROUP BY的语法<ul><li>Terms</li><li>Range</li><li>Date Range</li><li>Histogram</li><li>Date Histogram</li></ul></li><li>Metric指标分析类型，计算最大值、最小值、平均值 distinct conunt<ul><li>单值分析，只输出一个分析结果<ul><li>min、max、avg、sum</li><li>cardinality类型distinct count()</li></ul></li><li>多值分析，输出多个分析结果<ul><li>stats,extended stas</li><li>percentile,percentile rank</li><li>top hits</li></ul></li></ul></li><li>Pipeline管道分析类型，基于上一级的聚合分析结果进行再分析</li><li>Matrix矩阵分析类型</li></ul><h3 id="日志监控平台–平台架构ELK"><a href="#日志监控平台–平台架构ELK" class="headerlink" title="日志监控平台–平台架构ELK"></a>日志监控平台–平台架构ELK</h3><p>ElasticSearch是有其自己的套件的，简称ELK，即ElasticSearch，Logstash以及Kibana。ElasticSearch负责存储，Logstash负责收集数据来源，Kibana负责可视化数据，分工明确。</p><p>　　下面，我给大家用一个图来说明日志监控平台的架构，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es9.png" alt="image"></p><p>　　通过上图，我们可以清晰的看到日志平台整个流向过程。首先，多个独立的Agent，这里就是图左边的三个LogStash节点，他们负责收集不同来源的数据，由一个Indexer负责进行汇总和分析数据，在这个当中有一个中间过程，这里我们使用了Broker，用Redis来实现这部分功能，其作用充当一个缓冲区，之后由ElasticSearch负责存储和搜索数据，最后由前段的Kibana可视化我们收集的数据。</p><p>　　这里说明几点需要注意的地方：</p><p>采用LogStash收集各种日志数据，其类型可以是：系统日志、文件、Redis、MQ等等。<br>Broker作为远程代理和中心代理的缓冲区，使用Redis进行实现，原因有二：其一，可以提高系统的性能；其二，可以提高系统的高可用性，当中心代理提取数据失败时，数据保存在Redis中，可以规避数据丢失的风险。<br>中心代理使用LogStash，负责从Broker中获取数据，可以执行相关的分析和处理，它提供有Filter功能。<br>ElasticSearch用于存储最终的数据，并对外提供搜索功能，基于Restful。<br>Kibana提供一个简单、丰富的Web View可视化界面，用于可视化ElasticSearch集群中的数据，支持各种查询、统计和展示。</p><p>ELK介绍<br>需求背景：</p><p>业务发展越来越庞大，服务器越来越多<br>各种访问日志、应用日志、错误日志量越来越多，导致运维人员无法很好的去管理日志<br>开发人员排查问题，需要到服务器上查日志，不方便<br>运营人员需要一些数据，需要我们运维到服务器上分析日志<br>为什么要用到ELK：</p><p>一般我们需要进行日志分析场景：直接在日志文件中 grep、awk 就可以获得自己想要的信息。但在规模较大也就是日志量多而复杂的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p><p>大型系统通常都是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p><p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p><p>收集－能够采集多种来源的日志数据<br>传输－能够稳定的把日志数据传输到中央系统<br>存储－如何存储日志数据<br>分析－可以支持 UI 分析<br>警告－能够提供错误报告，监控机制<br>而ELK则提供了一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用。是目前主流的一种日志系统。</p><p>ELK简介：</p><p>ELK是三个开源软件的缩写，分别为：Elasticsearch 、 Logstash以及Kibana , 它们都是开源软件。不过现在还新增了一个Beats，它是一个轻量级的日志收集处理工具(Agent)，Beats占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具，目前由于原本的ELK Stack成员中加入了 Beats 工具所以已改名为Elastic Stack。</p><p>Elastic Stack包含：</p><p>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。详细可参考Elasticsearch权威指南</p><p>Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。它可以从许多来源接收日志，这些来源包括 syslog、消息传递（例如 RabbitMQ）和JMX，它能够以多种方式输出数据，包括电子邮件、websockets和 Elasticsearch。</p><p>Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</p><p>Beats在这里是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、cpu、io等资源消耗比较高。相比 Logstash，Beats所占系统的CPU和内存几乎可以忽略不计<br>ELK Stack （5.0版本之后）–&gt; Elastic Stack == （ELK Stack + Beats）。目前Beats包含六种工具：</p><p>Packetbeat： 网络数据（收集网络流量数据）<br>Metricbeat： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）<br>Filebeat： 日志文件（收集文件数据）<br>Winlogbeat： windows事件日志（收集 Windows 事件日志数据）<br>Auditbeat：审计数据 （收集审计日志）<br>Heartbeat：运行时间监控 （收集系统运行时的数据）<br>关于x-pack工具：</p><p>x-pack对Elastic Stack提供了安全、警报、监控、报表、图表于一身的扩展包，是收费的</p><p>** Kibana索引用来存储数据，千万不要删除了它。它是将es数据通过kibana进行web展示的关键。这个配置后，在es的web界面里就会看到这个.kibana索引 **</p><h4 id="提高-Elasticsearch-的高可用性"><a href="#提高-Elasticsearch-的高可用性" class="headerlink" title="提高 Elasticsearch 的高可用性"></a>提高 Elasticsearch 的高可用性</h4><p>这时集群的作用就体现出来了。假如 Elasticsearch<br>只放在一台服务器上，即单机运行，假如这台主机突然断网了或者被攻击了，那么整个 Elasticsearch 的服务就不可用了。但如果改成<br>Elasticsearch 集群的话，有一台主机宕机了，还有其他的主机可以支撑，这样就仍然可以保证服务是可用的。</p><p>那假如一台主机宕机了，那么不就无法访问这台主机的数据了吗？那假如我要访问的数据正好存在这台主机上，那不就获取不到了吗？难道其他的主机里面也存了一份一模一样的数据？那这岂不是很浪费吗？</p><p>为了解答这个问题，这里就引出了 Elasticsearch<br>的信息存储机制了。首先解答上面的问题，一台主机宕机了，这台主机里面存的数据依然是可以被访问到的，因为在其他的主机上也有备份，但备份的时候也不是整台主机备份，是分片备份的，那这里就又引出了一个概念——分片。</p><p>分片，英文叫做 Shard，顾名思义，分片就是对数据切分成了多个部分。我们知道 Elasticsearch<br>中一个索引（Index）相当于是一个数据库，如存某网站的用户信息，我们就建一个名为 user<br>的索引。但索引存储的时候并不是整个存一起的，它是被分片存储的，Elasticsearch<br>默认会把一个索引分成五个分片，当然这个数字是可以自定义的。分片是数据的容器，数据保存在分片内，分片又被分配到集群内的各个节点里。当你的集群规模扩大或者缩小时，<br>Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里，所以相当于一份数据被分成了多份并保存在不同的主机上。</p><p>那这还是没解决问题啊，如果一台主机挂掉了，那么这个分片里面的数据不就无法访问了？别的主机都是存储的其他的分片。其实是可以访问的，因为其他主机存储了这个分片的备份，叫做副本，这里就引出了另外一个概念——副本。</p><p>副本，英文叫做 Replica，同样顾名思义，副本就是对原分片的复制，和原分片的内容是一样的，Elasticsearch<br>默认会生成一份副本，所以相当于是五个原分片和五个分片副本，相当于一份数据存了两份，并分了十个分片，当然副本的数量也是可以自定义的。这时我们只需要将某个分片的副本存在另外一台主机上，这样当某台主机宕机了，我们依然还可以从另外一台主机的副本中找到对应的数据。所以从外部来看，数据结果是没有任何区别的。</p><p>一般来说，Elasticsearch 会尽量把一个索引的不同分片存储在不同的主机上，分片的副本也尽可能存在不同的主机上，这样可以提高容错率，从而提高高可用性。</p><p>但这时假如你只有一台主机，那不就没办法了吗？分片和副本其实是没意义的，一台主机挂掉了，就全挂掉了。</p><p>（2）健康状态</p><p>针对一个索引，Elasticsearch 中其实有专门的衡量索引健康状况的标志，分为三个等级：</p><ul><li><p>green，绿色。这代表所有的主分片和副本分片都已分配。你的集群是 100% 可用的。</p></li><li></li></ul><p>yellow，黄色。所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。不过，你的高可用性在某种程度上被弱化。如果更多的分片消失，你就会丢数据了。所以可把<br>yellow 想象成一个需要及时调查的警告。</p><ul><li>red，红色。至少一个主分片以及它的全部副本都在缺失中。这意味着你在缺少数据：搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。</li></ul><p>如果你只有一台主机的话，其实索引的健康状况也是<br>yellow，因为一台主机，集群没有其他的主机可以防止副本，所以说，这就是一个不健康的状态，因此集群也是十分有必要的。</p><p>（3）存储空间</p><p>另外，既然是群集，那么存储空间肯定也是联合起来的，假如一台主机的存储空间是固定的，那么集群它相对于单个主机也有更多的存储空间，可存储的数据量也更大。</p><p>所以综上所述，我们需要一个集群！</p><p>二、详细了解 Elasticsearch 集群</p><p>接下来我们再来了解下集群的结构是怎样的。</p><p>首先我们应该清楚多台主机构成了一个集群，每台主机称作一个节点（Node）。</p><p>如图就是一个三节点的集群：</p><p>在图中，每个 Node 都有三个分片，其中 P 开头的代表 Primary 分片，即主分片，R 开头的代表 Replica 分片，即副本分片。所以图中主分片<br>1、2，副本分片 0 储存在 1 号节点，副本分片 0、1、2 储存在 2 号节点，主分片 0 和副本分片 1、2 储存在 3 号节点，一共是 3 个主分片和<br>6 个副本分片。同时我们还注意到 1 号节点还有个 MASTER<br>的标识，这代表它是一个主节点，它相比其他的节点更加特殊，它有权限控制整个集群，比如资源的分配、节点的修改等等。</p><p>这里就引出了一个概念就是节点的类型，我们可以将节点分为这么四个类型：</p><ul><li><p>主节点：即 Master<br>节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。默认情况下任何一个集群中的节点都有可能被选为主节点。索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择。虽然主节点也可以协调节点，路由搜索和从客户端新增数据到数据节点，但最好不要使用这些专用的主节点。一个重要的原则是，尽可能做尽量少的工作。</p></li><li><p>数据节点：即 Data 节点。数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对 CPU、内存、IO<br>要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</p></li><li><p>负载均衡节点：也称作 Client<br>节点，也称作客户端节点。当一个节点既不配置为主节点，也不配置为数据节点时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。</p></li><li><p>预处理节点：也称作 Ingest 节点，在索引数据之前可以先对数据做预处理操作，所有节点其实默认都是支持 Ingest 操作的，也可以专门将某个节点配置为<br>Ingest 节点。</p></li></ul><p>以上就是节点几种类型，一个节点其实可以对应不同的类型，如一个节点可以同时成为主节点和数据节点和预处理节点，但如果一个节点既不是主节点也不是数据节点，那么它就是负载均衡节点。具体的类型可以通过具体的配置文件来设置。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo笔记</title>
      <link href="/2019/10/21/2019-04-11-dubbo/"/>
      <url>/2019/10/21/2019-04-11-dubbo/</url>
      
        <content type="html"><![CDATA[<h3 id="何为Dubbo"><a href="#何为Dubbo" class="headerlink" title="何为Dubbo"></a>何为Dubbo</h3><font size="4"><p>&nbsp; &nbsp; &nbsp;&nbsp;Dubbo是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。Dubbo采用全spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可。</p><h3 id="其核心部分包含"><a href="#其核心部分包含" class="headerlink" title="其核心部分包含:"></a>其核心部分包含:</h3><p><strong>远程通讯：</strong> 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</p><p><strong>集群容错:</strong> 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p><p><strong>自动发现:</strong> 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p><h3 id="Dubbo的由来"><a href="#Dubbo的由来" class="headerlink" title="Dubbo的由来"></a>Dubbo的由来</h3><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p><ul><li><p>单一应用架构</p><pre><code>  当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。  此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</code></pre></li><li><p>垂直应用架构</p><pre><code>  当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。  此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</code></pre></li><li><p>分布式服务架构</p><pre><code>  当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服  务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。  此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</code></pre></li><li><p>流动计算架构</p><pre><code>  当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调  度中心基于访问压力实时管理集群容量，提高集群利用率。  此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。</code></pre></li></ul><h3 id="Dubbo解决了哪些问题"><a href="#Dubbo解决了哪些问题" class="headerlink" title="Dubbo解决了哪些问题"></a>Dubbo解决了哪些问题</h3><p>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</p><p>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</p><p>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</p><p>Dubbo基于RPC（Remote Procedure Call 远程过程调用）协议，服务提供方和服务消费方之间的调用关系：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/dubbo1.png" alt="dubbo"></p><p><strong>节点角色说明：</strong></p><ul><li>Provider: 暴露服务的服务提供方。</li><li>Consumer: 调用远程服务的服务消费方。</li><li>Registry: 服务注册与发现的注册中心。</li><li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li><li>Container: 服务运行容器。</li></ul><p><strong>调用关系说明：</strong></p><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul></font><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL面试题目</title>
      <link href="/2019/10/21/2019-02-03-sql/"/>
      <url>/2019/10/21/2019-02-03-sql/</url>
      
        <content type="html"><![CDATA[<h3 id="sql执行顺序"><a href="#sql执行顺序" class="headerlink" title="sql执行顺序"></a>sql执行顺序</h3><font size="3"><h3 id="使用命令操作数据库"><a href="#使用命令操作数据库" class="headerlink" title="使用命令操作数据库"></a>使用命令操作数据库</h3><ul><li>mysql -h localhost -u root -p ====连接数据库</li><li>show databases; ====查看数据库</li><li>use 表名 ==== 选择表</li><li>show tables ====查看表</li></ul><hr><h3 id="sql-语法"><a href="#sql-语法" class="headerlink" title="sql 语法"></a>sql 语法</h3><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>查询中用到的关键词主要包含六个，并且他们写的顺序依次为</p><blockquote><p>select–from–where–group by–having–order by</p></blockquote><p>其中select和from是必须的，其他关键词是可选的，<strong>这六个关键词的执行顺序</strong><br>与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</p><blockquote><p>from–where–group by–having–select–order by,</p></blockquote><ul><li>from:需要从哪个数据表检索数据</li><li>where:过滤表中数据的条件</li><li>group by:如何将上面过滤出的数据分组</li><li>having:对上面已经分组的数据进行过滤的条件  </li><li>select:查看结果集中的哪个列，或列的计算结果</li><li>order by :按照什么样的顺序来查看返回的数据</li></ul><p>SELECT - 从数据库中提取数据</p><p>UPDATE - 更新数据库中的数据</p><p>DELETE - 从数据库中删除数据</p><p>INSERT INTO - 向数据库中插入新数据</p><p>CREATE DATABASE - 创建新数据库</p><p>ALTER DATABASE - 修改数据库</p><p>CREATE TABLE - 创建新表</p><p>ALTER TABLE - 变更（改变）数据库表</p><p>DROP TABLE - 删除表</p><p>CREATE INDEX - 创建索引（搜索键）</p><p>DROP INDEX - 删除索引</p><h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4><p>% 替代一个或多个字符</p><p>_ 仅替代一个字符</p><p>[charlist] 字符列中的任何单一字符</p><p>[^charlist]或者[!charlist] 不在字符列中的任何单一字符</p><p>其中搭配以上通配符可以让LIKE命令实现多种技巧：</p><p>1、LIKE’Mc%’ 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。</p><p>2、LIKE’%inger’ 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。</p><p>3、LIKE’%en%’ 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。</p><p>4、LIKE’_heryl’ 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。</p><p>5、LIKE’[CK]ars[eo]n’ 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。</p><p>6、LIKE’[M-Z]inger’ 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。</p><p>7、LIKE’M[^c]%’ 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>INNER JOIN：如果表中有至少一个匹配，则返回行</p><p>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</p><p>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</p><p>FULL JOIN：只要其中一个表中存在匹配，则返回行</p><h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>在开发中，有些数据的存储可能涉及到分库分表，查询的时候，可能需要查询所有的分表，这个时候，就需要用到UNION或者UNION ALL</p><h5 id="union-1"><a href="#union-1" class="headerlink" title="union"></a>union</h5><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集，请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列，列也必须拥有相似的数据类型，同时，每条 SELECT 语句中的列的顺序必须相同。</p><p>UNION 语法例句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name2</code></pre><h5 id="union-all"><a href="#union-all" class="headerlink" title="union all"></a>union all</h5><p>UNION all 语法例句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token keyword">union</span> <span class="token keyword">all</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> userc<span class="token punctuation">;</span></code></pre><p><strong>UNION ALL 命令和 UNION 命令几乎是等效的，不过 UNION ALL 命令会列出所有的值。</strong></p><h3 id="SQL-Aggregate-函数"><a href="#SQL-Aggregate-函数" class="headerlink" title="SQL Aggregate 函数"></a>SQL Aggregate 函数</h3><p>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。</p><p>有用的 Aggregate 函数：</p><p>AVG() - 返回平均值</p><p>COUNT() - 返回行数</p><p>FIRST() - 返回第一个记录的值</p><p>LAST() - 返回最后一个记录的值</p><p>MAX() - 返回最大值</p><p>MIN() - 返回最小值</p><p>SUM() - 返回总和</p><h3 id="Mysql-amp-Oracle"><a href="#Mysql-amp-Oracle" class="headerlink" title="Mysql &amp; Oracle"></a>Mysql &amp; Oracle</h3><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>mysql : limit 3,5 从第三条开始，向后查询五条数据</p><p>Oracle: 使用伪列rownum 来做子查询</p><pre><code>    select * from ( select t.*,rownum r from BANK t ) a where a.r &gt;2 and a.r &lt; 6</code></pre><h4 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h4><p>MySql： 创建表时：auto_increment</p><p>创建表格后添加： alter table tablename add id int auto_increment primary key</p><p>Oracle： 使用序列实现</p><pre class=" language-sql"><code class="language-sql">参数说明INCREMENT <span class="token keyword">BY</span> :序列变化的步进，负值表示递减。<span class="token punctuation">(</span>默认<span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">START</span> <span class="token keyword">WITH</span>:序列的初始值 。<span class="token punctuation">(</span>默认<span class="token number">1</span><span class="token punctuation">)</span>MAXvalue:序列可生成的最大值。<span class="token punctuation">(</span>默认不限制最大值，NOMAXVALUE<span class="token punctuation">)</span>MINVALUE:序列可生成的最小值。<span class="token punctuation">(</span>默认不限制最小值，NOMINVALUE<span class="token punctuation">)</span>CYCLE:用于定义当序列产生的值达到限制值后是否循环<span class="token punctuation">(</span><span class="token keyword">NOCYCLE</span>:不循环，CYCLE:循环<span class="token punctuation">)</span>。CACHE:表示缓存序列的个数，数据库异常终止可能会导致序列中断不连续的情况，默认值为<span class="token number">20</span>，如果不使用缓存可设置NOCACHE<span class="token comment" spellcheck="true">-- 序列</span><span class="token keyword">create</span> sequence sequsincrement <span class="token keyword">by</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">-- 每次增加1</span><span class="token keyword">start</span> <span class="token keyword">with</span> <span class="token number">3</span>  <span class="token comment" spellcheck="true">--从3开始</span>minvalue <span class="token number">1</span>    <span class="token comment" spellcheck="true">-- 最小值</span>maxvalue <span class="token number">1000</span> <span class="token comment" spellcheck="true">-- 最大值1000</span>cycle <span class="token comment" spellcheck="true">-- 周而复始</span>nocache<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 使用方法</span><span class="token keyword">insert</span> <span class="token keyword">into</span> bank <span class="token keyword">values</span><span class="token punctuation">(</span>sequ<span class="token punctuation">.</span>nextval<span class="token punctuation">,</span><span class="token string">'jack'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="存储过程简介"><a href="#存储过程简介" class="headerlink" title="存储过程简介"></a>存储过程简介</h4><p>存储过程是数据库的一个重要的功能，MySQL 5.0以前并不支持存储过程，这使得MySQL在应用上大打折扣。好在MySQL 5.0开始支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。<br>SQL语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p><p>存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式。</p><p>存储过程的优点：</p><p>(1).增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p><p>(2).标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</p><p>(3).较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p><p>(4).减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。</p><p>(5).作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</p><h4 id="MySQL存储过程的创建"><a href="#MySQL存储过程的创建" class="headerlink" title="MySQL存储过程的创建"></a>MySQL存储过程的创建</h4><p><strong>语法</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span>  过程名<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">IN</span><span class="token operator">|</span><span class="token keyword">OUT</span><span class="token operator">|</span><span class="token keyword">INOUT</span><span class="token punctuation">]</span> 参数名 数据类型<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">IN</span><span class="token operator">|</span><span class="token keyword">OUT</span><span class="token operator">|</span><span class="token keyword">INOUT</span><span class="token punctuation">]</span> 参数名 数据类型…<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>特性 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> 过程体<span class="token keyword">DELIMITER</span> <span class="token comment" spellcheck="true">//</span>  <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> myproc<span class="token punctuation">(</span><span class="token keyword">OUT</span> s <span class="token keyword">int</span><span class="token punctuation">)</span>    <span class="token keyword">BEGIN</span>      <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">INTO</span> s <span class="token keyword">FROM</span> students<span class="token punctuation">;</span>    <span class="token keyword">END</span>    <span class="token comment" spellcheck="true">//</span><span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span></code></pre><p>分隔符<br>MySQL默认以”;”为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要事先用“DELIMITER //”声明当前段分隔符，让编译器把两个”//“之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER ;”的意为把分隔符还原。</p><p><strong>过程体</strong></p><p>过程体的开始与结束使用BEGIN与END进行标识。</p><p><strong>参数</strong></p><p>存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT:</p><p>　　存储过程可以有0个或多个参数，用于存储过程的定义。</p><p>3种参数类型：</p><p>　　IN输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）</p><p>　　OUT输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）</p><p>　　INOUT输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）</p><p><strong>定义变量</strong><br>如果希望MySQL执行批量插入的操作，那么至少要有一个计数器来计算当前插入的是第几次。 </p><p>这里的变量是用在存储过程中的SQL语句中的，变量的作用范围在BEGIN …. END 中。</p><p>没有DEFAULT子句，初始值为NULL。</p><p>定义变量的操作</p><pre><code>DECLARE name,address VARCHAR;  -- 发现了吗，SQL中一般都喜欢先定义变量再定义类型，与Java是相反的。DECLARE age INT DEFAULT 20; -- 指定默认值。若没有DEFAULT子句，初始值为NULL。</code></pre><p>为变量赋值</p><pre><code>SET name = 'jay';  -- 为name变量设置值</code></pre><h3 id="sql-优化"><a href="#sql-优化" class="headerlink" title="sql 优化"></a>sql 优化</h3><p>1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><p>select id from t where num is null</p><p>最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.</p><p>3.应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num=10 or Name = ‘admin’<br>可以这样查询：<br>select id from t where num = 10union allselect id from t where Name = ‘admin’</p><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：<br>select id from t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了：<br>select id from t where num between 1 and 3<br>很多时候用 exists 代替 in 是一个好的选择：<br>select num from a where num in(select num from b)<br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num=a.num)</p><p>6.下面的查询也将导致全表扫描：<br>select id from t where name like ‘%abc%’<br>若要提高效率，可以考虑全文检索。</p><p>.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要</p><h3 id="sql-索引"><a href="#sql-索引" class="headerlink" title="sql 索引"></a>sql 索引</h3><p>MySQL官方对索引的定义：索引是帮助MySQL高效获取数据的数据结构。索引是在存储引擎中实现的，所以每种存储引擎中的索引都不一样。如MYISAM和InnoDB存储引擎只支持BTree索引；</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>创建索引<br>在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。</p><p>1.ALTER TABLE ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p><pre><code>    ALTER TABLE table_name ADD INDEX index_name (column_list)    ALTER TABLE table_name ADD UNIQUE (column_list)    ALTER TABLE table_name ADD PRIMARY KEY (column_list)</code></pre><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p><p>2.CREATE INDEX可对表增加普通索引或UNIQUE索引</p><pre><code>    CREATE INDEX index_name ON table_name (column_list)    CREATE UNIQUE INDEX index_name ON table_name (column_list)</code></pre><p>table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。</p><ol start="3"><li>索引类型<br>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。</li></ol><p>PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。</p><p>下面的SQL语句对students表在sid上添加PRIMARY KEY索引。</p><p>ALTER TABLE students ADD PRIMARY KEY (sid)</p><ol start="4"><li>删除索引<br>可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。</li></ol><p>DROP INDEX index_name ON talbe_name</p><p>ALTER TABLE table_name DROP INDEX index_name</p><p>ALTER TABLE table_name DROP PRIMARY KEY</p><p>其中，前两条语句是等价的，删除掉table_name中的索引index_name。</p><p>第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。</p><p>如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。</p><h4 id="什么情况下应不建或少建索引"><a href="#什么情况下应不建或少建索引" class="headerlink" title="什么情况下应不建或少建索引"></a>什么情况下应不建或少建索引</h4><p>1、表记录太少</p><p>2、经常插入、删除、修改的表</p><p>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p><p>3、数据重复且分布平均的表字段</p><p>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</p><p>4、经常和主字段一块查询但主字段索引值比较多的表字段</p><p>如gc_dfss（电费实收）表经常按收费序号、户标识编号、抄表日期、电费发生年月、操作 标志来具体查询某一笔收款的情况，如果将所有的字段都建在一个索引里那将会增加数据的修改、插入、删除时间，从实际上分析一笔收款如果按收费序号索引就已 经将记录减少到只有几条，如果再按后面的几个字段索引查询将对性能不产生太大的影响。</p><h4 id="MySQL聚集索引和非聚集索引"><a href="#MySQL聚集索引和非聚集索引" class="headerlink" title="MySQL聚集索引和非聚集索引"></a>MySQL聚集索引和非聚集索引</h4><p>聚集索引<br>　　一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。<br>　　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（联合索引）（不过mysql的innodb只支持主键聚集索引，不支持联合聚集索引），就像电话簿按姓氏和名字进行组织一样。</p><p>非聚集索引<br>　　一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以包含多个非聚集索引。</p><h3 id="mysql-引擎区别"><a href="#mysql-引擎区别" class="headerlink" title="mysql 引擎区别"></a>mysql 引擎区别</h3><p><strong>存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Blackhole, 5. CSV, 6. Performance_Schema, 7. Archive, 8. Federated , 9 Mrg_Myisam<br>但是我们主要分析使用MyIsam 和InnoDB</strong></p><p><font color="#008000">1) 事务支持</font></p><p>MyISAM不支持事务，而InnoDB支持。InnoDB的AUTOCOMMIT默认是打开的，即每条SQL语句会默认被封装成一个事务，自动提交，这样会影响速度，所以最好是把多条SQL语句显示放在begin和commit之间，组成一个事务去提交。</p><p>MyISAM是非事务安全型的，而InnoDB是事务安全型的，默认开启自动提交，宜合并事务，一同提交，减小数据库多次提交导致的开销，大大提高性能。</p><p><font color="#008000">2) 存储结构</font></p><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><p><font color="#008000">3) 存储空间</font></p><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。<br>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><p><font color="#008000">4) 可移植性、备份及恢复</font></p><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><p><font color="#008000">5) 事务支持</font></p><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><p><font color="#008000">6) AUTO_INCREMENT</font></p><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><p><font color="#008000">7) 表锁差异</font></p><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。简单来说就是, InnoDB支持数据行锁定，而MyISAM不支持行锁定，只支持锁定整个表。即MyISAM同一个表上的读锁和写锁是互斥的，MyISAM并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以MyISAM不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为MyISAM是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p><p><font color="#008000">8) 全文索引</font></p><p>MyISAM：支持(FULLTEXT类型的)全文索引<br>InnoDB：不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><p>全文索引是指对char、varchar和text中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实没啥用，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p><p>另外，MyIsam索引和数据分离，InnoDB在一起，MyIsam天生非聚簇索引，最多有一个unique的性质，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为“聚簇索引”</p><p><font color="#008000">9) 表主键</font></p><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p><p><font color="#008000">10) 表的具体行数</font></p><p>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><p><font color="#008000">11) CURD操作</font></p><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><p><font color="#008000">12) 外键</font></p><p>MyISAM：不支持<br>InnoDB：支持</p><p><font color="#008000">13) 查询效率</font></p><p>没有where的count(<em>)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(</em>)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(<em>)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(</em>)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><p>MyISAM和InnoDB两者的应用场景：</p><p>1) MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。<br>2) InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p><h3 id="什么叫事务？"><a href="#什么叫事务？" class="headerlink" title="什么叫事务？"></a>什么叫事务？</h3><p>简称ACID</p><p>A 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.</p><p>C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.</p><p>I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.</p><p>D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</p></font><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试题目</title>
      <link href="/2019/10/21/2019-02-03-spring-mian-shi-li-jie/"/>
      <url>/2019/10/21/2019-02-03-spring-mian-shi-li-jie/</url>
      
        <content type="html"><![CDATA[<p>1.谈谈你对Spring 的理解（2017-11-13-lyq）</p><p>Spring 是一个开源框架，为简化企业级应用开发而生。Spring 可以是使简单的JavaBean 实现以前只有EJB 才能实现的功能。Spring 是一个 IOC 和 AOP 容器框架。<br>Spring 容器的主要核心是：<br>控制反转（IOC），传统的 java 开发模式中，当需要一个对象时，我们会自己使用 new 或者 getInstance 等直接或者间接调用构造方法创建一个对象。而在 spring 开发模式中，spring 容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring 提供的对象就可以了，这是控制反转的思想。<br>依赖注入（DI），spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。<br>面向切面编程（AOP），在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口采用 JDK 动态代理，如果是类采用<br>CGLIB 方式实现动态代理。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题目</title>
      <link href="/2019/10/21/2019-02-03-redis-mian-shi/"/>
      <url>/2019/10/21/2019-02-03-redis-mian-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>Redis 是一个基于内存的高性能key-value数据库。<br>定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<br>Redis的出色之处不仅仅是性能，Redis是支持保存多种数据结构，此外单个value的最大限制是1GB。 Redis是单进程单线程的.</p><p>Redis提供了多种高可用方案包括：主从复制、哨兵模式的主从复制、以及集群</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><a href="https://www.cnblogs.com/hepingqingfeng/p/7263782.html" target="_blank" rel="noopener">博客</a></p><font face="微软雅黑" size="3"><blockquote><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据<br>。但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。</p></blockquote><blockquote><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库[1] （slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个<br>从数据库，而一个从数据库只能拥有一个主数据库。</p></blockquote><p>一台master主机可以拥有多台slave从机。而一台slave从机又可以拥有多个slave从机。如此下去，形成强大的多级服务器集群架构（高扩展）。可以避免Redis单点故障，实现容灾恢复效果（高可用）。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis5.png" alt=""></p><h5 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h5><blockquote><p>redis复制过程可分为三个阶段：</p></blockquote><ol><li>复制初始化阶段</li><li>数据同步阶段</li><li>命令传播阶段</li></ol><h6 id="复制初始化阶段"><a href="#复制初始化阶段" class="headerlink" title="复制初始化阶段"></a>复制初始化阶段</h6><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><p>具体步骤如下： </p><p>1）从服务器连接主服务器，发送SYNC命令； </p><p>2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </p><p>3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </p><p>　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </p><p>　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </p><p>　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p><h6 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h6><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 </p><p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p></font><h4 id="哨兵（Sentinel）"><a href="#哨兵（Sentinel）" class="headerlink" title="哨兵（Sentinel）"></a>哨兵（Sentinel）</h4><font face="微软雅黑" size="3"><p> 哨兵机制存在的意义：</p><p>没有哨兵机制的时候，主从复制结构部署存在的问题是什么？也可以说redis主节点发生故障如何解决？</p><pre><code>如果主节点down调，主从切换需要人工介入为了实现redis故障转移的自动化。自动发现，自动转移。不需要人工参与。</code></pre><h4 id="1、Sentinel（哨兵）进程的作用："><a href="#1、Sentinel（哨兵）进程的作用：" class="headerlink" title="1、Sentinel（哨兵）进程的作用："></a>1、Sentinel（哨兵）进程的作用：</h4><p>  1】、监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</p><p>  2】、提醒(Notification)：当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</p><p>  3】、自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作，它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p><h4 id="2、Sentinel（哨兵）进程的工作方式："><a href="#2、Sentinel（哨兵）进程的工作方式：" class="headerlink" title="2、Sentinel（哨兵）进程的工作方式："></a>2、Sentinel（哨兵）进程的工作方式：</h4><p> 1】、每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</p><p> 2】、如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）。</p><p> 3】、如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态。</p><p> 4】、当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）。</p><p> 5】、在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</p><p> 6】、当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p><p> 7】、若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</p></font><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><hr><p>以上三者的关系</p><p>==主从往往是为了读写分离、backup 等目的， 哨兵可以检测主从健康， 主挂了可以把从提升为主， 集群往往是为了数据 sharding， 解决单台机器资源的上限的问题==</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis3.png" alt="redis3"></p><p>在这个图中，每一个蓝色的圈都代表着一个redis的服务器节点。它们任何两个节点之间都是相互连通的。客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。</p><p>　　　　那么redis是怎么做到的呢？首先，在redis的每一个节点上，都有这么两个东西，一个是插槽（slot）可以理解为是一个可以存储两个数值的一个变量这个变量的取值范围是：0-16383。还有一个就是cluster我个人把这个cluster理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis4.png" alt="redis4"></p><p>还有就是因为如果集群的话，是有好多个redis一起工作的，那么，就需要这个集群不是那么容易挂掉，所以呢，理论上就应该给集群中的每个节点至少一个备用的redis服务。这个备用的redis称为从节点（slave）。那么这个集群是如何判断是否有某个节点挂掉了呢？</p><p>　　　　首先要说的是，每一个节点都存有这个集群所有主节点以及从节点的信息。</p><p>　　　　它们之间通过互相的ping-pong判断是否节点可以连接上。如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的备用节点。如果某个节点和所有从节点全部挂掉，我们集群就进入faill状态。还有就是如果有一半以上的主节点宕机，那么我们集群同样进入发力了状态。这就是我们的redis的投票机制</p><p>一、常见使用方式<br>Redis 的几种常见使用方式包括：</p><ul><li>Redis 单副本</li><li>Redis 多副本（主从）</li><li>Redis Sentinel（哨兵）</li><li>Redis Cluster</li><li>Redis 自研</li></ul><p>二、各种使用方式的优缺点</p><p><strong>1、Redis 单副本</strong></p><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p><p><strong>优点：</strong></p><p>架构简单，部署方便；</p><p>高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</p><p>高性能。</p><p><strong>缺点：</strong></p><p>不保证数据的可靠性；</p><p>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</p><p>高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</p><p><strong>2、Redis 多副本（主从）</strong></p><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p><p>阿里架构师进阶专题：Redis集群的5种使用方式，各自优缺点分析</p><p><strong>优点：</strong></p><p>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</p><p>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</p><p><strong>缺点：</strong></p><p>故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</p><p>主库的写能力受到单机的限制，可以考虑分片；</p><p>主库的存储能力受到单机的限制，可以考虑 Pika；</p><p>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</p><p><strong>3、Redis Sentinel（哨兵）</strong></p><p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p><p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n&gt;=1）的奇数个。</p><p><strong>优点：</strong></p><p>Redis Sentinel 集群部署简单；</p><p>能够解决 Redis 主从模式下的高可用切换问题；</p><p>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；</p><p>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</p><p><strong>缺点：</strong></p><p>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；</p><p>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；</p><p>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</p><p>不能解决读写分离问题，实现起来相对复杂。</p><p><strong>建议：</strong></p><p>如果监控同一业务，可以选择一套 Sentinel 集群监控多组 Redis 数据节点的方案，反之选择一套 Sentinel 监控一组 Redis 数据节点的方案。</p><p>sentinel monitor配置中的建议设置成 Sentinel 节点的一半加 1，当 Sentinel 部署在多个 IDC 的时候，单个 IDC 部署的 Sentinel 数量不建议超过（Sentinel 数量 – quorum）。</p><p>合理设置参数，防止误切，控制切换灵敏度控制：</p><p>a. quorum</p><p>b. down-after-milliseconds 30000</p><p>c. failover-timeout 180000</p><p>d. maxclient</p><p>e. timeout</p><p>部署的各个节点服务器时间尽量要同步，否则日志的时序性会混乱。</p><p>Redis 建议使用 pipeline 和 multi-keys 操作，减少 RTT 次数，提高请求效率。</p><p>自行搞定配置中心（zookeeper），方便客户端对实例的链接访问。</p><p><strong>4、Redis Cluster</strong></p><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p><p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p><strong>优点：</strong></p><p>无中心架构；</p><p>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</p><p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</p><p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</p><p>降低运维成本，提高系统的扩展性和可用性。</p><p><strong>缺点：</strong></p><p>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p><p>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</p><p>数据通过异步复制，不保证数据的强一致性。</p><p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p><p>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</p><p>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</p><p>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</p><p>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</p><p>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</p><p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p><p>避免产生 hot-key，导致主库节点成为系统的短板。</p><p>避免产生 big-key，导致网卡撑爆、慢查询等。</p><p>重试时间应该大于 cluster-node-time 时间。</p><p>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><font face="微软雅黑" size="3"><ul><li>Redis挂掉了，请求全部走数据库。</li><li>对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。</li><li>由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。</li></ul><h6 id="缓存雪崩的解决方案："><a href="#缓存雪崩的解决方案：" class="headerlink" title="缓存雪崩的解决方案："></a>缓存雪崩的解决方案：</h6></font>对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：<ul><li>事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。</li><li>事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li><li>事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><p>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，伪代码如下：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis1.png?token=AexgHZjCedfwNfJ5BsVbMewryF1mRv7Pks5cRZv0wA%3D%3D" alt="redis1"></p><p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p><p>注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p><p>（2）给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/redis2.png?token=AexgHewM_sBNhe6ItyHaVdtBy2cVSW17ks5cRZwrwA%3D%3D" alt="redis2"></p><p>解释说明：</p><p>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p><p>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p><p>关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><font face="微软雅黑" size="3"><blockquote><p>缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。</p></blockquote><p>解决缓存穿透也有两种方案：</p><p>由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！<br>当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。<br>这种情况我们一般会将空对象设置一个较短的过期时间。</p></font><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><font face="微软雅黑" size="3">　　缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免，用户请求的时候，再去加载相关的数据。<p>　　解决思路：</p><p>　　　　1，直接写个缓存刷新页面，上线时手工操作下。</p><p>　　　　2，数据量不大，可以在WEB系统启动的时候加载。</p><p>　　　　3，定时刷新缓存，<br>　　　　<br></p></font><p></p><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>　　缓存淘汰的策略有两种：</p><p>　　　　(1) 定时去清理过期的缓存。</p><p>　　　　(2)当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 </p><p>　　两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，大家可以根据自己的应用场景来权衡。1. 预估失效时间 2. 版本号（必须单调递增，时间戳是最好的选择）3. 提供手动清理缓存的接口。</p><h4 id="redis过期策略"><a href="#redis过期策略" class="headerlink" title="redis过期策略"></a>redis过期策略</h4><p>三种过期策略</p><p><strong>Redis中同时使用了惰性过期和定期过期两种过期策略。</strong></p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</p><p>优点：保证内存被尽快释放</p><p>缺点：</p><p>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key<br>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重<br>没人用</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</p><p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p><p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>含义：每隔一段时间执行一次删除过期key操作</p><p>优点：<br>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点<br>定期删除过期key–处理”惰性删除”的缺点</p><p>缺点<br>在内存友好方面，不如”定时删除”<br>在CPU时间友好方面，不如”惰性删除”</p><p>难点<br>合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）</p><h4 id="秒杀-抢购技术特点"><a href="#秒杀-抢购技术特点" class="headerlink" title="秒杀/抢购技术特点"></a>秒杀/抢购技术特点</h4><blockquote><p>秒杀会遇到的问题<br>1、超卖 2、</p></blockquote><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>(一)String</p><p>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。</p><p>(二)hash</p><p>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p><p>(三)list</p><p>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。</p><p>(四)set</p><p>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p><p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>(五)sorted set (Zset)</p><p>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。</p><h4 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式</title>
      <link href="/2019/10/21/2019-02-03-java-she-ji-mo-shi/"/>
      <url>/2019/10/21/2019-02-03-java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h2><p>优点：</p><p>(1) 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了</p><p>(2) 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。</p><p>缺点</p><p>(1) 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。</p><p>(2) 单例对象如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context</p><h2 id="恶汉式"><a href="#恶汉式" class="headerlink" title="恶汉式"></a>恶汉式</h2><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h2 id="恶汉式-1"><a href="#恶汉式-1" class="headerlink" title="恶汉式"></a>恶汉式</h2><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>优点：<br>　<br>工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。<br>　<br> 缺点：</p><p> 由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 人类 */</span><span class="token keyword">interface</span> <span class="token class-name">PeopleDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 说话方法     */</span>    <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 男人 */</span><span class="token keyword">class</span> <span class="token class-name">ManaDemo</span> <span class="token keyword">implements</span> <span class="token class-name">PeopleDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"男人说话"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 女人 */</span><span class="token keyword">class</span> <span class="token class-name">WamnDemo</span> <span class="token keyword">implements</span> <span class="token class-name">PeopleDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"女人说话"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 通过反射实现工厂 */</span><span class="token keyword">class</span> <span class="token class-name">FactoryDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> PeopleDemo <span class="token function">simaple</span><span class="token punctuation">(</span>Class <span class="token class-name">c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// newInstance调用无参构造方法</span>        PeopleDemo peoples <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            peoples <span class="token operator">=</span> <span class="token punctuation">(</span>PeopleDemo<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> peoples<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 实现类 */</span><span class="token keyword">class</span> <span class="token class-name">TestDemo</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        PeopleDemo simaple <span class="token operator">=</span> FactoryDemo<span class="token punctuation">.</span><span class="token function">simaple</span><span class="token punctuation">(</span>WamnDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        simaple<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象产品1 */</span><span class="token keyword">interface</span> <span class="token class-name">IProduct1</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象产品2 */</span><span class="token keyword">interface</span> <span class="token class-name">IProduct2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品1 */</span><span class="token keyword">class</span> <span class="token class-name">Product1</span> <span class="token keyword">implements</span> <span class="token class-name">IProduct1</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是1型产品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体产品2 */</span><span class="token keyword">class</span> <span class="token class-name">Product2</span> <span class="token keyword">implements</span> <span class="token class-name">IProduct2</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是2型产品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 抽象工厂 */</span><span class="token keyword">interface</span> <span class="token class-name">IFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> IProduct1 <span class="token function">createProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> IProduct2 <span class="token function">createProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 具体工厂 == 生产产品 */</span><span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token keyword">implements</span> <span class="token class-name">IFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> IProduct1 <span class="token function">createProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> IProduct2 <span class="token function">createProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Product2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 客户端 */</span><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        IFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">createProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">createProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础笔记</title>
      <link href="/2019/10/21/2019-02-03-java-ji-chu/"/>
      <url>/2019/10/21/2019-02-03-java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="1、java-包访问权限"><a href="#1、java-包访问权限" class="headerlink" title="1、java 包访问权限"></a>1、java 包访问权限</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc1.gif" alt=""></p><h3 id="2、Java中的面向接口编程"><a href="#2、Java中的面向接口编程" class="headerlink" title="2、Java中的面向接口编程"></a>2、Java中的面向接口编程</h3><p> 面向接口编程是很多软件架构设计理论都倡导的编程方式，学习Java自然少不了这一部分，下面是我在学习过程中整理出来的关于如何在Java中实现面向接口编程的知识。</p><p>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，通常推荐“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p><h3 id="3、main方法"><a href="#3、main方法" class="headerlink" title="3、main方法"></a>3、main方法</h3><pre><code>/*** Java中的main()方法详解*/public class HelloWorld {    public static void main(String args[]) {        System.out.println("Hello World!");    }}</code></pre><p>一、先说类：<br>HelloWorld 类中有main()方法，说明这是个java应用程序，通过JVM直接启动运行的程序。<br>既然是类，java允许类不加public关键字约束，当然类的定义只能限制为public或者无限制关键字（默认的）。</p><p>二、再说main()方法</p><blockquote><p>这个main()方法的声明为：public static void main(String args[])。必须这么定义，这是Java的规范。<br>为什么要这么定义，和JVM的运行有关系。<br>当一个类中有main()方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法。<br>由于JVM在运行这个Java应用程序的时候，首先会调用main方法，调用时不实例化这个类的对象，而是通过类名直接调用因此需要是限制为public static。(类名.main())<br>对于java中的main方法，jvm有限制，不能有返回值，因此返回值类型为void。<br>main方法中还有一个输入参数，类型为String[]，这个也是java的规范，main()方法中必须有一个入参，类型必须String[]，至于字符串数组的名字，这个是可以自己设定的，根据习惯，这个字符串数组的名字一般和sun java规范范例中mian参数名保持一致，取名为args。因此，main()方法定义必须是：“public static void main(String 字符串数组参数名[])”。</p></blockquote><p>三、main()方法中可以throw Exception<br>因此main()方法中可以抛出异常，main()方法上也可以声明抛出异常。</p><p>四、main()方法中字符串参数数组作用<br>main()方法中字符串参数数组作用是接收命令行输入参数的，命令行的参数之间用空格隔开。</p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p><p>编译</p><p>运行</p><p>编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。</p><p>运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。</p><p>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p><p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p><p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><pre><code>首先String不属于8中基本类型，String是一个对象String 由于使用final 修饰存储在常量区（不是new出来的）new出来的存储在对象存储在堆中，栈中存放的为引用地址。</code></pre><h3 id="4、java类的初始化顺序"><a href="#4、java类的初始化顺序" class="headerlink" title="4、java类的初始化顺序"></a>4、java类的初始化顺序</h3><h4 id="本类的初始化顺序"><a href="#本类的初始化顺序" class="headerlink" title="本类的初始化顺序"></a>本类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitialOrderTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变量</span>    <span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"变量"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 静态初始化块</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticField<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 初始化块</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>运行结果：<br><br>    静态变量<br><br>    静态初始化块<br>a<br>    变量<br><br>    初始化块<br><br>    构造器<br></p><h4 id="含有父类的初始化顺序"><a href="#含有父类的初始化顺序" class="headerlink" title="含有父类的初始化顺序"></a>含有父类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String p_StaticField <span class="token operator">=</span> <span class="token string">"父类--静态变量"</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变量</span>    <span class="token keyword">public</span> String p_Field <span class="token operator">=</span> <span class="token string">"父类--变量"</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 静态初始化块</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 初始化块</span>    <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">", j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        j <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 静态变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String s_StaticField <span class="token operator">=</span> <span class="token string">"子类--静态变量"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 变量</span>    <span class="token keyword">public</span> String s_Field <span class="token operator">=</span> <span class="token string">"子类--变量"</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 静态初始化块</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 初始化块</span>    <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">",j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 程序入口</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>  </code></pre><p>运行结果：<br>父类–静态变量<br>父类–静态初始化块<br>子类–静态变量<br>子类–静态初始化块<br>父类–变量<br>父类–初始化块<br>父类–构造器<br>子类–变量<br>子类–初始化块<br>子类–构造器</p><h3 id="5、Java中如何进行异常处理"><a href="#5、Java中如何进行异常处理" class="headerlink" title="5、Java中如何进行异常处理"></a>5、Java中如何进行异常处理</h3><h4 id="Java异常的分类和类结构图"><a href="#Java异常的分类和类结构图" class="headerlink" title="Java异常的分类和类结构图"></a>Java异常的分类和类结构图</h4><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p><p>Throwable又派生出Error类和Exception类。</p><p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p><p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc3.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc7.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc4.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc6.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc5.png" alt=""></p><p>在Java中异常的继承主要有两个： Error和Exception 这两个，而Error就是jvm出现错误，以及系统奔溃等现象这些错误没办法通过程序来处理，所以在程序中不能使用catch来捕捉处理这类的异常。</p><p>对于Exception 又可以分为checkedException 和RuntimeException 这两种异常，checkedException异常在进行编译运行之前就可以知道会不会发生异常，如果不对这些异常进行抛出、捕获的话就不能通过编译。而RuntimeException就是运行的时候出现的异常在之前你是没办法确定是不是会出现异常。</p><blockquote><p>Java的异常处理是通过5个关键字来实现的：try、catch、 finally、throw、throws</p></blockquote><h4 id="try…catch…finally语句块"><a href="#try…catch…finally语句块" class="headerlink" title="try…catch…finally语句块"></a>try…catch…finally语句块</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//try块中放可能发生异常的代码。</span>     <span class="token comment" spellcheck="true">//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span>     <span class="token comment" spellcheck="true">//如果发生异常，则尝试去匹配catch块。</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span>    <span class="token comment" spellcheck="true">//catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span>    <span class="token comment" spellcheck="true">//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span>    <span class="token comment" spellcheck="true">//如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span>    <span class="token comment" spellcheck="true">//如果try中没有发生异常，则所有的catch块将被忽略。</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//finally块通常是可选的。</span>   <span class="token comment" spellcheck="true">//无论异常是否发生，异常是否匹配被处理，finally都会执行。</span>   <span class="token comment" spellcheck="true">//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span>  <span class="token comment" spellcheck="true">//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span><span class="token punctuation">}</span></code></pre><p><strong>需要注意的地方</strong></p><p>1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p><p>2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。</p><p>3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。<br>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）<br>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol><li>不管有没有出现异常，finally块中代码都会执行；</li><li>当try和catch中有return时，finally仍然会执行；</li><li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li><li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li></ol><p><strong>举例：</strong></p><p>情况1. try{} catch(){}finally{} return;<br>显然程序按顺序执行。</p><p>情况2. :try{ return; }catch(){} finally{} return;<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，最后执行try中return;</p><p>finally块之后的语句return，因为程序在try中已经return所以不再执行。</p><p>情况3. :try{ } catch(){return;} finally{} return;<br>程序先执行try，如果遇到异常执行catch块，<br>有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，<br>最后执行catch块中return. finally之后也就是4处的代码不再执行。<br>无异常：执行完try再finally再return.</p><p>情况4:try{ return; }catch(){} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p><p>情况5:try{} catch(){return;}finally{return;}<br>程序执行catch块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p><p>情况6:try{ return;}catch(){return;} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；<br>则再执行finally块，因为finally块中有return所以提前退出。<br>无异常：则再执行finally块，因为finally块中有return所以提前退出。</p><p>最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。<br>如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，<br>编译器把finally中的return实现为一个warning。</p><p>也就是说，如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）</p><p>下面是个测试程序</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            x<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>            <span class="token operator">++</span>x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果是2。<br>    在try语句中，在执行return语句时，要返回的结果已经准备好了，就在此时，程序转到finally执行了。<br>在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，<br>因此，即使finally中对变量x进行了改变，但是不会影响返回结果。<br>它应该使用栈保存返回值。<br><strong>finally中的return 会覆盖 try 或者catch中的返回值。</strong></p><h4 id="throws-函数声明"><a href="#throws-函数声明" class="headerlink" title="throws 函数声明"></a>throws 函数声明</h4><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p><p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p><p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ExceptionType1<span class="token punctuation">,</span> ExceptionType2<span class="token punctuation">,</span> ExceptionTypeN <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span><span class="token punctuation">}</span></code></pre><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        String s <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NumberFormatException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h4><p>通过上面的两个demo可以得知：</p><p>1、throw用在方法体内，上面代码显示了，是直接在main方法体内</p><p>   throws用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。这个看上面的代码就理解了</p><p>2、throw是具体向外抛异常的，抛出的是一个异常实例</p><p>   throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常</p><p>3、throw，如果执行了，那么一定是抛出了某种异常了，安生throws表示可能出现，但不一定。</p><p>4、同时出现的时候，throws出现在函数头、throw出现在函数体，两种不会由函数去处理，真正的处理由函数的上层调用处理</p><h4 id="for-中try还是for外try"><a href="#for-中try还是for外try" class="headerlink" title="for 中try还是for外try"></a>for 中try还是for外try</h4><p>try放在for循环的里面所有的for循环都会执行，当遇到异常时，抛出异常继续执行；放在外面，当遇到异常时，抛出异常，后面的循环就会终止，并不会执行。</p><h3 id="6、-变量命名规范"><a href="#6、-变量命名规范" class="headerlink" title="6、 变量命名规范"></a>6、 变量命名规范</h3><p>首字母：字母、$和下划线。变量名：由$、字母、数字和下划线组成。</p><h3 id="7、方法重载与方法重写"><a href="#7、方法重载与方法重写" class="headerlink" title="7、方法重载与方法重写"></a>7、方法重载与方法重写</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc2.png" alt=""></p><h3 id="8、继承-封装-多态-抽象"><a href="#8、继承-封装-多态-抽象" class="headerlink" title="8、继承 封装 多态 抽象"></a>8、继承 封装 多态 抽象</h3><p>1、请描述一下java</p><p>java是一个面向对象的编程语言，有继承 封装 多态的特性，同时java也是一开源的语言，一次编译到处运行，有很完善的生态系统，包括各种各样的企业级框架。</p><p>2、抽象</p><p>抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。</p><p>3、封装</p><blockquote><p> 1）将实例变量标记为私有的（private），表示只能在类的内部使用。 <br><br>   2）提供公有（public）的get和set方法，用来控制对实例变量的存取动作。</p></blockquote><p>   封装的目的是：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。</p><p>4、继承</p><p>目的：实现代码的复用。</p><p>继承是从已有的类得到继承信息创建新的类的过程，继承可以表示为 is-a 关系 。父类的私有属性和构造方法并不能被继承。另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。</p><p>5、多态</p><p>多态可以大概分为两种方式：方法重载与方法重写。</p><ul><li>方法重载（Overload）:编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致。</li><li>方法重写（Override）:运行时的多态（也称为后绑定）。<br>要实现方法重写需要做：1.方法重写，也就是子类继承父类并重写了父类已经有的方法。 2.用父类型引用来引用子类型对象，这样可以实现调用同样的方法会根据子类对象的不同表示出不一样的行为。</li></ul><h3 id="9、接口-amp-amp-抽象类"><a href="#9、接口-amp-amp-抽象类" class="headerlink" title="9、接口 &amp;&amp; 抽象类"></a>9、接口 &amp;&amp; 抽象类</h3><p>接口<br>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。<br>抽象类</p><p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：<br>abstract void fun() 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法</p><p>接口和抽象类的区别</p><p>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p><p>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p><p>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p><p>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>5）抽象类中的方法子类必须全部实现,不然子类也是抽象类,而接口中的抽象方法子类必须全部实现。</p><p>6）抽象类是一种模板设计模式,而接口是一种行为规范。</p><h3 id="10、自动类型转换和强制类型转换规则"><a href="#10、自动类型转换和强制类型转换规则" class="headerlink" title="10、自动类型转换和强制类型转换规则"></a>10、自动类型转换和强制类型转换规则</h3><ul><li>自动类型转换也叫隐式类型转换</li><li>表达式的数据类型自动提升</li><li>从低位类型到高位类型自动转换；从高位类型到低位类型需要强制类型转换：</li><li>boolean类型与其他基本类型不能进行类型的转换（既不能进行自动类型的提升，也不能强制类型转换）</li></ul><h3 id="11、选择结构"><a href="#11、选择结构" class="headerlink" title="11、选择结构"></a>11、选择结构</h3><ul><li>if</li><li>switch<blockquote><p>在switch 中可以使用的类型 Java支持的数据类型有五种<br>  他们分别是：<br>  byte、char、short、int、enum；<br>  以上是JDK1.6以前的版本。<br>  JDK1.7时，又增加了String</p></blockquote></li></ul><p>语法</p><pre><code>int is = 0;switch (is) {    case 1:        System.out.println("**");        break;    case 2:        break;    default:        System.out.println();        break;}</code></pre><ul><li>while</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先判断再执行</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"好好学习，天天向上！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 先执行再判断</span><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>for</li></ul><pre><code> for (int is = 0; is &lt; 100; is++) {     System.out.println("好好学习！"); }</code></pre><h3 id="12、break-amp-amp-continue"><a href="#12、break-amp-amp-continue" class="headerlink" title="12、break &amp;&amp; continue"></a>12、break &amp;&amp; continue</h3><pre><code>continue 作用：跳过循环体中剩余的语句而执行下一次循环break语句终止某个循环，程序跳转到循环块外的下一条语句</code></pre><h3 id="13、数组"><a href="#13、数组" class="headerlink" title="13、数组"></a>13、数组</h3><pre><code>public static void main(String[] args) {    //声明数组    String [] arr;    int arr1[];    //初始化数组    int arr2[]=new int[]{1,2,3,4,5};    String[] array1={"马超","马云","关羽","刘备","张飞"};    String[] array2=new String[]{"黄渤","张艺兴","孙红雷","小猪","牙哥","黄磊"};    String[] array=new String[5];    //查看数组的长度    int length=array1.length;    System.out.println("length：  "+array1.length);    //输出数组//      System.out.println(array1);     //结果：[Ljava.lang.String;@32f22097    System.out.println("arr2:  "+Arrays.toString(arr2));    //遍历数组    for (int i = 0; i &lt; array1.length; i++) {//          System.out.println(array1[i]);    }    //int数组转成string数组    int[]  array3={1,2,3,4,5,6,7,8,9,0};    String arrStrings=Arrays.toString(array3);//      System.out.println(arrStrings);    //从array中创建arraylist    ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;(Arrays.asList(array1));    System.out.println(arrayList);    //数组中是否包含某一个值    String a="马超";    if (Arrays.asList(array1).contains(a)) {        System.out.println("马超在这里");    }    //将数组转成set集合    Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(array2));    System.out.println(set);    //将数组转成list集合    List&lt;String&gt; list=new ArrayList&lt;String&gt;();    for (int i = 0; i &lt; array2.length; i++) {        list.add(array2[i]);    }    String[] arrStrings2={"1","2","3"};    List&lt;String &gt; list2=java.util.Arrays.asList(arrStrings2);    System.out.println(list2);    //Arrays.fill()填充数组    int[] arr3=new int[5];    Arrays.fill(arr3, 10);  //将数组全部填充10    for (int i = 0; i &lt; arr3.length; i++) {        System.out.println(arr3[i]);    }    //数组排序    int[] arr4 = {3, 7, 2, 1, 9};    Arrays.sort(arr4);    for (int i = 0; i &lt; arr4.length; i++) {        System.out.println(arr4[i]);    }    int[] arr5 = {3, 7, 2, 1, 9,3,45,7,8,8,3,2,65,34,5};    Arrays.sort(arr5, 1, 4);  //从第几个到第几个之间的进行排序    for (int i = 0; i &lt; arr5.length; i++) {        System.out.println(arr5[i]);    }    //复制数组    int[] arr6 = {3, 7, 2, 1};    int[] arr7=Arrays.copyOf(arr6, 10);  //指定新数组的长度    int[] arr8=Arrays.copyOfRange(arr6, 1, 3); //只复制从索引[1]到索引[3]之间的元素（不包括索引[3]的元素）    for (int i = 0; i &lt; arr8.length; i++) {        System.out.println(arr8[i]);    }    //比较两个数组    int[] arr9 = {1, 2, 3, 4,5,6,7,8,9,0};    boolean arr10=Arrays.equals(arr6, arr9);    System.out.println(arr10);    //去重复    //利用set的特性    int[] arr11 = {1, 2, 3, 4,5,6,7,8,9,0,3,2,4,5,6,7,4,32,2,1,1,4,6,3};    Set&lt;Integer&gt; set2=new HashSet&lt;Integer&gt;();    for (int i = 0; i &lt; arr11.length; i++) {        set2.add(arr11[i]);    }        System.out.println(set2);    int[] arr12 = new int[set2.size()];    int j=0;    for (Integer i:set2) {        arr12[j++]=i;    }    System.out.println(Arrays.toString(arr12));}</code></pre><h3 id="14、String-StringBuffer-StringBuilder"><a href="#14、String-StringBuffer-StringBuilder" class="headerlink" title="14、String StringBuffer StringBuilder"></a>14、String StringBuffer StringBuilder</h3><ul><li>String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</li><li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li><li>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li></ul><p><strong>String，StingBuffer，StringBuilder效率如何呢</strong></p><p>从高到底的顺序依次是：StringBuilder  &gt;  StingBuffer &gt; String</p><p>&nbsp; &nbsp; &nbsp; &nbsp;String是字符串常量，所以他的效率自然而然是最低的。对于StringBuffer和StringBuilder它们属于变量，是可以改变的对象，每次对字符串的操作，实际上实在一个对象上操作，所以效率更高一些。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;StringBuffer是线程安全的，考虑到安全问题，相对他的性能会更低一点。由此知道了从效率的角度看，StringBuilder最高，其次是StringBuffer，最后是String字符串常量。</p><p><strong>String 类的常用方法都有那些？</strong></p><ul><li>indexOf()：返回指定字符的索引</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h3 id="15、基本数据类型-amp-amp-包装类型"><a href="#15、基本数据类型-amp-amp-包装类型" class="headerlink" title="15、基本数据类型 &amp;&amp; 包装类型"></a>15、基本数据类型 &amp;&amp; 包装类型</h3><table><thead><tr><th>基本类型</th><th>包装器类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc8.png" alt=""></p><p>拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc9.png" alt=""></p><h4 id="2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"><a href="#2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆" class="headerlink" title="2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"></a>2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆</h4><ul><li>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</li><li>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</li><li>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</li><li>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</li></ul><h4 id="3、基本类型出现的原因"><a href="#3、基本类型出现的原因" class="headerlink" title="3、基本类型出现的原因"></a>3、基本类型出现的原因</h4><p>在Java编程思想的第一章就讲到：万物皆对象，new一个对象存储在堆中，我们通过堆栈的引用来使用这些对象，但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在堆栈中，因此更加高效。</p><h4 id="4、包装类型出现的原因"><a href="#4、包装类型出现的原因" class="headerlink" title="4、包装类型出现的原因"></a>4、包装类型出现的原因</h4><p>Java是一个面向对象的语言，基本类型并不具有对象的性质，为了与其他对象“接轨”就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p><h3 id="16、java日期处理"><a href="#16、java日期处理" class="headerlink" title="16、java日期处理"></a>16、java日期处理</h3><h4 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h4><blockquote><p>Date类用来指定日期和时间，其构造函数及常用方法如下：<br><br>public Date()从当前时间构造日期时间对象。<br><br>public String toString()转换成字符串。<br><br>public long getTime()它包含的是一个长整型数据long, 表示的是从GMT(格林尼治标准时间)1970年, 1 月 1日00:00:00这一刻之前或者是之后经历的毫秒数.</p></blockquote><h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><blockquote><p>通过向SimpleDateFormat 的构造函数传递格式字符串“yyyy-MM-dd”,<br>yyyy是年,MM是月,dd是日. 字符的个数决定了日期是如何格式化的.传递“yy-MM-dd”会显示 13-2-22</p></blockquote><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc11.png" alt=""></p><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><blockquote><p>Calendar类主要用于完成日期字段之间的相互操作的功能 <br><br>Calendar类是一个抽象基类,不能new，我们可以通过Calendar.getInstance得到其实例，下面列出Calendar的一些常用方法：<br><br>set(int year, int month, int date)设置日历字段 <br><br>set(int field, int value) 将给定的日历字段设置为给定值 <br><br>get(int field)返回给定日历字段的值 <br><br>getTime()返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的 Date 对象。</p></blockquote><h5 id="Calendar示例"><a href="#Calendar示例" class="headerlink" title="Calendar示例"></a>Calendar示例</h5><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc10.png" alt=""></p><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul><li>abs()返回某数字的绝对值.</li><li>ceil()会找到下一个最大整数。</li><li>floor()返回紧邻的最小整数。</li><li>max()返回两个值中的最大值。</li><li>min()返回两个值中的最小值。</li><li>random()返回一个随机数，在0.0到1.0之间的双精度数。</li><li>round()返回与某浮点数值最接近的整数值。</li><li>sqrt()返回某数值的平方根。</li></ul><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><blockquote><p>Random类 伪随机数产生器。</p></blockquote><p>常用方法:</p><ul><li>public boolean nextBoolean()<br>该方法的作用是生成一个随机的boolean值。</li><li>public double nextDouble()<br>该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。</li><li>public int nextInt()<br>该方法的作用是生成一个随机的int值。</li><li>public int nextInt(int n)<br>该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。</li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 将日期解析为指定格式的字符串     */</span>    Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 将字符串解析为日期对象     */</span>    SimpleDateFormat sim <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String ss <span class="token operator">=</span> <span class="token string">"2020-01-01"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Date parse <span class="token operator">=</span> sim<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parse<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sim<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ParseException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Calendar使用     */</span>    Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Date time <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 设置日期     */</span>    calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Random随机数     */</span>    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc12.png" alt=""></p><h3 id="17-集合框架"><a href="#17-集合框架" class="headerlink" title="17.集合框架"></a>17.集合框架</h3><p>** 什么是集合 **</p><blockquote><p>通常情况下，把具有相同性质的一类东西，汇聚成一个整体，就可以称为集合。</p></blockquote><p>** 什么是集合框架 **</p><blockquote><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p></blockquote><ul><li>接口：即表示集合的抽象数据类型。</li><li>实现：也就是集合框架中接口的具体实现。</li><li>算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。</li></ul><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p>Java集合框架图。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc14.png" alt=""></p><p>1) 首先查看jdk中Collection类的源码后:</p><pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {</code></pre><p>通过查看可以发现Collection是一个接口类，其继承了java迭代接口Iterable</p><p><strong>Collection接口中的方法如下:</strong><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc13.png" alt=""></p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul><li><p>ArrayList底层其实就是一个Object类型的数组，非线程安全的集合。查询元素快，插入，删除中间元素慢，初始化的长度为10，每次扩容为原大小的1.5倍，可以通过构造方法改变初始容量大小。</p></li><li><p>ArrayList快在下标定位，慢在数组复制。</p></li><li><p>由于每次添加的时候，通过扩容机制判断原数组是否还有空间，若没有则重新实例化一个空间更大的新数组，把旧数组的数据拷贝到新数组中，耗费时间和性能</p></li></ul><p><strong>Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0，JDK差异，每次约按1.5倍扩容。 JDK8 中ArrayList扩容的实现是通过grow()方法里使用语句newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)（即1.5倍扩容）计算容量，然后调用Arrays.copyof()方法进行对原数组进行复制。</strong></p><p><strong>若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</strong></p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote><p><font size="3"> 基于数组实现的线程安全的集合。线程同步（方法被synchronized修饰），性能比ArrayList差。 </font></p></blockquote><font size="4">Vector 的数据结构和使用方法与ArrayList差不多。最大的不同就是Vector是线程安全的。几乎所有的对数据操作的方法都被synchronized关键字修饰。synchronized是线程同步的，当一个线程已经获得Vector对象的锁时，其他线程必须等待直到该锁被释放。从这里就可以得知Vector的性能要比ArrayList低。若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</font><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>基于双向循环链表实现的非线程安全的集合。查询元素慢，插入，删除中间元素快。</p><h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</p><h4 id="几种集合的区别"><a href="#几种集合的区别" class="headerlink" title="几种集合的区别"></a>几种集合的区别</h4><p>ArrayList查询快，写数据慢；LinkedList查询慢，写数据快<br>ArrayList查询快是因为底层是由数组实现，通过下标定位数据快。写数据慢是因为复制数组耗时。LinkedList底层是双向循环链表，查询数据依次遍历慢。写数据只需修改指针引用。<br>ArrayList和LinkedList都不是线程安全的，小并发量的情况下可以使用Vector，若并发量很多，且读多写少可以考虑使用CopyOnWriteArrayList。</p><h4 id="遍历list集合"><a href="#遍历list集合" class="headerlink" title="遍历list集合"></a>遍历list集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * for循环遍历     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * foreach遍历     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过迭代器遍历     */</span>    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>[set][1]</p><blockquote><p>在选择的时候，如果顺序很重要，则可以选择TreeSet，如果操作性能和时间效率很重要的话，则可以选择HashSet</p></blockquote><ul><li><p>HashSet集合</p><blockquote><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置，存取速度比较快。</p></blockquote><ul><li>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树，底层实际上是一个HashMap。</li><li>所以可以直接总结出：HashSet实际上就是封装了HashMap，操作HashSet元素实际上就是操作HashMap。这也是面向对象的一种体现，重用性贼高！</li><li>无序，允许为null，，有且仅有一个元素为null！</li><li>线程不安全的。</li><li>HashSet还有一个子类LinkedHashSet</li></ul></li><li><p>TreeSet集合</p><ul><li>底层数据结构是红黑树(是一个自平衡的二叉树)</li><li>有排序功能，支持两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</li><li>有序，不允许为null</li><li>线程不安全的。</li></ul></li><li><p>LinkedHashSet集合</p><ul><li>迭代是有序的</li><li>允许为null，有且仅有一个元素为null！</li><li>底层实际上是一个HashMap+双向链表实例(其实就是LinkedHashMap)</li><li>线程不安全的。</li><li>性能比HashSet差一丢丢，因为要维护一个双向链表</li><li>初始容量与迭代无关，LinkedHashSet迭代的是双向链表</li></ul></li></ul><h4 id="遍历set集合"><a href="#遍历set集合" class="headerlink" title="遍历set集合"></a>遍历set集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 迭代器遍历方式     */</span>    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 遍历     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str<span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="set-和list的区别"><a href="#set-和list的区别" class="headerlink" title="set 和list的区别"></a>set 和list的区别</h4><ul><li>List接口：存储一组不唯一，有序的对象</li><li>Set接口：存储一组唯一，无序的对象</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>*<em>Map接口不是继承Collection接口；Map接口用于维护键／值对（key/value pairs），他的实现类有: *</em><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc15.png" alt=""></p><h4 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc16.png" alt=""></p><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p><strong>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</strong></p><h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><p>! 从Hashtable的命名规范就可以看出，t没有大写，并不是我写错了</p><p>底层是哈希表数据结构，不可以存入null键null值。该集合是线程同步的。</p><h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。</p><h5 id="LinkedHashMap："><a href="#LinkedHashMap：" class="headerlink" title="LinkedHashMap："></a>LinkedHashMap：</h5><p>该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>该类是线程安全的 Map 实现。与 Hashtable 相似，但 Hashtable 的 synchronized 是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对 hash 表的不同部分进行的修改。ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p><h4 id="遍历map集合"><a href="#遍历map集合" class="headerlink" title="遍历map集合"></a>遍历map集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 第二种     */</span>    <span class="token comment" spellcheck="true">//遍历map中的键</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历map中的值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 迭代器     */</span>    Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过键找值遍历（效率低）     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="三种集合在实际工作用到的地方"><a href="#三种集合在实际工作用到的地方" class="headerlink" title="三种集合在实际工作用到的地方"></a>三种集合在实际工作用到的地方</h4><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>容器指的是集合框架</p><p>同步容器是通过syncrhoized关键字对线程不安全的操作进行加锁来保证线程安全的，其原理是使得多线程轮流获取同步锁进行对集合的操作，所以性能有所下降。，像Vector、Hashtable、Stack。</p><p> 为此，java.util.concurrent提供了多种并发容器，以：在原有集合的拷贝上进行操作，用修改后的集合替换原集合  的方式来达到并发且安全地使用集合类的目的。</p><pre><code>根据接口的类型，主要有以下四种接口，其他具体的容器均是对这些接口的实现类：</code></pre><p>Queue类型：阻塞队列BlockingQueue、非阻塞队列ConcurrentLinkedQueue</p><p>Map类型：ConcurrentMap</p><p>Set类型：ConcurrentSkipListSet、CopyOnWriteArraySet</p><p>List类型：CopyOnWriteArrayList</p><h4 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h4><font size="3"><p>　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>　　<br>　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p></font><h3 id="hascode"><a href="#hascode" class="headerlink" title="hascode"></a>hascode</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>根据这个方法的声明可知，它是一个本地方法，它的实现与本地机器有关，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p><p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及Hashtable，如果没有很好的覆写键的hashcode()和equals()方法，那么将无法正确的处理键。</p><p>　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）—–HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。</p><p>所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。</p><h3 id="18、泛形"><a href="#18、泛形" class="headerlink" title="18、泛形"></a>18、泛形</h3><p><strong>什么是泛型</strong></p><pre><code>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</code></pre><h4 id="泛形方法"><a href="#泛形方法" class="headerlink" title="泛形方法"></a>泛形方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 说明： * 1）&lt;E>非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;E>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;E>表明该方法将使用泛型类型E，此时才可以在方法中使用泛型类型E。 * 4）与泛型类的定义一样，此处E可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 * * @param inputArray * @param &lt;E> */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 输出数组元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>E element <span class="token operator">:</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="泛形类"><a href="#泛形类" class="headerlink" title="泛形类"></a>泛形类</h4><h4 id="泛形接口"><a href="#泛形接口" class="headerlink" title="泛形接口"></a>泛形接口</h4><h4 id="泛形通配符：？"><a href="#泛形通配符：？" class="headerlink" title="泛形通配符：？"></a>泛形通配符：？</h4><h4 id="泛形的限定"><a href="#泛形的限定" class="headerlink" title="泛形的限定"></a>泛形的限定</h4><p>我们知道使用泛型类时：如果明确参数类型，那么泛型就代表一种类型；如果使用通配符？，那么泛型就代表任意类型。但有时候我们希望指定某些类型(不是一个，也不要所有)能作为参数类型，这应该怎么办呢？</p><pre><code>    Java中利用泛型的限定解决了这个问题，即泛型的限定。我们只需要按这样的格式书写：   上限：&lt;？ extends E&gt;表示参数类型是E及其所有子类。   下限：&lt;? super E&gt;表示参数类型是E及其所有超类(即父类)。</code></pre><h4 id="Java泛型中E、T、K、V等的含义"><a href="#Java泛型中E、T、K、V等的含义" class="headerlink" title="Java泛型中E、T、K、V等的含义"></a>Java泛型中E、T、K、V等的含义</h4><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)（集合泛形）</li><li>T - Type（Java 类）（接口）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ -  表示不确定的java类型</li></ul><h3 id="19、枚举"><a href="#19、枚举" class="headerlink" title="19、枚举"></a>19、枚举</h3><p>enum 的全称为 enumeration， 是 JDK 1.5  中引入的新特性，存放在 java.lang 包中，另外到了JDK1.6后switch语句支持枚举类型。</p><p><a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71333103</a></p><h3 id="20、io流"><a href="#20、io流" class="headerlink" title="20、io流"></a>20、io流</h3><p>Java中使用IO(输入输出）来读取和写入，读写设备上的数据、硬盘文件、内存、键盘……，根据数据的走向可分为输入流和输出流，这个走向是以内存为基准的，即往内存中读数据是输入流，从内存中往外写是输出流。</p><p><strong>根据处理的数据类型可分为字节流和字符流</strong></p><p>  1.字节流可以处理所有数据类型的数据，在java中以Stream结尾</p><p>  2.字符流处理文本数据，在java中以Reader和Writer结尾。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc17.png" alt=""></p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="输入流-InputStream"><a href="#输入流-InputStream" class="headerlink" title="输入流 InputStream"></a>输入流 InputStream</h5><p><strong>API</strong></p><ul><li>int read( )    读取一个字节，返回值为所读的字节</li><li>int read( byte b[ ] )   读取多个字节，放置到字节数组b中，通常读取的字节数量为b的长度，返回值为实际读取的字节的数量</li><li>int read( byte b[ ], int off, int len )   读取len个字节，放置到以下标off开始字节数组b中，返回值为实际读取的字节的数量</li><li>int available( )   返回值为流中尚未读取的字节的数量</li><li>long skip( long n )   读指针跳过n个字节不读，返回值为实际跳过的字节数量</li><li>close( )   流操作完毕后必须关闭</li></ul><p>代码</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    InputStream inputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将读取到的一个字节给i，中文占两个字节</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 关闭流</span>            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="输出流-OutputStream"><a href="#输出流-OutputStream" class="headerlink" title="输出流 OutputStream"></a>输出流 OutputStream</h5><p><strong>API</strong></p><ul><li>void write( int b ); 　　//往流中写一个字节b</li><li>void write( byte b[ ] ); //往流中写一个字节数组b</li><li>void write( byte b[ ], int off, int len );  把字节数组b中从下标off开始，长度为len的字节写入流中</li><li>flush( )  刷空输出流，并输出所有被缓存的字节由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li><li>close( ) 流操作完毕后必须关闭 </li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 没有则会创建文件</span>    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    OutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>        os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"超哥"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 关闭流</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="输入流-Reader"><a href="#输入流-Reader" class="headerlink" title="输入流 Reader"></a>输入流 Reader</h5><p><strong>API</strong></p><ul><li>int read() throws IOException;  读取一个字符，返回值为读取的字符</li><li>int read(char cbuf [  ]) throws IOException; 读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</li><li>abstract int read( char cbuf[ ] , int off , int len) throws IOException;   读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</li><li>boolean markSupported( ); 判断当前流是否支持做标记</li><li>void mark ( int readAheadLimit ) throws IOException;   给当前流作标记，最多支持readAheadLimit个字符的回溯。</li><li>void reset( ) throws IOException;    将当前流重置到做标记处</li><li>abstract void close( ) throws IOException;   关闭</li></ul><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Reader os <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 关闭流</span>            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="输出流-Writer"><a href="#输出流-Writer" class="headerlink" title="输出流 Writer"></a>输出流 Writer</h5><p><strong>API</strong></p><ul><li>void write (int c) throws IOException； 将整型值c的低16位写入输出流</li><li>void write ( String str ) throws IOException； 将字符串str中的字符写入输出流</li><li>void write( char cbuf[ ] )  throws IOException；  将字符数组cbuf[]写入输出流</li><li>abstract void write( char cbuf[ ] , int off , int len) throws IOException； 将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流</li><li>void write( String str , int off , int len) throws IOException；  将字符串str 中从索引off开始处的len个字符写入输出流</li><li>flush( )   刷空输出流，并输出所有被缓存的字节。</li><li>close( )  关闭流</li></ul><h4 id="字节、字符流转换类"><a href="#字节、字符流转换类" class="headerlink" title="字节、字符流转换类"></a>字节、字符流转换类</h4><p>字节转为字符流</p><blockquote><p>字符 不需要转为字节流，字节流可以读取任意数据，而字符读取内容有限。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将字节流转换为字符流</span>        InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h5 id="缓冲流介绍"><a href="#缓冲流介绍" class="headerlink" title="缓冲流介绍"></a>缓冲流介绍</h5><blockquote><p>普通的字节、字符流都是一个字节一个字符这样读取的,而缓冲流则是将数据先缓冲起来,然后一起写入或者读取出来。<br>缓冲流为I/O流增加了内存缓冲区，使用缓冲流的好处是，能够更高效的读写信息。缓冲流要“套接”在相应的节点流(低级流)之上，对读写的数据提供了缓冲的功能。<br>缓冲输入流支持其父类的mark()和reset()方法：mark()用于“标记”当前位置，就像加入了一个书签，可以使用reset()方法返回这个标记重新读取数据</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 字节缓冲流</span>        BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>J2SDK提供了四种缓存流：<br><font size="4"><br><strong>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter</strong> </font></p><h5 id="缓冲流字节流"><a href="#缓冲流字节流" class="headerlink" title="缓冲流字节流"></a>缓冲流字节流</h5><pre><code>java.io.BufferedInputStream类可以对任何的InputStream流进行带缓冲的封装以达到性能的改善。该类在已定义输入流上再定义一个具有缓冲的输入流，可以从此流中成批地读取字符而不会每次都引起直接对数据源的读操作。数据输入时，首先被放入缓冲区，随后的读操作就是对缓冲区中的内容进行访问java.io.BufferedOutputStream不直接写入输出流，先写入缓冲区，当缓冲区满时，字节数据才会写到BufferedOutputStream所连接的流，调用该类的flush()将缓冲区全部写入输出流</code></pre><h3 id="21、序列化"><a href="#21、序列化" class="headerlink" title="21、序列化"></a>21、序列化</h3><h4 id="对象序列化概述"><a href="#对象序列化概述" class="headerlink" title="对象序列化概述"></a>对象序列化概述</h4><blockquote><p>一般地，对象不能脱离应用程序。但有时候，需要将对象的状态保存下来，在需要时再将对象恢复，即对象持久化（Persistence）。对象序列化（Object Serialization）可以将对象存储到外存中或以二进制形式通过网络传输。对象反串行化可以从这些数据中重构一个与原始对象状态相同的对象<br>为了实现对象系列化，对应的类必须实现下面的两种接口之一：<br>Serializable<br>Externalizable</p></blockquote><h4 id="将对象保存到磁盘文件"><a href="#将对象保存到磁盘文件" class="headerlink" title="将对象保存到磁盘文件"></a>将对象保存到磁盘文件</h4><ul><li>通过java.io.ObjectOutputStream可以将对象输出到磁盘文件、网络等设备</li><li>调用这个类的writeObject()方法，可以向特定的文件或网络输出对象</li><li>writeObject()方法序列化指定的对象，并遍历该对象对其它对象的引用，递归的序列化所有被引用到的其它对象，从而建立一个完整的序列化流</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        OutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Student需要序列化</span>        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setI</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="从磁盘读出保存的对象"><a href="#从磁盘读出保存的对象" class="headerlink" title="从磁盘读出保存的对象"></a>从磁盘读出保存的对象</h4><ul><li>通过java.io.ObjectInputStream对象可以从磁盘文件中读出保存的对象（或从网络中读出传递的对象）</li><li>调用这个类的readObject()方法，从特定的设备读出对象readObject()方法反序列化输入流中的对象，遍历该对象中所有对其它对象的引用，并递归的反序列化这些引用对象</li><li>readObject()方法返回的是Object对象，所以，需要对它进行必要的（向下）造型操作。</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><ul><li>通过在属性前面加上transient关键字，限制属性写入到文件或网络中</li><li>还可以在未实现系列化接口的引用类型属性前面加上transient关键字，避免对此类属性进行递归系列化时出现java.io.NotSerializableException异常</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> String name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加一个transient修饰的属性</span></code></pre><p>什么被序列化<br>属性（包括基本数据类型、数组、对其它对象的引用）<br>类名<br>什么不被序列化<br>static的属性<br>方法<br>加了transient修饰符的属性</p><h3 id="22、多线程"><a href="#22、多线程" class="headerlink" title="22、多线程"></a>22、多线程</h3><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7526608.html</a></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt="image"></p><h4 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h4><table><thead><tr><th>术语</th><th>英文单词</th><th>描述</th></tr></thead><tbody><tr><td>共享变量</td><td></td><td>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。</td></tr><tr><td>内存屏障</td><td>Memory Barriers</td><td>是一组处理器指令，用于实现对内存操作的顺序限制。</td></tr><tr><td>缓冲行</td><td>Cache line</td><td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td></tr><tr><td>原子操作</td><td>Atomic operations</td><td>不可中断的一个或一系列操作。</td></tr><tr><td>缓存行填充</td><td>cache line fill</td><td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有）</td></tr><tr><td>缓存命中</td><td>cache hit</td><td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。</td></tr><tr><td>写命中</td><td>write hit</td><td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td></tr><tr><td>写缺失</td><td>write misses the cache</td><td>一个有效的缓存行被写入到不存在的内存区域。</td></tr></tbody></table><p><strong>什么是进程</strong></p><p>进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例。</p><p><strong>进程时间片的概念</strong></p><pre><code>一个操作系统中，如果同时运行着多个进程，他们是一定交替运行的。每个进程不管有没有运行完毕，都只占据一段时间的CPU。这个运行时间就是进程时间片。它非常短促，所以感觉不到他们是交替占用CPU。</code></pre><p><strong>什么是线程</strong></p><ul><li><p>线程：进程内部的控制流。它也是一段可运行的指令。</p></li><li><p>特点：资源占用小，线程间通信容易。</p></li><li><p>多进程是指操作系统能同时运行多个任务（程序）。</p></li></ul><p>多线程：</p><pre><code>指的是这个程序（一个进程）运行时产生了不止一个线程</code></pre><h4 id="线程进程的区别体现在几个方面："><a href="#线程进程的区别体现在几个方面：" class="headerlink" title="线程进程的区别体现在几个方面："></a>线程进程的区别体现在几个方面：</h4><p>第一：  因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p><p>第二：  体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p><p>3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p><p>4.线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；</p><p>5.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p><p>第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p><p>并行与并发：</p><pre><code>1.    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。2.    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。并发性（concurrency）和并行性（parallel）</code></pre><p><strong>线程的特点</strong></p><ul><li>线程的运行方式和进程一样，在同一个进程内部，线程也是交替占用CPU。每个线程的运行时间，称为线程时间片。</li><li>线程有开始、中间和结束部分，即有一定的生命周期。</li><li>同一个进程中的多个线程是共享一块内存空间和一组系统资源。</li><li>线程不能作为具体的可执行命令体存在。最终用户不能直接执行线程，线程只能运行在进程中。</li></ul><p><strong>如何创建线程</strong></p><pre><code>两种方法来创建线程：继承java.lang.Thread类，并覆盖run( )方法。 class mythread extends Thread {     public void run( ) {         /* 覆盖该方法*/      } }实现java.lang.Runnable接口，并实现run( )方法。class mythread implements Runnable{      @Override      public void run( ) {          /* 实现该方法*/      } }一个线程的对象只能执行一次start()方法</code></pre><p><strong>线程的启动</strong></p><ul><li><p>新建的线程不会自动开始运行，必须通过start( )方法启动线程。如果不调用这个方法，线程将不会运行。</p></li><li><p>也就是说可以事先创建线程，并在需要的时候才启动他们。如：</p><pre class=" language-java"><code class="language-java">  继承Thread的线程：Typer  t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Typer</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>实现Runnable接口的线程：<br>Runnable  mt =   new Typer ( );<br>Thread    t  =   new Thread(mt);// 父类的类型子类的对象<br>t.start( );</p><pre><code>**线程执行过程**- 调用start( )方法时，将创建一个新的线程，并为线程分配系统资源，如内存。接着它将调用 run( ) 方法。- run( ) 方法中的代码定义执行线程所需的功能。    - run()方法能够调用其他方法，引用其他的类，申明变量。    - run()方法在程序中确定另一个并发线程的执行入口。- 当run()方法中的任务完成返回时，该线程也将结束。**注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。从程序运行的结果可以发现，多线程程序是乱序执行。**#### Thread和Runnable的区别实现Runnable接口比继承Thread类所具有的优势：- 适合多个相同的程序代码的线程去处理同一个资源- 可以避免java中的单继承的限制- 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立- 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类#### 线程状态下面的这个图非常重要!![](https://raw.githubusercontent.com/Flyiyu/use/master/jc18.jpg)1. 新建状态（New）：新创建了一个线程对象。2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：    - 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持    有的锁)    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。    - 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。#### 线程调度线程的调度1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：static int MAX_PRIORITY    线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY    线程可以具有的最低优先级，取值为1。static int NORM_PRIORITY          分配给线程的默认优先级，取值为5。Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。#### 守护线程1. 定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。2. 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。3. 设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。4. 在 Daemon 线程中产生的新线程也是 Daemon 的。5. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。6. example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。7. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。##### yield()、sleep()、join()和interrupt()方法   1、yield()　　　&amp;ensp;&amp;ensp;yield()是Thread类的静态方法。它能让当前线程暂停，但不会阻塞该线程，而是由“运行状态”进入到“就绪状态”，从而让 其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是 当前线程又进入到“运行状态”继续运行！　　值得注意的是，yield()方法不会释放锁。2、sleep()　　&amp;ensp;&amp;ensp;sleep()是Thread类的静态方法。该方法声明抛出了InterrupedException异常。所以使用时，要么捕捉，要么声明抛出。　　有2种重载方式：——static void sleep(long millis)　　:　　让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。——static void sleep(long millis , int nanos)　　：　　让当前正在执行的线程暂停millis毫秒加nanos微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。　　sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。常用来暂停程序的运行。　　　　同时注意，sleep()方法不会释放锁。3、join()　　join() 是Thread的一个实例方法。表示，当某个程序执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join的线程执行完毕。有3种重载的形式：——join()　　:　　等待被join的线程执行完成——join(long millis)　　：　　等待被join的线程的时间最长为millis毫秒，若在millis毫秒内，被join的线程还未执行结束，则不等待。——join(long millis , int nanos)　　:　　等待被join的线程的时间最长为millis毫秒加nanos微秒，若在此时间内，被join的线程还未执行结束，则不等待。&amp;ensp;&amp;ensp;即当前线程内，用某个线程对象调用join()后，会使当前线程等待，直到该线程对象的线程运行完毕，原线程才会继续运行。4、interrupt()　　　　　我们经常通过判断线程的中断标记来控制线程。　 　　　&amp;ensp;&amp;ensp;interrupt()是Thread类的一个实例方法，用于中断本线程。这个方法被调用时，会立即将线程的中断标志设置为“true”。所以当中断处于“阻塞状态”的线程时，由于处于阻塞状态，中断标记会被设置为“false”，抛出一个 InterruptedException。所以我们在线程的循环外捕获这个异常，就可以退出线程了。　&amp;ensp;&amp;ensp;interrupt()并不会中断处于“运行状态”的线程，它会把线程的“中断标记”设置为true，所以我们可以不断通过isInterrupted()来检测中断标记，从而在调用了interrupt()后终止线程，这也是通常我们对interrupt()的用法。　　&amp;ensp;&amp;ensp;Interrupted()是Thread类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，isInterrupted()是Thread类的实例方法，返回一个布尔类型来判断线程是否已经被中断。它们都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。　　　　　　#### start 与 run 区别1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。2. 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。3. 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。#### Synchronized关键字synchronized是一个重量级锁，相对于Lock，它会显得那么笨重 诚然，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。  1、同步和异步的区别和联系 　　&amp;ensp;&amp;ensp;所谓同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其它的命令。&amp;ensp;&amp;ensp;异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 &amp;ensp;&amp;ensp;同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行(死心眼)。异步在一定程度上可以看做是多线程的，请求一个方法后，就不管了，继续执行其他的方法。1、原理**在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。**　　&amp;ensp;&amp;ensp;当当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。　　&amp;ensp;&amp;ensp;不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。例如，现在有个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。2、基本规则　　&amp;ensp;&amp;ensp;第一条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。　　&amp;ensp;&amp;ensp;第二条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。　&amp;ensp;&amp;ensp;第三条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。1、普通同步方法，锁是当前实例对象2、静态同步方法，锁是当前类的class对象3、同步方法块，锁是括号里面的对象3、实例锁和全局锁&amp;ensp;&amp;ensp;实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。               实例锁对应的就是synchronized关键字。&amp;ensp;&amp;ensp;全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。               全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。&amp;ensp;&amp;ensp;就是说，一个非静态方法上的synchronized关键字，代表该方法依赖其所属对象。一个静态方法上synchronized关键字，代表该方法依赖这个类本身。#### synchronized, wait, notify结合:典型场景生产者消费者问题```java/**   * 生产者生产出来的产品交给店员   */  public synchronized void produce()  {      if(this.product &gt;= MAX_PRODUCT)      {          try          {              wait();                System.out.println("产品已满,请稍候再生产");          }          catch(InterruptedException e)          {              e.printStackTrace();          }          return;      }      this.product++;      System.out.println("生产者生产第" + this.product + "个产品.");      notifyAll();   //通知等待区的消费者可以取出产品了  }  /**   * 消费者从店员取产品   */  public synchronized void consume()  {      if(this.product &lt;= MIN_PRODUCT)      {          try           {              wait();               System.out.println("缺货,稍候再取");          }           catch (InterruptedException e)           {              e.printStackTrace();          }          return;      }      System.out.println("消费者取走了第" + this.product + "个产品.");      this.product--;      notifyAll();   //通知等待去的生产者可以生产产品了  }</code></pre><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="Volatile的官方定义"><a href="#Volatile的官方定义" class="headerlink" title="Volatile的官方定义"></a>Volatile的官方定义</h5><p>  Java语言规范第三版中对volatile的定义如下：<br>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>  volatile这个关键字。其实这个关键字有两层语义。第一层语义就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化。我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。</p><p><strong>Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</strong></p><h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><p>　　为什么出现这种情况呢，我们需要先了解一下JMM（java内存模型）</p><p>　　java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><p>　　JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc31.png" alt=""></p><p>　需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p><p>  那么这种共享变量在多线程模型中的不可见性如何解决呢？比较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，有点炮打蚊子的意思。比较合理的方式其实就是volatile</p><h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><h5 id="ThreadLocal概念"><a href="#ThreadLocal概念" class="headerlink" title="ThreadLocal概念"></a>ThreadLocal概念</h5><p>ThreadLocal 是线程的局部变量， 是每一个线程所单独持有的，其他线程不能对其进行访问。</p><p>  ThreadLocal，直译为“线程本地”或“本地线程”，如果你真的这么认为，那就错了！其实，它就是一个容器，用于存放线程的局部变量，我认为应该叫做 ThreadLocalVariable（线程局部变量）才对，真不理解为什么当初 Sun 公司的工程师这样命名。</p><p>  当使用ThreadLocal维护变量的时候 为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。</p><p>  但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p><p><strong>跳出误区</strong></p><p>  需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p><h5 id="ThreadLocal常用方法介绍"><a href="#ThreadLocal常用方法介绍" class="headerlink" title="ThreadLocal常用方法介绍"></a>ThreadLocal常用方法介绍</h5><p>public void set(T value)：将值放入线程局部变量中</p><p>public T get()：从线程局部变量中获取值</p><p>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</p><p>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </p><p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要自己来实现的，给这个线程局部变量一个初始值吧。</p><h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><pre><code>Runnable r[] = new Runnable[2];</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc25.jpg" alt=""></p><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>  如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>  那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？  在Java中可以通过线程池来达到这样的效果.</p><p>  合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p><p>下为常见的四种：</p><ol><li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li><li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li><li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li><li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li></ol><h4 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h4><blockquote><p>阻塞队列提供了可阻塞的入队和出对操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用；</p></blockquote><p>在Java中，主要有以下类型的阻塞队列：</p><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个支持延时获取元素的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 </li></ul><h4 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h4><h3 id="JAVA-锁"><a href="#JAVA-锁" class="headerlink" title="JAVA 锁"></a>JAVA 锁</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>  乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为<br>别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数<br>据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），<br>如果失败则要重复读-比较-写的操作。</p><p>  java 中的乐观锁基本都是通过 CAS 操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>  悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人<br>会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。<br>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，<br>才会转换为悲观锁，如 RetreenLock。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>  自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁<br>的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>  线程自旋是需要消耗 cpu 的，说白了就是让 cpu 在做无用功，如果一直获取不到锁，那线程<br>也不能一直占用 cpu 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁<br>的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><p><strong>自旋锁的优缺点</strong></p><p>  自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来<br>说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p><p>  但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合<br>使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p><p><strong>自旋锁时间阈值（1.6 引入了适应性自旋锁）</strong></p><p>  自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择<br>自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p><h5 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h5><p>  synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重<br>入锁</p><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>  ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完<br>成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等<br>避免多线程死锁的方法。</p><h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><p>  首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有<br>AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，<br>区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所<br>有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。</v></p><p>  通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些<br>同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger<br>的性能是 ReentantLock 的好几倍。</p><h5 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h5><p>  本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫<br>做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受<br>影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p><h5 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h5><p>  为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如<br>果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写<br>锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p><p>读锁<br>  如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p><p>写锁<br>  如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。<br>总之，读的时候上读锁，写的时候上写锁！<br>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现<br>ReentrantReadWriteLock。</p><h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>公平锁（Fair）</p><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁（Nonfair）<br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p><ol><li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li><li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li></ol><h5 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h5><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p><p>独占锁</p><p>  独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。<br>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线<br>程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p>共享锁</p><p>  共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种<br>乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等<br>待线程的锁获取模式。</li><li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，<br>或者被一个 写操作访问，但两者不能同时进行。</li></ol><h5 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（Mutex Lock）</h5><p>  Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又<br>是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用<br>户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么<br>Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为<br>“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。<br>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和<br>“偏向锁”。</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>  锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。<br>锁升级<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，<br>也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，<br>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量<br>级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场<br>景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀<br>为重量级锁。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>  Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线<br>程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起<br>来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级<br>锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换<br>ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所<br>以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻<br>量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进<br>一步提高性能</p><h5 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h5><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul><li>减少锁持有时间</li></ul><p>只用在有线程安全要求的程序上加锁</p><ul><li>减小锁粒度</li></ul><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。<br>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是<br>ConcurrentHashMap。</p><ul><li>锁分离</li></ul><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互<br>斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]<br>JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如<br>LinkedBlockingQueue 从头部取出，从尾部放数据</p><ul><li>锁粗化</li></ul><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完<br>公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步<br>和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p><ul><li>锁消除<br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这<br>些对象的锁操作，多数是因为程序员编码不规范引起</li></ul><h3 id="虚拟机常用命令"><a href="#虚拟机常用命令" class="headerlink" title="虚拟机常用命令"></a>虚拟机常用命令</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>数组</strong></p><ul><li>数组作为数据存储结构的缺陷</li><li>在无序数组中，搜索是低效的</li><li>而在有序数组中插入效率又很低</li><li>不管在哪一种数组中删除效率都很低</li><li>创建一个数组之后，它的大小又是不可变的</li></ul><p><strong>链表</strong></p><ul><li>链表是一种有序的列表</li><li>链表的内容通常存储与内存中分散的位置上</li><li>链表由节点组成，每一个节点的结构都相同</li><li>节点分为数据域和链域，数据域是存放节点的内容，链域存放的是下一个节点的指针</li></ul><h4 id="单向链表（Single-Linked-List）"><a href="#单向链表（Single-Linked-List）" class="headerlink" title="单向链表（Single-Linked List）"></a>单向链表（Single-Linked List）</h4><p>　　单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。</p><p>　　单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc20.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc21.png" alt=""></p><h3 id="栈-stack-与堆-heap"><a href="#栈-stack-与堆-heap" class="headerlink" title="栈(stack)与堆(heap)"></a>栈(stack)与堆(heap)</h3><p>1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制；</p><ol><li><p>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中(对象可能在常量池里)（字符串常量对象存放在常量池中。）；</p></li><li><p>堆：存放所有new出来的对象；</p></li><li><p>静态域：存放静态成员（static定义的）；</p></li><li><p>常量池：存放字符串常量和基本类型常量（public static final）。有时，在嵌入式系统中，常量本身会和其他部分分割离开(由于版权等其他原因)，所以在这种情况下，可以选择将其放在ROM中 ；</p></li><li><p>非RAM存储：硬盘等永久存储空间</p></li></ol><p>堆栈是一种有序表。</p><p>堆栈只允许数据自有序列表（前端）作输入、输出操作。<br>堆栈的存取顺序就像手枪的弹夹一样，最先压进去的子弹会被最后打出来<br>具有先进后出FILO（First In Last Out）的特性</p><p>堆栈的典型操作</p><p>入栈：又称压栈，是指将数据放入堆栈</p><p>出栈：将数据从堆栈中取出来</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> obj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 指向标     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> pointer<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 数组的长度     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 给定一个默认的长度     */</span>    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法的重载     *     * @param size     */</span>    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断堆栈是否已经满了     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 由于指向标的位置是从-1开始的，数组的下标是从0开始的         */</span>        <span class="token keyword">return</span> pointer <span class="token operator">==</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 入栈</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * // isFull满的         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空间已满！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 对堆进行扩容</span>            obj <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * // 每次加一             */</span>            pointer<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * 循环给数组赋值             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            pointer<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 出栈     *     * @return     */</span>    <span class="token keyword">public</span> Object <span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"栈空间已空！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            Object o <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            pointer<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> o<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断堆栈是否为空     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * isEmpty空的         * 如果pointer==-1就返回true         */</span>        <span class="token keyword">return</span> pointer <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stack stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 出栈         */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>主要是两个：队头，队尾</p><p>入队：队尾指针向后移动</p><p>出队：队头指针向后移动</p><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><h4 id="1-形参与实参"><a href="#1-形参与实参" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h4><h3 id="1-形参与实参-1"><a href="#1-形参与实参-1" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h3><p>我们先来重温一组语法：</p><blockquote><ol><li><p>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</p></li><li><p>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p></li></ol></blockquote><p>举个栗子：</p><pre><code>public static void func(int a){ a=20; System.out.println(a);}public static void main(String[] args) { int a=10;//变量 func(a);}</code></pre><p>例子中<br>int a=10;中的a在被调用之前就已经创建并初始化，在调用func方法时，他被当做参数传入，所以这个a是实参。<br>而func(int a)中的a只有在func被调用时它的生命周期才开始，而在func调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p><h3 id="2-Java的数据类型"><a href="#2-Java的数据类型" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h3><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p><blockquote><p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p></blockquote><p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p><blockquote><ol><li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：</li></ol><blockquote><p>4种整数类型：byte、short、int、long<br>2种浮点数类型：float、double<br>1种字符类型：char<br>1种布尔类型：boolean</p></blockquote><ol start="2"><li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：</li></ol><blockquote><p>类<br>接口<br>数组</p></blockquote></blockquote><p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p><h3 id="3-JVM内存的划分及职能"><a href="#3-JVM内存的划分及职能" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h3><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznUXxpugnTGGCB8eWHmcg9sjc88CMjoWuagmLTgibGKIJchE6JkC1Plw.jpg" alt=""></p><p>有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</p><h5 id="1-虚拟机栈"><a href="#1-虚拟机栈" class="headerlink" title="1. 虚拟机栈"></a>1. 虚拟机栈</h5><h5 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h5><h5 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h5><h5 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h5><h5 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h5><p>我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。</p><hr><blockquote><p><strong>1. 虚拟机栈</strong></p></blockquote><p>虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</p><p>栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p><p>下图表示了一个Java栈的模型以及栈帧的组成：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzhafOtSl5zaWYfOCzicibCgWQRISwTlEr0Kd1TJj3ibia5mQvb7sTUyVq5A.jpg" alt=""></p><p><strong>栈帧</strong>:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p><p>每个栈帧中包括：</p><ol><li><p><strong>局部变量表</strong>:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</p></li><li><p><strong>操作数栈</strong>:Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指操作数栈。</p></li><li><p><strong>指向运行时常量池的引用</strong>:存储程序执行时可能用到常量的引用。</p></li><li><p><strong>方法返回地址</strong>:存储方法执行完成后的返回地址。</p></li></ol><hr><blockquote><p><strong>2. 堆：</strong></p></blockquote><p>堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</p><hr><blockquote><p><strong>3. 方法区：</strong></p></blockquote><p>方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</p><p>方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</p><hr><blockquote><p><strong>4. 本地方法栈：</strong></p></blockquote><p>本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</p><p><strong>有人会疑惑：什么是本地方法？为什么Java还要调用本地方法？</strong></p><hr><blockquote><p><strong>5. 程序计数器：</strong></p></blockquote><p>线程私有的。<br>记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p><hr><h3 id="4-数据如何在内存中存储？"><a href="#4-数据如何在内存中存储？" class="headerlink" title="4. 数据如何在内存中存储？"></a>4. 数据如何在内存中存储？</h3><p>从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有三个地方：</p><ul><li><p>堆</p></li><li><p>栈</p></li><li><p>静态方法区</p></li><li><p>常量区</p></li></ul><p>相应地，每个存储区域都有自己的内存分配策略：</p><ul><li><p>堆式：</p></li><li><p>栈式</p></li><li><p>静态</p></li></ul><p>我们已经知道：Java中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？<br>这里要分以下的情况进行探究：</p><blockquote><p><strong>1. 基本数据类型的存储：</strong></p><ul><li><p>A. 基本数据类型的局部变量</p></li><li><p>B. 基本数据类型的成员变量</p></li><li><p>C. 基本数据类型的静态变量</p></li></ul><p><strong>2. 引用数据类型的存储</strong></p></blockquote><hr><blockquote><p><strong>1. 基本数据类型的存储</strong></p></blockquote><hr><p>我们分别来研究一下：</p><h5 id="A-基本数据类型的局部变量"><a href="#A-基本数据类型的局部变量" class="headerlink" title="A.基本数据类型的局部变量"></a><strong>A.基本数据类型的局部变量</strong></h5><ol><li><p>定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的<strong>“虚拟机栈”</strong>，数据本身的值就是存储在栈空间里面。  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznNuHDLtNxibO1b1yN7wV4HPSno4CHZWXaEicootMFec7t31G38HzFpSQ.png" alt=""></p></li></ol><pre><code>如上图，在方法内定义的变量直接存储在栈中，如</code></pre><pre><code>    int age=50;    int weight=50;    int grade=6;</code></pre><p>当我们写“int age=50；”，其实是分为两步的：</p><pre><code>    int age;//定义变量    age=50;//赋值</code></pre><p>首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。因此我们可以知道：<br><strong>我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</strong></p><p>我们再来看“int weight=50；”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：<strong>栈中的数据在当前线程下是共享的</strong>。</p><p>那么如果再执行下面的代码呢？</p><pre><code>    weight=40；</code></pre><p>当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。由此可知：</p><p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p><hr><h5 id="B-基本数据类型的成员变量"><a href="#B-基本数据类型的成员变量" class="headerlink" title="B. 基本数据类型的成员变量"></a><strong>B. 基本数据类型的成员变量</strong></h5><p>成员变量：顾名思义，就是在类体中定义的变量。<br>看下图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozziaY24epYoPoM45SJiajF9qCXtupO2539ia0NMKIYUo3yjhFibJ1ZgTvIWg.jpg" alt=""></p><p>我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码：</p><pre><code>     public class Person{ 2  private int age; 3  private String name; 4  private int grade; 5//篇幅较长，省略setter getter方法 6  static void run(){ 7     System.out.println("run....");  8   }; 9}1011//调用12Person per=new Person();</code></pre><p>同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：<strong>基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</strong></p><hr><h5 id="C-基本数据类型的静态变量"><a href="#C-基本数据类型的静态变量" class="headerlink" title="C. 基本数据类型的静态变量"></a><strong>C. 基本数据类型的静态变量</strong></h5><p>前面提到<strong>方法区</strong>用来存储一些共享数据，因此<strong>基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</strong></p><hr><blockquote><p><strong>2. 引用数据类型的存储:</strong></p></blockquote><p>上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</p><pre><code>1Person per=new Person();</code></pre><p>实际上，它也是有两个过程：</p><pre><code>1Person per;//定义变量2per=new Person();//赋值</code></pre><p>在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：<br><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p><h3 id="6-值传递和引用传递"><a href="#6-值传递和引用传递" class="headerlink" title="6. 值传递和引用传递"></a>6. 值传递和引用传递</h3><p>前面已经介绍过形参和实参，也介绍了数据类型以及数据在内存中的存储形式，接下来，就是文章的主题：值传递和引用的传递。</p><blockquote><p><strong>值传递：</strong><br>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p></blockquote><p>来看个例子：</p><pre><code> 1public static void valueCrossTest(int age,float weight){ 2    System.out.println("传入的age："+age); 3    System.out.println("传入的weight："+weight); 4    age=33; 5    weight=89.5f; 6    System.out.println("方法内重新赋值后的age："+age); 7    System.out.println("方法内重新赋值后的weight："+weight); 8    } 910//测试11public static void main(String[] args) {12        int a=25;13        float w=77.5f;14        valueCrossTest(a,w);15        System.out.println("方法执行后的age："+a);16        System.out.println("方法执行后的weight："+w);17}</code></pre><p>输出结果：</p><pre><code>1传入的age：252传入的weight：77.534方法内重新赋值后的age：335方法内重新赋值后的weight：89.567方法执行后的age：258方法执行后的weight：77.5</code></pre><p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p><p>这是什么造型呢？！！</p><p>下面我们根据上面学到的知识点，进行详细的分析：</p><p>首先程序运行时，调用mian()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是mian()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozz8YSBg6NLka2h6iamHia5566dpw4dXrpCnfwicnWE0hAADoicyb3dBWWBeg.png" alt=""></p><p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzicu2h4XZlxSVE3ynyB1pIxaplvHibiazgvFiaFYuvVe8IrRK9U3dk1vxCA.jpg" alt=""></p><p>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzf8EMVLtiaMibiaaTxM4aV8ibUZphsG0oHs4qWj3QDHPK6Wia8NBiaQZqXTLQ.jpg" alt=""></p><p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p><blockquote><p><strong>引用传递：</strong><br>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</p></blockquote><p>举个栗子：<br>先定义一个对象：</p><pre><code> 1public class Person { 2        private String name; 3        private int age; 4 5        public String getName() { 6            return name; 7        } 8        public void setName(String name) { 9            this.name = name;10        }11        public int getAge() {12            return age;13        }14        public void setAge(int age) {15            this.age = age;16        }17}</code></pre><p>我们写个函数测试一下：</p><pre><code> 1public static void PersonCrossTest(Person person){ 2        System.out.println("传入的person的name："+person.getName()); 3        person.setName("我是张小龙"); 4        System.out.println("方法内重新赋值后的name："+person.getName()); 5    } 6//测试 7public static void main(String[] args) { 8        Person p=new Person(); 9        p.setName("我是马化腾");10        p.setAge(45);11        PersonCrossTest(p);12        System.out.println("方法执行后的name："+p.getName());13}</code></pre><p>输出结果：</p><pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是张小龙</code></pre><p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p><p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p><p>下面我们对上面的例子稍作修改，加上一行代码，</p><pre><code>1public static void PersonCrossTest(Person person){2        System.out.println("传入的person的name："+person.getName());3        person=new Person();//加多此行代码4        person.setName("我是张小龙");5        System.out.println("方法内重新赋值后的name："+person.getName());6    }</code></pre><p>输出结果：</p><pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是马化腾</code></pre><p>`<br>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p><p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p><pre><code>1Person p=new Person();2        p.setName("我是马化腾");3        p.setAge(45);4        PersonCrossTest(p);</code></pre><p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozztCU4pWxX96C9qiaDiaYSHOjV1Okfm6FIF3H1iciaKvqBTjibGeGnHP0VlsA.jpg" alt=""></p><p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p><pre><code>1person=new Person();</code></pre><p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p><p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p><p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p><p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p><p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p><p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong>  </p><p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzRTVdZIvztpofveECo4HxchhGmtHX4J6WZLRGcLiatiaDEMHwkyRpwtKg.jpg" alt=""></p><p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p><p><strong>p和person都是指向同一个对象</strong>。</p><p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p><p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p><p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p><p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p><p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p><h4 id="2-Java的数据类型-1"><a href="#2-Java的数据类型-1" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h4><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p><blockquote><p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p></blockquote><p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p><blockquote><ol><li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：<br>4种整数类型：byte、short、int、long<br> 2种浮点数类型：float、double<br> 1种字符类型：char<br> 1种布尔类型：boolean</li><li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：<br>类<br> 接口<br> 数组</li></ol></blockquote><p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p><h4 id="3-JVM内存的划分及职能-1"><a href="#3-JVM内存的划分及职能-1" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h4><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="transient-1"><a href="#transient-1" class="headerlink" title="transient"></a>transient</h4><p>先解释下Java中的对象序列化</p><p>在讨论transient之前，有必要先搞清楚Java中序列化的含义；</p><blockquote><p>Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</p></blockquote><p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p><p><strong>关于transient关键字</strong></p><p>Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化，这一看好像很好理解，就是不被序列化，那么什么情况下，一个对象的某些字段不需要被序列化呢？如果有如下情况，可以考虑使用关键字transient修饰：</p><p>1、类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p><p>2、其它，看具体业务需求吧，哪些字段不想被序列化；</p><p>PS，记得之前看HashMap源码的时候，发现有个字段是用transient修饰的，我觉得还是有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增），对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p><h3 id="jdk1-8新特性学习"><a href="#jdk1-8新特性学习" class="headerlink" title="jdk1.8新特性学习"></a>jdk1.8新特性学习</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是一种运行于服务器端的Java应用程序，具有独立于平台和协议的特性，可以生成动态的Web页面</p><p>担当客户请求与服务器响应的中间层 </p><p>有特殊的技术规范</p><p>必须继承某个特定父类</p><p>必须配置之后才能执行</p><p>有特定的生命周期</p><h3 id="、时间复杂度-amp-amp-空间复杂度"><a href="#、时间复杂度-amp-amp-空间复杂度" class="headerlink" title="、时间复杂度&amp;&amp;空间复杂度"></a>、时间复杂度&amp;&amp;空间复杂度</h3><h3 id="、算法"><a href="#、算法" class="headerlink" title="、算法"></a>、算法</h3><h3 id="、Gc"><a href="#、Gc" class="headerlink" title="、Gc"></a>、Gc</h3><h3 id="各种树"><a href="#各种树" class="headerlink" title="各种树"></a>各种树</h3><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><p><a href="https://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis笔记</title>
      <link href="/2019/10/21/2019-01-23-mybatis/"/>
      <url>/2019/10/21/2019-01-23-mybatis/</url>
      
        <content type="html"><![CDATA[<h3 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h3><blockquote><p>MyBatis 本是apache的一个开源项目iBatis, MyBatis 是一个高级<br>映射的优秀的持久层orm框架。<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设<br>置参数以及获取结果集。<br>MyBatis可以使用简单的XML或注解用于配置和原<br>始映射，将接口和Java的POJO（Plain Old Java<br>Objects，普通的Java对象）映射成数据库中的记<br>录.</p></blockquote><h3 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h3><blockquote><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。<br>iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（sDAO）<br>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p></blockquote><p>Mybatis的架构<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mybatis3.png?token=AexgHdHBH0caqaCOim6-m7vOOHulfMt7ks5cPxMWwA%3D%3D" alt=""></p><p>实现功能<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mybatis1.png?token=AexgHZThrRM9vGnIUzPFPYGE3tuxMZcYks5cPxNpwA%3D%3D" alt="image"></p><h3 id="MyBatis的实现原理"><a href="#MyBatis的实现原理" class="headerlink" title="MyBatis的实现原理"></a>MyBatis的实现原理</h3><font face="微软雅黑" size="3"><p>&nbsp; &nbsp; &nbsp; &nbsp;</p><p>mybatis底层还是采用原生jdbc来对数据库进行操作的，只是通过 SqlSessionFactory，SqlSession Executor,StatementHandler，ParameterHandler,ResultHandler和TypeHandler等几个处理器封装了这些过程</p></font><h3 id="为什么要使用MyBatis？"><a href="#为什么要使用MyBatis？" class="headerlink" title="为什么要使用MyBatis？"></a>为什么要使用MyBatis？</h3><ul><li>MyBatis是一个半自动化的持久化层框架。</li><li>JDBC<br>– SQL写在Java代码块里，耦合度高导致硬编码内伤<br>– 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见<br></li><li>Hibernate和JPA<ol><li>长难复杂SQL，对于Hibernate而言处理也不容易</li><li>内部自动生产的SQL，不容易做特殊优化。</li><li>基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。<br>导致数据库性能下降。</li></ol></li><li>对开发人员而言，核心sql还是需要自己优化</li><li>sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3></li><li>SqlSession 的实例不是线程安全的，因此是不能<br>被共享的。</li><li>SqlSession每次使用完成后需要正确关闭，这个<br>关闭操作是必须的</li><li>SqlSession可以直接调用方法的id进行数据库操<br>作，但是我们一般还是推荐使用SqlSession获取<br>到Dao接口的代理类，执行代理对象的方法，可<br>以更安全的进行类型检查操作</li></ul><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><font face="微软雅黑" size="3"><p>①、一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的，一级缓存默认是开启的</p><p>②、</p><ul><li>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，二级缓存是跨SqlSession的。</li><li>二级缓存的原理和一级缓存原理一样，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去缓存中取。但是一级缓存是基于 sqlSession 的，而 二级缓存是基于 mapper文件的namespace的，也就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果两个mapper的namespace相同，即使是两个mapper，那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域中。</li><li>开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中，如果我们要再取这个缓存的话，就需要反序列化了。所以mybatis中的pojo都去实现Serializable接口。　</li></ul></font><p><strong>我们可以看到 mapper.xml 文件中就这么一个空标签<cache>，其实这里可以配置<cache type="org.apache.ibatis.cache.impl.PerpetualCache">,PerpetualCache这个类是mybatis默认实现缓存功能的类。我们不写type就使用mybatis默认的缓存，也可以去实现 Cache 接口来自定义缓存。</cache></cache></strong></p><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/mybatis2.png?token=AexgHbOqd1GWn9Tx_j6McMag6Z-VP-n2ks5cPqAvwA%3D%3D" alt="image"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Test</span>    <span class="token comment" spellcheck="true">/**      * 返回一行数据       * 测试一级缓存     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用类加载器加载mybatis的配置文件（它也加载关联的映射文件）</span>        <span class="token comment" spellcheck="true">// 1.加载配置文件</span>        Reader reader <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsReader</span><span class="token punctuation">(</span><span class="token string">"mybatis.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建sqlsessionfactory 二级缓存 通过配置信息构建一个sqlSessionFactory</span>        SqlSessionFactory sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.获取链接 一级缓存 通过sqlSessionFactory打开一个数据库会话</span>        SqlSession session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.获得mapper</span>        <span class="token comment" spellcheck="true">// 把接口和sql映射文件对应，对应之后就可以通过接口找到具体的sql位置</span>        ProductDaoMapper mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>ProductDaoMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product pro <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pro<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第二次查询</span>        ProductDaoMapper mapper2 <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>ProductDaoMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product pro2 <span class="token operator">=</span> mapper2<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pro2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><font size="6px">二级缓存</font><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTwoCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//根据 sqlSessionFactory 产生 session</span>    SqlSession sqlSession1 <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SqlSession sqlSession2 <span class="token operator">=</span> sessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String statement <span class="token operator">=</span> <span class="token string">"com.ys.twocache.UserMapper.selectUserByUserId"</span><span class="token punctuation">;</span>    UserMapper userMapper1 <span class="token operator">=</span> sqlSession1<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UserMapper userMapper2 <span class="token operator">=</span> sqlSession2<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第一次查询，发出sql语句，并将查询的结果放入缓存中</span>    User u1 <span class="token operator">=</span> userMapper1<span class="token punctuation">.</span><span class="token function">selectUserByUserId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u1<span class="token punctuation">)</span><span class="token punctuation">;</span>    sqlSession1<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一次查询完后关闭sqlSession</span>    <span class="token comment" spellcheck="true">//第二次查询，即使sqlSession1已经关闭了，这次查询依然不发出sql语句</span>    User u2 <span class="token operator">=</span> userMapper2<span class="token punctuation">.</span><span class="token function">selectUserByUserId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>u2<span class="token punctuation">)</span><span class="token punctuation">;</span>    sqlSession2<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="二级缓存的应用场景"><a href="#二级缓存的应用场景" class="headerlink" title="二级缓存的应用场景"></a>二级缓存的应用场景</h3><font face="微软雅黑" size="3"><p>　　对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分的，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题可能需要在业务层根据需求对数据有针对性缓存。</p></font><h3 id="二级缓存整合其他缓存框架"><a href="#二级缓存整合其他缓存框架" class="headerlink" title="二级缓存整合其他缓存框架"></a>二级缓存整合其他缓存框架</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mybatis自带的二级缓存，但是这个缓存是单服务器工作，无法实现分布式缓存。那么什么是分布式缓存呢？假设现在有两个服务器1和2，用户访问的时候访问了1服务器，查询后的缓存就会放在1服务器上，假设现在有个用户访问的是2服务器，那么他在2服务器上就无法获取刚刚那个缓存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，就得找一个分布式的缓存，专门用来存储缓存数据的，这样不同的服务器要缓存数据都往它那里存，取缓存数据也从它那里取</p><p>二级缓存如：Ehcache，Redis</p><h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><h4 id="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h4><font face="微软雅黑" size="3">答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、、、标签，都会被解析为一个MappedStatement对象。</select></font><p><strong>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</strong></p><p><strong>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</strong></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>  （1）一级缓存（SqlSession级别）</p><pre><code>  MyBatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行     相同的sql语句，第一次执行后会将查询到的数据存储到缓存当中，第二次会从缓     存中进行查找，从而提高查询效率，当一个SqlSession结束之后，一级缓存也将不     存在，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，Mybatis默认开启一级缓存。</code></pre><p>  （2）二级缓存（Mapper级别）</p><pre><code>     二级缓存的作用域是mapper的同一个namespace，执行两次相同的SQL语句，     第一次执行后会将查询到的数据存储到缓存当中，第二次会从缓存中进行查找，从而提高查询效率，默认不开启</code></pre><p>（3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h4 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h4><p>① 创建SqlSessionFactory</p><p>② 通过SqlSessionFactory创建SqlSession</p><p>③ 通过sqlsession执行数据库操作</p><p>④ 调用session.commit()提交事务</p><p>⑤ 调用session.close()关闭会话</p><h3 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h3><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 </p><p>（2）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。</p><p>使用Hibernate查询关联对象或者关联集合对象时，</p><p>可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，</p><p>需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一份简明的 Markdown 笔记与教程</title>
      <link href="/2018/12/17/2018-09-06-markdown-intro/"/>
      <url>/2018/12/17/2018-09-06-markdown-intro/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>专注于文字内容；</p></li><li><p>纯文本，易读易写，可以方便地纳入版本控制；</p></li><li><p>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。</p></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>各类代码托管平台</p><p>  主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。</p></li><li><p>技术社区和写作平台</p><p>  StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记</p></li><li><p>论坛</p><p>  V2EX、光谷社区</p></li></ul><p>个人感觉比较遗憾的一点是各平台可能采用不同语言实现的 Markdown 解析引擎，或采用同一解析引擎的不同版本，而且可能有不同程度的定制与扩展，这导致在不同平台上使用 Markdown 写作时体验并不完全一致。不过幸好对于大家公认的一些标准语法，各家都是支持的。</p><h3 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h3><p>理论上任何一款文本编辑器都能用于编辑 Markdown 文档，它们分别提供了不同程度的语法高亮、预览等功能，以下只是列举其中一部分，选择自己称手的即可。</p><ul><li><p>现代编辑器</p><p>  VSCode / Atom</p></li><li><p>传统编辑器</p><p>  Vim / Emacs / Sublime Text / Notepad++</p></li><li><p>IDE 自带编辑器</p><p>  IntelliJ IDEA / Android Studio / WebStorm</p></li><li><p>专用编辑器</p><p>  Ulysses / Mou / Typora / Markpad</p></li><li><p>在线编辑器</p><p>  各种支持 Markdown 的网站都提供了在线编辑器</p></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>Markdown：</strong></p><pre><code># atx-style 一级标题## 二级标题###### 六级标题Setext-style 一级标题===二级标题---</code></pre><p><strong>预览效果：</strong></p><blockquote><h1 id="atx-style-一级标题"><a href="#atx-style-一级标题" class="headerlink" title="atx-style 一级标题"></a>atx-style 一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="Setext-style-一级标题"><a href="#Setext-style-一级标题" class="headerlink" title="Setext-style 一级标题"></a>Setext-style 一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>atx-style 一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Setext-style 一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span></code></pre><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>中间没有空行的连续不断的几行文字被视为一个段落。</p><p><strong>Markdown：</strong></p><pre><code>白日依山尽，黄河入海流。（句号后面没空格）欲穷千里目，更上一层楼。  （句号后面有俩空格）</code></pre><p><strong>预览效果：</strong></p><p>白日依山尽，</p><p>黄河入海流。<br>（句号后面没空格）</p><p>欲穷千里目，</p><p>更上一层楼。<br>（句号后面有俩空格）</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>白日依山尽，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>黄河入海流。（句号后面没有空格）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>欲穷千里目，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>  更上一层楼。  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>  （句号后面有俩空格）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><h3 id="行内格式"><a href="#行内格式" class="headerlink" title="行内格式"></a>行内格式</h3><p>对段落或者部分文本的强调效果。</p><p><strong>Markdown：</strong></p><pre><code>后面俩字**加黑**后面俩字*斜体*</code></pre><p><strong>预览效果：</strong></p><p>后面俩字<strong>加黑</strong></p><p>后面俩字<em>斜体</em></p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>  后面俩字  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>加黑<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>  后面俩字  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>斜体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p><strong>Markdown：</strong></p><pre><code>&gt; 引用块段落一。&gt;&gt; 引用块段落二。&gt;&gt; 内嵌引用块段落一。&gt;&gt; ### 引用块内的标题</code></pre><p><strong>预览效果：</strong></p><blockquote><p>引用块段落一。</p><p>引用块段落二。</p><blockquote><p>内嵌引用块段落一。</p></blockquote><h3 id="引用块内的标题"><a href="#引用块内的标题" class="headerlink" title="引用块内的标题"></a>引用块内的标题</h3></blockquote><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blockquote</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>引用块段落一。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>引用块段落二。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blockquote</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>内嵌引用块段落一。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blockquote</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>引用块内的标题<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>引用块内的标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blockquote</span><span class="token punctuation">></span></span></code></pre><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>Markdown 支持行内式链接和引用式链接。</p><p><strong>Markdown：</strong></p><pre><code>行内式 [博客](https://mazhuang.org "我的个人博客") 链接，带 title。行内式 [GitHub](https://github.com/mzlogin) 链接。引用式 [博客][1] 链接。引用式 [GitHub][2] 链接，带 title。[1]: https://mazhuang.org[2]: https://github.com/mzlogin "我的 GitHub 主页"</code></pre><p><strong>预览效果：</strong></p><p>行内式 <a href="https://mazhuang.org" title="我的个人博客" target="_blank" rel="noopener">博客</a> 链接，带 title。</p><p>行内式 <a href="https://github.com/mzlogin" target="_blank" rel="noopener">GitHub</a> 链接。</p><p>引用式 <a href="https://mazhuang.org" target="_blank" rel="noopener">博客</a> 链接。</p><p>引用式 <a href="https://github.com/mzlogin" title="我的 GitHub 主页" target="_blank" rel="noopener">GitHub</a> 链接，带 title。</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>行内式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://mazhuang.org<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>我的个人博客<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>博客<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> 链接，带 title。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>行内式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/mzlogin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>GitHub<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> 链接。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>引用式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://mazhuang.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>博客<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> 链接。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>引用式 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/mzlogin<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>我的 GitHub 主页<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>GitHub<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span> 链接，带 title。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>在超链接的写法前加一个 <code>!</code>，就是引用图片的方法。</p><p><strong>Markdown：</strong></p><pre><code>![Alt text](https://mazhuang.org/favicon.ico "favicon")</code></pre><p><strong>预览效果：</strong></p><p><img src="https://mazhuang.org/favicon.ico" alt="Alt text" title="favicon"></p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://mazhuang.org/favicon.ico<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Alt text<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>favicon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>包括有序列表和无序列表。</p><p><strong>Markdown：</strong></p><pre><code>- 苹果- 葡萄- 榴莲1. 苹果2. 葡萄3. 榴莲</code></pre><p><strong>预览效果：</strong></p><ul><li>苹果</li><li>葡萄</li><li>榴莲</li></ul><ol><li>苹果</li><li>葡萄</li><li>榴莲</li></ol><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>葡萄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>榴莲<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>苹果<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>葡萄<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>榴莲<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span></code></pre><p>其中无序列表的标记可以使用 <code>+</code>、<code>-</code> 或 <code>*</code>，有序列表前的数字可以是乱序的。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>支持行内代码和代码块。</p><p><strong>Markdown：</strong></p><pre><code>Android 里使用 `TextUtils` 类的 `isEmpty` 方法来判断字符串是否为空。```javaif (TextUtils.isEmpty(text)) {    return null;}```</code></pre><p><strong>预览效果：</strong></p><p>Android 里使用 <code>TextUtils</code> 类的 <code>isEmpty</code> 方法来判断字符串是否为空。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>TextUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Android 里使用 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>TextUtils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> 类的 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>isEmpty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> 方法来判断字符串是否为空。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>highlight highlight-source-java<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-k<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>if<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> (<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-smi<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>TextUtils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-k<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>isEmpty(text)) {    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-k<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>return<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pl-c1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>null<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>;}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>上例中的语言标记 <code>java</code> 可选填，可用于在编辑器和渲染后的效果里添加语法高亮。</p><p>块式代码也可以对整个代码段缩进四个空格，或一个 Tab 来实现。</p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>使用一个单独行里的三个或以上 <code>*</code>、<code>-</code> 来生产一条水平分割线，它们之间可以有空格。</p><p><strong>Markdown：</strong></p><pre><code>***------ - -</code></pre><p><strong>预览效果：</strong></p><hr><hr><hr><p><strong>对应 HTML：</strong></p><pre><code>&lt;hr /&gt;&lt;hr /&gt;&lt;hr /&gt;</code></pre><h3 id="嵌入-HTML"><a href="#嵌入-HTML" class="headerlink" title="嵌入 HTML"></a>嵌入 HTML</h3><p>Markdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML 标签的方式。它对应的只是 HTML 标签的一个很小的子集。</p><p>对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML 来写就好了。</p><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>本节的内容是介绍一些受到广泛支持的 Markdown 扩展语法。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown：</strong></p><pre><code>| 编号  | 姓名（左） | 年龄（右） | 性别（中） || ----- | :--------  | ---------: | :------:   || 0     | 张三       | 28         | 男         || 1     | 李四       | 29         | 男         |</code></pre><p><strong>预览效果：</strong></p><table><thead><tr><th>编号</th><th align="left">姓名（左）</th><th align="right">年龄（右）</th><th align="center">性别（中）</th></tr></thead><tbody><tr><td>0</td><td align="left">张三</td><td align="right">28</td><td align="center">男</td></tr><tr><td>1</td><td align="left">李四</td><td align="right">29</td><td align="center">男</td></tr></tbody></table><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>thead</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>编号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>姓名（左）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>年龄（右）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>性别（中）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>thead</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tbody</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>28<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>李四<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>29<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tbody</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span></code></pre><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>在 GitHub / GitLab 里有较好的支持。</p><p><strong>Markdown：</strong></p><pre><code>- [x] 洗碗- [ ] 清洗油烟机- [ ] 拖地</code></pre><p><strong>预览效果：</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 洗碗</li><li><input disabled="" type="checkbox"> 清洗油烟机</li><li><input disabled="" type="checkbox"> 拖地</li></ul><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>contains-task-list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item-checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">checked</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 洗碗<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item-checkbox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 清洗油烟机<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>task-list-item-checkbox<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 拖地<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><p>如果是在 GitHub / GitLab 的 Issue 里，会附赠任务完成比例提示效果：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-1.png" alt="task list 1"></p><p>还可以直接在网页上拖动调整顺序，勾选和取消勾选。</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-2.png" alt="task list 2"></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><strong>Markdown：</strong></p><pre><code>后面三个字打上~~删除线~~。</code></pre><p><strong>预览效果：</strong></p><p>后面三个字打上<del>删除线</del>。</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>后面三个字打上<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">></span></span>。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>自动链接扩展，即：当识别到 URL，或用 <code>&lt;</code>、<code>&gt;</code> 包括的 URL 时，会自动为其生成 <code>a</code> 标签。</p><p><strong>Markdown：</strong></p><pre><code>https://github.com&lt;example@gmail.com&gt;</code></pre><p><strong>预览效果：</strong></p><p><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><p><a href="mailto:example@gmail.com" target="_blank" rel="noopener">example@gmail.com</a></p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>https://github.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mailto:example@gmail.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>example@gmail.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><p>以 GitHub Pages 为例。</p><p><strong>Markdown：</strong></p><pre><code>:camel: :blush: :smile:</code></pre><p><strong>预览效果：</strong></p><p>:camel: :blush: :smile:</p><p><strong>对应 HTML：</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emoji<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:camel:<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:camel:<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://assets-cdn.github.com/images/icons/emoji/unicode/1f42b.png<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emoji<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:blush:<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:blush:<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emoji<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:smile:<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>:smile:<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>脑洞清奇的工程师们还发掘了很多使用 Markdown 的方法，大部分都是引入第三方 JavaScript 插件来实现。对这部分我只做简述，对其中的部分功能比如作图等，还是推荐用专门的可视化工具去做。</p><h3 id="画流程图和时序图"><a href="#画流程图和时序图" class="headerlink" title="画流程图和时序图"></a>画流程图和时序图</h3><p>有部分网站和编辑器实现了对 Markdown 里流程图和时序图的支持，比如我们使用的项目管理工具 TAPD 的在线编辑器，还有 VSCode + 插件 Markdown Preview Enhanced 等。</p><p>以我们使用的项目管理工具 TAPD 的在线编辑器为例：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-flowchart.png" alt="流程图"></p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-seq.png" alt="时序图"></p><h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><p>仍然以 TAPD 为例：</p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-math.png" alt="数学公式"></p><p>应该是利用 JavaScript 支持了 LaTeX 公式语法。</p><h3 id="用-Markdown-做-PPT"><a href="#用-Markdown-做-PPT" class="headerlink" title="用 Markdown 做 PPT"></a>用 Markdown 做 PPT</h3><p>有专门的工具 <a href="https://github.com/yhatt/marp" target="_blank" rel="noopener">Marp</a>，另外使用 VSCode + 插件 Markdown Preview Enhanced 也可以实现。</p><h3 id="用-Markdown-写微信公众号"><a href="#用-Markdown-写微信公众号" class="headerlink" title="用 Markdown 写微信公众号"></a>用 Markdown 写微信公众号</h3><p>可以将公众号素材用 Markdown 编辑好后，贴到在线排版工具以后，复制到公众号编辑器里即可。有多种页面主题和代码主题可选择。</p><p>我维护的工具地址：<a href="https://md.mazhuang.org" target="_blank" rel="noopener">https://md.mazhuang.org</a></p><p><img src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/wechat-markdown.png" alt="微信公众号"></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>想象力丰富的工程师们还扩展了很多基于 Markdown 的玩法，包括但不限于：</p><ul><li>自动生成 / 更新 Table of Contents</li><li>流程图 / 时序图</li><li>制作幻灯片</li><li>集成 PlantUML / GraphViz 的能力</li><li>导出 HTML / PDF / 电子书</li><li>…</li></ul><p>以上功能基本都可以用 VSCode + 插件 Markdown Preview Enhanced 实现。</p><p>另外可以参考我以前的一篇博客 <a href="https://mazhuang.org/2017/09/01/markdown-odd-skills/" target="_blank" rel="noopener">关于 Markdown 的一些奇技淫巧</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">Markdown: Syntax - DARING FIREBALL</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown - 维基百科</a></li><li><a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GitHub Flavored Markdown Spec</a></li><li><a href="https://mazhuang.org/2017/09/01/markdown-odd-skills/" target="_blank" rel="noopener">关于 Markdown 的一些奇技淫巧</a></li></ul><hr><p>欢迎关注我的微信公众号，接收 markdown-intro 最新动态。</p><div align="center"><img width="192px" height="192px" src="https://mazhuang.org/assets/images/qrcode.jpg"></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
