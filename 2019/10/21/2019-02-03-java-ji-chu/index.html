<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="java基础笔记, Tom Blog">
    <meta name="description" content="1、java 包访问权限
2、Java中的面向接口编程 面向接口编程是很多软件架构设计理论都倡导的编程方式，学习Java自然少不了这一部分，下面是我在学习过程中整理出来的关于如何在Java中实现面向接口编程的知识。
接口体现的是一种规范和实">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>java基础笔记 | Tom Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Tom Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Tom Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        java基础笔记
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-10-21
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="1、java-包访问权限"><a href="#1、java-包访问权限" class="headerlink" title="1、java 包访问权限"></a>1、java 包访问权限</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc1.gif" alt=""></p>
<h3 id="2、Java中的面向接口编程"><a href="#2、Java中的面向接口编程" class="headerlink" title="2、Java中的面向接口编程"></a>2、Java中的面向接口编程</h3><p> 面向接口编程是很多软件架构设计理论都倡导的编程方式，学习Java自然少不了这一部分，下面是我在学习过程中整理出来的关于如何在Java中实现面向接口编程的知识。</p>
<p>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，通常推荐“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p>
<h3 id="3、main方法"><a href="#3、main方法" class="headerlink" title="3、main方法"></a>3、main方法</h3><pre><code>/**
* Java中的main()方法详解
*/
public class HelloWorld {
    public static void main(String args[]) {
        System.out.println("Hello World!");
    }
}</code></pre><p>一、先说类：<br>HelloWorld 类中有main()方法，说明这是个java应用程序，通过JVM直接启动运行的程序。<br>既然是类，java允许类不加public关键字约束，当然类的定义只能限制为public或者无限制关键字（默认的）。</p>
<p>二、再说main()方法</p>
<blockquote>
<p>这个main()方法的声明为：public static void main(String args[])。必须这么定义，这是Java的规范。<br>为什么要这么定义，和JVM的运行有关系。<br>当一个类中有main()方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法。<br>由于JVM在运行这个Java应用程序的时候，首先会调用main方法，调用时不实例化这个类的对象，而是通过类名直接调用因此需要是限制为public static。(类名.main())<br>对于java中的main方法，jvm有限制，不能有返回值，因此返回值类型为void。<br>main方法中还有一个输入参数，类型为String[]，这个也是java的规范，main()方法中必须有一个入参，类型必须String[]，至于字符串数组的名字，这个是可以自己设定的，根据习惯，这个字符串数组的名字一般和sun java规范范例中mian参数名保持一致，取名为args。因此，main()方法定义必须是：“public static void main(String 字符串数组参数名[])”。</p>
</blockquote>
<p>三、main()方法中可以throw Exception<br>因此main()方法中可以抛出异常，main()方法上也可以声明抛出异常。</p>
<p>四、main()方法中字符串参数数组作用<br>main()方法中字符串参数数组作用是接收命令行输入参数的，命令行的参数之间用空格隔开。</p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<p>编译</p>
<p>运行</p>
<p>编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。</p>
<p>运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。</p>
<p>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p>
<p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p>
<p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><pre><code>首先String不属于8中基本类型，String是一个对象

String 由于使用final 修饰存储在常量区（不是new出来的）

new出来的存储在对象存储在堆中，栈中存放的为引用地址。
</code></pre><h3 id="4、java类的初始化顺序"><a href="#4、java类的初始化顺序" class="headerlink" title="4、java类的初始化顺序"></a>4、java类的初始化顺序</h3><h4 id="本类的初始化顺序"><a href="#本类的初始化顺序" class="headerlink" title="本类的初始化顺序"></a>本类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitialOrderTest</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticField<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>运行结果：<br><br>    静态变量<br><br>    静态初始化块<br>a<br>    变量<br><br>    初始化块<br><br>    构造器<br></p>
<h4 id="含有父类的初始化顺序"><a href="#含有父类的初始化顺序" class="headerlink" title="含有父类的初始化顺序"></a>含有父类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>   
    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String p_StaticField <span class="token operator">=</span> <span class="token string">"父类--静态变量"</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String p_Field <span class="token operator">=</span> <span class="token string">"父类--变量"</span><span class="token punctuation">;</span>   

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">", j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        j <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>   

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String s_StaticField <span class="token operator">=</span> <span class="token string">"子类--静态变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String s_Field <span class="token operator">=</span> <span class="token string">"子类--变量"</span><span class="token punctuation">;</span>   

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   
    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">",j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 程序入口</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>  </code></pre>
<p>运行结果：<br>父类–静态变量<br>父类–静态初始化块<br>子类–静态变量<br>子类–静态初始化块<br>父类–变量<br>父类–初始化块<br>父类–构造器<br>子类–变量<br>子类–初始化块<br>子类–构造器</p>
<h3 id="5、Java中如何进行异常处理"><a href="#5、Java中如何进行异常处理" class="headerlink" title="5、Java中如何进行异常处理"></a>5、Java中如何进行异常处理</h3><h4 id="Java异常的分类和类结构图"><a href="#Java异常的分类和类结构图" class="headerlink" title="Java异常的分类和类结构图"></a>Java异常的分类和类结构图</h4><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p>
<p>Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc3.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc7.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc4.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc6.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc5.png" alt=""></p>
<p>在Java中异常的继承主要有两个： Error和Exception 这两个，而Error就是jvm出现错误，以及系统奔溃等现象这些错误没办法通过程序来处理，所以在程序中不能使用catch来捕捉处理这类的异常。</p>
<p>对于Exception 又可以分为checkedException 和RuntimeException 这两种异常，checkedException异常在进行编译运行之前就可以知道会不会发生异常，如果不对这些异常进行抛出、捕获的话就不能通过编译。而RuntimeException就是运行的时候出现的异常在之前你是没办法确定是不是会出现异常。</p>
<blockquote>
<p>Java的异常处理是通过5个关键字来实现的：try、catch、 finally、throw、throws</p>
</blockquote>
<h4 id="try…catch…finally语句块"><a href="#try…catch…finally语句块" class="headerlink" title="try…catch…finally语句块"></a>try…catch…finally语句块</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">//try块中放可能发生异常的代码。</span>
     <span class="token comment" spellcheck="true">//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span>
     <span class="token comment" spellcheck="true">//如果发生异常，则尝试去匹配catch块。</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span>
    <span class="token comment" spellcheck="true">//catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span>
    <span class="token comment" spellcheck="true">//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span>
    <span class="token comment" spellcheck="true">//如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span>
    <span class="token comment" spellcheck="true">//如果try中没有发生异常，则所有的catch块将被忽略。</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//finally块通常是可选的。</span>
   <span class="token comment" spellcheck="true">//无论异常是否发生，异常是否匹配被处理，finally都会执行。</span>
   <span class="token comment" spellcheck="true">//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span>
  <span class="token comment" spellcheck="true">//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>需要注意的地方</strong></p>
<p>1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p>
<p>2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。</p>
<p>3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。<br>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）<br>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol>
<li>不管有没有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li>
</ol>
<p><strong>举例：</strong></p>
<p>情况1. try{} catch(){}finally{} return;<br>显然程序按顺序执行。</p>
<p>情况2. :try{ return; }catch(){} finally{} return;<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，最后执行try中return;</p>
<p>finally块之后的语句return，因为程序在try中已经return所以不再执行。</p>
<p>情况3. :try{ } catch(){return;} finally{} return;<br>程序先执行try，如果遇到异常执行catch块，<br>有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，<br>最后执行catch块中return. finally之后也就是4处的代码不再执行。<br>无异常：执行完try再finally再return.</p>
<p>情况4:try{ return; }catch(){} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况5:try{} catch(){return;}finally{return;}<br>程序执行catch块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况6:try{ return;}catch(){return;} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；<br>则再执行finally块，因为finally块中有return所以提前退出。<br>无异常：则再执行finally块，因为finally块中有return所以提前退出。</p>
<p>最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。<br>如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，<br>编译器把finally中的return实现为一个warning。</p>
<p>也就是说，如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）</p>
<p>下面是个测试程序</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            x<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>结果是2。<br>    在try语句中，在执行return语句时，要返回的结果已经准备好了，就在此时，程序转到finally执行了。<br>在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，<br>因此，即使finally中对变量x进行了改变，但是不会影响返回结果。<br>它应该使用栈保存返回值。<br><strong>finally中的return 会覆盖 try 或者catch中的返回值。</strong></p>
<h4 id="throws-函数声明"><a href="#throws-函数声明" class="headerlink" title="throws 函数声明"></a>throws 函数声明</h4><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p>
<p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>
<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ExceptionType1<span class="token punctuation">,</span> ExceptionType2<span class="token punctuation">,</span> ExceptionTypeN <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>
        String s <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NumberFormatException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h4><p>通过上面的两个demo可以得知：</p>
<p>1、throw用在方法体内，上面代码显示了，是直接在main方法体内</p>
<p>   throws用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。这个看上面的代码就理解了</p>
<p>2、throw是具体向外抛异常的，抛出的是一个异常实例</p>
<p>   throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常</p>
<p>3、throw，如果执行了，那么一定是抛出了某种异常了，安生throws表示可能出现，但不一定。</p>
<p>4、同时出现的时候，throws出现在函数头、throw出现在函数体，两种不会由函数去处理，真正的处理由函数的上层调用处理</p>
<h4 id="for-中try还是for外try"><a href="#for-中try还是for外try" class="headerlink" title="for 中try还是for外try"></a>for 中try还是for外try</h4><p>try放在for循环的里面所有的for循环都会执行，当遇到异常时，抛出异常继续执行；放在外面，当遇到异常时，抛出异常，后面的循环就会终止，并不会执行。</p>
<h3 id="6、-变量命名规范"><a href="#6、-变量命名规范" class="headerlink" title="6、 变量命名规范"></a>6、 变量命名规范</h3><p>首字母：字母、$和下划线。变量名：由$、字母、数字和下划线组成。</p>
<h3 id="7、方法重载与方法重写"><a href="#7、方法重载与方法重写" class="headerlink" title="7、方法重载与方法重写"></a>7、方法重载与方法重写</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc2.png" alt=""></p>
<h3 id="8、继承-封装-多态-抽象"><a href="#8、继承-封装-多态-抽象" class="headerlink" title="8、继承 封装 多态 抽象"></a>8、继承 封装 多态 抽象</h3><p>1、请描述一下java</p>
<p>java是一个面向对象的编程语言，有继承 封装 多态的特性，同时java也是一开源的语言，一次编译到处运行，有很完善的生态系统，包括各种各样的企业级框架。</p>
<p>2、抽象</p>
<p>抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。</p>
<p>3、封装</p>
<blockquote>
<p> 1）将实例变量标记为私有的（private），表示只能在类的内部使用。 <br><br>   2）提供公有（public）的get和set方法，用来控制对实例变量的存取动作。</p>
</blockquote>
<p>   封装的目的是：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。</p>
<p>4、继承</p>
<p>目的：实现代码的复用。</p>
<p>继承是从已有的类得到继承信息创建新的类的过程，继承可以表示为 is-a 关系 。父类的私有属性和构造方法并不能被继承。另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。</p>
<p>5、多态</p>
<p>多态可以大概分为两种方式：方法重载与方法重写。</p>
<ul>
<li>方法重载（Overload）:编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致。</li>
<li>方法重写（Override）:运行时的多态（也称为后绑定）。<br>要实现方法重写需要做：1.方法重写，也就是子类继承父类并重写了父类已经有的方法。 2.用父类型引用来引用子类型对象，这样可以实现调用同样的方法会根据子类对象的不同表示出不一样的行为。</li>
</ul>
<h3 id="9、接口-amp-amp-抽象类"><a href="#9、接口-amp-amp-抽象类" class="headerlink" title="9、接口 &amp;&amp; 抽象类"></a>9、接口 &amp;&amp; 抽象类</h3><p>接口<br>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。<br>抽象类</p>
<p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：<br>abstract void fun() 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法</p>
<p>接口和抽象类的区别</p>
<p>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p>
<p>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p>
<p>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p>
<p>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p>5）抽象类中的方法子类必须全部实现,不然子类也是抽象类,而接口中的抽象方法子类必须全部实现。</p>
<p>6）抽象类是一种模板设计模式,而接口是一种行为规范。</p>
<h3 id="10、自动类型转换和强制类型转换规则"><a href="#10、自动类型转换和强制类型转换规则" class="headerlink" title="10、自动类型转换和强制类型转换规则"></a>10、自动类型转换和强制类型转换规则</h3><ul>
<li>自动类型转换也叫隐式类型转换</li>
<li>表达式的数据类型自动提升</li>
<li>从低位类型到高位类型自动转换；从高位类型到低位类型需要强制类型转换：</li>
<li>boolean类型与其他基本类型不能进行类型的转换（既不能进行自动类型的提升，也不能强制类型转换）</li>
</ul>
<h3 id="11、选择结构"><a href="#11、选择结构" class="headerlink" title="11、选择结构"></a>11、选择结构</h3><ul>
<li>if</li>
<li>switch<blockquote>
<p>在switch 中可以使用的类型 Java支持的数据类型有五种<br>  他们分别是：<br>  byte、char、short、int、enum；<br>  以上是JDK1.6以前的版本。<br>  JDK1.7时，又增加了String</p>
</blockquote>
</li>
</ul>
<p>语法</p>
<pre><code>int is = 0;
switch (is) {
    case 1:
        System.out.println("**");
        break;
    case 2:
        break;
    default:
        System.out.println();
        break;
}</code></pre><ul>
<li>while</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先判断再执行</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"好好学习，天天向上！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 先执行再判断</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>for</li>
</ul>
<pre><code> for (int is = 0; is &lt; 100; is++) {
     System.out.println("好好学习！");
 }</code></pre><h3 id="12、break-amp-amp-continue"><a href="#12、break-amp-amp-continue" class="headerlink" title="12、break &amp;&amp; continue"></a>12、break &amp;&amp; continue</h3><pre><code>continue 作用：跳过循环体中剩余的语句而执行下一次循环
break语句终止某个循环，程序跳转到循环块外的下一条语句</code></pre><h3 id="13、数组"><a href="#13、数组" class="headerlink" title="13、数组"></a>13、数组</h3><pre><code>public static void main(String[] args) {
    //声明数组
    String [] arr;
    int arr1[];

    //初始化数组
    int arr2[]=new int[]{1,2,3,4,5};
    String[] array1={"马超","马云","关羽","刘备","张飞"};
    String[] array2=new String[]{"黄渤","张艺兴","孙红雷","小猪","牙哥","黄磊"};

    String[] array=new String[5];


    //查看数组的长度
    int length=array1.length;
    System.out.println("length：  "+array1.length);

    //输出数组
//      System.out.println(array1);     //结果：[Ljava.lang.String;@32f22097
    System.out.println("arr2:  "+Arrays.toString(arr2));

    //遍历数组
    for (int i = 0; i &lt; array1.length; i++) {
//          System.out.println(array1[i]);
    }
    //int数组转成string数组
    int[]  array3={1,2,3,4,5,6,7,8,9,0};
    String arrStrings=Arrays.toString(array3);
//      System.out.println(arrStrings);

    //从array中创建arraylist
    ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;(Arrays.asList(array1));
    System.out.println(arrayList);

    //数组中是否包含某一个值
    String a="马超";
    if (Arrays.asList(array1).contains(a)) {
        System.out.println("马超在这里");
    }

    //将数组转成set集合
    Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(array2));
    System.out.println(set);

    //将数组转成list集合
    List&lt;String&gt; list=new ArrayList&lt;String&gt;();
    for (int i = 0; i &lt; array2.length; i++) {
        list.add(array2[i]);
    }
    String[] arrStrings2={"1","2","3"};
    List&lt;String &gt; list2=java.util.Arrays.asList(arrStrings2);
    System.out.println(list2);


    //Arrays.fill()填充数组
    int[] arr3=new int[5];
    Arrays.fill(arr3, 10);  //将数组全部填充10
    for (int i = 0; i &lt; arr3.length; i++) {
        System.out.println(arr3[i]);
    }

    //数组排序
    int[] arr4 = {3, 7, 2, 1, 9};
    Arrays.sort(arr4);
    for (int i = 0; i &lt; arr4.length; i++) {
        System.out.println(arr4[i]);
    }

    int[] arr5 = {3, 7, 2, 1, 9,3,45,7,8,8,3,2,65,34,5};
    Arrays.sort(arr5, 1, 4);  //从第几个到第几个之间的进行排序
    for (int i = 0; i &lt; arr5.length; i++) {
        System.out.println(arr5[i]);
    }


    //复制数组
    int[] arr6 = {3, 7, 2, 1};
    int[] arr7=Arrays.copyOf(arr6, 10);  //指定新数组的长度

    int[] arr8=Arrays.copyOfRange(arr6, 1, 3); //只复制从索引[1]到索引[3]之间的元素（不包括索引[3]的元素）
    for (int i = 0; i &lt; arr8.length; i++) {
        System.out.println(arr8[i]);
    }

    //比较两个数组
    int[] arr9 = {1, 2, 3, 4,5,6,7,8,9,0};
    boolean arr10=Arrays.equals(arr6, arr9);
    System.out.println(arr10);

    //去重复
    //利用set的特性
    int[] arr11 = {1, 2, 3, 4,5,6,7,8,9,0,3,2,4,5,6,7,4,32,2,1,1,4,6,3};
    Set&lt;Integer&gt; set2=new HashSet&lt;Integer&gt;();
    for (int i = 0; i &lt; arr11.length; i++) {
        set2.add(arr11[i]);
    }
        System.out.println(set2);
    int[] arr12 = new int[set2.size()];
    int j=0;
    for (Integer i:set2) {
        arr12[j++]=i;
    }
    System.out.println(Arrays.toString(arr12));
}</code></pre><h3 id="14、String-StringBuffer-StringBuilder"><a href="#14、String-StringBuffer-StringBuilder" class="headerlink" title="14、String StringBuffer StringBuilder"></a>14、String StringBuffer StringBuilder</h3><ul>
<li>String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</li>
<li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li>
<li>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
<p><strong>String，StingBuffer，StringBuilder效率如何呢</strong></p>
<p>从高到底的顺序依次是：StringBuilder  &gt;  StingBuffer &gt; String</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;String是字符串常量，所以他的效率自然而然是最低的。对于StringBuffer和StringBuilder它们属于变量，是可以改变的对象，每次对字符串的操作，实际上实在一个对象上操作，所以效率更高一些。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;StringBuffer是线程安全的，考虑到安全问题，相对他的性能会更低一点。由此知道了从效率的角度看，StringBuilder最高，其次是StringBuffer，最后是String字符串常量。</p>
<p><strong>String 类的常用方法都有那些？</strong></p>
<ul>
<li>indexOf()：返回指定字符的索引</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h3 id="15、基本数据类型-amp-amp-包装类型"><a href="#15、基本数据类型-amp-amp-包装类型" class="headerlink" title="15、基本数据类型 &amp;&amp; 包装类型"></a>15、基本数据类型 &amp;&amp; 包装类型</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc8.png" alt=""></p>
<p>拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc9.png" alt=""></p>
<h4 id="2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"><a href="#2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆" class="headerlink" title="2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"></a>2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆</h4><ul>
<li>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</li>
<li>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</li>
<li>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</li>
<li>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</li>
</ul>
<h4 id="3、基本类型出现的原因"><a href="#3、基本类型出现的原因" class="headerlink" title="3、基本类型出现的原因"></a>3、基本类型出现的原因</h4><p>在Java编程思想的第一章就讲到：万物皆对象，new一个对象存储在堆中，我们通过堆栈的引用来使用这些对象，但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在堆栈中，因此更加高效。</p>
<h4 id="4、包装类型出现的原因"><a href="#4、包装类型出现的原因" class="headerlink" title="4、包装类型出现的原因"></a>4、包装类型出现的原因</h4><p>Java是一个面向对象的语言，基本类型并不具有对象的性质，为了与其他对象“接轨”就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h3 id="16、java日期处理"><a href="#16、java日期处理" class="headerlink" title="16、java日期处理"></a>16、java日期处理</h3><h4 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h4><blockquote>
<p>Date类用来指定日期和时间，其构造函数及常用方法如下：<br><br>public Date()从当前时间构造日期时间对象。<br><br>public String toString()转换成字符串。<br><br>public long getTime()它包含的是一个长整型数据long, 表示的是从GMT(格林尼治标准时间)1970年, 1 月 1日00:00:00这一刻之前或者是之后经历的毫秒数.</p>
</blockquote>
<h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><blockquote>
<p>通过向SimpleDateFormat 的构造函数传递格式字符串“yyyy-MM-dd”,<br>yyyy是年,MM是月,dd是日. 字符的个数决定了日期是如何格式化的.传递“yy-MM-dd”会显示 13-2-22</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc11.png" alt=""></p>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><blockquote>
<p>Calendar类主要用于完成日期字段之间的相互操作的功能 <br><br>Calendar类是一个抽象基类,不能new，我们可以通过Calendar.getInstance得到其实例，下面列出Calendar的一些常用方法：<br><br>set(int year, int month, int date)设置日历字段 <br><br>set(int field, int value) 将给定的日历字段设置为给定值 <br><br>get(int field)返回给定日历字段的值 <br><br>getTime()返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的 Date 对象。</p>
</blockquote>
<h5 id="Calendar示例"><a href="#Calendar示例" class="headerlink" title="Calendar示例"></a>Calendar示例</h5><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc10.png" alt=""></p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul>
<li>abs()返回某数字的绝对值.</li>
<li>ceil()会找到下一个最大整数。</li>
<li>floor()返回紧邻的最小整数。</li>
<li>max()返回两个值中的最大值。</li>
<li>min()返回两个值中的最小值。</li>
<li>random()返回一个随机数，在0.0到1.0之间的双精度数。</li>
<li>round()返回与某浮点数值最接近的整数值。</li>
<li>sqrt()返回某数值的平方根。</li>
</ul>
<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><blockquote>
<p>Random类 伪随机数产生器。</p>
</blockquote>
<p>常用方法:</p>
<ul>
<li>public boolean nextBoolean()<br>该方法的作用是生成一个随机的boolean值。</li>
<li>public double nextDouble()<br>该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。</li>
<li>public int nextInt()<br>该方法的作用是生成一个随机的int值。</li>
<li>public int nextInt(int n)<br>该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。</li>
</ul>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * 将日期解析为指定格式的字符串
     */</span>
    Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 将字符串解析为日期对象
     */</span>
    SimpleDateFormat sim <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String ss <span class="token operator">=</span> <span class="token string">"2020-01-01"</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Date parse <span class="token operator">=</span> sim<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parse<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sim<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ParseException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * Calendar使用
     */</span>
    Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Date time <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 设置日期
     */</span>
    calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * Random随机数
     */</span>
    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc12.png" alt=""></p>
<h3 id="17-集合框架"><a href="#17-集合框架" class="headerlink" title="17.集合框架"></a>17.集合框架</h3><p>** 什么是集合 **</p>
<blockquote>
<p>通常情况下，把具有相同性质的一类东西，汇聚成一个整体，就可以称为集合。</p>
</blockquote>
<p>** 什么是集合框架 **</p>
<blockquote>
<p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>
</blockquote>
<ul>
<li>接口：即表示集合的抽象数据类型。</li>
<li>实现：也就是集合框架中接口的具体实现。</li>
<li>算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。</li>
</ul>
<h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p>Java集合框架图。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc14.png" alt=""></p>
<p>1) 首先查看jdk中Collection类的源码后:</p>
<pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {</code></pre><p>通过查看可以发现Collection是一个接口类，其继承了java迭代接口Iterable</p>
<p><strong>Collection接口中的方法如下:</strong><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc13.png" alt=""></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul>
<li><p>ArrayList底层其实就是一个Object类型的数组，非线程安全的集合。查询元素快，插入，删除中间元素慢，初始化的长度为10，每次扩容为原大小的1.5倍，可以通过构造方法改变初始容量大小。</p>
</li>
<li><p>ArrayList快在下标定位，慢在数组复制。</p>
</li>
<li><p>由于每次添加的时候，通过扩容机制判断原数组是否还有空间，若没有则重新实例化一个空间更大的新数组，把旧数组的数据拷贝到新数组中，耗费时间和性能</p>
</li>
</ul>
<p><strong>Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0，JDK差异，每次约按1.5倍扩容。 JDK8 中ArrayList扩容的实现是通过grow()方法里使用语句newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)（即1.5倍扩容）计算容量，然后调用Arrays.copyof()方法进行对原数组进行复制。</strong></p>
<p><strong>若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</strong></p>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote>
<p><font size="3"> 基于数组实现的线程安全的集合。线程同步（方法被synchronized修饰），性能比ArrayList差。 </font></p>
</blockquote>
<font size="4">
Vector 的数据结构和使用方法与ArrayList差不多。最大的不同就是Vector是线程安全的。几乎所有的对数据操作的方法都被synchronized关键字修饰。synchronized是线程同步的，当一个线程已经获得Vector对象的锁时，其他线程必须等待直到该锁被释放。从这里就可以得知Vector的性能要比ArrayList低。
若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合
</font>

<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>基于双向循环链表实现的非线程安全的集合。查询元素慢，插入，删除中间元素快。</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</p>
<h4 id="几种集合的区别"><a href="#几种集合的区别" class="headerlink" title="几种集合的区别"></a>几种集合的区别</h4><p>ArrayList查询快，写数据慢；LinkedList查询慢，写数据快<br>ArrayList查询快是因为底层是由数组实现，通过下标定位数据快。写数据慢是因为复制数组耗时。LinkedList底层是双向循环链表，查询数据依次遍历慢。写数据只需修改指针引用。<br>ArrayList和LinkedList都不是线程安全的，小并发量的情况下可以使用Vector，若并发量很多，且读多写少可以考虑使用CopyOnWriteArrayList。</p>
<h4 id="遍历list集合"><a href="#遍历list集合" class="headerlink" title="遍历list集合"></a>遍历list集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * for循环遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * foreach遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 通过迭代器遍历
     */</span>
    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>[set][1]</p>
<blockquote>
<p>在选择的时候，如果顺序很重要，则可以选择TreeSet，如果操作性能和时间效率很重要的话，则可以选择HashSet</p>
</blockquote>
<ul>
<li><p>HashSet集合</p>
<blockquote>
<p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置，存取速度比较快。</p>
</blockquote>
<ul>
<li>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树，底层实际上是一个HashMap。</li>
<li>所以可以直接总结出：HashSet实际上就是封装了HashMap，操作HashSet元素实际上就是操作HashMap。这也是面向对象的一种体现，重用性贼高！</li>
<li>无序，允许为null，，有且仅有一个元素为null！</li>
<li>线程不安全的。</li>
<li>HashSet还有一个子类LinkedHashSet</li>
</ul>
</li>
<li><p>TreeSet集合</p>
<ul>
<li>底层数据结构是红黑树(是一个自平衡的二叉树)</li>
<li>有排序功能，支持两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</li>
<li>有序，不允许为null</li>
<li>线程不安全的。</li>
</ul>
</li>
<li><p>LinkedHashSet集合</p>
<ul>
<li>迭代是有序的</li>
<li>允许为null，有且仅有一个元素为null！</li>
<li>底层实际上是一个HashMap+双向链表实例(其实就是LinkedHashMap)</li>
<li>线程不安全的。</li>
<li>性能比HashSet差一丢丢，因为要维护一个双向链表</li>
<li>初始容量与迭代无关，LinkedHashSet迭代的是双向链表</li>
</ul>
</li>
</ul>
<h4 id="遍历set集合"><a href="#遍历set集合" class="headerlink" title="遍历set集合"></a>遍历set集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 迭代器遍历方式
     */</span>
    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str<span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="set-和list的区别"><a href="#set-和list的区别" class="headerlink" title="set 和list的区别"></a>set 和list的区别</h4><ul>
<li>List接口：存储一组不唯一，有序的对象</li>
<li>Set接口：存储一组唯一，无序的对象</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>*<em>Map接口不是继承Collection接口；Map接口用于维护键／值对（key/value pairs），他的实现类有: *</em><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc15.png" alt=""></p>
<h4 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc16.png" alt=""></p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p><strong>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</strong></p>
<h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><p>! 从Hashtable的命名规范就可以看出，t没有大写，并不是我写错了</p>
<p>底层是哈希表数据结构，不可以存入null键null值。该集合是线程同步的。</p>
<h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。</p>
<h5 id="LinkedHashMap："><a href="#LinkedHashMap：" class="headerlink" title="LinkedHashMap："></a>LinkedHashMap：</h5><p>该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。</p>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>该类是线程安全的 Map 实现。与 Hashtable 相似，但 Hashtable 的 synchronized 是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对 hash 表的不同部分进行的修改。ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<h4 id="遍历map集合"><a href="#遍历map集合" class="headerlink" title="遍历map集合"></a>遍历map集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 第二种
     */</span>
    <span class="token comment" spellcheck="true">//遍历map中的键</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//遍历map中的值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * 迭代器
     */</span>
    Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * 通过键找值遍历（效率低）
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="三种集合在实际工作用到的地方"><a href="#三种集合在实际工作用到的地方" class="headerlink" title="三种集合在实际工作用到的地方"></a>三种集合在实际工作用到的地方</h4><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>容器指的是集合框架</p>
<p>同步容器是通过syncrhoized关键字对线程不安全的操作进行加锁来保证线程安全的，其原理是使得多线程轮流获取同步锁进行对集合的操作，所以性能有所下降。，像Vector、Hashtable、Stack。</p>
<p> 为此，java.util.concurrent提供了多种并发容器，以：在原有集合的拷贝上进行操作，用修改后的集合替换原集合  的方式来达到并发且安全地使用集合类的目的。</p>
<pre><code>根据接口的类型，主要有以下四种接口，其他具体的容器均是对这些接口的实现类：</code></pre><p>Queue类型：阻塞队列BlockingQueue、非阻塞队列ConcurrentLinkedQueue</p>
<p>Map类型：ConcurrentMap</p>
<p>Set类型：ConcurrentSkipListSet、CopyOnWriteArraySet</p>
<p>List类型：CopyOnWriteArrayList</p>
<h4 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h4><font size="3">

<p>　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>　　<br>　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
</font>

<h3 id="hascode"><a href="#hascode" class="headerlink" title="hascode"></a>hascode</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>根据这个方法的声明可知，它是一个本地方法，它的实现与本地机器有关，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p>
<p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及Hashtable，如果没有很好的覆写键的hashcode()和equals()方法，那么将无法正确的处理键。</p>
<p>　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）—–HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。</p>
<p>所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。</p>
<h3 id="18、泛形"><a href="#18、泛形" class="headerlink" title="18、泛形"></a>18、泛形</h3><p><strong>什么是泛型</strong></p>
<pre><code>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。
在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</code></pre><h4 id="泛形方法"><a href="#泛形方法" class="headerlink" title="泛形方法"></a>泛形方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 说明：
 * 1）&lt;E>非常重要，可以理解为声明此方法为泛型方法。
 * 2）只有声明了&lt;E>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
 * 3）&lt;E>表明该方法将使用泛型类型E，此时才可以在方法中使用泛型类型E。
 * 4）与泛型类的定义一样，此处E可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
 *
 * @param inputArray
 * @param &lt;E>
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 输出数组元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>E element <span class="token operator">:</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="泛形类"><a href="#泛形类" class="headerlink" title="泛形类"></a>泛形类</h4><h4 id="泛形接口"><a href="#泛形接口" class="headerlink" title="泛形接口"></a>泛形接口</h4><h4 id="泛形通配符：？"><a href="#泛形通配符：？" class="headerlink" title="泛形通配符：？"></a>泛形通配符：？</h4><h4 id="泛形的限定"><a href="#泛形的限定" class="headerlink" title="泛形的限定"></a>泛形的限定</h4><p>我们知道使用泛型类时：如果明确参数类型，那么泛型就代表一种类型；如果使用通配符？，那么泛型就代表任意类型。但有时候我们希望指定某些类型(不是一个，也不要所有)能作为参数类型，这应该怎么办呢？</p>
<pre><code>    Java中利用泛型的限定解决了这个问题，即泛型的限定。我们只需要按这样的格式书写：

   上限：&lt;？ extends E&gt;表示参数类型是E及其所有子类。

   下限：&lt;? super E&gt;表示参数类型是E及其所有超类(即父类)。</code></pre><h4 id="Java泛型中E、T、K、V等的含义"><a href="#Java泛型中E、T、K、V等的含义" class="headerlink" title="Java泛型中E、T、K、V等的含义"></a>Java泛型中E、T、K、V等的含义</h4><ul>
<li>E - Element (在集合中使用，因为集合中存放的是元素)（集合泛形）</li>
<li>T - Type（Java 类）（接口）</li>
<li>K - Key（键）</li>
<li>V - Value（值）</li>
<li>N - Number（数值类型）</li>
<li>？ -  表示不确定的java类型</li>
</ul>
<h3 id="19、枚举"><a href="#19、枚举" class="headerlink" title="19、枚举"></a>19、枚举</h3><p>enum 的全称为 enumeration， 是 JDK 1.5  中引入的新特性，存放在 java.lang 包中，另外到了JDK1.6后switch语句支持枚举类型。</p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71333103</a></p>
<h3 id="20、io流"><a href="#20、io流" class="headerlink" title="20、io流"></a>20、io流</h3><p>Java中使用IO(输入输出）来读取和写入，读写设备上的数据、硬盘文件、内存、键盘……，根据数据的走向可分为输入流和输出流，这个走向是以内存为基准的，即往内存中读数据是输入流，从内存中往外写是输出流。</p>
<p><strong>根据处理的数据类型可分为字节流和字符流</strong></p>
<p>  1.字节流可以处理所有数据类型的数据，在java中以Stream结尾</p>
<p>  2.字符流处理文本数据，在java中以Reader和Writer结尾。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc17.png" alt=""></p>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="输入流-InputStream"><a href="#输入流-InputStream" class="headerlink" title="输入流 InputStream"></a>输入流 InputStream</h5><p><strong>API</strong></p>
<ul>
<li>int read( )    读取一个字节，返回值为所读的字节</li>
<li>int read( byte b[ ] )   读取多个字节，放置到字节数组b中，通常读取的字节数量为b的长度，返回值为实际读取的字节的数量</li>
<li>int read( byte b[ ], int off, int len )   读取len个字节，放置到以下标off开始字节数组b中，返回值为实际读取的字节的数量</li>
<li>int available( )   返回值为流中尚未读取的字节的数量</li>
<li>long skip( long n )   读指针跳过n个字节不读，返回值为实际跳过的字节数量</li>
<li>close( )   流操作完毕后必须关闭</li>
</ul>
<p>代码</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    InputStream inputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将读取到的一个字节给i，中文占两个字节</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h5 id="输出流-OutputStream"><a href="#输出流-OutputStream" class="headerlink" title="输出流 OutputStream"></a>输出流 OutputStream</h5><p><strong>API</strong></p>
<ul>
<li>void write( int b ); 　　//往流中写一个字节b</li>
<li>void write( byte b[ ] ); //往流中写一个字节数组b</li>
<li>void write( byte b[ ], int off, int len );  把字节数组b中从下标off开始，长度为len的字节写入流中</li>
<li>flush( )  刷空输出流，并输出所有被缓存的字节由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li>
<li>close( ) 流操作完毕后必须关闭 </li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 没有则会创建文件</span>
    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    OutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"超哥"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="输入流-Reader"><a href="#输入流-Reader" class="headerlink" title="输入流 Reader"></a>输入流 Reader</h5><p><strong>API</strong></p>
<ul>
<li>int read() throws IOException;  读取一个字符，返回值为读取的字符</li>
<li>int read(char cbuf [  ]) throws IOException; 读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</li>
<li>abstract int read( char cbuf[ ] , int off , int len) throws IOException;   读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</li>
<li>boolean markSupported( ); 判断当前流是否支持做标记</li>
<li>void mark ( int readAheadLimit ) throws IOException;   给当前流作标记，最多支持readAheadLimit个字符的回溯。</li>
<li>void reset( ) throws IOException;    将当前流重置到做标记处</li>
<li>abstract void close( ) throws IOException;   关闭</li>
</ul>
<p><strong>代码</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Reader os <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="输出流-Writer"><a href="#输出流-Writer" class="headerlink" title="输出流 Writer"></a>输出流 Writer</h5><p><strong>API</strong></p>
<ul>
<li>void write (int c) throws IOException； 将整型值c的低16位写入输出流</li>
<li>void write ( String str ) throws IOException； 将字符串str中的字符写入输出流</li>
<li>void write( char cbuf[ ] )  throws IOException；  将字符数组cbuf[]写入输出流</li>
<li>abstract void write( char cbuf[ ] , int off , int len) throws IOException； 将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流</li>
<li>void write( String str , int off , int len) throws IOException；  将字符串str 中从索引off开始处的len个字符写入输出流</li>
<li>flush( )   刷空输出流，并输出所有被缓存的字节。</li>
<li>close( )  关闭流</li>
</ul>
<h4 id="字节、字符流转换类"><a href="#字节、字符流转换类" class="headerlink" title="字节、字符流转换类"></a>字节、字符流转换类</h4><p>字节转为字符流</p>
<blockquote>
<p>字符 不需要转为字节流，字节流可以读取任意数据，而字符读取内容有限。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将字节流转换为字符流</span>
        InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h5 id="缓冲流介绍"><a href="#缓冲流介绍" class="headerlink" title="缓冲流介绍"></a>缓冲流介绍</h5><blockquote>
<p>普通的字节、字符流都是一个字节一个字符这样读取的,而缓冲流则是将数据先缓冲起来,然后一起写入或者读取出来。<br>缓冲流为I/O流增加了内存缓冲区，使用缓冲流的好处是，能够更高效的读写信息。缓冲流要“套接”在相应的节点流(低级流)之上，对读写的数据提供了缓冲的功能。<br>缓冲输入流支持其父类的mark()和reset()方法：mark()用于“标记”当前位置，就像加入了一个书签，可以使用reset()方法返回这个标记重新读取数据</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 字节缓冲流</span>
        BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>J2SDK提供了四种缓存流：<br><font size="4"><br><strong>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter</strong> </font></p>
<h5 id="缓冲流字节流"><a href="#缓冲流字节流" class="headerlink" title="缓冲流字节流"></a>缓冲流字节流</h5><pre><code>java.io.BufferedInputStream类可以对任何的InputStream流进行带缓冲的封装以达到性能的改善。该类在已定义输入流上再定义一个具有缓冲的输入流，可以从此流中成批地读取字符而不会每次都引起直接对数据源的读操作。数据输入时，首先被放入缓冲区，随后的读操作就是对缓冲区中的内容进行访问
java.io.BufferedOutputStream不直接写入输出流，先写入缓冲区，当缓冲区满时，字节数据才会写到BufferedOutputStream所连接的流，调用该类的flush()将缓冲区全部写入输出流</code></pre><h3 id="21、序列化"><a href="#21、序列化" class="headerlink" title="21、序列化"></a>21、序列化</h3><h4 id="对象序列化概述"><a href="#对象序列化概述" class="headerlink" title="对象序列化概述"></a>对象序列化概述</h4><blockquote>
<p>一般地，对象不能脱离应用程序。但有时候，需要将对象的状态保存下来，在需要时再将对象恢复，即对象持久化（Persistence）。对象序列化（Object Serialization）可以将对象存储到外存中或以二进制形式通过网络传输。对象反串行化可以从这些数据中重构一个与原始对象状态相同的对象<br>为了实现对象系列化，对应的类必须实现下面的两种接口之一：<br>Serializable<br>Externalizable</p>
</blockquote>
<h4 id="将对象保存到磁盘文件"><a href="#将对象保存到磁盘文件" class="headerlink" title="将对象保存到磁盘文件"></a>将对象保存到磁盘文件</h4><ul>
<li>通过java.io.ObjectOutputStream可以将对象输出到磁盘文件、网络等设备</li>
<li>调用这个类的writeObject()方法，可以向特定的文件或网络输出对象</li>
<li>writeObject()方法序列化指定的对象，并遍历该对象对其它对象的引用，递归的序列化所有被引用到的其它对象，从而建立一个完整的序列化流</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        OutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Student需要序列化</span>
        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">setI</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="从磁盘读出保存的对象"><a href="#从磁盘读出保存的对象" class="headerlink" title="从磁盘读出保存的对象"></a>从磁盘读出保存的对象</h4><ul>
<li>通过java.io.ObjectInputStream对象可以从磁盘文件中读出保存的对象（或从网络中读出传递的对象）</li>
<li>调用这个类的readObject()方法，从特定的设备读出对象readObject()方法反序列化输入流中的对象，遍历该对象中所有对其它对象的引用，并递归的反序列化这些引用对象</li>
<li>readObject()方法返回的是Object对象，所以，需要对它进行必要的（向下）造型操作。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Student student <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><ul>
<li>通过在属性前面加上transient关键字，限制属性写入到文件或网络中</li>
<li>还可以在未实现系列化接口的引用类型属性前面加上transient关键字，避免对此类属性进行递归系列化时出现java.io.NotSerializableException异常</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> String name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加一个transient修饰的属性</span></code></pre>
<p>什么被序列化<br>属性（包括基本数据类型、数组、对其它对象的引用）<br>类名<br>什么不被序列化<br>static的属性<br>方法<br>加了transient修饰符的属性</p>
<h3 id="22、多线程"><a href="#22、多线程" class="headerlink" title="22、多线程"></a>22、多线程</h3><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7526608.html</a></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt="image"></p>
<h4 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h4><table>
<thead>
<tr>
<th>术语</th>
<th>英文单词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>共享变量</td>
<td></td>
<td>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。</td>
</tr>
<tr>
<td>内存屏障</td>
<td>Memory Barriers</td>
<td>是一组处理器指令，用于实现对内存操作的顺序限制。</td>
</tr>
<tr>
<td>缓冲行</td>
<td>Cache line</td>
<td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td>
</tr>
<tr>
<td>原子操作</td>
<td>Atomic operations</td>
<td>不可中断的一个或一系列操作。</td>
</tr>
<tr>
<td>缓存行填充</td>
<td>cache line fill</td>
<td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有）</td>
</tr>
<tr>
<td>缓存命中</td>
<td>cache hit</td>
<td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。</td>
</tr>
<tr>
<td>写命中</td>
<td>write hit</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td>
</tr>
<tr>
<td>写缺失</td>
<td>write misses the cache</td>
<td>一个有效的缓存行被写入到不存在的内存区域。</td>
</tr>
</tbody></table>
<p><strong>什么是进程</strong></p>
<p>进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例。</p>
<p><strong>进程时间片的概念</strong></p>
<pre><code>一个操作系统中，如果同时运行着多个进程，他们是一定交替运行的。每个进程不管有没有运行完毕，都只占据一段时间的CPU。
这个运行时间就是进程时间片。它非常短促，所以感觉不到他们是交替占用CPU。
</code></pre><p><strong>什么是线程</strong></p>
<ul>
<li><p>线程：进程内部的控制流。它也是一段可运行的指令。</p>
</li>
<li><p>特点：资源占用小，线程间通信容易。</p>
</li>
<li><p>多进程是指操作系统能同时运行多个任务（程序）。</p>
</li>
</ul>
<p>多线程：</p>
<pre><code>指的是这个程序（一个进程）运行时产生了不止一个线程</code></pre><h4 id="线程进程的区别体现在几个方面："><a href="#线程进程的区别体现在几个方面：" class="headerlink" title="线程进程的区别体现在几个方面："></a>线程进程的区别体现在几个方面：</h4><p>第一：  因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p>
<p>第二：  体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p>
<p>3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p>
<p>4.线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；</p>
<p>5.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p>
<p>第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p>
<p>并行与并发：</p>
<pre><code>1.    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
2.    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，
那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。
并发性（concurrency）和并行性（parallel）
</code></pre><p><strong>线程的特点</strong></p>
<ul>
<li>线程的运行方式和进程一样，在同一个进程内部，线程也是交替占用CPU。每个线程的运行时间，称为线程时间片。</li>
<li>线程有开始、中间和结束部分，即有一定的生命周期。</li>
<li>同一个进程中的多个线程是共享一块内存空间和一组系统资源。</li>
<li>线程不能作为具体的可执行命令体存在。最终用户不能直接执行线程，线程只能运行在进程中。</li>
</ul>
<p><strong>如何创建线程</strong></p>
<pre><code>两种方法来创建线程：
继承java.lang.Thread类，并覆盖run( )方法。
 class mythread extends Thread {
     public void run( ) {
         /* 覆盖该方法*/
      }
 }
实现java.lang.Runnable接口，并实现run( )方法。
class mythread implements Runnable{
      @Override
      public void run( ) {
          /* 实现该方法*/
      }
 }
一个线程的对象只能执行一次start()方法</code></pre><p><strong>线程的启动</strong></p>
<ul>
<li><p>新建的线程不会自动开始运行，必须通过start( )方法启动线程。如果不调用这个方法，线程将不会运行。</p>
</li>
<li><p>也就是说可以事先创建线程，并在需要的时候才启动他们。如：</p>
<pre class=" language-java"><code class="language-java">  继承Thread的线程：
Typer  t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Typer</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
<p>实现Runnable接口的线程：<br>Runnable  mt =   new Typer ( );<br>Thread    t  =   new Thread(mt);// 父类的类型子类的对象<br>t.start( );</p>
<pre><code>**线程执行过程**
- 调用start( )方法时，将创建一个新的线程，并为线程分配系统资源，如内存。接着它将调用 run( ) 方法。

- run( ) 方法中的代码定义执行线程所需的功能。
    - run()方法能够调用其他方法，引用其他的类，申明变量。
    - run()方法在程序中确定另一个并发线程的执行入口。
- 当run()方法中的任务完成返回时，该线程也将结束。

**注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。
从程序运行的结果可以发现，多线程程序是乱序执行。**

#### Thread和Runnable的区别

实现Runnable接口比继承Thread类所具有的优势：

- 适合多个相同的程序代码的线程去处理同一个资源
- 可以避免java中的单继承的限制
- 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
- 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类

#### 线程状态

下面的这个图非常重要!

![](https://raw.githubusercontent.com/Flyiyu/use/master/jc18.jpg)


1. 新建状态（New）：新创建了一个线程对象。
2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    - 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持    有的锁)
    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
    - 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。


#### 线程调度
线程的调度

1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。

Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
static int MAX_PRIORITY
    线程可以具有的最高优先级，取值为10。
static int MIN_PRIORITY
    线程可以具有的最低优先级，取值为1。
static int NORM_PRIORITY
          分配给线程的默认优先级，取值为5。

Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。

每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。
JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。

2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。

4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。

6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。
 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。

#### 守护线程
1. 定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公
共服务，在没有用户线程可服务时会自动离开。
2. 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。
3. 设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程
的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。
4. 在 Daemon 线程中产生的新线程也是 Daemon 的。
5. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的
生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程
依旧是活跃的。
6. example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,
程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线
程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统
中的可回收资源。
7. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周
期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依
赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退
出了；如果还有一个或以上的非守护线程则 JVM 不会退出。




##### yield()、sleep()、join()和interrupt()方法   

1、yield()　

　　&amp;ensp;&amp;ensp;yield()是Thread类的静态方法。它能让当前线程暂停，但不会阻塞该线程，而是由“运行状态”进入到“就绪状态”，从而让 其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是 当前线程又进入到“运行状态”继续运行！

　　值得注意的是，yield()方法不会释放锁。



2、sleep()

　　&amp;ensp;&amp;ensp;sleep()是Thread类的静态方法。该方法声明抛出了InterrupedException异常。所以使用时，要么捕捉，要么声明抛出。

　　有2种重载方式：

——static void sleep(long millis)　　:　　让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。

——static void sleep(long millis , int nanos)　　：　　让当前正在执行的线程暂停millis毫秒加nanos微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。

　　sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。常用来暂停程序的运行。　　

　　同时注意，sleep()方法不会释放锁。



3、join()

　　join() 是Thread的一个实例方法。表示，当某个程序执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join的线程执行完毕。

有3种重载的形式：

——join()　　:　　等待被join的线程执行完成

——join(long millis)　　：　　等待被join的线程的时间最长为millis毫秒，若在millis毫秒内，被join的线程还未执行结束，则不等待。

——join(long millis , int nanos)　　:　　等待被join的线程的时间最长为millis毫秒加nanos微秒，若在此时间内，被join的线程还未执行结束，则不等待。

&amp;ensp;&amp;ensp;即当前线程内，用某个线程对象调用join()后，会使当前线程等待，直到该线程对象的线程运行完毕，原线程才会继续运行。



4、interrupt()　　　

　　我们经常通过判断线程的中断标记来控制线程。　 　

　　&amp;ensp;&amp;ensp;interrupt()是Thread类的一个实例方法，用于中断本线程。这个方法被调用时，会立即将线程的中断标志设置为“true”。所以当中断处于“阻塞状态”的线程时，由于处于阻塞状态，中断标记会被设置为“false”，抛出一个 InterruptedException。所以我们在线程的循环外捕获这个异常，就可以退出线程了。

　&amp;ensp;&amp;ensp;interrupt()并不会中断处于“运行状态”的线程，它会把线程的“中断标记”设置为true，所以我们可以不断通过isInterrupted()来检测中断标记，从而在调用了interrupt()后终止线程，这也是通常我们对interrupt()的用法。

　　&amp;ensp;&amp;ensp;Interrupted()是Thread类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，isInterrupted()是Thread类的实例方法，返回一个布尔类型来判断线程是否已经被中断。它们都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。
　　
　　
　　
#### start 与 run 区别
1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。
2. 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运
行。
3. 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运
行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。

#### Synchronized关键字

synchronized是一个重量级锁，相对于Lock，它会显得那么笨重 诚然，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。

  1、同步和异步的区别和联系

 　　&amp;ensp;&amp;ensp;所谓同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其它的命令。

&amp;ensp;&amp;ensp;异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。

 &amp;ensp;&amp;ensp;同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行(死心眼)。

异步在一定程度上可以看做是多线程的，请求一个方法后，就不管了，继续执行其他的方法。



1、原理

**在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。**

　　&amp;ensp;&amp;ensp;当当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。

　　&amp;ensp;&amp;ensp;不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。
例如，现在有个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。



2、基本规则

　　&amp;ensp;&amp;ensp;第一条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。

　　&amp;ensp;&amp;ensp;第二条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。

　&amp;ensp;&amp;ensp;第三条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。

1、普通同步方法，锁是当前实例对象

2、静态同步方法，锁是当前类的class对象

3、同步方法块，锁是括号里面的对象




3、实例锁和全局锁

&amp;ensp;&amp;ensp;实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。
               实例锁对应的就是synchronized关键字。

&amp;ensp;&amp;ensp;全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。
               全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。

&amp;ensp;&amp;ensp;就是说，一个非静态方法上的synchronized关键字，代表该方法依赖其所属对象。一个静态方法上synchronized关键字，代表该方法依赖这个类本身。



#### synchronized, wait, notify结合:典型场景生产者消费者问题

```java
/**
   * 生产者生产出来的产品交给店员
   */
  public synchronized void produce()
  {
      if(this.product &gt;= MAX_PRODUCT)
      {
          try
          {
              wait();  
              System.out.println("产品已满,请稍候再生产");
          }
          catch(InterruptedException e)
          {
              e.printStackTrace();
          }
          return;
      }

      this.product++;
      System.out.println("生产者生产第" + this.product + "个产品.");
      notifyAll();   //通知等待区的消费者可以取出产品了
  }

  /**
   * 消费者从店员取产品
   */
  public synchronized void consume()
  {
      if(this.product &lt;= MIN_PRODUCT)
      {
          try 
          {
              wait(); 
              System.out.println("缺货,稍候再取");
          } 
          catch (InterruptedException e) 
          {
              e.printStackTrace();
          }
          return;
      }

      System.out.println("消费者取走了第" + this.product + "个产品.");
      this.product--;
      notifyAll();   //通知等待去的生产者可以生产产品了
  }
</code></pre><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="Volatile的官方定义"><a href="#Volatile的官方定义" class="headerlink" title="Volatile的官方定义"></a>Volatile的官方定义</h5><p>  Java语言规范第三版中对volatile的定义如下：<br>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p>  volatile这个关键字。其实这个关键字有两层语义。第一层语义就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化。我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。</p>
<p><strong>Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</strong></p>
<h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><p>　　为什么出现这种情况呢，我们需要先了解一下JMM（java内存模型）</p>
<p>　　java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>　　JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc31.png" alt=""></p>
<p>　需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p>
<p>  那么这种共享变量在多线程模型中的不可见性如何解决呢？比较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，有点炮打蚊子的意思。比较合理的方式其实就是volatile</p>
<h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><h5 id="ThreadLocal概念"><a href="#ThreadLocal概念" class="headerlink" title="ThreadLocal概念"></a>ThreadLocal概念</h5><p>ThreadLocal 是线程的局部变量， 是每一个线程所单独持有的，其他线程不能对其进行访问。</p>
<p>  ThreadLocal，直译为“线程本地”或“本地线程”，如果你真的这么认为，那就错了！其实，它就是一个容器，用于存放线程的局部变量，我认为应该叫做 ThreadLocalVariable（线程局部变量）才对，真不理解为什么当初 Sun 公司的工程师这样命名。</p>
<p>  当使用ThreadLocal维护变量的时候 为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。</p>
<p>  但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
<p><strong>跳出误区</strong></p>
<p>  需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p>
<h5 id="ThreadLocal常用方法介绍"><a href="#ThreadLocal常用方法介绍" class="headerlink" title="ThreadLocal常用方法介绍"></a>ThreadLocal常用方法介绍</h5><p>public void set(T value)：将值放入线程局部变量中</p>
<p>public T get()：从线程局部变量中获取值</p>
<p>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</p>
<p>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </p>
<p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要自己来实现的，给这个线程局部变量一个初始值吧。</p>
<h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><pre><code>Runnable r[] = new Runnable[2];</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc25.jpg" alt=""></p>
<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>  如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>  那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？  在Java中可以通过线程池来达到这样的效果.</p>
<p>  合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<p>下为常见的四种：</p>
<ol>
<li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li>
<li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li>
<li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li>
<li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li>
</ol>
<h4 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h4><blockquote>
<p>阻塞队列提供了可阻塞的入队和出对操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用；</p>
</blockquote>
<p>在Java中，主要有以下类型的阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个支持延时获取元素的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 </li>
</ul>
<h4 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h4><h3 id="JAVA-锁"><a href="#JAVA-锁" class="headerlink" title="JAVA 锁"></a>JAVA 锁</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>  乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为<br>别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数<br>据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），<br>如果失败则要重复读-比较-写的操作。</p>
<p>  java 中的乐观锁基本都是通过 CAS 操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>  悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人<br>会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。<br>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，<br>才会转换为悲观锁，如 RetreenLock。</p>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>  自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁<br>的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>  线程自旋是需要消耗 cpu 的，说白了就是让 cpu 在做无用功，如果一直获取不到锁，那线程<br>也不能一直占用 cpu 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁<br>的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p><strong>自旋锁的优缺点</strong></p>
<p>  自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来<br>说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>  但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合<br>使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p>
<p><strong>自旋锁时间阈值（1.6 引入了适应性自旋锁）</strong></p>
<p>  自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择<br>自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p>
<h5 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h5><p>  synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重<br>入锁</p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>  ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完<br>成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等<br>避免多线程死锁的方法。</p>
<h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><p>  首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有<br>AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，<br>区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所<br>有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。</v></p>
<p>  通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些<br>同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger<br>的性能是 ReentantLock 的好几倍。</p>
<h5 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h5><p>  本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫<br>做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受<br>影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<h5 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h5><p>  为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如<br>果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写<br>锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p>
<p>读锁<br>  如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p>
<p>写锁<br>  如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。<br>总之，读的时候上读锁，写的时候上写锁！<br>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现<br>ReentrantReadWriteLock。</p>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>公平锁（Fair）</p>
<p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁（Nonfair）<br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<ol>
<li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li>
<li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li>
</ol>
<h5 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h5><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<p>独占锁</p>
<p>  独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。<br>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线<br>程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p>共享锁</p>
<p>  共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种<br>乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等<br>待线程的锁获取模式。</li>
<li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，<br>或者被一个 写操作访问，但两者不能同时进行。</li>
</ol>
<h5 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（Mutex Lock）</h5><p>  Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又<br>是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用<br>户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么<br>Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为<br>“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。<br>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和<br>“偏向锁”。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>  锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。<br>锁升级<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，<br>也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，<br>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量<br>级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场<br>景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀<br>为重量级锁。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>  Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线<br>程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起<br>来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级<br>锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换<br>ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所<br>以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻<br>量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进<br>一步提高性能</p>
<h5 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h5><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul>
<li>减少锁持有时间</li>
</ul>
<p>只用在有线程安全要求的程序上加锁</p>
<ul>
<li>减小锁粒度</li>
</ul>
<p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。<br>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是<br>ConcurrentHashMap。</p>
<ul>
<li>锁分离</li>
</ul>
<p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互<br>斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]<br>JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如<br>LinkedBlockingQueue 从头部取出，从尾部放数据</p>
<ul>
<li>锁粗化</li>
</ul>
<p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完<br>公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步<br>和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p>
<ul>
<li>锁消除<br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这<br>些对象的锁操作，多数是因为程序员编码不规范引起</li>
</ul>
<h3 id="虚拟机常用命令"><a href="#虚拟机常用命令" class="headerlink" title="虚拟机常用命令"></a>虚拟机常用命令</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>数组</strong></p>
<ul>
<li>数组作为数据存储结构的缺陷</li>
<li>在无序数组中，搜索是低效的</li>
<li>而在有序数组中插入效率又很低</li>
<li>不管在哪一种数组中删除效率都很低</li>
<li>创建一个数组之后，它的大小又是不可变的</li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>链表是一种有序的列表</li>
<li>链表的内容通常存储与内存中分散的位置上</li>
<li>链表由节点组成，每一个节点的结构都相同</li>
<li>节点分为数据域和链域，数据域是存放节点的内容，链域存放的是下一个节点的指针</li>
</ul>
<h4 id="单向链表（Single-Linked-List）"><a href="#单向链表（Single-Linked-List）" class="headerlink" title="单向链表（Single-Linked List）"></a>单向链表（Single-Linked List）</h4><p>　　单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。</p>
<p>　　单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc20.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc21.png" alt=""></p>
<h3 id="栈-stack-与堆-heap"><a href="#栈-stack-与堆-heap" class="headerlink" title="栈(stack)与堆(heap)"></a>栈(stack)与堆(heap)</h3><p>1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制；</p>
<ol>
<li><p>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中(对象可能在常量池里)（字符串常量对象存放在常量池中。）；</p>
</li>
<li><p>堆：存放所有new出来的对象；</p>
</li>
<li><p>静态域：存放静态成员（static定义的）；</p>
</li>
<li><p>常量池：存放字符串常量和基本类型常量（public static final）。有时，在嵌入式系统中，常量本身会和其他部分分割离开(由于版权等其他原因)，所以在这种情况下，可以选择将其放在ROM中 ；</p>
</li>
<li><p>非RAM存储：硬盘等永久存储空间</p>
</li>
</ol>
<p>堆栈是一种有序表。</p>
<p>堆栈只允许数据自有序列表（前端）作输入、输出操作。<br>堆栈的存取顺序就像手枪的弹夹一样，最先压进去的子弹会被最后打出来<br>具有先进后出FILO（First In Last Out）的特性</p>
<p>堆栈的典型操作</p>
<p>入栈：又称压栈，是指将数据放入堆栈</p>
<p>出栈：将数据从堆栈中取出来</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> obj<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 指向标
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> pointer<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 数组的长度
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 给定一个默认的长度
     */</span>
    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 方法的重载
     *
     * @param size
     */</span>
    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断堆栈是否已经满了
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * 由于指向标的位置是从-1开始的，数组的下标是从0开始的
         */</span>
        <span class="token keyword">return</span> pointer <span class="token operator">==</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 入栈</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * // isFull满的
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空间已满！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 对堆进行扩容</span>
            obj <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">/**
             * // 每次加一
             */</span>
            pointer<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">/**
             * 循环给数组赋值
             */</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            pointer<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 出栈
     *
     * @return
     */</span>
    <span class="token keyword">public</span> Object <span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"栈空间已空！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            Object o <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span><span class="token punctuation">;</span>
            pointer<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> o<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断堆栈是否为空
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * isEmpty空的
         * 如果pointer==-1就返回true
         */</span>
        <span class="token keyword">return</span> pointer <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Stack stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * 出栈
         */</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>主要是两个：队头，队尾</p>
<p>入队：队尾指针向后移动</p>
<p>出队：队头指针向后移动</p>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><h4 id="1-形参与实参"><a href="#1-形参与实参" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h4><h3 id="1-形参与实参-1"><a href="#1-形参与实参-1" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h3><p>我们先来重温一组语法：</p>
<blockquote>
<ol>
<li><p>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</p>
</li>
<li><p>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p>
</li>
</ol>
</blockquote>
<p>举个栗子：</p>
<pre><code>public static void func(int a){
 a=20;
 System.out.println(a);
}
public static void main(String[] args) {
 int a=10;//变量
 func(a);
}</code></pre><p>例子中<br>int a=10;中的a在被调用之前就已经创建并初始化，在调用func方法时，他被当做参数传入，所以这个a是实参。<br>而func(int a)中的a只有在func被调用时它的生命周期才开始，而在func调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p>
<h3 id="2-Java的数据类型"><a href="#2-Java的数据类型" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h3><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p>
<blockquote>
<p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p>
</blockquote>
<p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p>
<blockquote>
<ol>
<li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：</li>
</ol>
<blockquote>
<p>4种整数类型：byte、short、int、long<br>2种浮点数类型：float、double<br>1种字符类型：char<br>1种布尔类型：boolean</p>
</blockquote>
<ol start="2">
<li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：</li>
</ol>
<blockquote>
<p>类<br>接口<br>数组</p>
</blockquote>
</blockquote>
<p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p>
<h3 id="3-JVM内存的划分及职能"><a href="#3-JVM内存的划分及职能" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h3><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznUXxpugnTGGCB8eWHmcg9sjc88CMjoWuagmLTgibGKIJchE6JkC1Plw.jpg" alt=""></p>
<p>有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</p>
<h5 id="1-虚拟机栈"><a href="#1-虚拟机栈" class="headerlink" title="1. 虚拟机栈"></a>1. 虚拟机栈</h5><h5 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h5><h5 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h5><h5 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h5><h5 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h5><p>我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。</p>
<hr>
<blockquote>
<p><strong>1. 虚拟机栈</strong></p>
</blockquote>
<p>虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</p>
<p>栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p>
<p>下图表示了一个Java栈的模型以及栈帧的组成：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzhafOtSl5zaWYfOCzicibCgWQRISwTlEr0Kd1TJj3ibia5mQvb7sTUyVq5A.jpg" alt=""></p>
<p><strong>栈帧</strong>:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>每个栈帧中包括：</p>
<ol>
<li><p><strong>局部变量表</strong>:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</p>
</li>
<li><p><strong>操作数栈</strong>:Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指操作数栈。</p>
</li>
<li><p><strong>指向运行时常量池的引用</strong>:存储程序执行时可能用到常量的引用。</p>
</li>
<li><p><strong>方法返回地址</strong>:存储方法执行完成后的返回地址。</p>
</li>
</ol>
<hr>
<blockquote>
<p><strong>2. 堆：</strong></p>
</blockquote>
<p>堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</p>
<hr>
<blockquote>
<p><strong>3. 方法区：</strong></p>
</blockquote>
<p>方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</p>
<p>方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</p>
<hr>
<blockquote>
<p><strong>4. 本地方法栈：</strong></p>
</blockquote>
<p>本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</p>
<p><strong>有人会疑惑：什么是本地方法？为什么Java还要调用本地方法？</strong></p>
<hr>
<blockquote>
<p><strong>5. 程序计数器：</strong></p>
</blockquote>
<p>线程私有的。<br>记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<hr>
<h3 id="4-数据如何在内存中存储？"><a href="#4-数据如何在内存中存储？" class="headerlink" title="4. 数据如何在内存中存储？"></a>4. 数据如何在内存中存储？</h3><p>从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有三个地方：</p>
<ul>
<li><p>堆</p>
</li>
<li><p>栈</p>
</li>
<li><p>静态方法区</p>
</li>
<li><p>常量区</p>
</li>
</ul>
<p>相应地，每个存储区域都有自己的内存分配策略：</p>
<ul>
<li><p>堆式：</p>
</li>
<li><p>栈式</p>
</li>
<li><p>静态</p>
</li>
</ul>
<p>我们已经知道：Java中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？<br>这里要分以下的情况进行探究：</p>
<blockquote>
<p><strong>1. 基本数据类型的存储：</strong></p>
<ul>
<li><p>A. 基本数据类型的局部变量</p>
</li>
<li><p>B. 基本数据类型的成员变量</p>
</li>
<li><p>C. 基本数据类型的静态变量</p>
</li>
</ul>
<p><strong>2. 引用数据类型的存储</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>1. 基本数据类型的存储</strong></p>
</blockquote>
<hr>
<p>我们分别来研究一下：</p>
<h5 id="A-基本数据类型的局部变量"><a href="#A-基本数据类型的局部变量" class="headerlink" title="A.基本数据类型的局部变量"></a><strong>A.基本数据类型的局部变量</strong></h5><ol>
<li><p>定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的<strong>“虚拟机栈”</strong>，数据本身的值就是存储在栈空间里面。  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznNuHDLtNxibO1b1yN7wV4HPSno4CHZWXaEicootMFec7t31G38HzFpSQ.png" alt=""></p>
</li>
</ol>
<pre><code>如上图，在方法内定义的变量直接存储在栈中，如</code></pre><pre><code>    int age=50;
    int weight=50;
    int grade=6;</code></pre><p>当我们写“int age=50；”，其实是分为两步的：</p>
<pre><code>    int age;//定义变量
    age=50;//赋值</code></pre><p>首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。因此我们可以知道：<br><strong>我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</strong></p>
<p>我们再来看“int weight=50；”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：<strong>栈中的数据在当前线程下是共享的</strong>。</p>
<p>那么如果再执行下面的代码呢？</p>
<pre><code>    weight=40；</code></pre><p>当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。由此可知：</p>
<p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p>
<hr>
<h5 id="B-基本数据类型的成员变量"><a href="#B-基本数据类型的成员变量" class="headerlink" title="B. 基本数据类型的成员变量"></a><strong>B. 基本数据类型的成员变量</strong></h5><p>成员变量：顾名思义，就是在类体中定义的变量。<br>看下图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozziaY24epYoPoM45SJiajF9qCXtupO2539ia0NMKIYUo3yjhFibJ1ZgTvIWg.jpg" alt=""></p>
<p>我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码：</p>
<pre><code>     public class Person{ 2  private int age; 3  private String name; 4  private int grade; 5//篇幅较长，省略setter getter方法 6  static void run(){ 7     System.out.println("run....");  8   }; 9}1011//调用12Person per=new Person();</code></pre><p>同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：<strong>基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</strong></p>
<hr>
<h5 id="C-基本数据类型的静态变量"><a href="#C-基本数据类型的静态变量" class="headerlink" title="C. 基本数据类型的静态变量"></a><strong>C. 基本数据类型的静态变量</strong></h5><p>前面提到<strong>方法区</strong>用来存储一些共享数据，因此<strong>基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</strong></p>
<hr>
<blockquote>
<p><strong>2. 引用数据类型的存储:</strong></p>
</blockquote>
<p>上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</p>
<pre><code>1Person per=new Person();</code></pre><p>实际上，它也是有两个过程：</p>
<pre><code>1Person per;//定义变量2per=new Person();//赋值</code></pre><p>在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：<br><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p>
<h3 id="6-值传递和引用传递"><a href="#6-值传递和引用传递" class="headerlink" title="6. 值传递和引用传递"></a>6. 值传递和引用传递</h3><p>前面已经介绍过形参和实参，也介绍了数据类型以及数据在内存中的存储形式，接下来，就是文章的主题：值传递和引用的传递。</p>
<blockquote>
<p><strong>值传递：</strong><br>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
</blockquote>
<p>来看个例子：</p>
<pre><code> 1public static void valueCrossTest(int age,float weight){ 2    System.out.println("传入的age："+age); 3    System.out.println("传入的weight："+weight); 4    age=33; 5    weight=89.5f; 6    System.out.println("方法内重新赋值后的age："+age); 7    System.out.println("方法内重新赋值后的weight："+weight); 8    } 910//测试11public static void main(String[] args) {12        int a=25;13        float w=77.5f;14        valueCrossTest(a,w);15        System.out.println("方法执行后的age："+a);16        System.out.println("方法执行后的weight："+w);17}</code></pre><p>输出结果：</p>
<pre><code>1传入的age：252传入的weight：77.534方法内重新赋值后的age：335方法内重新赋值后的weight：89.567方法执行后的age：258方法执行后的weight：77.5</code></pre><p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p>
<p>这是什么造型呢？！！</p>
<p>下面我们根据上面学到的知识点，进行详细的分析：</p>
<p>首先程序运行时，调用mian()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是mian()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozz8YSBg6NLka2h6iamHia5566dpw4dXrpCnfwicnWE0hAADoicyb3dBWWBeg.png" alt=""></p>
<p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzicu2h4XZlxSVE3ynyB1pIxaplvHibiazgvFiaFYuvVe8IrRK9U3dk1vxCA.jpg" alt=""></p>
<p>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzf8EMVLtiaMibiaaTxM4aV8ibUZphsG0oHs4qWj3QDHPK6Wia8NBiaQZqXTLQ.jpg" alt=""></p>
<p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p>
<blockquote>
<p><strong>引用传递：</strong><br>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</p>
</blockquote>
<p>举个栗子：<br>先定义一个对象：</p>
<pre><code> 1public class Person { 2        private String name; 3        private int age; 4 5        public String getName() { 6            return name; 7        } 8        public void setName(String name) { 9            this.name = name;10        }11        public int getAge() {12            return age;13        }14        public void setAge(int age) {15            this.age = age;16        }17}</code></pre><p>我们写个函数测试一下：</p>
<pre><code> 1public static void PersonCrossTest(Person person){ 2        System.out.println("传入的person的name："+person.getName()); 3        person.setName("我是张小龙"); 4        System.out.println("方法内重新赋值后的name："+person.getName()); 5    } 6//测试 7public static void main(String[] args) { 8        Person p=new Person(); 9        p.setName("我是马化腾");10        p.setAge(45);11        PersonCrossTest(p);12        System.out.println("方法执行后的name："+p.getName());13}</code></pre><p>输出结果：</p>
<pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是张小龙</code></pre><p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p>
<p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p>
<p>下面我们对上面的例子稍作修改，加上一行代码，</p>
<pre><code>1public static void PersonCrossTest(Person person){2        System.out.println("传入的person的name："+person.getName());3        person=new Person();//加多此行代码4        person.setName("我是张小龙");5        System.out.println("方法内重新赋值后的name："+person.getName());6    }</code></pre><p>输出结果：</p>
<pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是马化腾</code></pre><p>`<br>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p>
<p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p>
<pre><code>1Person p=new Person();2        p.setName("我是马化腾");3        p.setAge(45);4        PersonCrossTest(p);</code></pre><p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozztCU4pWxX96C9qiaDiaYSHOjV1Okfm6FIF3H1iciaKvqBTjibGeGnHP0VlsA.jpg" alt=""></p>
<p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p>
<pre><code>1person=new Person();</code></pre><p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p>
<p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p>
<p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p>
<p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p>
<p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p>
<p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong>  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzRTVdZIvztpofveECo4HxchhGmtHX4J6WZLRGcLiatiaDEMHwkyRpwtKg.jpg" alt=""></p>
<p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p>
<p><strong>p和person都是指向同一个对象</strong>。</p>
<p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p>
<p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p>
<p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p>
<p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p>
<h4 id="2-Java的数据类型-1"><a href="#2-Java的数据类型-1" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h4><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p>
<blockquote>
<p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p>
</blockquote>
<p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p>
<blockquote>
<ol>
<li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：<br>4种整数类型：byte、short、int、long<br> 2种浮点数类型：float、double<br> 1种字符类型：char<br> 1种布尔类型：boolean</li>
<li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：<br>类<br> 接口<br> 数组</li>
</ol>
</blockquote>
<p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p>
<h4 id="3-JVM内存的划分及职能-1"><a href="#3-JVM内存的划分及职能-1" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h4><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="transient-1"><a href="#transient-1" class="headerlink" title="transient"></a>transient</h4><p>先解释下Java中的对象序列化</p>
<p>在讨论transient之前，有必要先搞清楚Java中序列化的含义；</p>
<blockquote>
<p>Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</p>
</blockquote>
<p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p>
<p><strong>关于transient关键字</strong></p>
<p>Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化，这一看好像很好理解，就是不被序列化，那么什么情况下，一个对象的某些字段不需要被序列化呢？如果有如下情况，可以考虑使用关键字transient修饰：</p>
<p>1、类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p>
<p>2、其它，看具体业务需求吧，哪些字段不想被序列化；</p>
<p>PS，记得之前看HashMap源码的时候，发现有个字段是用transient修饰的，我觉得还是有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增），对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p>
<h3 id="jdk1-8新特性学习"><a href="#jdk1-8新特性学习" class="headerlink" title="jdk1.8新特性学习"></a>jdk1.8新特性学习</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是一种运行于服务器端的Java应用程序，具有独立于平台和协议的特性，可以生成动态的Web页面</p>
<p>担当客户请求与服务器响应的中间层 </p>
<p>有特殊的技术规范</p>
<p>必须继承某个特定父类</p>
<p>必须配置之后才能执行</p>
<p>有特定的生命周期</p>
<h3 id="、时间复杂度-amp-amp-空间复杂度"><a href="#、时间复杂度-amp-amp-空间复杂度" class="headerlink" title="、时间复杂度&amp;&amp;空间复杂度"></a>、时间复杂度&amp;&amp;空间复杂度</h3><h3 id="、算法"><a href="#、算法" class="headerlink" title="、算法"></a>、算法</h3><h3 id="、Gc"><a href="#、Gc" class="headerlink" title="、Gc"></a>、Gc</h3><h3 id="各种树"><a href="#各种树" class="headerlink" title="各种树"></a>各种树</h3><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><p><a href="https://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/10/21/2019-02-03-java-she-ji-mo-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="java设计模式">
                        
                        <span class="card-title">java设计模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            单例模式(Singleton Pattern)优点：
(1) 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了
(2) 单例模式可以在系统设置全局的访问
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-10-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/10/21/2019-01-23-mybatis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="Mybatis笔记">
                        
                        <span class="card-title">Mybatis笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Mybatis简介
MyBatis 本是apache的一个开源项目iBatis, MyBatis 是一个高级映射的优秀的持久层orm框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis可以使用简
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-10-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Mybatis/" class="post-category">
                                    Mybatis
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Mybatis/">
                        <span class="chip bg-color">Mybatis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">年份</span>
            <a href="http://flytom.club" target="_blank">FlyTom</a>
            <!-- |&nbsp;Powered by&nbsp;
            
            <a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
             -->
            <!-- 
            
            
             -->
            <!-- 
            <!-- <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span> -->
            <!-- 
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
             -->
            <!-- <br> -->
            <!-- 
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
             -->
            <!-- <br> -->
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis"><!-- 














    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>
 -->
</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->


    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
