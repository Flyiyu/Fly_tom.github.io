<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="java基础笔记, Tom Blog">
    <meta name="description" content="包括内容：基础知识点，集合类，队列，线程（基础），io
网站：https://blog.csdn.net/topdeveloperr/article/details/81414318
基础知识点面向对象的特性答：封装、继承和多态。
多态分为">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>java基础笔记 | Tom Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Tom Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Tom Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        java基础笔记
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-10-21
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>包括内容：基础知识点，集合类，队列，线程（基础），io</p>
<p>网站：<a href="https://blog.csdn.net/topdeveloperr/article/details/81414318" target="_blank" rel="noopener">https://blog.csdn.net/topdeveloperr/article/details/81414318</a></p>
<h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><h3 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h3><p>答：封装、继承和多态。</p>
<p>多态分为<strong>编译时多态和运行时多态。</strong></p>
<ul>
<li><p>编译时多态：<strong>方法的重载</strong></p>
</li>
<li><p>运行时多态：指程序中定义的对象引用所指向的具体类型在运行期间才确定。</p>
</li>
</ul>
<p><strong>运行时多态</strong>有三个<strong>条件</strong>：</p>
<p>多态的存在有三个前提:</p>
<ul>
<li><p>要有继承关系</p>
</li>
<li><p>子类要重写父类的方法</p>
</li>
<li><p>父类引用指向子类对,</p>
</li>
</ul>
<p>父类Animal</p>
<pre><code> 1 class Animal {
 2    int num = 10;
 3    static int age = 20;
 4    public void eat() {
 5        System.out.println("动物吃饭");
 6        }
 7    public static void sleep() {
 8        System.out.println("动物在睡觉");
 9        }
10    public void run(){
11        System.out.println("动物在奔跑");
12       }
13}</code></pre><p>子类Cat</p>
<pre><code>1class Cat extends Animal {
 2    int num = 80;
 3    static int age = 90;
 4     String name = "tomCat";
 5    public void eat() {
 6        System.out.println("猫吃饭");
 7    }
 8    public static void sleep() {
 9        System.out.println("猫在睡觉");
10    }
11    public void catchMouse() {
12        System.out.println("猫在抓老鼠");
13    }
14}</code></pre><p>测试类Demo_Test1</p>
<pre><code> 1class Demo_Test1 {
 2    public static void main(String[] args) {
 3    Animal am = new Cat();
 4    am.eat();
 5    am.sleep();
 6    am.run();
 7    //am.catchMouse();这里先注释掉，等会会说明
 8     //System.out.println(am.name);//这里先注释，待会说明
 9    System.out.println(am.num);
10    System.out.println(am.age);
11    }
12}</code></pre><p>以上的三段代码充分体现了多态的三个前提，即：</p>
<p>1、存在继承关系Cat类继承了Animal类</p>
<p>2、子类要重写父类的方法子类重写(override)了父类的两个成员方法eat()，sleep()。其中eat()是非静态的，sleep()是静态的（static）。</p>
<p>3、父类数据类型的引用指向子类对象。</p>
<p>如果再深究一点呢，我们可以看看上面测试类的输出结果，或许对多态会有更深层次的认识。猜一猜上面<br>的结果是什么。</p>
<p>可以看出来</p>
<p>子类Cat重写了父类Animal的非静态成员方法am.eat();的输出结果为：猫吃饭。</p>
<p>子类重写了父类(Animal)的静态成员方法am.sleep();的输出结果为：动物在睡觉</p>
<p>未被子类（Cat）重写的父类（Animal）方法am.run()输出结果为：动物在奔跑</p>
<p><strong>那么我们可以根据以上情况总结出多态成员访问的特点：</strong></p>
<pre><code>1成员变量
2- 编译看左边(父类),运行看左边(父类)
3成员方法
4- 编译看左边(父类)，运行看右边(子类)。动态绑定
5静态方法
6- 编译看左边(父类)，运行看左边(父类)。
7
8(静态和类相关，算不上重写，所以，访问还是左边的)
9只有非静态的成员方法,编译看左边,运行看右边</code></pre><p><strong>那么多态有什么弊端呢？</strong></p>
<p>不能使用子类特有的成员属性和子类特有的成员方法。</p>
<p>参考：<a href="https://www.zhihu.com/question/30082151" target="_blank" rel="noopener">https://www.zhihu.com/question/30082151</a></p>
<p>很明显，执行强转语句Cat ct = (Cat)am;之后，ct就指向最开始在堆内存中创建的那个Cat类型的对象了。</p>
<p><strong>这就是多态的魅力吧，虽然它有缺点，但是它确实十分灵活，减少多余对象的创建，不用说为了使用子类的某个方法又去重新再堆内存中开辟一个新的子类对象。</strong></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><hr>
<p>String是类类型，不是基本类型。</p>
<p>基本类型 有八种：整型 （4种）字符型 （1种）浮点型 （2种）布尔型（1种）</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0002.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0003.jpg" alt=""></p>
<p>缓存池</p>
<pre><code> 1 public class Main_1 {
 2    public static void main(String[] args) {
 3        Integer a = 1;
 4        Integer b = 2;
 5        Integer c = 3;
 6        Integer d = 3;
 7        Integer e = 321;
 8        Integer f = 321;
 9        Long g = 3L;
10        System.out.println(c == d);//true，缓存池
11        System.out.println(e == f);//false，不在缓存池
12        System.out.println(c == (a + b));//true
13        System.out.println(c.equals(a + b));//true
14        System.out.println(g == (a + b));//true
15        System.out.println(g.equals(a + b));//false
16        System.out.println(g.equals(a + h));//true
17    }</code></pre><p><strong>使用==的情况：</strong></p>
<ul>
<li><p>如果比较Integer变量，<strong>默认比较的是地址值。</strong></p>
</li>
<li><p>特例：如果比较的<strong>某一边有操作表达式(例如a+b)</strong>，那么比较的是<strong>具体数值</strong></p>
</li>
</ul>
<p><strong>使用equals()的情况：</strong></p>
<ul>
<li><p>无论是Integer还是Long中的equals()<strong>默认比较的是数值</strong>。</p>
</li>
<li><p><strong>特例：Long的equals()方法，JDK的默认实现：会判断是否是Long类型</strong></p>
</li>
</ul>
<p><strong>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</strong></p>
<ul>
<li><p>new Integer(123) <strong>每次都会新建一个对象</strong></p>
</li>
<li><p>Integer.valueOf(123) <strong>会使用缓存池中的对象</strong>，多次调用会取得同一个对象的引用。</p>
</li>
</ul>
<p><strong>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</strong></p>
<pre><code>1public static Integer valueOf(int i) {
2    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
3        return IntegerCache.cache[i + (-IntegerCache.low)];
4    return new Integer(i);
5}</code></pre><p><strong>基本类型对应的缓冲池如下：</strong></p>
<ul>
<li><p>boolean values true and false</p>
</li>
<li><p>all byte values</p>
</li>
<li><p>short values between -128 and 127</p>
</li>
<li><p>int values between -128 and 127</p>
</li>
<li><p>char in the range \u0000 to \u007F</p>
</li>
</ul>
<p><strong>默认IntegerCache.low 是-127，Integer.high是128，如果在这个区间[-128,127]内，他就会把变量i当做一个变量，放到内存中，用比较是会得出true；但如果不在这个范围内，就会去new一个Integer对象，当运用“”时，会比较Integer两个对象地址，得出false。</strong></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>String 被声明为 final，因此它不可被继承。</strong></p>
<pre><code>首先String不属于8中基本类型，String是一个对象

String 由于使用final 修饰存储在常量区（不是new出来的）

new出来的存储在对象存储在堆中，栈中存放的为引用地址。
</code></pre><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<pre><code>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}</code></pre><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<pre><code>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}</code></pre><h4 id="String不可变的好处"><a href="#String不可变的好处" class="headerlink" title="String不可变的好处"></a>String不可变的好处</h4><p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p><strong>注意：不是string创建后就默认进入池的，请看下方intern()</strong></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0004.jpg" alt=""></p>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p>Program Creek : Why String is immutable in Java?</p>
<h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<pre><code>1String s1 = new String("aaa");
2String s2 = new String("aaa");
3System.out.println(s1 == s2);           // false
4String s3 = s1.intern();
5String s4 = s1.intern();
6System.out.println(s3 == s4);           // true</code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<pre><code>1String s5 = "bbb";
2String s6 = "bbb";
3System.out.println(s5 == s6);  // true</code></pre><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li><p>StackOverflow : What is String interning?</p>
</li>
<li><p>深入解析 String#intern</p>
</li>
</ul>
<h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li><p>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</p>
</li>
<li><p>而使用 new 的方式会在堆中创建一个字符串对象。</p>
</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<pre><code>1public class NewStringTest {
2    public static void main(String[] args) {
3        String s = new String("abc");
4    }
5}</code></pre><p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<pre><code> 1// ...
 2Constant pool:
 3// ...
 4   #2 = Class              #18            // java/lang/String
 5   #3 = String             #19            // abc
 6// ...
 7  #18 = Utf8               java/lang/String
 8  #19 = Utf8               abc
 9// ...
10
11  public static void main(java.lang.String[]);
12    descriptor: ([Ljava/lang/String;)V
13    flags: ACC_PUBLIC, ACC_STATIC
14    Code:
15      stack=3, locals=2, args_size=1
16         0: new           #2                  // class java/lang/String
17         3: dup
18         4: ldc           #3                  // String abc
19         6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V
20         9: astore_1
21// ...</code></pre><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre><code>1public String(String original) {2    this.value = original.value;3    this.hash = original.hash;4}</code></pre><h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p>
<ul>
<li><p>String 不可变</p>
</li>
<li><p>StringBuffer 和 StringBuilder 可变</p>
</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li><p>String 不可变，因此是线程安全的</p>
</li>
<li><p>StringBuilder 不是线程安全的</p>
</li>
<li><p>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p>
</li>
</ul>
<p><strong>对于三者使用的总结：</strong></p>
<p>1.如果要操作少量的数据用 String</p>
<p>2.<strong>单线程</strong>操作字符串缓冲区下操作大量数据 StringBuilder</p>
<p>3.<strong>多线程</strong>操作字符串缓冲区下操作大量数据 StringBuffer</p>
<h3 id="String-和StringBuffer的区别？"><a href="#String-和StringBuffer的区别？" class="headerlink" title="String 和StringBuffer的区别？"></a>String 和StringBuffer的区别？</h3><p>String是immutable的,其内容一旦创建好之后，就不可以发生改变。</p>
<p>StringBuffer 是可以变长的，内容也可以发生改变<br>改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。</p>
<p><a href="https://blog.csdn.net/yeweiyang16/article/details/51755552" target="_blank" rel="noopener">https://blog.csdn.net/yeweiyang16/article/details/51755552</a></p>
<p><strong>初始化：可以指定给对象的实体的初始容量为参数字符串s的长度额外再加16个字符</strong></p>
<p><strong>扩容：尝试将新容量扩为大小变成原容量的1倍+2，然后if判断一下 容量如果不够，直接扩充到需要的容量大小。</strong></p>
<p>StackOverflow : String, StringBuffer, and StringBuilder</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h2 id="参数传递-1"><a href="#参数传递-1" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li>Java基本数据类型传递参数时是值传递；引用类型传递参数时是引用传递。</li>
<li>值传递时，将实参的值传递一份给形参；引用传递时，将实参的地址值传递一份给形参。</li>
<li>值传递时，实参把它的值传递给对应的形参，函数接收的是原始值的一个拷贝，此时内存中存在两个相等的基本类型，即实参和形参，后面方法中的操作都是对形参这个值的修改，不影响实参的值。引用传递时，实参的引用(地址，而不是参数的值)被传递给方法中相对应的形参，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。</li>
<li>需要特殊考虑String，以及Integer、Double等几个基本类型包装类，它们都是immutable类型，因为没有提供自身修改的函数，每次操作都是新创建一个对象，所以要特殊对待。因为最后的操作不会修改实参，可以认为是和基本数据类型相似，为值传递。</li>
</ul>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p>
<pre><code>1public class Dog {
 2
 3    String name;
 4
 5    Dog(String name) {
 6        this.name = name;
 7    }
 8
 9    String getName() {
10        return this.name;
11    }
12
13    void setName(String name) {
14        this.name = name;
15    }
16
17    String getObjectAddress() {
18        return super.toString();
19    }
20}
 1public class PassByValueExample {
 2    public static void main(String[] args) {
 3        Dog dog = new Dog("A");
 4        System.out.println(dog.getObjectAddress()); // Dog@4554617c
 5        func(dog);
 6        System.out.println(dog.getObjectAddress()); // Dog@4554617c
 7        System.out.println(dog.getName());          // A
 8    }
 9
10    private static void func(Dog dog) {
11        System.out.println(dog.getObjectAddress()); // Dog@4554617c
12        dog = new Dog("B");
13        System.out.println(dog.getObjectAddress()); // Dog@74a14482
14        System.out.println(dog.getName());          // B
15    }
16}</code></pre><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<pre><code> 1class PassByValueExample {
 2    public static void main(String[] args) {
 3        Dog dog = new Dog("A");
 4        func(dog);
 5        System.out.println(dog.getName());          // B
 6    }
 7
 8    private static void func(Dog dog) {
 9        dog.setName("B");
10    }
11}</code></pre><p>StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</p>
<h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<pre><code>1// float f = 1.1;</code></pre><p>1.1f 字面量才是 float 类型。</p>
<pre><code>1float f = 1.1f;</code></pre><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<pre><code>1short s1 = 1;2// s1 = s1 + 1;</code></pre><p>但是使用 += 运算符可以执行隐式类型转换。</p>
<pre><code>1s1 += 1;</code></pre><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<pre><code>1s1 = (short) (s1 + 1);</code></pre><p>StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<pre><code>1String s = "a";
2switch (s) {
3    case "a":
4        System.out.println("aaa");
5        break;
6    case "b":
7        System.out.println("bbb");
8        break;
9}</code></pre><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong></p>
<p>抽象类和普通类最大的区别是：</p>
<p><strong>抽象类不能被实例化，需要继承抽象类才能实例化其子类</strong>。</p>
<pre><code> 1public abstract class AbstractClassExample {
 2
 3    protected int x;
 4    private int y;
 5
 6    public abstract void func1();
 7
 8    public void func2() {
 9        System.out.println("func2");
10    }
11}
1public class AbstractExtendClassExample extends AbstractClassExample {
2    @Override
3    public void func1() {
4        System.out.println("func1");
5    }
6}
</code></pre><p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p><strong>从 Java 8 开始，接口也可以拥有默认的方法实现</strong>，这是因为不支持默认方法的接口的维护成本太高了。</p>
<p><strong>在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</strong></p>
<p><strong>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</strong></p>
<p><strong>接口的字段默认都是 static 和 final 的。</strong></p>
<pre><code> 1public interface InterfaceExample {
 2    void func1();
 3
 4    default void func2(){
 5        System.out.println("func2");
 6    }
 7
 8    int x = 123;
 9    // int y;               // Variable 'y' might not have been initialized
10    public int z = 0;       // Modifier 'public' is redundant for interface fields
11    // private int k = 0;   // Modifier 'private' not allowed here
12    // protected int l = 0; // Modifier 'protected' not allowed here
13    // private void fun3(); // Modifier 'private' not allowed here
14}
1public class InterfaceImplementExample implements InterfaceExample {
2    @Override
3    public void func1() {
4        System.out.println("func1");
5    }
6}</code></pre><p><strong>3. 比较</strong></p>
<ul>
<li><p><strong>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</strong></p>
</li>
<li><p>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</p>
</li>
<li><p><strong>接口的字段只能是 static 和 final 类型的</strong>，而抽象类的字段没有这种限制。</p>
</li>
<li><p><strong>接口的成员只能是 public 的</strong>，而抽象类的成员可以有多种访问权限。</p>
</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li><p>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</p>
</li>
<li><p>需要使用多重继承。</p>
</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li><p>需要在几个相关的类中共享代码。</p>
</li>
<li><p>需要能控制继承来的成员的访问权限，而不是都为 public。</p>
</li>
<li><p>需要继承非静态static和非常量final字段。</p>
</li>
</ul>
<p><strong>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</strong></p>
<ul>
<li><p>深入理解 abstract class 和 interface</p>
</li>
<li><p>When to Use Abstract Class and Interface</p>
</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li><p><strong>访问父类的构造函数</strong>：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</p>
</li>
<li><p><strong>访问父类的成员</strong>：如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</p>
</li>
</ul>
<p>Using the Keyword super</p>
<h3 id="继承相关小问题"><a href="#继承相关小问题" class="headerlink" title="继承相关小问题"></a>继承相关小问题</h3><h4 id="接口是否可继承接口"><a href="#接口是否可继承接口" class="headerlink" title="接口是否可继承接口?"></a>接口是否可继承接口?</h4><p>可以，比如List 就继承了接口Collection</p>
<h4 id="抽象类是否可实现-implements-接口"><a href="#抽象类是否可实现-implements-接口" class="headerlink" title="抽象类是否可实现(implements)接口?"></a>抽象类是否可实现(implements)接口?</h4><p>可以，比如 MouseAdapter鼠标监听适配器 是一个抽象类，并且实现了MouseListener接口</p>
<h4 id="抽象类是否可继承实体类（concrete-class）？"><a href="#抽象类是否可继承实体类（concrete-class）？" class="headerlink" title="抽象类是否可继承实体类（concrete class）？"></a>抽象类是否可继承实体类（concrete class）？</h4><p>可以，所有抽象类，都继承了Object</p>
<h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h2><p>经典：</p>
<p><a href="https://fangjian0423.github.io/2016/03/12/java-Object-method/" target="_blank" rel="noopener">https://fangjian0423.github.io/2016/03/12/java-Object-method/</a></p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><pre><code> 1public native int hashCode()
 2
 3public boolean equals(Object obj)
 4
 5protected native Object clone() throws CloneNotSupportedException
 6
 7public String toString()
 8
 9public final native Class&lt;?&gt; getClass()
10
11protected void finalize() throws Throwable {}
12
13public final native void notify()
14
15public final native void notifyAll()
16
17public final native void wait(long timeout) throws InterruptedException
18
19public final void wait(long timeout, int nanos) throws InterruptedException
20
21public final void wait() throws InterruptedException</code></pre><ul>
<li>getClass方法</li>
</ul>
<ul>
<li>返回当前运行时对象的Class对象</li>
</ul>
<ul>
<li>hashCode方法</li>
</ul>
<ul>
<li>该方法返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。（文章中有对hashcode的详细解释）</li>
</ul>
<ul>
<li>equals方法</li>
</ul>
<ul>
<li>如果重写了equals方法，通常有必要重写hashCode方法，这点已经在hashCode方法中说明了。</li>
</ul>
<ul>
<li>clone方法</li>
</ul>
<ul>
<li><p>创建并返回当前对象的一份拷贝。<strong>Object本身没有实现Cloneable接口</strong>，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</p>
</li>
<li><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
</li>
</ul>
<ul>
<li>toString方法</li>
</ul>
<ul>
<li>Object对象的默认实现，即输出类的名字@实例的哈希码的16进制。</li>
</ul>
<ul>
<li>notify方法：</li>
</ul>
<ul>
<li>唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。</li>
</ul>
<ul>
<li>notifyAll方法</li>
</ul>
<ul>
<li>跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</li>
</ul>
<ul>
<li>wait(long timeout) throws InterruptedException方法</li>
</ul>
<ul>
<li>wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。</li>
</ul>
<ul>
<li>wait(long timeout, int nanos) throws InterruptedException方法</li>
</ul>
<ul>
<li>跟wait(long timeout)方法类似，<strong>多了一个nanos参数，这个参数表示额外时间</strong>（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</li>
</ul>
<ul>
<li><p>wait() throws InterruptedException方法</p>
<p>需要注意的是 wait(0, 0)和wait(0)效果是一样的，即一直等待。</p>
</li>
</ul>
<ul>
<li>跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念。</li>
</ul>
<ul>
<li>finalize方法</li>
</ul>
<ul>
<li>该方法的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。</li>
</ul>
<p><strong>补充：什么是Native Method</strong></p>
<p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ul>
<li><p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</p>
</li>
<li><p>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p>
</li>
</ul>
<pre><code>Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false</code></pre><ul>
<li>== 是java提供的等于比较运算符,用来比较两个变量指向的内存地址是否相同.</li>
<li>所以用”==”判断两个引用数据类型是否相等的时候，<strong>实际上是在判断两个引用是否指向同一个对象</strong></li>
<li>而equals()是Object提供的一个方法.Object中equals()方法的默认实现就是返回两个对象==的比较结果.但是equals()可以被重写,所以我们在具体使用的时候需要关注equals()方法有没有被重写.</li>
</ul>
<pre><code>public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
</code></pre><blockquote>
<p>当调用 String 类型数据的 equals() 方法时，首先会判断两个字符串的引用是否相等，也就是说两个字符串引用是否指向同一个对象，是则返回true。</p>
</blockquote>
<blockquote>
<p>如果不是指向同一个对象，则把两个字符串中的字符挨个进行比较。由于 s1 和 s3 字符串都是 “hello”，是可以匹配成功的，所以最终返回 true。</p>
</blockquote>
<pre><code>由于Java程序员们会创建各种满足它们业务需求的对象，系统无法提前知道两个对象在什么条件下算相等，Java干脆把判断对象是否相等的权力交给编程人员。

具体的措施是：所有的类都必须继承 Object 类，而 Object 类中写有equals()方法。编程人员可以通过重写 equals() 方法来实现自己的比较策略，也可以不重写，使用Object类的equals()比较策略。</code></pre><p><strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?</strong></p>
<p><strong>因为hashCode()方法和equals()方法都可以通过自定义类重写</strong>，是可以做到equals相同，但是hashCode不同的</p>
<p>但是，在Object类的equals()方法中有这么一段话</p>
<p>翻译如下：</p>
<p>通常来讲，在重写这个方法的时候，也需要对hashCode方法进行重写，<br>以此来保证这两个方法的一致性——<br>当equals返回true的时候，这两个对象一定有相同的hashcode.</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><pre><code>public native int hashCode();</code></pre><blockquote>
<p>集合Set中的元素是无序不可重复的，那判断两个元素是否重复的依据是什么呢？ “比较对象是否相等当然用Object.equal()了”，某猿如是说。但是，Set中存在大量对象，后添加到集合Set中的对象元素比较次数会逐渐增多，大大降低了程序运行效率。 Java中采用哈希算法(也叫散列算法)来解决这个问题，将对象(或数据)依特定算法直接映射到一个地址上，对象的存取效率大大提高。这样一来，当含有海量元素的集合Set需要添加某元素(对象)时，先调用这个元素的hashCode()，就能一下子定位到此元素实际存储位置，如果这个位置没有元素，说明此对象时第一次存储到集合Set, 直接将此对象存储在此位置上；若此位置有对象存在，调用equal()看看这两个对象是否相等，相等就舍弃此元素不存，不等则散列到其他地址。</p>
</blockquote>
<h3 id="hashCode-amp-amp-equals"><a href="#hashCode-amp-amp-equals" class="headerlink" title="hashCode() &amp;&amp; equals()"></a>hashCode() &amp;&amp; equals()</h3><p>重写 equals 方法的同时也需要重写 hashCode 方法，有没有想过为什么？</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc32.png" alt="image"></p>
<p>假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。</p>
<p>然而重写了equals，且s1.equals(s2)返回true，根据hashcode的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。</p>
<p>以下是关于hashcode的一些规定：</p>
<ul>
<li>两个对象相等，hashcode一定相等</li>
<li>两个对象不等，hashcode不一定不等</li>
<li>hashcode相等，两个对象不一定相等</li>
<li>hashcode不等，两个对象一定不等</li>
</ul>
<p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<pre><code>public class ToStringExample {

    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
ToStringExample@4554617c</code></pre><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<pre><code>public class CloneExample {
2    private int a;
3    private int b;
4}
1CloneExample e1 = new CloneExample();
2// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</code></pre><p>重写 clone() 得到以下实现：</p>
<pre><code>1public class CloneExample {
2    private int a;
3    private int b;
4
5    @Override
6    public CloneExample clone() throws CloneNotSupportedException {
7        return (CloneExample)super.clone();
8    }
9}
1CloneExample e1 = new CloneExample();
2try {
3    CloneExample e2 = e1.clone();
4} catch (CloneNotSupportedException e) {
5    e.printStackTrace();
6}
1java.lang.CloneNotSupportedException: CloneExample</code></pre><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<pre><code>1public class CloneExample implements Cloneable {
2    private int a;
3    private int b;
4
5    @Override
6    public Object clone() throws CloneNotSupportedException {
7        return super.clone();
8    }
9}</code></pre><p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<pre><code>1public class ShallowCloneExample implements Cloneable {
 2
 3    private int[] arr;
 4
 5    public ShallowCloneExample() {
 6        arr = new int[10];
 7        for (int i = 0; i &lt; arr.length; i++) {
 8            arr[i] = i;
 9        }
10    }
11
12    public void set(int index, int value) {
13        arr[index] = value;
14    }
15
16    public int get(int index) {
17        return arr[index];
18    }
19
20    @Override
21    protected ShallowCloneExample clone() throws CloneNotSupportedException {
22        return (ShallowCloneExample) super.clone();
23    }
24}
1ShallowCloneExample e1 = new ShallowCloneExample();
2ShallowCloneExample e2 = null;
3try {
4    e2 = e1.clone();
5} catch (CloneNotSupportedException e) {
6    e.printStackTrace();
7}
8e1.set(2, 222);
9System.out.println(e2.get(2)); // 222</code></pre><p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<pre><code> 1public class DeepCloneExample implements Cloneable {
 2
 3    private int[] arr;
 4
 5    public DeepCloneExample() {
 6        arr = new int[10];
 7        for (int i = 0; i &lt; arr.length; i++) {
 8            arr[i] = i;
 9        }
10    }
11
12    public void set(int index, int value) {
13        arr[index] = value;
14    }
15
16    public int get(int index) {
17        return arr[index];
18    }
19
20    @Override
21    protected DeepCloneExample clone() throws CloneNotSupportedException {
22        DeepCloneExample result = (DeepCloneExample) super.clone();
23        result.arr = new int[arr.length];
24        for (int i = 0; i &lt; arr.length; i++) {
25            result.arr[i] = arr[i];
26        }
27        return result;
28    }
29}
1DeepCloneExample e1 = new DeepCloneExample();
2DeepCloneExample e2 = null;
3try {
4    e2 = e1.clone();
5} catch (CloneNotSupportedException e) {
6    e.printStackTrace();
7}
8e1.set(2, 222);
9System.out.println(e2.get(2)); // 2</code></pre><p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<pre><code> 1public class CloneConstructorExample {
 2
 3    private int[] arr;
 4
 5    public CloneConstructorExample() {
 6        arr = new int[10];
 7        for (int i = 0; i &lt; arr.length; i++) {
 8            arr[i] = i;
 9        }
10    }
11
12    public CloneConstructorExample(CloneConstructorExample original) {
13        arr = new int[original.arr.length];
14        for (int i = 0; i &lt; original.arr.length; i++) {
15            arr[i] = original.arr[i];
16        }
17    }
18
19    public void set(int index, int value) {
20        arr[index] = value;
21    }
22
23    public int get(int index) {
24        return arr[index];
25    }
26}
1CloneConstructorExample e1 = new CloneConstructorExample();
2CloneConstructorExample e2 = new CloneConstructorExample(e1);
3e1.set(2, 222);
4System.out.println(e2.get(2)); // 2</code></pre><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>修饰类：表示该类不能被继承</p>
</li>
<li><p>修饰方法：表示该方法不能被重写</p>
</li>
<li><p>修饰变量：表示该变量只能被赋值一次</p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
</li>
</ul>
<ul>
<li><p>对于基本类型，final 使数值不变；</p>
</li>
<li><p>对于引用类型，final 使引用不变，表示该引用只有一次指向对象的机会，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</p>
</li>
</ul>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally 是用于异常处理的场面，无论是否有异常抛出，都会执行</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p>finalize是Object的方法，所有类都继承了该方法。 当一个对象满足垃圾回收的条件，并且被回收的时候，其finalize()方法就会被调用</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. 静态变量</strong></p>
<ul>
<li><p>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</p>
</li>
<li><p>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p>
</li>
</ul>
<pre><code> 1public class A {
 2    private int x;         // 实例变量
 3    private static int y;  // 静态变量
 4
 5    public static void main(String[] args) {
 6        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
 7        A a = new A();
 8        int x = a.x;
 9        int y = A.y;
10    }
11}</code></pre><p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。<strong>所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。</strong></p>
<pre><code>1public abstract class A {
2    public static void func1(){
3    }
4    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
5}</code></pre><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>
<pre><code> 1public class A {
 2    private static int x;
 3    private int y;
 4
 5    public static void func1(){
 6        int a = x;
 7        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
 8        // int b = this.y;     // 'A.this' cannot be referenced from a static context
 9    }
10}</code></pre><p><strong>3. 静态语句块</strong></p>
<p><strong>静态语句块在类初始化时运行一次。</strong></p>
<pre><code> 1public class A {
 2    static {
 3        System.out.println("123");
 4    }
 5
 6    public static void main(String[] args) {
 7        A a1 = new A();
 8        A a2 = new A();
 9    }
10}
1123</code></pre><p><strong>4. 静态内部类</strong></p>
<p><strong>非静态内部类依赖于外部类的实例，而静态内部类不需要。</strong></p>
<p>当一个内部类没有使用static修饰的时候，是不能直接使用内部类创建对象，须要先使用外部类对象.new内部类对象及(外部类对象.new 内部类（）)</p>
<p>而静态内部类只需要<code>new OuterClass.InnerClass();</code></p>
<pre><code> 1public class OuterClass {
 2    class InnerClass {
 3    }
 4
 5    static class StaticInnerClass {
 6    }
 7
 8    public static void main(String[] args) {
 9        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
10        OuterClass outerClass = new OuterClass();
11        InnerClass innerClass = outerClass.new InnerClass();
12        StaticInnerClass staticInnerClass = new StaticInnerClass();
13    }
14}
</code></pre><p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<pre><code>1import static com.xxx.ClassName.*</code></pre><p><strong>6. 初始化顺序</strong></p>
<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li><p>父类（静态变量、静态语句块）</p>
</li>
<li><p>子类（静态变量、静态语句块）</p>
</li>
<li><p>父类（实例变量、普通语句块）</p>
</li>
<li><p>父类（构造函数）</p>
</li>
<li><p>子类（实例变量、普通语句块）</p>
</li>
<li><p>子类（构造函数）</p>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>每个类都有一个  <strong>Class</strong>  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName("com.mysql.jdbc.Driver")</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><p><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</p>
</li>
<li><p><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</p>
</li>
<li><p><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</p>
</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><p><strong>可扩展性</strong>  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p>
</li>
<li><p><strong>类浏览器和可视化开发环境</strong>  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</p>
</li>
<li><p><strong>调试器和测试工具</strong>  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</p>
</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><p><strong>性能开销</strong>  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li><p><strong>安全限制</strong>  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li><p><strong>内部暴露</strong>  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
<li><p>Trail: The Reflection API</p>
</li>
<li><p>深入解析 Java 反射（1）- 基础</p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>运行时异常：</p>
<pre><code>1NullPointerException 空指针异常
2ArithmeticException 算术异常，比如除数为零
3ClassCastException 类型转换异常
4ConcurrentModificationException同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常 
5IndexOutOfBoundsException 数组下标越界异常
6NegativeArraySizeException 为数组分配的空间是负数异常</code></pre><p><strong>一般异常又叫做可查异常（受检异常），在编译过程中，必须进行处理，要么捕捉，要么通过throws 抛出去.</strong></p>
<pre><code>1比如FileNotFoundException</code></pre><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0005.jpg" alt=""></p>
<h3 id="Error和Exception有什么区别"><a href="#Error和Exception有什么区别" class="headerlink" title="Error和Exception有什么区别?"></a>Error和Exception有什么区别?</h3><p>Error和Exception都实现了Throwable接口</p>
<p>Error指的是JVM层面的错误，比如内存不足OutOfMemoryError</p>
<p>Exception 指的是代码逻辑的异常，比如下标越界OutOfIndexException</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><pre><code>1public class Box&lt;T&gt; {
2    // T stands for "Type"
3    private T t;
4    public void set(T t) { this.t = t; }
5    public T get() { return t; }
6}</code></pre><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><p>&amp; 有两个作用，分别是 位与 和 逻辑与</p>
<p>&amp;&amp; 就是逻辑与</p>
<p><strong>长路与&amp;</strong>：两侧，都会被运算</p>
<p><strong>短路与&amp;&amp;</strong>：只要第一个是false，第二个就不进行运算了</p>
<h3 id="heap和stack有什么区别"><a href="#heap和stack有什么区别" class="headerlink" title="heap和stack有什么区别"></a>heap和stack有什么区别</h3><p>heap: 堆</p>
<p>stack: 栈</p>
<ul>
<li>存放的内容不一样：<ul>
<li>heap: 是存放对象的</li>
<li>stack: 是存放基本类型(int, float, boolean 等等)、引用(对象地址)、方法调用</li>
</ul>
</li>
<li>存取方式不一样：<ul>
<li>heap: 是自动增加大小的，所以不需要指定大小，但是存取相对较慢</li>
<li>stack: 先入后出的顺序，并且存取速度比较快</li>
</ul>
</li>
</ul>
<h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><p>数组获取长度的手段是 .length 属性</p>
<p>String获取长度的手段是 length()方法</p>
<p>集合获取长度的手段是 size()方法</p>
<p>文件获取长度的手段是 length()方法</p>
<h3 id="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"><a href="#Set里的元素是不能重复的，那么用什么方法来区分重复与否呢" class="headerlink" title="Set里的元素是不能重复的，那么用什么方法来区分重复与否呢"></a>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢</h3><p>以HashSet为例，判断重复的逻辑是：</p>
<ol>
<li><p>首先看hashcode是否相同，如果不同，就是不重复的</p>
</li>
<li><p>如果hashcode一样，再比较equals，如果不同，就是不重复的，否则就是重复的。</p>
</li>
</ol>
<p><a href="http://how2j.cn/k/collection/collection-hashcode/371.html#step2530" target="_blank" rel="noopener">http://how2j.cn/k/collection/collection-hashcode/371.html#step2530</a></p>
<h3 id="构造函数器-Constructor是否可被override-是否可以继承String类"><a href="#构造函数器-Constructor是否可被override-是否可以继承String类" class="headerlink" title="构造函数器/Constructor是否可被override?是否可以继承String类?"></a>构造函数器/Constructor是否可被override?是否可以继承String类?</h3><p>子类不能继承父类的构造方法，所以就不存在重写父类的构造方法。</p>
<p>String是final修饰的，所以不能够被继承</p>
<h3 id="try-catch-finally-执行顺序"><a href="#try-catch-finally-执行顺序" class="headerlink" title="try catch finally 执行顺序"></a>try catch finally 执行顺序</h3><p>try里的return和finally里的return 都会支持，但是当前方法<strong>只会采纳finally中return的值</strong></p>
<p><a href="https://www.cnblogs.com/superFish2016/p/6687549.html" target="_blank" rel="noopener">https://www.cnblogs.com/superFish2016/p/6687549.html</a></p>
<p><strong>总结以上测试：</strong></p>
<p>1、finally语句总会执行</p>
<p>2、如果try、catch中有return语句，finally中没有return，那么<strong>在finally中去修改除了包装类型和静态变量、全局变量以外的数据</strong>都不会对try、catch中返回的变量有任何的影响（包装类型、静态变量会改变、全局变量）。<strong>但是修改包装类型和静态变量、全局变量，会改变变量的值。</strong></p>
<p>3、尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生。</p>
<p>4、finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略。</p>
<p><strong>所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。</strong></p>
<h3 id="char型变量中能不能存贮一个中文汉字-为什么"><a href="#char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="char型变量中能不能存贮一个中文汉字?为什么?"></a>char型变量中能不能存贮一个中文汉字?为什么?</h3><p>char是16位的，占两个字节</p>
<p>汉字通常使用GBK或者UNICODE编码，也是使用两个字节</p>
<p>所以可以存放汉字</p>
<h3 id="一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h3><p>可以包括多个类，但是只能出现一个public修饰的类，但是可以出现多个非public修饰的类。</p>
<h3 id="java中有几种类型的流？"><a href="#java中有几种类型的流？" class="headerlink" title="java中有几种类型的流？"></a>java中有几种类型的流？</h3><p>Java中所有的流都是基于字节流，所以最基本的流是</p>
<pre><code> 1输入输出字节流
 2
 3InputStream
 4
 5OutputStream
 6
 7在字节流的基础上，封装了字符流
 8
 9Reader
10
11Writer
12
13进一步，又封装了缓存流
14
15BufferedReader
16
17PrintWriter
18
19以及数据流
20
21DataInputStream
22
23DataOutputStream
24
25对象流
26
27ObjectInputStream
28
29ObjectOutputStream
30
31以及一些其他的奇奇怪怪的流 ~~~</code></pre><h3 id="什么是java序列化，如何实现java序列化？"><a href="#什么是java序列化，如何实现java序列化？" class="headerlink" title="什么是java序列化，如何实现java序列化？"></a>什么是java序列化，如何实现java序列化？</h3><p>序列化指的是把一个Java对象，通过某种介质进行传输，比如Socket输入输出流，或者保存在一个文件里。</p>
<p>实现java序列化的手段是让该类实现接口 Serializable，这个接口是一个标识性接口，没有任何方法，仅仅用于表示该类可以序列化。</p>
<p><strong>JAVA序列化ID问题</strong></p>
<p><a href="https://blog.csdn.net/qq_35370263/article/details/79482993" target="_blank" rel="noopener">https://blog.csdn.net/qq_35370263/article/details/79482993</a></p>
<p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单 1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p>
<h3 id="在JAVA中，如何跳出当前的多重嵌套循环？"><a href="#在JAVA中，如何跳出当前的多重嵌套循环？" class="headerlink" title="在JAVA中，如何跳出当前的多重嵌套循环？"></a>在JAVA中，如何跳出当前的多重嵌套循环？</h3><pre><code> 1public class HelloWorld {
 2    public static void main(String[] args) {
 3
 4        //打印单数    
 5        outloop: //outloop这个标示是可以自定义的比如outloop1,ol2,out5
 6        for (int i = 0; i &lt; 10; i++) {
 7
 8            for (int j = 0; j &lt; 10; j++) {
 9                System.out.println(i+":"+j);
10                if(0==j%2) 
11                    break outloop; //如果是双数，结束外部循环
12            }
13
14        }
15
16    }
17}
</code></pre><h3 id="Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以-implements-实现-interface-接口"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以-implements-实现-interface-接口" class="headerlink" title="Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以 implements(实现)interface(接口)?"></a>Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以 implements(实现)interface(接口)?</h3><p>匿名内部类本质上就是在继承其他类，实现其他接口</p>
<p>如例:<br>匿名类1，就是继承了Thread<br>匿名类2 ，就是实现了Runnable接口</p>
<pre><code> 1package j2se;
 2
 3public class HelloWorld {
 4
 5    public static void main(String[] args) {
 6
 7        // 匿名类1
 8        new Thread() {
 9            public void run() {
10
11            }
12        };
13
14        // 匿名类2
15        new Runnable() {
16            public void run() {
17
18            }
19        };
20
21    }
22}
</code></pre><h3 id="内部类可以引用外部类的成员吗？有没有什么限制？"><a href="#内部类可以引用外部类的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用外部类的成员吗？有没有什么限制？"></a>内部类可以引用外部类的成员吗？有没有什么限制？</h3><p>可以使用</p>
<p>如果是非静态内部类，可是使用外部类的所有成员</p>
<p>如果是静态内部类，只能使用外部类的静态成员</p>
<h3 id="Class-forName的作用-为什么要用"><a href="#Class-forName的作用-为什么要用" class="headerlink" title="Class.forName的作用?为什么要用?"></a>Class.forName的作用?为什么要用?</h3><p>Class.forName常见的场景是在数据库驱动初始化的时候调用。</p>
<p><strong>Class.forName本身的意义是加载类到JVM中。 一旦一个类被加载到JVM中，它的静态属性就会被初始化，在初始化的过程中就会执行相关代码，从而达到”加载驱动的效果”</strong></p>
<h3 id="JDK-中常用的包有哪些？"><a href="#JDK-中常用的包有哪些？" class="headerlink" title="JDK 中常用的包有哪些？"></a>JDK 中常用的包有哪些？</h3><p>答：java.lang、java.util、java.io、java.net、java.sql。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0006.jpg" alt=""></p>
<p>容器主要包括 Collection 和 Map 两种，Collection 又包含了 List、Set 以及 Queue。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><strong>Set</strong></p>
<ul>
<li><p>HashSet：基于哈希实现，支持快速查找，但不支持有序性操作，例如根据一个范围查找元素的操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的；</p>
</li>
<li><p>TreeSet：基于红黑树实现，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logN)；</p>
</li>
<li><p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。</p>
</li>
</ul>
<p><strong>List</strong></p>
<ul>
<li><p>ArrayList：基于动态数组实现，支持随机访问；</p>
</li>
<li><p>Vector：和 ArrayList 类似，但它是线程安全的；</p>
</li>
<li><p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
</ul>
<p><strong>Queue</strong></p>
<ul>
<li><p>LinkedList：可以用它来支持双向队列；</p>
</li>
<li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</p>
</li>
</ul>
<blockquote>
<p>　优先队列是一种用来维护一组元素构成的结合S的数据结构，其中每个元素都有一个关键字key，元素之间的比较都是通过key来比较的。优先队列包括最大优先队列和最小优先队列，优先队列的应用比较广泛，比如作业系统中的调度程序，当一个作业完成后，需要在所有等待调度的作业中选择一个优先级最高的作业来执行，并且也可以添加一个新的作业到作业的优先队列中。Java中，PriorityQueue的底层数据结构就是堆（默认是小堆）。</p>
</blockquote>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><p>HashMap：基于哈希实现；</p>
</li>
<li><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
</li>
<li><p>LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p>
</li>
<li><p>TreeMap：基于红黑树实现。</p>
</li>
</ul>
<h2 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h2><p>Collection是接口，是List和Set的父接口</p>
<p>Collections是工具类，提供了排序，混淆等等很多实用方法</p>
<h2 id="List、Set-和-Map-的初始容量和加载因子"><a href="#List、Set-和-Map-的初始容量和加载因子" class="headerlink" title="List、Set 和 Map 的初始容量和加载因子"></a>List、Set 和 Map 的初始容量和加载因子</h2><p>答：<br>加载因子的系数小于等于1，意指  即当 元素个数 超过 容量长度*加载因子的系数 时，进行扩容。</p>
<ol>
<li>List</li>
</ol>
<p>ArrayList 的初始容量是 10；加载因子为 0.5； 扩容增量：<strong>原容量的 0.5 倍 +1</strong>；一次扩容后长度为 16。</p>
<p>Vector 初始容量为 10，加载因子是 1。扩容增量：<strong>原容量的 1 倍</strong>，如 Vector 的容量为 10，一次扩容后是容量为 20。</p>
<ol start="2">
<li>Set</li>
</ol>
<p>HashSet，初始容量为 16，加载因子为 0.75； 扩容增量：<strong>原容量的 1 倍</strong>； 如 HashSet 的容量为 16，一次扩容后容量为 32</p>
<ol start="3">
<li>Map</li>
</ol>
<p>HashMap，初始容量 16，加载因子为 0.75； 扩容增量：<strong>原容量的 1 倍</strong>； 如 HashMap 的容量为 16，一次扩容后容量为 32</p>
<h2 id="Comparable-接口和-Comparator-接口有什么区别？"><a href="#Comparable-接口和-Comparator-接口有什么区别？" class="headerlink" title="Comparable 接口和 Comparator 接口有什么区别？"></a>Comparable 接口和 Comparator 接口有什么区别？</h2><p>答：<br>详细可以看：<a href="https://blog.csdn.net/u011240877/article/details/53399019" target="_blank" rel="noopener">https://blog.csdn.net/u011240877/article/details/53399019</a></p>
<ul>
<li><p>对于一些普通的数据类型（比如 String, Integer, Double…），<strong>它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。</strong></p>
</li>
<li><p>而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。</p>
</li>
</ul>
<p><strong>对比：</strong></p>
<ul>
<li><p>Comparable简单，但是如果需要重新定义比较类型时，需要修改源代码。</p>
</li>
<li><p>Comparator不需要修改源代码，自定义一个比较器，实现自定义的比较方法。</p>
</li>
</ul>
<h2 id="Java-集合的快速失败机制-“fail-fast”"><a href="#Java-集合的快速失败机制-“fail-fast”" class="headerlink" title="Java 集合的快速失败机制 “fail-fast”"></a>Java 集合的快速失败机制 “fail-fast”</h2><p>答：</p>
<p>它是 java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>
<p>可以知道<strong>在进行add，remove，clear等涉及到修改集合中的元素个数的操作时</strong>，modCount就会发生改变(modCount ++),所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化</p>
<p>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>解决办法：</p>
<ol>
<li><p>在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized；</p>
</li>
<li><p>使用 CopyOnWriteArrayList 来替换 ArrayList。</p>
</li>
</ol>
<p><strong>java.util.concurrent包中包含的并发集合类如下：</strong></p>
<p>详细：<a href="http://raychase.iteye.com/blog/1998965" target="_blank" rel="noopener">http://raychase.iteye.com/blog/1998965</a></p>
<pre><code>1ConcurrentHashMap23CopyOnWriteArrayList45CopyOnWriteArraySet</code></pre><h3 id="1、java-包访问权限"><a href="#1、java-包访问权限" class="headerlink" title="1、java 包访问权限"></a>1、java 包访问权限</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc1.gif" alt=""></p>
<h3 id="2、Java中的面向接口编程"><a href="#2、Java中的面向接口编程" class="headerlink" title="2、Java中的面向接口编程"></a>2、Java中的面向接口编程</h3><p> 面向接口编程是很多软件架构设计理论都倡导的编程方式，学习Java自然少不了这一部分，下面是我在学习过程中整理出来的关于如何在Java中实现面向接口编程的知识。</p>
<p>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，通常推荐“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p>
<h3 id="3、main方法"><a href="#3、main方法" class="headerlink" title="3、main方法"></a>3、main方法</h3><pre><code>/**
* Java中的main()方法详解
*/
public class HelloWorld {
    public static void main(String args[]) {
        System.out.println("Hello World!");
    }
}</code></pre><p>一、先说类：<br>HelloWorld 类中有main()方法，说明这是个java应用程序，通过JVM直接启动运行的程序。<br>既然是类，java允许类不加public关键字约束，当然类的定义只能限制为public或者无限制关键字（默认的）。</p>
<p>二、再说main()方法</p>
<blockquote>
<p>这个main()方法的声明为：public static void main(String args[])。必须这么定义，这是Java的规范。<br>为什么要这么定义，和JVM的运行有关系。<br>当一个类中有main()方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法。<br>由于JVM在运行这个Java应用程序的时候，首先会调用main方法，调用时不实例化这个类的对象，而是通过类名直接调用因此需要是限制为public static。(类名.main())<br>对于java中的main方法，jvm有限制，不能有返回值，因此返回值类型为void。<br>main方法中还有一个输入参数，类型为String[]，这个也是java的规范，main()方法中必须有一个入参，类型必须String[]，至于字符串数组的名字，这个是可以自己设定的，根据习惯，这个字符串数组的名字一般和sun java规范范例中mian参数名保持一致，取名为args。因此，main()方法定义必须是：“public static void main(String 字符串数组参数名[])”。</p>
</blockquote>
<p>三、main()方法中可以throw Exception<br>因此main()方法中可以抛出异常，main()方法上也可以声明抛出异常。</p>
<p>四、main()方法中字符串参数数组作用<br>main()方法中字符串参数数组作用是接收命令行输入参数的，命令行的参数之间用空格隔开。</p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<p>编译</p>
<p>运行</p>
<p>编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。</p>
<p>运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。</p>
<p>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p>
<p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p>
<p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。</p>
<h3 id="4、java类的初始化顺序"><a href="#4、java类的初始化顺序" class="headerlink" title="4、java类的初始化顺序"></a>4、java类的初始化顺序</h3><h4 id="本类的初始化顺序"><a href="#本类的初始化顺序" class="headerlink" title="本类的初始化顺序"></a>本类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitialOrderTest</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticField<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>运行结果：<br><br>    静态变量<br><br>    静态初始化块<br>a<br>    变量<br><br>    初始化块<br><br>    构造器<br></p>
<h4 id="含有父类的初始化顺序"><a href="#含有父类的初始化顺序" class="headerlink" title="含有父类的初始化顺序"></a>含有父类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>   
    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String p_StaticField <span class="token operator">=</span> <span class="token string">"父类--静态变量"</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String p_Field <span class="token operator">=</span> <span class="token string">"父类--变量"</span><span class="token punctuation">;</span>   

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">", j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        j <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>   

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String s_StaticField <span class="token operator">=</span> <span class="token string">"子类--静态变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String s_Field <span class="token operator">=</span> <span class="token string">"子类--变量"</span><span class="token punctuation">;</span>   

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   
    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">",j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 程序入口</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>  </code></pre>
<p>运行结果：<br>父类–静态变量<br>父类–静态初始化块<br>子类–静态变量<br>子类–静态初始化块<br>父类–变量<br>父类–初始化块<br>父类–构造器<br>子类–变量<br>子类–初始化块<br>子类–构造器</p>
<h3 id="5、Java中如何进行异常处理"><a href="#5、Java中如何进行异常处理" class="headerlink" title="5、Java中如何进行异常处理"></a>5、Java中如何进行异常处理</h3><h4 id="Java异常的分类和类结构图"><a href="#Java异常的分类和类结构图" class="headerlink" title="Java异常的分类和类结构图"></a>Java异常的分类和类结构图</h4><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p>
<p>Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc3.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc7.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc4.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc6.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc5.png" alt=""></p>
<p>在Java中异常的继承主要有两个： Error和Exception 这两个，而Error就是jvm出现错误，以及系统奔溃等现象这些错误没办法通过程序来处理，所以在程序中不能使用catch来捕捉处理这类的异常。</p>
<p>对于Exception 又可以分为checkedException 和RuntimeException 这两种异常，checkedException异常在进行编译运行之前就可以知道会不会发生异常，如果不对这些异常进行抛出、捕获的话就不能通过编译。而RuntimeException就是运行的时候出现的异常在之前你是没办法确定是不是会出现异常。</p>
<blockquote>
<p>Java的异常处理是通过5个关键字来实现的：try、catch、 finally、throw、throws</p>
</blockquote>
<h4 id="try…catch…finally语句块"><a href="#try…catch…finally语句块" class="headerlink" title="try…catch…finally语句块"></a>try…catch…finally语句块</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">//try块中放可能发生异常的代码。</span>
     <span class="token comment" spellcheck="true">//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span>
     <span class="token comment" spellcheck="true">//如果发生异常，则尝试去匹配catch块。</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span>
    <span class="token comment" spellcheck="true">//catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span>
    <span class="token comment" spellcheck="true">//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span>
    <span class="token comment" spellcheck="true">//如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span>
    <span class="token comment" spellcheck="true">//如果try中没有发生异常，则所有的catch块将被忽略。</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//finally块通常是可选的。</span>
   <span class="token comment" spellcheck="true">//无论异常是否发生，异常是否匹配被处理，finally都会执行。</span>
   <span class="token comment" spellcheck="true">//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span>
  <span class="token comment" spellcheck="true">//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>需要注意的地方</strong></p>
<p>1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p>
<p>2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。</p>
<p>3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。<br>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）<br>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol>
<li>不管有没有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li>
</ol>
<p><strong>举例：</strong></p>
<p>情况1. try{} catch(){}finally{} return;<br>显然程序按顺序执行。</p>
<p>情况2. :try{ return; }catch(){} finally{} return;<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，最后执行try中return;</p>
<p>finally块之后的语句return，因为程序在try中已经return所以不再执行。</p>
<p>情况3. :try{ } catch(){return;} finally{} return;<br>程序先执行try，如果遇到异常执行catch块，<br>有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，<br>最后执行catch块中return. finally之后也就是4处的代码不再执行。<br>无异常：执行完try再finally再return.</p>
<p>情况4:try{ return; }catch(){} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况5:try{} catch(){return;}finally{return;}<br>程序执行catch块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况6:try{ return;}catch(){return;} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；<br>则再执行finally块，因为finally块中有return所以提前退出。<br>无异常：则再执行finally块，因为finally块中有return所以提前退出。</p>
<p>最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。<br>如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，<br>编译器把finally中的return实现为一个warning。</p>
<p>也就是说，如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）</p>
<p>下面是个测试程序</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            x<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>结果是2。<br>    在try语句中，在执行return语句时，要返回的结果已经准备好了，就在此时，程序转到finally执行了。<br>在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，<br>因此，即使finally中对变量x进行了改变，但是不会影响返回结果。<br>它应该使用栈保存返回值。<br><strong>finally中的return 会覆盖 try 或者catch中的返回值。</strong></p>
<h4 id="throws-函数声明"><a href="#throws-函数声明" class="headerlink" title="throws 函数声明"></a>throws 函数声明</h4><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p>
<p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>
<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ExceptionType1<span class="token punctuation">,</span> ExceptionType2<span class="token punctuation">,</span> ExceptionTypeN <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>
        String s <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NumberFormatException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h4><p>通过上面的两个demo可以得知：</p>
<p>1、throw用在方法体内，上面代码显示了，是直接在main方法体内</p>
<p>   throws用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。这个看上面的代码就理解了</p>
<p>2、throw是具体向外抛异常的，抛出的是一个异常实例</p>
<p>   throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常</p>
<p>3、throw，如果执行了，那么一定是抛出了某种异常了，安生throws表示可能出现，但不一定。</p>
<p>4、同时出现的时候，throws出现在函数头、throw出现在函数体，两种不会由函数去处理，真正的处理由函数的上层调用处理</p>
<h4 id="for-中try还是for外try"><a href="#for-中try还是for外try" class="headerlink" title="for 中try还是for外try"></a>for 中try还是for外try</h4><p>try放在for循环的里面所有的for循环都会执行，当遇到异常时，抛出异常继续执行；放在外面，当遇到异常时，抛出异常，后面的循环就会终止，并不会执行。</p>
<h3 id="6、-变量命名规范"><a href="#6、-变量命名规范" class="headerlink" title="6、 变量命名规范"></a>6、 变量命名规范</h3><p>首字母：字母、$和下划线。变量名：由$、字母、数字和下划线组成。</p>
<h3 id="7、方法重载与方法重写"><a href="#7、方法重载与方法重写" class="headerlink" title="7、方法重载与方法重写"></a>7、方法重载与方法重写</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc2.png" alt=""></p>
<h3 id="8、继承-封装-多态-抽象"><a href="#8、继承-封装-多态-抽象" class="headerlink" title="8、继承 封装 多态 抽象"></a>8、继承 封装 多态 抽象</h3><p>1、请描述一下java</p>
<p>java是一个面向对象的编程语言，有继承 封装 多态的特性，同时java也是一开源的语言，一次编译到处运行，有很完善的生态系统，包括各种各样的企业级框架。</p>
<p>2、抽象</p>
<p>抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。</p>
<p>3、封装</p>
<blockquote>
<p> 1）将实例变量标记为私有的（private），表示只能在类的内部使用。 <br><br>   2）提供公有（public）的get和set方法，用来控制对实例变量的存取动作。</p>
</blockquote>
<p>   封装的目的是：增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。</p>
<p>4、继承</p>
<p>目的：实现代码的复用。</p>
<p>继承是从已有的类得到继承信息创建新的类的过程，继承可以表示为 is-a 关系 。父类的私有属性和构造方法并不能被继承。另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。</p>
<p>5、多态</p>
<p>多态可以大概分为两种方式：方法重载与方法重写。</p>
<ul>
<li>方法重载（Overload）:编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致。</li>
<li>方法重写（Override）:运行时的多态（也称为后绑定）。<br>要实现方法重写需要做：1.方法重写，也就是子类继承父类并重写了父类已经有的方法。 2.用父类型引用来引用子类型对象，这样可以实现调用同样的方法会根据子类对象的不同表示出不一样的行为。</li>
</ul>
<h3 id="9、接口-amp-amp-抽象类"><a href="#9、接口-amp-amp-抽象类" class="headerlink" title="9、接口 &amp;&amp; 抽象类"></a>9、接口 &amp;&amp; 抽象类</h3><p>接口<br>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。<br>抽象类</p>
<p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：<br>abstract void fun() 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法</p>
<p>接口和抽象类的区别</p>
<p>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p>
<p>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p>
<p>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p>
<p>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p>5）抽象类中的方法子类必须全部实现,不然子类也是抽象类,而接口中的抽象方法子类必须全部实现。</p>
<p>6）抽象类是一种模板设计模式,而接口是一种行为规范。</p>
<h3 id="10、自动类型转换和强制类型转换规则"><a href="#10、自动类型转换和强制类型转换规则" class="headerlink" title="10、自动类型转换和强制类型转换规则"></a>10、自动类型转换和强制类型转换规则</h3><ul>
<li>自动类型转换也叫隐式类型转换</li>
<li>表达式的数据类型自动提升</li>
<li>从低位类型到高位类型自动转换；从高位类型到低位类型需要强制类型转换：</li>
<li>boolean类型与其他基本类型不能进行类型的转换（既不能进行自动类型的提升，也不能强制类型转换）</li>
</ul>
<h3 id="11、选择结构"><a href="#11、选择结构" class="headerlink" title="11、选择结构"></a>11、选择结构</h3><ul>
<li>if</li>
<li>switch<blockquote>
<p>在switch 中可以使用的类型 Java支持的数据类型有五种<br>  他们分别是：<br>  byte、char、short、int、enum；<br>  以上是JDK1.6以前的版本。<br>  JDK1.7时，又增加了String</p>
</blockquote>
</li>
</ul>
<p>语法</p>
<pre><code>int is = 0;
switch (is) {
    case 1:
        System.out.println("**");
        break;
    case 2:
        break;
    default:
        System.out.println();
        break;
}</code></pre><ul>
<li>while</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先判断再执行</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"好好学习，天天向上！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 先执行再判断</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>for</li>
</ul>
<pre><code> for (int is = 0; is &lt; 100; is++) {
     System.out.println("好好学习！");
 }</code></pre><h3 id="12、break-amp-amp-continue"><a href="#12、break-amp-amp-continue" class="headerlink" title="12、break &amp;&amp; continue"></a>12、break &amp;&amp; continue</h3><pre><code>continue 作用：跳过循环体中剩余的语句而执行下一次循环
break语句终止某个循环，程序跳转到循环块外的下一条语句</code></pre><h3 id="13、数组"><a href="#13、数组" class="headerlink" title="13、数组"></a>13、数组</h3><pre><code>public static void main(String[] args) {
    //声明数组
    String [] arr;
    int arr1[];

    //初始化数组
    int arr2[]=new int[]{1,2,3,4,5};
    String[] array1={"马超","马云","关羽","刘备","张飞"};
    String[] array2=new String[]{"黄渤","张艺兴","孙红雷","小猪","牙哥","黄磊"};

    String[] array=new String[5];


    //查看数组的长度
    int length=array1.length;
    System.out.println("length：  "+array1.length);

    //输出数组
//      System.out.println(array1);     //结果：[Ljava.lang.String;@32f22097
    System.out.println("arr2:  "+Arrays.toString(arr2));

    //遍历数组
    for (int i = 0; i &lt; array1.length; i++) {
//          System.out.println(array1[i]);
    }
    //int数组转成string数组
    int[]  array3={1,2,3,4,5,6,7,8,9,0};
    String arrStrings=Arrays.toString(array3);
//      System.out.println(arrStrings);

    //从array中创建arraylist
    ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;(Arrays.asList(array1));
    System.out.println(arrayList);

    //数组中是否包含某一个值
    String a="马超";
    if (Arrays.asList(array1).contains(a)) {
        System.out.println("马超在这里");
    }

    //将数组转成set集合
    Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(array2));
    System.out.println(set);

    //将数组转成list集合
    List&lt;String&gt; list=new ArrayList&lt;String&gt;();
    for (int i = 0; i &lt; array2.length; i++) {
        list.add(array2[i]);
    }
    String[] arrStrings2={"1","2","3"};
    List&lt;String &gt; list2=java.util.Arrays.asList(arrStrings2);
    System.out.println(list2);


    //Arrays.fill()填充数组
    int[] arr3=new int[5];
    Arrays.fill(arr3, 10);  //将数组全部填充10
    for (int i = 0; i &lt; arr3.length; i++) {
        System.out.println(arr3[i]);
    }

    //数组排序
    int[] arr4 = {3, 7, 2, 1, 9};
    Arrays.sort(arr4);
    for (int i = 0; i &lt; arr4.length; i++) {
        System.out.println(arr4[i]);
    }

    int[] arr5 = {3, 7, 2, 1, 9,3,45,7,8,8,3,2,65,34,5};
    Arrays.sort(arr5, 1, 4);  //从第几个到第几个之间的进行排序
    for (int i = 0; i &lt; arr5.length; i++) {
        System.out.println(arr5[i]);
    }


    //复制数组
    int[] arr6 = {3, 7, 2, 1};
    int[] arr7=Arrays.copyOf(arr6, 10);  //指定新数组的长度

    int[] arr8=Arrays.copyOfRange(arr6, 1, 3); //只复制从索引[1]到索引[3]之间的元素（不包括索引[3]的元素）
    for (int i = 0; i &lt; arr8.length; i++) {
        System.out.println(arr8[i]);
    }

    //比较两个数组
    int[] arr9 = {1, 2, 3, 4,5,6,7,8,9,0};
    boolean arr10=Arrays.equals(arr6, arr9);
    System.out.println(arr10);

    //去重复
    //利用set的特性
    int[] arr11 = {1, 2, 3, 4,5,6,7,8,9,0,3,2,4,5,6,7,4,32,2,1,1,4,6,3};
    Set&lt;Integer&gt; set2=new HashSet&lt;Integer&gt;();
    for (int i = 0; i &lt; arr11.length; i++) {
        set2.add(arr11[i]);
    }
        System.out.println(set2);
    int[] arr12 = new int[set2.size()];
    int j=0;
    for (Integer i:set2) {
        arr12[j++]=i;
    }
    System.out.println(Arrays.toString(arr12));
}</code></pre><h3 id="14、String-StringBuffer-StringBuilder"><a href="#14、String-StringBuffer-StringBuilder" class="headerlink" title="14、String StringBuffer StringBuilder"></a>14、String StringBuffer StringBuilder</h3><ul>
<li>String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</li>
<li>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li>
<li>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
<p><strong>String，StingBuffer，StringBuilder效率如何呢</strong></p>
<p>从高到底的顺序依次是：StringBuilder  &gt;  StingBuffer &gt; String</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;String是字符串常量，所以他的效率自然而然是最低的。对于StringBuffer和StringBuilder它们属于变量，是可以改变的对象，每次对字符串的操作，实际上实在一个对象上操作，所以效率更高一些。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;StringBuffer是线程安全的，考虑到安全问题，相对他的性能会更低一点。由此知道了从效率的角度看，StringBuilder最高，其次是StringBuffer，最后是String字符串常量。</p>
<p><strong>String 类的常用方法都有那些？</strong></p>
<ul>
<li>indexOf()：返回指定字符的索引</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h3 id="15、基本数据类型-amp-amp-包装类型"><a href="#15、基本数据类型-amp-amp-包装类型" class="headerlink" title="15、基本数据类型 &amp;&amp; 包装类型"></a>15、基本数据类型 &amp;&amp; 包装类型</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc8.png" alt=""></p>
<p>拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc9.png" alt=""></p>
<h4 id="2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"><a href="#2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆" class="headerlink" title="2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"></a>2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆</h4><ul>
<li>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</li>
<li>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</li>
<li>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</li>
<li>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</li>
</ul>
<h4 id="3、基本类型出现的原因"><a href="#3、基本类型出现的原因" class="headerlink" title="3、基本类型出现的原因"></a>3、基本类型出现的原因</h4><p>在Java编程思想的第一章就讲到：万物皆对象，new一个对象存储在堆中，我们通过堆栈的引用来使用这些对象，但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在堆栈中，因此更加高效。</p>
<h4 id="4、包装类型出现的原因"><a href="#4、包装类型出现的原因" class="headerlink" title="4、包装类型出现的原因"></a>4、包装类型出现的原因</h4><p>Java是一个面向对象的语言，基本类型并不具有对象的性质，为了与其他对象“接轨”就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h3 id="16、java日期处理"><a href="#16、java日期处理" class="headerlink" title="16、java日期处理"></a>16、java日期处理</h3><h4 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h4><blockquote>
<p>Date类用来指定日期和时间，其构造函数及常用方法如下：<br><br>public Date()从当前时间构造日期时间对象。<br><br>public String toString()转换成字符串。<br><br>public long getTime()它包含的是一个长整型数据long, 表示的是从GMT(格林尼治标准时间)1970年, 1 月 1日00:00:00这一刻之前或者是之后经历的毫秒数.</p>
</blockquote>
<h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><blockquote>
<p>通过向SimpleDateFormat 的构造函数传递格式字符串“yyyy-MM-dd”,<br>yyyy是年,MM是月,dd是日. 字符的个数决定了日期是如何格式化的.传递“yy-MM-dd”会显示 13-2-22</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc11.png" alt=""></p>
<h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><blockquote>
<p>Calendar类主要用于完成日期字段之间的相互操作的功能 <br><br>Calendar类是一个抽象基类,不能new，我们可以通过Calendar.getInstance得到其实例，下面列出Calendar的一些常用方法：<br><br>set(int year, int month, int date)设置日历字段 <br><br>set(int field, int value) 将给定的日历字段设置为给定值 <br><br>get(int field)返回给定日历字段的值 <br><br>getTime()返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的 Date 对象。</p>
</blockquote>
<p>如果是1则代表的是对年份操作，2是对月份操作，3是对星期操作，5是对日期操作，11是对小时操作，12是对分钟操作，13是对秒操作，14是对毫秒操作。例如：Calendar calendar = Calendar.getInstance(); calendar .add(5,1);则表示对日期进行加一天操作</p>
<h5 id="Calendar示例"><a href="#Calendar示例" class="headerlink" title="Calendar示例"></a>Calendar示例</h5><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc10.png" alt=""></p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul>
<li>abs()返回某数字的绝对值.</li>
<li>ceil()会找到下一个最大整数。</li>
<li>floor()返回紧邻的最小整数。</li>
<li>max()返回两个值中的最大值。</li>
<li>min()返回两个值中的最小值。</li>
<li>random()返回一个随机数，在0.0到1.0之间的双精度数。</li>
<li>round()返回与某浮点数值最接近的整数值。</li>
<li>sqrt()返回某数值的平方根。</li>
</ul>
<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><blockquote>
<p>Random类 伪随机数产生器。</p>
</blockquote>
<p>常用方法:</p>
<ul>
<li>public boolean nextBoolean()<br>该方法的作用是生成一个随机的boolean值。</li>
<li>public double nextDouble()<br>该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。</li>
<li>public int nextInt()<br>该方法的作用是生成一个随机的int值。</li>
<li>public int nextInt(int n)<br>该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。</li>
</ul>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * 将日期解析为指定格式的字符串
     */</span>
    Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 将字符串解析为日期对象
     */</span>
    SimpleDateFormat sim <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String ss <span class="token operator">=</span> <span class="token string">"2020-01-01"</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Date parse <span class="token operator">=</span> sim<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parse<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sim<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ParseException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * Calendar使用
     */</span>
    Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Date time <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 设置日期
     */</span>
    calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * Random随机数
     */</span>
    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc12.png" alt=""></p>
<h3 id="17-集合框架"><a href="#17-集合框架" class="headerlink" title="17.集合框架"></a>17.集合框架</h3><p>** 什么是集合 **</p>
<blockquote>
<p>通常情况下，把具有相同性质的一类东西，汇聚成一个整体，就可以称为集合。</p>
</blockquote>
<p>** 什么是集合框架 **</p>
<blockquote>
<p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>
</blockquote>
<ul>
<li>接口：即表示集合的抽象数据类型。</li>
<li>实现：也就是集合框架中接口的具体实现。</li>
<li>算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。</li>
</ul>
<h4 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h4><p>Java集合框架图。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc14.png" alt=""></p>
<p>1) 首先查看jdk中Collection类的源码后:</p>
<pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {</code></pre><p>通过查看可以发现Collection是一个接口类，其继承了java迭代接口Iterable</p>
<p><strong>Collection接口中的方法如下:</strong><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc13.png" alt=""></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul>
<li><p>ArrayList底层其实就是一个Object类型的数组，非线程安全的集合。查询元素快，插入，删除中间元素慢，初始化的长度为10，每次扩容为原大小的1.5倍，可以通过构造方法改变初始容量大小。</p>
</li>
<li><p>ArrayList快在下标定位，慢在数组复制。</p>
</li>
<li><p>由于每次添加的时候，通过扩容机制判断原数组是否还有空间，若没有则重新实例化一个空间更大的新数组，把旧数组的数据拷贝到新数组中，耗费时间和性能</p>
</li>
</ul>
<p><strong>Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0，JDK差异，每次约按1.5倍扩容。 JDK8 中ArrayList扩容的实现是通过grow()方法里使用语句newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)（即1.5倍扩容）计算容量，然后调用Arrays.copyof()方法进行对原数组进行复制。</strong></p>
<p><strong>若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</strong></p>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote>
<p><font size="3"> 基于数组实现的线程安全的集合。线程同步（方法被synchronized修饰），性能比ArrayList差。 </font></p>
</blockquote>
<font size="4">
Vector 的数据结构和使用方法与ArrayList差不多。最大的不同就是Vector是线程安全的。几乎所有的对数据操作的方法都被synchronized关键字修饰。synchronized是线程同步的，当一个线程已经获得Vector对象的锁时，其他线程必须等待直到该锁被释放。从这里就可以得知Vector的性能要比ArrayList低。
若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合
</font>

<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>基于双向循环链表实现的非线程安全的集合。查询元素慢，插入，删除中间元素快。</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</p>
<h4 id="几种集合的区别"><a href="#几种集合的区别" class="headerlink" title="几种集合的区别"></a>几种集合的区别</h4><p>ArrayList查询快，写数据慢；LinkedList查询慢，写数据快<br>ArrayList查询快是因为底层是由数组实现，通过下标定位数据快。写数据慢是因为复制数组耗时。LinkedList底层是双向循环链表，查询数据依次遍历慢。写数据只需修改指针引用。<br>ArrayList和LinkedList都不是线程安全的，小并发量的情况下可以使用Vector，若并发量很多，且读多写少可以考虑使用CopyOnWriteArrayList。</p>
<h4 id="遍历list集合"><a href="#遍历list集合" class="headerlink" title="遍历list集合"></a>遍历list集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * for循环遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * foreach遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 通过迭代器遍历
     */</span>
    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>[set][1]</p>
<blockquote>
<p>在选择的时候，如果顺序很重要，则可以选择TreeSet，如果操作性能和时间效率很重要的话，则可以选择HashSet</p>
</blockquote>
<ul>
<li><p>HashSet集合</p>
<blockquote>
<p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置，存取速度比较快。</p>
</blockquote>
<ul>
<li>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树，底层实际上是一个HashMap。</li>
<li>所以可以直接总结出：HashSet实际上就是封装了HashMap，操作HashSet元素实际上就是操作HashMap。这也是面向对象的一种体现，重用性贼高！</li>
<li>无序，允许为null，，有且仅有一个元素为null！</li>
<li>线程不安全的。</li>
<li>HashSet还有一个子类LinkedHashSet</li>
</ul>
</li>
<li><p>TreeSet集合</p>
<ul>
<li>底层数据结构是红黑树(是一个自平衡的二叉树)</li>
<li>有排序功能，支持两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</li>
<li>有序，不允许为null</li>
<li>线程不安全的。</li>
</ul>
</li>
<li><p>LinkedHashSet集合</p>
<ul>
<li>迭代是有序的</li>
<li>允许为null，有且仅有一个元素为null！</li>
<li>底层实际上是一个HashMap+双向链表实例(其实就是LinkedHashMap)</li>
<li>线程不安全的。</li>
<li>性能比HashSet差一丢丢，因为要维护一个双向链表</li>
<li>初始容量与迭代无关，LinkedHashSet迭代的是双向链表</li>
</ul>
</li>
</ul>
<h4 id="遍历set集合"><a href="#遍历set集合" class="headerlink" title="遍历set集合"></a>遍历set集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 迭代器遍历方式
     */</span>
    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str<span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="set-和list的区别"><a href="#set-和list的区别" class="headerlink" title="set 和list的区别"></a>set 和list的区别</h4><ul>
<li>List接口：存储一组不唯一，有序的对象</li>
<li>Set接口：存储一组唯一，无序的对象</li>
</ul>
<h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><p>*<em>Map接口不是继承Collection接口；Map接口用于维护键／值对（key/value pairs），他的实现类有: *</em><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc15.png" alt=""></p>
<h4 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc16.png" alt=""></p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p><strong>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</strong></p>
<h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><p>! 从Hashtable的命名规范就可以看出，t没有大写，并不是我写错了</p>
<p>底层是哈希表数据结构，不可以存入null键null值。该集合是线程同步的。</p>
<h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p>底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。</p>
<h5 id="LinkedHashMap："><a href="#LinkedHashMap：" class="headerlink" title="LinkedHashMap："></a>LinkedHashMap：</h5><p>该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。</p>
<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>该类是线程安全的 Map 实现。与 Hashtable 相似，但 Hashtable 的 synchronized 是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对 hash 表的不同部分进行的修改。ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<h4 id="遍历map集合"><a href="#遍历map集合" class="headerlink" title="遍历map集合"></a>遍历map集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 第二种
     */</span>
    <span class="token comment" spellcheck="true">//遍历map中的键</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//遍历map中的值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * 迭代器
     */</span>
    Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * 通过键找值遍历（效率低）
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="三种集合在实际工作用到的地方"><a href="#三种集合在实际工作用到的地方" class="headerlink" title="三种集合在实际工作用到的地方"></a>三种集合在实际工作用到的地方</h4><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>容器指的是集合框架</p>
<p>同步容器是通过syncrhoized关键字对线程不安全的操作进行加锁来保证线程安全的，其原理是使得多线程轮流获取同步锁进行对集合的操作，所以性能有所下降。，像Vector、Hashtable、Stack。</p>
<p> 为此，java.util.concurrent提供了多种并发容器，以：在原有集合的拷贝上进行操作，用修改后的集合替换原集合  的方式来达到并发且安全地使用集合类的目的。</p>
<pre><code>根据接口的类型，主要有以下四种接口，其他具体的容器均是对这些接口的实现类：</code></pre><p>Queue类型：阻塞队列BlockingQueue、非阻塞队列ConcurrentLinkedQueue</p>
<p>Map类型：ConcurrentMap</p>
<p>Set类型：ConcurrentSkipListSet、CopyOnWriteArraySet</p>
<p>List类型：CopyOnWriteArrayList</p>
<h4 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h4><font size="3">

<p>　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>　　<br>　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
</font>

<h3 id="hascode"><a href="#hascode" class="headerlink" title="hascode"></a>hascode</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>根据这个方法的声明可知，它是一个本地方法，它的实现与本地机器有关，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p>
<p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及Hashtable，如果没有很好的覆写键的hashcode()和equals()方法，那么将无法正确的处理键。</p>
<p>　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）—–HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。</p>
<p>所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。</p>
<h3 id="18、泛形"><a href="#18、泛形" class="headerlink" title="18、泛形"></a>18、泛形</h3><p><strong>什么是泛型</strong></p>
<pre><code>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。
在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</code></pre><h4 id="泛形方法"><a href="#泛形方法" class="headerlink" title="泛形方法"></a>泛形方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 说明：
 * 1）&lt;E>非常重要，可以理解为声明此方法为泛型方法。
 * 2）只有声明了&lt;E>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
 * 3）&lt;E>表明该方法将使用泛型类型E，此时才可以在方法中使用泛型类型E。
 * 4）与泛型类的定义一样，此处E可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
 *
 * @param inputArray
 * @param &lt;E>
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 输出数组元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>E element <span class="token operator">:</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="泛形类"><a href="#泛形类" class="headerlink" title="泛形类"></a>泛形类</h4><h4 id="泛形接口"><a href="#泛形接口" class="headerlink" title="泛形接口"></a>泛形接口</h4><h4 id="泛形通配符：？"><a href="#泛形通配符：？" class="headerlink" title="泛形通配符：？"></a>泛形通配符：？</h4><h4 id="泛形的限定"><a href="#泛形的限定" class="headerlink" title="泛形的限定"></a>泛形的限定</h4><p>我们知道使用泛型类时：如果明确参数类型，那么泛型就代表一种类型；如果使用通配符？，那么泛型就代表任意类型。但有时候我们希望指定某些类型(不是一个，也不要所有)能作为参数类型，这应该怎么办呢？</p>
<pre><code>    Java中利用泛型的限定解决了这个问题，即泛型的限定。我们只需要按这样的格式书写：

   上限：&lt;？ extends E&gt;表示参数类型是E及其所有子类。

   下限：&lt;? super E&gt;表示参数类型是E及其所有超类(即父类)。</code></pre><h4 id="Java泛型中E、T、K、V等的含义"><a href="#Java泛型中E、T、K、V等的含义" class="headerlink" title="Java泛型中E、T、K、V等的含义"></a>Java泛型中E、T、K、V等的含义</h4><ul>
<li>E - Element (在集合中使用，因为集合中存放的是元素)（集合泛形）</li>
<li>T - Type（Java 类）（接口）</li>
<li>K - Key（键）</li>
<li>V - Value（值）</li>
<li>N - Number（数值类型）</li>
<li>？ -  表示不确定的java类型</li>
</ul>
<h3 id="19、枚举"><a href="#19、枚举" class="headerlink" title="19、枚举"></a>19、枚举</h3><p>enum 的全称为 enumeration， 是 JDK 1.5  中引入的新特性，存放在 java.lang 包中，另外到了JDK1.6后switch语句支持枚举类型。</p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71333103</a></p>
<h3 id="20、io流"><a href="#20、io流" class="headerlink" title="20、io流"></a>20、io流</h3><p>Java中使用IO(输入输出）来读取和写入，读写设备上的数据、硬盘文件、内存、键盘……，根据数据的走向可分为输入流和输出流，这个走向是以内存为基准的，即往内存中读数据是输入流，从内存中往外写是输出流。</p>
<p><strong>根据处理的数据类型可分为字节流和字符流</strong></p>
<p>  1.字节流可以处理所有数据类型的数据，在java中以Stream结尾</p>
<p>  2.字符流处理文本数据，在java中以Reader和Writer结尾。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc17.png" alt=""></p>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="输入流-InputStream"><a href="#输入流-InputStream" class="headerlink" title="输入流 InputStream"></a>输入流 InputStream</h5><p><strong>API</strong></p>
<ul>
<li>int read( )    读取一个字节，返回值为所读的字节</li>
<li>int read( byte b[ ] )   读取多个字节，放置到字节数组b中，通常读取的字节数量为b的长度，返回值为实际读取的字节的数量</li>
<li>int read( byte b[ ], int off, int len )   读取len个字节，放置到以下标off开始字节数组b中，返回值为实际读取的字节的数量</li>
<li>int available( )   返回值为流中尚未读取的字节的数量</li>
<li>long skip( long n )   读指针跳过n个字节不读，返回值为实际跳过的字节数量</li>
<li>close( )   流操作完毕后必须关闭</li>
</ul>
<p>代码</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    InputStream inputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将读取到的一个字节给i，中文占两个字节</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h5 id="输出流-OutputStream"><a href="#输出流-OutputStream" class="headerlink" title="输出流 OutputStream"></a>输出流 OutputStream</h5><p><strong>API</strong></p>
<ul>
<li>void write( int b ); 　　//往流中写一个字节b</li>
<li>void write( byte b[ ] ); //往流中写一个字节数组b</li>
<li>void write( byte b[ ], int off, int len );  把字节数组b中从下标off开始，长度为len的字节写入流中</li>
<li>flush( )  刷空输出流，并输出所有被缓存的字节由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li>
<li>close( ) 流操作完毕后必须关闭 </li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 没有则会创建文件</span>
    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    OutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"超哥"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h5 id="输入流-Reader"><a href="#输入流-Reader" class="headerlink" title="输入流 Reader"></a>输入流 Reader</h5><p><strong>API</strong></p>
<ul>
<li>int read() throws IOException;  读取一个字符，返回值为读取的字符</li>
<li>int read(char cbuf [  ]) throws IOException; 读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</li>
<li>abstract int read( char cbuf[ ] , int off , int len) throws IOException;   读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</li>
<li>boolean markSupported( ); 判断当前流是否支持做标记</li>
<li>void mark ( int readAheadLimit ) throws IOException;   给当前流作标记，最多支持readAheadLimit个字符的回溯。</li>
<li>void reset( ) throws IOException;    将当前流重置到做标记处</li>
<li>abstract void close( ) throws IOException;   关闭</li>
</ul>
<p><strong>代码</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Reader os <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="输出流-Writer"><a href="#输出流-Writer" class="headerlink" title="输出流 Writer"></a>输出流 Writer</h5><p><strong>API</strong></p>
<ul>
<li>void write (int c) throws IOException； 将整型值c的低16位写入输出流</li>
<li>void write ( String str ) throws IOException； 将字符串str中的字符写入输出流</li>
<li>void write( char cbuf[ ] )  throws IOException；  将字符数组cbuf[]写入输出流</li>
<li>abstract void write( char cbuf[ ] , int off , int len) throws IOException； 将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流</li>
<li>void write( String str , int off , int len) throws IOException；  将字符串str 中从索引off开始处的len个字符写入输出流</li>
<li>flush( )   刷空输出流，并输出所有被缓存的字节。</li>
<li>close( )  关闭流</li>
</ul>
<h4 id="字节、字符流转换类"><a href="#字节、字符流转换类" class="headerlink" title="字节、字符流转换类"></a>字节、字符流转换类</h4><p>字节转为字符流</p>
<blockquote>
<p>字符 不需要转为字节流，字节流可以读取任意数据，而字符读取内容有限。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将字节流转换为字符流</span>
        InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><h5 id="缓冲流介绍"><a href="#缓冲流介绍" class="headerlink" title="缓冲流介绍"></a>缓冲流介绍</h5><blockquote>
<p>普通的字节、字符流都是一个字节一个字符这样读取的,而缓冲流则是将数据先缓冲起来,然后一起写入或者读取出来。<br>缓冲流为I/O流增加了内存缓冲区，使用缓冲流的好处是，能够更高效的读写信息。缓冲流要“套接”在相应的节点流(低级流)之上，对读写的数据提供了缓冲的功能。<br>缓冲输入流支持其父类的mark()和reset()方法：mark()用于“标记”当前位置，就像加入了一个书签，可以使用reset()方法返回这个标记重新读取数据</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 字节缓冲流</span>
        BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>J2SDK提供了四种缓存流：<br><font size="4"><br><strong>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter</strong> </font></p>
<h5 id="缓冲流字节流"><a href="#缓冲流字节流" class="headerlink" title="缓冲流字节流"></a>缓冲流字节流</h5><pre><code>java.io.BufferedInputStream类可以对任何的InputStream流进行带缓冲的封装以达到性能的改善。该类在已定义输入流上再定义一个具有缓冲的输入流，可以从此流中成批地读取字符而不会每次都引起直接对数据源的读操作。数据输入时，首先被放入缓冲区，随后的读操作就是对缓冲区中的内容进行访问
java.io.BufferedOutputStream不直接写入输出流，先写入缓冲区，当缓冲区满时，字节数据才会写到BufferedOutputStream所连接的流，调用该类的flush()将缓冲区全部写入输出流</code></pre><h3 id="21、序列化"><a href="#21、序列化" class="headerlink" title="21、序列化"></a>21、序列化</h3><h4 id="对象序列化概述"><a href="#对象序列化概述" class="headerlink" title="对象序列化概述"></a>对象序列化概述</h4><blockquote>
<p>一般地，对象不能脱离应用程序。但有时候，需要将对象的状态保存下来，在需要时再将对象恢复，即对象持久化（Persistence）。对象序列化（Object Serialization）可以将对象存储到外存中或以二进制形式通过网络传输。对象反串行化可以从这些数据中重构一个与原始对象状态相同的对象<br>为了实现对象系列化，对应的类必须实现下面的两种接口之一：<br>Serializable<br>Externalizable</p>
</blockquote>
<h4 id="将对象保存到磁盘文件"><a href="#将对象保存到磁盘文件" class="headerlink" title="将对象保存到磁盘文件"></a>将对象保存到磁盘文件</h4><ul>
<li>通过java.io.ObjectOutputStream可以将对象输出到磁盘文件、网络等设备</li>
<li>调用这个类的writeObject()方法，可以向特定的文件或网络输出对象</li>
<li>writeObject()方法序列化指定的对象，并遍历该对象对其它对象的引用，递归的序列化所有被引用到的其它对象，从而建立一个完整的序列化流</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        OutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Student需要序列化</span>
        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">setI</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="从磁盘读出保存的对象"><a href="#从磁盘读出保存的对象" class="headerlink" title="从磁盘读出保存的对象"></a>从磁盘读出保存的对象</h4><ul>
<li>通过java.io.ObjectInputStream对象可以从磁盘文件中读出保存的对象（或从网络中读出传递的对象）</li>
<li>调用这个类的readObject()方法，从特定的设备读出对象readObject()方法反序列化输入流中的对象，遍历该对象中所有对其它对象的引用，并递归的反序列化这些引用对象</li>
<li>readObject()方法返回的是Object对象，所以，需要对它进行必要的（向下）造型操作。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Student student <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><ul>
<li>通过在属性前面加上transient关键字，限制属性写入到文件或网络中</li>
<li>还可以在未实现系列化接口的引用类型属性前面加上transient关键字，避免对此类属性进行递归系列化时出现java.io.NotSerializableException异常</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> String name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加一个transient修饰的属性</span></code></pre>
<p>什么被序列化<br>属性（包括基本数据类型、数组、对其它对象的引用）<br>类名<br>什么不被序列化<br>static的属性<br>方法<br>加了transient修饰符的属性</p>
<h3 id="22、多线程"><a href="#22、多线程" class="headerlink" title="22、多线程"></a>22、多线程</h3><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7526608.html</a></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt="image"></p>
<h4 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h4><table>
<thead>
<tr>
<th>术语</th>
<th>英文单词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>共享变量</td>
<td></td>
<td>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。</td>
</tr>
<tr>
<td>内存屏障</td>
<td>Memory Barriers</td>
<td>是一组处理器指令，用于实现对内存操作的顺序限制。</td>
</tr>
<tr>
<td>缓冲行</td>
<td>Cache line</td>
<td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td>
</tr>
<tr>
<td>原子操作</td>
<td>Atomic operations</td>
<td>不可中断的一个或一系列操作。</td>
</tr>
<tr>
<td>缓存行填充</td>
<td>cache line fill</td>
<td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有）</td>
</tr>
<tr>
<td>缓存命中</td>
<td>cache hit</td>
<td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。</td>
</tr>
<tr>
<td>写命中</td>
<td>write hit</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td>
</tr>
<tr>
<td>写缺失</td>
<td>write misses the cache</td>
<td>一个有效的缓存行被写入到不存在的内存区域。</td>
</tr>
</tbody></table>
<p><strong>什么是进程</strong></p>
<p>进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例。</p>
<p><strong>进程时间片的概念</strong></p>
<p>一个操作系统中，如果同时运行着多个进程，他们是一定交替运行的。每个进程不管有没有运行完毕，都只占据一段时间的CPU。<br>这个运行时间就是进程时间片。它非常短促，所以感觉不到他们是交替占用CPU。</p>
<p><strong>什么是线程</strong></p>
<ul>
<li><p>线程：进程内部的控制流。它也是一段可运行的指令。</p>
</li>
<li><p>特点：资源占用小，线程间通信容易。</p>
</li>
<li><p>多进程是指操作系统能同时运行多个任务（程序）。</p>
</li>
</ul>
<p>多线程：</p>
<pre><code>指的是这个程序（一个进程）运行时产生了不止一个线程</code></pre><h4 id="线程进程的区别体现在几个方面："><a href="#线程进程的区别体现在几个方面：" class="headerlink" title="线程进程的区别体现在几个方面："></a>线程进程的区别体现在几个方面：</h4><p>第一：  因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p>
<p>第二：  体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p>
<p>3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p>
<p>4.线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；</p>
<p>5.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p>
<p>第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p>
<p>并行与并发：</p>
<pre><code>1.    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
2.    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，
那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。
并发性（concurrency）和并行性（parallel）
</code></pre><p><strong>线程的特点</strong></p>
<ul>
<li>线程的运行方式和进程一样，在同一个进程内部，线程也是交替占用CPU。每个线程的运行时间，称为线程时间片。</li>
<li>线程有开始、中间和结束部分，即有一定的生命周期。</li>
<li>同一个进程中的多个线程是共享一块内存空间和一组系统资源。</li>
<li>线程不能作为具体的可执行命令体存在。最终用户不能直接执行线程，线程只能运行在进程中。</li>
</ul>
<p><strong>如何创建线程</strong></p>
<pre><code>两种方法来创建线程：
继承java.lang.Thread类，并覆盖run( )方法。
 class mythread extends Thread {
     public void run( ) {
         /* 覆盖该方法*/
      }
 }
实现java.lang.Runnable接口，并实现run( )方法。
class mythread implements Runnable{
      @Override
      public void run( ) {
          /* 实现该方法*/
      }
 }
一个线程的对象只能执行一次start()方法</code></pre><p><strong>线程的启动</strong></p>
<ul>
<li><p>新建的线程不会自动开始运行，必须通过start( )方法启动线程。如果不调用这个方法，线程将不会运行。</p>
</li>
<li><p>也就是说可以事先创建线程，并在需要的时候才启动他们。如：</p>
<pre class=" language-java"><code class="language-java">  继承Thread的线程：
Typer  t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Typer</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
<p>实现Runnable接口的线程：<br>Runnable  mt =   new Typer ( );<br>Thread    t  =   new Thread(mt);// 父类的类型子类的对象<br>t.start( );</p>
<pre><code>**线程执行过程**
- 调用start( )方法时，将创建一个新的线程，并为线程分配系统资源，如内存。接着它将调用 run( ) 方法。

- run( ) 方法中的代码定义执行线程所需的功能。
    - run()方法能够调用其他方法，引用其他的类，申明变量。
    - run()方法在程序中确定另一个并发线程的执行入口。
- 当run()方法中的任务完成返回时，该线程也将结束。

**注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。
从程序运行的结果可以发现，多线程程序是乱序执行。**

#### Thread和Runnable的区别

实现Runnable接口比继承Thread类所具有的优势：

- 适合多个相同的程序代码的线程去处理同一个资源
- 可以避免java中的单继承的限制
- 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
- 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类

#### 线程状态

下面的这个图非常重要!

![](https://raw.githubusercontent.com/Flyiyu/use/master/jc18.jpg)


1. 新建状态（New）：新创建了一个线程对象。
2. 就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3. 运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4. 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    - 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持    有的锁)
    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
    - 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。


#### 线程调度
线程的调度

1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。

Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
static int MAX_PRIORITY
    线程可以具有的最高优先级，取值为10。
static int MIN_PRIORITY
    线程可以具有的最低优先级，取值为1。
static int NORM_PRIORITY
          分配给线程的默认优先级，取值为5。

Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。

每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。
JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。

2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。

4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。

6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。
 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。

#### 守护线程
1. 定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公
共服务，在没有用户线程可服务时会自动离开。
2. 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。
3. 设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程
的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。
4. 在 Daemon 线程中产生的新线程也是 Daemon 的。
5. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的
生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程
依旧是活跃的。
6. example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,
程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线
程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统
中的可回收资源。
7. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周
期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依
赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退
出了；如果还有一个或以上的非守护线程则 JVM 不会退出。




##### yield()、sleep()、join()和interrupt()方法   

1、yield()　

　　&amp;ensp;&amp;ensp;yield()是Thread类的静态方法。它能让当前线程暂停，但不会阻塞该线程，而是由“运行状态”进入到“就绪状态”，从而让 其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是 当前线程又进入到“运行状态”继续运行！

　　值得注意的是，yield()方法不会释放锁。



2、sleep()

　　&amp;ensp;&amp;ensp;sleep()是Thread类的静态方法。该方法声明抛出了InterrupedException异常。所以使用时，要么捕捉，要么声明抛出。

　　有2种重载方式：

——static void sleep(long millis)　　:　　让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。

——static void sleep(long millis , int nanos)　　：　　让当前正在执行的线程暂停millis毫秒加nanos微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。

　　sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。常用来暂停程序的运行。　　

　　同时注意，sleep()方法不会释放锁。



3、join()

　　join() 是Thread的一个实例方法。表示，当某个程序执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join的线程执行完毕。

有3种重载的形式：

——join()　　:　　等待被join的线程执行完成

——join(long millis)　　：　　等待被join的线程的时间最长为millis毫秒，若在millis毫秒内，被join的线程还未执行结束，则不等待。

——join(long millis , int nanos)　　:　　等待被join的线程的时间最长为millis毫秒加nanos微秒，若在此时间内，被join的线程还未执行结束，则不等待。

&amp;ensp;&amp;ensp;即当前线程内，用某个线程对象调用join()后，会使当前线程等待，直到该线程对象的线程运行完毕，原线程才会继续运行。



4、interrupt()　　　

　　我们经常通过判断线程的中断标记来控制线程。　 　

　　&amp;ensp;&amp;ensp;interrupt()是Thread类的一个实例方法，用于中断本线程。这个方法被调用时，会立即将线程的中断标志设置为“true”。所以当中断处于“阻塞状态”的线程时，由于处于阻塞状态，中断标记会被设置为“false”，抛出一个 InterruptedException。所以我们在线程的循环外捕获这个异常，就可以退出线程了。

　&amp;ensp;&amp;ensp;interrupt()并不会中断处于“运行状态”的线程，它会把线程的“中断标记”设置为true，所以我们可以不断通过isInterrupted()来检测中断标记，从而在调用了interrupt()后终止线程，这也是通常我们对interrupt()的用法。

　　&amp;ensp;&amp;ensp;Interrupted()是Thread类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，isInterrupted()是Thread类的实例方法，返回一个布尔类型来判断线程是否已经被中断。它们都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。
　　
　　
　　
#### start 与 run 区别
1. start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。
2. 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运
行。
3. 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运
行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。

#### Synchronized关键字

synchronized是一个重量级锁，相对于Lock，它会显得那么笨重 诚然，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。

  1、同步和异步的区别和联系

 　　&amp;ensp;&amp;ensp;所谓同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其它的命令。

&amp;ensp;&amp;ensp;异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。

 &amp;ensp;&amp;ensp;同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行(死心眼)。

异步在一定程度上可以看做是多线程的，请求一个方法后，就不管了，继续执行其他的方法。



1、原理

**在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。**

　　&amp;ensp;&amp;ensp;当当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。

　　&amp;ensp;&amp;ensp;不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。
例如，现在有个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。



2、基本规则

　　&amp;ensp;&amp;ensp;第一条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。

　　&amp;ensp;&amp;ensp;第二条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。

　&amp;ensp;&amp;ensp;第三条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。

1、普通同步方法，锁是当前实例对象

2、静态同步方法，锁是当前类的class对象

3、同步方法块，锁是括号里面的对象




3、实例锁和全局锁

&amp;ensp;&amp;ensp;实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。
               实例锁对应的就是synchronized关键字。

&amp;ensp;&amp;ensp;全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。
               全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。

&amp;ensp;&amp;ensp;就是说，一个非静态方法上的synchronized关键字，代表该方法依赖其所属对象。一个静态方法上synchronized关键字，代表该方法依赖这个类本身。



#### synchronized, wait, notify结合:典型场景生产者消费者问题

```java
/**
   * 生产者生产出来的产品交给店员
   */
  public synchronized void produce()
  {
      if(this.product &gt;= MAX_PRODUCT)
      {
          try
          {
              wait();  
              System.out.println("产品已满,请稍候再生产");
          }
          catch(InterruptedException e)
          {
              e.printStackTrace();
          }
          return;
      }

      this.product++;
      System.out.println("生产者生产第" + this.product + "个产品.");
      notifyAll();   //通知等待区的消费者可以取出产品了
  }

  /**
   * 消费者从店员取产品
   */
  public synchronized void consume()
  {
      if(this.product &lt;= MIN_PRODUCT)
      {
          try 
          {
              wait(); 
              System.out.println("缺货,稍候再取");
          } 
          catch (InterruptedException e) 
          {
              e.printStackTrace();
          }
          return;
      }

      System.out.println("消费者取走了第" + this.product + "个产品.");
      this.product--;
      notifyAll();   //通知等待去的生产者可以生产产品了
  }
</code></pre><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="Volatile的官方定义"><a href="#Volatile的官方定义" class="headerlink" title="Volatile的官方定义"></a>Volatile的官方定义</h5><p>  Java语言规范第三版中对volatile的定义如下：<br>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p>  volatile这个关键字。其实这个关键字有两层语义。第一层语义就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化。我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。</p>
<p><strong>Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</strong></p>
<h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><p>　　为什么出现这种情况呢，我们需要先了解一下JMM（java内存模型）</p>
<p>　　java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>　　JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc31.png" alt=""></p>
<p>　需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p>
<p>  那么这种共享变量在多线程模型中的不可见性如何解决呢？比较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，有点炮打蚊子的意思。比较合理的方式其实就是volatile</p>
<h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><h5 id="ThreadLocal概念"><a href="#ThreadLocal概念" class="headerlink" title="ThreadLocal概念"></a>ThreadLocal概念</h5><p>ThreadLocal 是线程的局部变量， 是每一个线程所单独持有的，其他线程不能对其进行访问。</p>
<p>  ThreadLocal，直译为“线程本地”或“本地线程”，如果你真的这么认为，那就错了！其实，它就是一个容器，用于存放线程的局部变量，我认为应该叫做 ThreadLocalVariable（线程局部变量）才对，真不理解为什么当初 Sun 公司的工程师这样命名。</p>
<p>  当使用ThreadLocal维护变量的时候 为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。</p>
<p>  但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
<p><strong>跳出误区</strong></p>
<p>  需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p>
<h5 id="ThreadLocal常用方法介绍"><a href="#ThreadLocal常用方法介绍" class="headerlink" title="ThreadLocal常用方法介绍"></a>ThreadLocal常用方法介绍</h5><p>public void set(T value)：将值放入线程局部变量中</p>
<p>public T get()：从线程局部变量中获取值</p>
<p>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</p>
<p>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </p>
<p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要自己来实现的，给这个线程局部变量一个初始值吧。</p>
<h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><pre><code>Runnable r[] = new Runnable[2];</code></pre><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc25.jpg" alt=""></p>
<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>  如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>  那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？  在Java中可以通过线程池来达到这样的效果.</p>
<p>  合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<p>下为常见的四种：</p>
<ol>
<li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li>
<li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li>
<li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li>
<li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li>
</ol>
<h4 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h4><blockquote>
<p>阻塞队列提供了可阻塞的入队和出对操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用；</p>
</blockquote>
<p>在Java中，主要有以下类型的阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个支持延时获取元素的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 </li>
</ul>
<h4 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h4><h3 id="JAVA-锁"><a href="#JAVA-锁" class="headerlink" title="JAVA 锁"></a>JAVA 锁</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>  乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为<br>别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数<br>据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），<br>如果失败则要重复读-比较-写的操作。</p>
<p>  java 中的乐观锁基本都是通过 CAS 操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>  悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人<br>会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。<br>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，<br>才会转换为悲观锁，如 RetreenLock。</p>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>  自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁<br>的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>  线程自旋是需要消耗 cpu 的，说白了就是让 cpu 在做无用功，如果一直获取不到锁，那线程<br>也不能一直占用 cpu 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁<br>的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p><strong>自旋锁的优缺点</strong></p>
<p>  自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来<br>说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>  但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合<br>使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p>
<p><strong>自旋锁时间阈值（1.6 引入了适应性自旋锁）</strong></p>
<p>  自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择<br>自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p>
<h5 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h5><p>  synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重<br>入锁</p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>  ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完<br>成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等<br>避免多线程死锁的方法。</p>
<h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><p>  首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有<br>AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，<br>区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所<br>有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。</v></p>
<p>  通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些<br>同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger<br>的性能是 ReentantLock 的好几倍。</p>
<h5 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h5><p>  本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫<br>做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受<br>影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<h5 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h5><p>  为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如<br>果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写<br>锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p>
<p>读锁<br>  如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p>
<p>写锁<br>  如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。<br>总之，读的时候上读锁，写的时候上写锁！<br>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现<br>ReentrantReadWriteLock。</p>
<h5 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h5><p>公平锁（Fair）</p>
<p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁（Nonfair）<br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<ol>
<li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li>
<li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li>
</ol>
<h5 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h5><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<p>独占锁</p>
<p>  独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。<br>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线<br>程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p>共享锁</p>
<p>  共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种<br>乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等<br>待线程的锁获取模式。</li>
<li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，<br>或者被一个 写操作访问，但两者不能同时进行。</li>
</ol>
<h5 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（Mutex Lock）</h5><p>  Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又<br>是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用<br>户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么<br>Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为<br>“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。<br>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和<br>“偏向锁”。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>  锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。<br>锁升级<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，<br>也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，<br>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量<br>级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场<br>景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀<br>为重量级锁。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>  Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线<br>程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起<br>来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级<br>锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换<br>ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所<br>以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻<br>量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进<br>一步提高性能</p>
<h5 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h5><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul>
<li>减少锁持有时间</li>
</ul>
<p>只用在有线程安全要求的程序上加锁</p>
<ul>
<li>减小锁粒度</li>
</ul>
<p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。<br>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是<br>ConcurrentHashMap。</p>
<ul>
<li>锁分离</li>
</ul>
<p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互<br>斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]<br>JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如<br>LinkedBlockingQueue 从头部取出，从尾部放数据</p>
<ul>
<li>锁粗化</li>
</ul>
<p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完<br>公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步<br>和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p>
<ul>
<li>锁消除<br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这<br>些对象的锁操作，多数是因为程序员编码不规范引起</li>
</ul>
<h3 id="虚拟机常用命令"><a href="#虚拟机常用命令" class="headerlink" title="虚拟机常用命令"></a>虚拟机常用命令</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>数组</strong></p>
<ul>
<li>数组作为数据存储结构的缺陷</li>
<li>在无序数组中，搜索是低效的</li>
<li>而在有序数组中插入效率又很低</li>
<li>不管在哪一种数组中删除效率都很低</li>
<li>创建一个数组之后，它的大小又是不可变的</li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>链表是一种有序的列表</li>
<li>链表的内容通常存储与内存中分散的位置上</li>
<li>链表由节点组成，每一个节点的结构都相同</li>
<li>节点分为数据域和链域，数据域是存放节点的内容，链域存放的是下一个节点的指针</li>
</ul>
<h4 id="单向链表（Single-Linked-List）"><a href="#单向链表（Single-Linked-List）" class="headerlink" title="单向链表（Single-Linked List）"></a>单向链表（Single-Linked List）</h4><p>　　单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。</p>
<p>　　单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc20.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc21.png" alt=""></p>
<h3 id="栈-stack-与堆-heap"><a href="#栈-stack-与堆-heap" class="headerlink" title="栈(stack)与堆(heap)"></a>栈(stack)与堆(heap)</h3><p>1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制；</p>
<ol>
<li><p>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中(对象可能在常量池里)（字符串常量对象存放在常量池中。）；</p>
</li>
<li><p>堆：存放所有new出来的对象；</p>
</li>
<li><p>静态域：存放静态成员（static定义的）；</p>
</li>
<li><p>常量池：存放字符串常量和基本类型常量（public static final）。有时，在嵌入式系统中，常量本身会和其他部分分割离开(由于版权等其他原因)，所以在这种情况下，可以选择将其放在ROM中 ；</p>
</li>
<li><p>非RAM存储：硬盘等永久存储空间</p>
</li>
</ol>
<p>堆栈是一种有序表。</p>
<p>堆栈只允许数据自有序列表（前端）作输入、输出操作。<br>堆栈的存取顺序就像手枪的弹夹一样，最先压进去的子弹会被最后打出来<br>具有先进后出FILO（First In Last Out）的特性</p>
<p>堆栈的典型操作</p>
<p>入栈：又称压栈，是指将数据放入堆栈</p>
<p>出栈：将数据从堆栈中取出来</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> obj<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 指向标
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> pointer<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 数组的长度
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 给定一个默认的长度
     */</span>
    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 方法的重载
     *
     * @param size
     */</span>
    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断堆栈是否已经满了
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * 由于指向标的位置是从-1开始的，数组的下标是从0开始的
         */</span>
        <span class="token keyword">return</span> pointer <span class="token operator">==</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 入栈</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * // isFull满的
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空间已满！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 对堆进行扩容</span>
            obj <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">/**
             * // 每次加一
             */</span>
            pointer<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">/**
             * 循环给数组赋值
             */</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            pointer<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 出栈
     *
     * @return
     */</span>
    <span class="token keyword">public</span> Object <span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"栈空间已空！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            Object o <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span><span class="token punctuation">;</span>
            pointer<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> o<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断堆栈是否为空
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * isEmpty空的
         * 如果pointer==-1就返回true
         */</span>
        <span class="token keyword">return</span> pointer <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Stack stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * 出栈
         */</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>主要是两个：队头，队尾</p>
<p>入队：队尾指针向后移动</p>
<p>出队：队头指针向后移动</p>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><h4 id="1-形参与实参"><a href="#1-形参与实参" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h4><h3 id="1-形参与实参-1"><a href="#1-形参与实参-1" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h3><p>我们先来重温一组语法：</p>
<blockquote>
<ol>
<li><p>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</p>
</li>
<li><p>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p>
</li>
</ol>
</blockquote>
<p>举个栗子：</p>
<pre><code>public static void func(int a){
 a=20;
 System.out.println(a);
}
public static void main(String[] args) {
 int a=10;//变量
 func(a);
}</code></pre><p>例子中<br>int a=10;中的a在被调用之前就已经创建并初始化，在调用func方法时，他被当做参数传入，所以这个a是实参。<br>而func(int a)中的a只有在func被调用时它的生命周期才开始，而在func调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p>
<h3 id="2-Java的数据类型"><a href="#2-Java的数据类型" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h3><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p>
<blockquote>
<p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p>
</blockquote>
<p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p>
<blockquote>
<ol>
<li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：</li>
</ol>
<blockquote>
<p>4种整数类型：byte、short、int、long<br>2种浮点数类型：float、double<br>1种字符类型：char<br>1种布尔类型：boolean</p>
</blockquote>
<ol start="2">
<li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：</li>
</ol>
<blockquote>
<p>类<br>接口<br>数组</p>
</blockquote>
</blockquote>
<p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p>
<h3 id="3-JVM内存的划分及职能"><a href="#3-JVM内存的划分及职能" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h3><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznUXxpugnTGGCB8eWHmcg9sjc88CMjoWuagmLTgibGKIJchE6JkC1Plw.jpg" alt=""></p>
<p>有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</p>
<h5 id="1-虚拟机栈"><a href="#1-虚拟机栈" class="headerlink" title="1. 虚拟机栈"></a>1. 虚拟机栈</h5><h5 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h5><h5 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h5><h5 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h5><h5 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h5><p>我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。</p>
<hr>
<blockquote>
<p><strong>1. 虚拟机栈</strong></p>
</blockquote>
<p>虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</p>
<p>栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p>
<p>下图表示了一个Java栈的模型以及栈帧的组成：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzhafOtSl5zaWYfOCzicibCgWQRISwTlEr0Kd1TJj3ibia5mQvb7sTUyVq5A.jpg" alt=""></p>
<p><strong>栈帧</strong>:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>每个栈帧中包括：</p>
<ol>
<li><p><strong>局部变量表</strong>:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</p>
</li>
<li><p><strong>操作数栈</strong>:Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指操作数栈。</p>
</li>
<li><p><strong>指向运行时常量池的引用</strong>:存储程序执行时可能用到常量的引用。</p>
</li>
<li><p><strong>方法返回地址</strong>:存储方法执行完成后的返回地址。</p>
</li>
</ol>
<hr>
<blockquote>
<p><strong>2. 堆：</strong></p>
</blockquote>
<p>堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</p>
<hr>
<blockquote>
<p><strong>3. 方法区：</strong></p>
</blockquote>
<p>方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</p>
<p>方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</p>
<hr>
<blockquote>
<p><strong>4. 本地方法栈：</strong></p>
</blockquote>
<p>本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</p>
<p><strong>有人会疑惑：什么是本地方法？为什么Java还要调用本地方法？</strong></p>
<hr>
<blockquote>
<p><strong>5. 程序计数器：</strong></p>
</blockquote>
<p>线程私有的。<br>记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<hr>
<h3 id="4-数据如何在内存中存储？"><a href="#4-数据如何在内存中存储？" class="headerlink" title="4. 数据如何在内存中存储？"></a>4. 数据如何在内存中存储？</h3><p>从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有三个地方：</p>
<ul>
<li><p>堆</p>
</li>
<li><p>栈</p>
</li>
<li><p>静态方法区</p>
</li>
<li><p>常量区</p>
</li>
</ul>
<p>相应地，每个存储区域都有自己的内存分配策略：</p>
<ul>
<li><p>堆式：</p>
</li>
<li><p>栈式</p>
</li>
<li><p>静态</p>
</li>
</ul>
<p>我们已经知道：Java中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？<br>这里要分以下的情况进行探究：</p>
<blockquote>
<p><strong>1. 基本数据类型的存储：</strong></p>
<ul>
<li><p>A. 基本数据类型的局部变量</p>
</li>
<li><p>B. 基本数据类型的成员变量</p>
</li>
<li><p>C. 基本数据类型的静态变量</p>
</li>
</ul>
<p><strong>2. 引用数据类型的存储</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>1. 基本数据类型的存储</strong></p>
</blockquote>
<hr>
<p>我们分别来研究一下：</p>
<h5 id="A-基本数据类型的局部变量"><a href="#A-基本数据类型的局部变量" class="headerlink" title="A.基本数据类型的局部变量"></a><strong>A.基本数据类型的局部变量</strong></h5><ol>
<li><p>定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的<strong>“虚拟机栈”</strong>，数据本身的值就是存储在栈空间里面。  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznNuHDLtNxibO1b1yN7wV4HPSno4CHZWXaEicootMFec7t31G38HzFpSQ.png" alt=""></p>
</li>
</ol>
<pre><code>如上图，在方法内定义的变量直接存储在栈中，如</code></pre><pre><code>    int age=50;
    int weight=50;
    int grade=6;</code></pre><p>当我们写“int age=50；”，其实是分为两步的：</p>
<pre><code>    int age;//定义变量
    age=50;//赋值</code></pre><p>首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。因此我们可以知道：<br><strong>我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</strong></p>
<p>我们再来看“int weight=50；”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：<strong>栈中的数据在当前线程下是共享的</strong>。</p>
<p>那么如果再执行下面的代码呢？</p>
<pre><code>    weight=40；</code></pre><p>当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。由此可知：</p>
<p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p>
<hr>
<h5 id="B-基本数据类型的成员变量"><a href="#B-基本数据类型的成员变量" class="headerlink" title="B. 基本数据类型的成员变量"></a><strong>B. 基本数据类型的成员变量</strong></h5><p>成员变量：顾名思义，就是在类体中定义的变量。<br>看下图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozziaY24epYoPoM45SJiajF9qCXtupO2539ia0NMKIYUo3yjhFibJ1ZgTvIWg.jpg" alt=""></p>
<p>我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码：</p>
<pre><code>     public class Person{ 2  private int age; 3  private String name; 4  private int grade; 5//篇幅较长，省略setter getter方法 6  static void run(){ 7     System.out.println("run....");  8   }; 9}1011//调用12Person per=new Person();</code></pre><p>同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：<strong>基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</strong></p>
<hr>
<h5 id="C-基本数据类型的静态变量"><a href="#C-基本数据类型的静态变量" class="headerlink" title="C. 基本数据类型的静态变量"></a><strong>C. 基本数据类型的静态变量</strong></h5><p>前面提到<strong>方法区</strong>用来存储一些共享数据，因此<strong>基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</strong></p>
<hr>
<blockquote>
<p><strong>2. 引用数据类型的存储:</strong></p>
</blockquote>
<p>上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</p>
<pre><code>1Person per=new Person();</code></pre><p>实际上，它也是有两个过程：</p>
<pre><code>1Person per;//定义变量2per=new Person();//赋值</code></pre><p>在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：<br><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p>
<h3 id="6-值传递和引用传递"><a href="#6-值传递和引用传递" class="headerlink" title="6. 值传递和引用传递"></a>6. 值传递和引用传递</h3><p>前面已经介绍过形参和实参，也介绍了数据类型以及数据在内存中的存储形式，接下来，就是文章的主题：值传递和引用的传递。</p>
<blockquote>
<p><strong>值传递：</strong><br>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p>
</blockquote>
<p>来看个例子：</p>
<pre><code> 1public static void valueCrossTest(int age,float weight){ 2    System.out.println("传入的age："+age); 3    System.out.println("传入的weight："+weight); 4    age=33; 5    weight=89.5f; 6    System.out.println("方法内重新赋值后的age："+age); 7    System.out.println("方法内重新赋值后的weight："+weight); 8    } 910//测试11public static void main(String[] args) {12        int a=25;13        float w=77.5f;14        valueCrossTest(a,w);15        System.out.println("方法执行后的age："+a);16        System.out.println("方法执行后的weight："+w);17}</code></pre><p>输出结果：</p>
<pre><code>1传入的age：252传入的weight：77.534方法内重新赋值后的age：335方法内重新赋值后的weight：89.567方法执行后的age：258方法执行后的weight：77.5</code></pre><p>从上面的打印结果可以看到：<br>a和w作为实参传入valueCrossTest之后，无论在方法内做了什么操作，最终a和w都没变化。</p>
<p>这是什么造型呢？！！</p>
<p>下面我们根据上面学到的知识点，进行详细的分析：</p>
<p>首先程序运行时，调用mian()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是mian()方法中的局部变量，因此可以断定，a和w是躺着mian方法所在的栈帧中<br>如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozz8YSBg6NLka2h6iamHia5566dpw4dXrpCnfwicnWE0hAADoicyb3dBWWBeg.png" alt=""></p>
<p>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得，如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzicu2h4XZlxSVE3ynyB1pIxaplvHibiazgvFiaFYuvVe8IrRK9U3dk1vxCA.jpg" alt=""></p>
<p>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzf8EMVLtiaMibiaaTxM4aV8ibUZphsG0oHs4qWj3QDHPK6Wia8NBiaQZqXTLQ.jpg" alt=""></p>
<p>也就是说，age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。<br>因此：<br><strong>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</strong></p>
<blockquote>
<p><strong>引用传递：</strong><br>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</p>
</blockquote>
<p>举个栗子：<br>先定义一个对象：</p>
<pre><code> 1public class Person { 2        private String name; 3        private int age; 4 5        public String getName() { 6            return name; 7        } 8        public void setName(String name) { 9            this.name = name;10        }11        public int getAge() {12            return age;13        }14        public void setAge(int age) {15            this.age = age;16        }17}</code></pre><p>我们写个函数测试一下：</p>
<pre><code> 1public static void PersonCrossTest(Person person){ 2        System.out.println("传入的person的name："+person.getName()); 3        person.setName("我是张小龙"); 4        System.out.println("方法内重新赋值后的name："+person.getName()); 5    } 6//测试 7public static void main(String[] args) { 8        Person p=new Person(); 9        p.setName("我是马化腾");10        p.setAge(45);11        PersonCrossTest(p);12        System.out.println("方法执行后的name："+p.getName());13}</code></pre><p>输出结果：</p>
<pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是张小龙</code></pre><p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的<strong>“引用传递”</strong>，对形参的操作，改变了实际对象的内容。</p>
<p>那么，到这里就结题了吗？<br>不是的，没那么简单，<br>能看得到想要的效果<br>是因为刚好选对了例子而已！！！</p>
<p>下面我们对上面的例子稍作修改，加上一行代码，</p>
<pre><code>1public static void PersonCrossTest(Person person){2        System.out.println("传入的person的name："+person.getName());3        person=new Person();//加多此行代码4        person.setName("我是张小龙");5        System.out.println("方法内重新赋值后的name："+person.getName());6    }</code></pre><p>输出结果：</p>
<pre><code>1传入的person的name：我是马化腾2方法内重新赋值后的name：我是张小龙3方法执行后的name：我是马化腾</code></pre><p>`<br>为什么这次的输出和上次的不一样了呢？<br>看出什么问题了吗？</p>
<p>按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时</p>
<pre><code>1Person p=new Person();2        p.setName("我是马化腾");3        p.setAge(45);4        PersonCrossTest(p);</code></pre><p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozztCU4pWxX96C9qiaDiaYSHOjV1Okfm6FIF3H1iciaKvqBTjibGeGnHP0VlsA.jpg" alt=""></p>
<p>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：</p>
<pre><code>1person=new Person();</code></pre><p>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：<strong>引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变</strong>。</p>
<p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p>
<p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p>
<p>由此可见：<strong>引用传递，在Java中并不存在。</strong></p>
<p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p>
<p>这是因为：<strong>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</strong>  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzRTVdZIvztpofveECo4HxchhGmtHX4J6WZLRGcLiatiaDEMHwkyRpwtKg.jpg" alt=""></p>
<p>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p>
<p><strong>p和person都是指向同一个对象</strong>。</p>
<p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p>
<p><strong>p依旧是指向旧的对象，person指向新对象的地址。</strong></p>
<p>所以此时<strong>对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系</strong>。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。<br>只是在传递过程中：</p>
<p><strong>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</strong></p>
<p><strong>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</strong></p>
<h4 id="2-Java的数据类型-1"><a href="#2-Java的数据类型-1" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h4><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p>
<blockquote>
<p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p>
</blockquote>
<p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p>
<blockquote>
<ol>
<li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：<br>4种整数类型：byte、short、int、long<br> 2种浮点数类型：float、double<br> 1种字符类型：char<br> 1种布尔类型：boolean</li>
<li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：<br>类<br> 接口<br> 数组</li>
</ol>
</blockquote>
<p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p>
<h4 id="3-JVM内存的划分及职能-1"><a href="#3-JVM内存的划分及职能-1" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h4><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：</p>
<h3 id="关键字-1"><a href="#关键字-1" class="headerlink" title="关键字"></a>关键字</h3><h4 id="transient-1"><a href="#transient-1" class="headerlink" title="transient"></a>transient</h4><p>先解释下Java中的对象序列化</p>
<p>在讨论transient之前，有必要先搞清楚Java中序列化的含义；</p>
<blockquote>
<p>Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。</p>
</blockquote>
<p>当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p>
<p><strong>关于transient关键字</strong></p>
<p>Java中transient关键字的作用，简单地说，就是让某些被修饰的成员属性变量不被序列化，这一看好像很好理解，就是不被序列化，那么什么情况下，一个对象的某些字段不需要被序列化呢？如果有如下情况，可以考虑使用关键字transient修饰：</p>
<p>1、类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积（示例而已，一般不会这样设计），那么在序列化的时候，面积这个属性就没必要被序列化了；</p>
<p>2、其它，看具体业务需求吧，哪些字段不想被序列化；</p>
<p>PS，记得之前看HashMap源码的时候，发现有个字段是用transient修饰的，我觉得还是有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，modCount都会自增），对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。</p>
<h3 id="System-currentTimeMillis"><a href="#System-currentTimeMillis" class="headerlink" title="System.currentTimeMillis()"></a>System.currentTimeMillis()</h3><p>System位于java.lang包下，有很多可以获取到系统底层的东西：</p>
<p>System类本意就代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
<p>currentTimeMillis方法</p>
<pre><code>public static long currentTimeMillis()</code></pre><p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<p>可以直接把这个方法强制转换成date类型。</p>
<p>代码如下：</p>
<pre><code>long currentTime = System.currentTimeMillis();

SimpleDateFormat formatter = new SimpleDateFormat("yyyy年-MM月dd日-HH时mm分ss秒");

Date date = new Date(currentTime);

System.out.println(formatter.format(date));</code></pre><p>运行结果如下：</p>
<pre><code>当前时间:2017年-12月19日-10时14分28秒</code></pre><p>另：</p>
<p>可获得当前的系统和用户属性：</p>
<pre><code>String osName = System.getProperty(“os.name”);

String user = System.getProperty(“user.name”);

System.out.println(“当前操作系统是：” + osName);

System.out.println(“当前用户是：” + user);
</code></pre><p>System.getProperty 这个方法可以得到很多系统的属性。</p>
<h3 id="jdk1-8新特性学习"><a href="#jdk1-8新特性学习" class="headerlink" title="jdk1.8新特性学习"></a>jdk1.8新特性学习</h3><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是一种运行于服务器端的Java应用程序，具有独立于平台和协议的特性，可以生成动态的Web页面</p>
<p>担当客户请求与服务器响应的中间层 </p>
<p>有特殊的技术规范</p>
<p>必须继承某个特定父类</p>
<p>必须配置之后才能执行</p>
<p>有特定的生命周期</p>
<h3 id="、时间复杂度-amp-amp-空间复杂度"><a href="#、时间复杂度-amp-amp-空间复杂度" class="headerlink" title="、时间复杂度&amp;&amp;空间复杂度"></a>、时间复杂度&amp;&amp;空间复杂度</h3><h3 id="、算法"><a href="#、算法" class="headerlink" title="、算法"></a>、算法</h3><h3 id="、Gc"><a href="#、Gc" class="headerlink" title="、Gc"></a>、Gc</h3><h3 id="各种树"><a href="#各种树" class="headerlink" title="各种树"></a>各种树</h3><h3 id="Map-2"><a href="#Map-2" class="headerlink" title="Map"></a>Map</h3><p><a href="https://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/10/21/2019-02-03-java-she-ji-mo-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="java设计模式">
                        
                        <span class="card-title">java设计模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            单例模式(Singleton Pattern)优点：
(1) 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了
(2) 单例模式可以在系统设置全局的访问
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-10-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/10/21/2019-01-23-mybatis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="Mybatis笔记">
                        
                        <span class="card-title">Mybatis笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Mybatis简介
MyBatis 本是apache的一个开源项目iBatis, MyBatis 是一个高级映射的优秀的持久层orm框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis可以使用简
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-10-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Mybatis/" class="post-category">
                                    Mybatis
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Mybatis/">
                        <span class="chip bg-color">Mybatis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">年份</span>
            <a href="https://flytom.club" target="_blank">FlyTom</a>
            <!-- |&nbsp;Powered by&nbsp;
            
            <a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
             -->
            <!-- 
            
            
             -->
            <!-- 
            <!-- <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span> -->
            <!-- 
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
             -->
            <!-- <br> -->
            <!-- 
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
             -->
            <!-- <br> -->
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis"><!-- 














    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>
 -->
</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->


    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
