<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="SpringBoot笔记, Tom Blog">
    <meta name="description" content="简介微服务什么是微服务 微服务架构就是将单一程序开发成一个微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信，通常是HTTP RESTFUL API。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>SpringBoot笔记 | Tom Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Tom Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Tom Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        SpringBoot笔记
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/SpringBoot/">
                                <span class="chip bg-color">SpringBoot</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Spring系列/" class="post-category">
                                Spring系列
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-08
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                        7.2k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        27 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h4><pre class=" language-java"><code class="language-java"> 微服务架构就是将单一程序开发成一个微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信，通常是HTTP RESTFUL API。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</code></pre>
<h4 id="微服务由来"><a href="#微服务由来" class="headerlink" title="微服务由来"></a>微服务由来</h4><p> 微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。</p>
<h4 id="为什么需要微服务？"><a href="#为什么需要微服务？" class="headerlink" title="为什么需要微服务？"></a>为什么需要微服务？</h4><p> 在传统的IT行业软件大多都是各种独立系统的堆砌，这些系统的问题总结来说就是扩展性差，可靠性不高，维护成本高。到后面引入了SOA服务化，但是，由于 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。最终 SOA 看起来很美，但却成为了企业级奢侈品，中小公司都望而生畏。</p>
<h4 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h4><ol>
<li>将复杂的业务拆分成多个小的业务，每个业务拆分成一个服务，将复杂的问题简单化。利于分工，降低新人的学习成本。 </li>
<li>微服务系统是分布式系统，业务与业务之间完全解耦，随着业务的增加可以根据业务再拆分，具有极强的横向扩展能力。面对搞并发的场景可以将服务集群化部署，加强系统负载能力。 </li>
<li>服务间采用HTTP协议通信，服务与服务之间完全独立。每个服务可以根据业务场景选取合适的编程语言和数据库。 </li>
<li>微服务每个服务都是独立部署的，每个服务的修改和部署对其他服务没有影响。</li>
</ol>
<h4 id="微服务和SOA的关系"><a href="#微服务和SOA的关系" class="headerlink" title="微服务和SOA的关系"></a>微服务和SOA的关系</h4><p>SOA即面向服务的架构，SOA是根据企业服务总线（ESB）模式来整合集成大量单一庞大的系统，微服务可以说是SOA的一种实现，将复杂的业务组件化。但它比ESB实现的SOA更加的轻便敏捷和简单。</p>
<h2 id="Spring-Boot简介"><a href="#Spring-Boot简介" class="headerlink" title="Spring Boot简介"></a>Spring Boot简介</h2><p>随着使用 Spring 进行开发的个人和企业越来越多，Spring 也慢慢从一个单一简洁的小框架变成一个大而全的开源软件，Spring 的边界不断进行扩充，到了后来 Spring 几乎可以做任何事情，市面上主流的开源软件、中间件都有 Spring 对应组件支持，人们在享用 Spring 的便利之后，也遇到了一些问题。</p>
<p>2013 年，微服务的概念也慢慢兴起，快速开发微小独立的应用变得更为急迫，Spring刚好处在这样一个交叉点上，于 2013 年初启动了 Spring Boot 项目的研发。2014 年，Spring Boot 伴随着 Spring 4.0 诞生发布了第一个正式版本。</p>
<p>Spring Boot 并不是要成为 Spring 平台里面众多“Foundation”层项目的替代者。Spring Boot 的目标不在于为已解决的问题域提供新的解决方案，而是为平台带来另一种开发体验，从而简化对这些已有技术的使用。对于已经熟悉 Spring 生态系统的开发人员来说，Spring Boot 是一个很理想的选择；对于采用 Spring 技术的新人来说，Spring Boot 提供一种更简洁的方式来使用这些技术。</p>
<h3 id="Spring-Boot-的主要优点："><a href="#Spring-Boot-的主要优点：" class="headerlink" title="Spring Boot 的主要优点："></a>Spring Boot 的主要优点：</h3><ul>
<li>为所有 Spring 开发者更快的入门</li>
<li>开箱即用，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器Tomcat<code></code>Jetty`简化 Web 项目</li>
<li>简化 XML 配置</li>
</ul>
<p>嵌入式<code>Tomcat</code>、<code>Jetty</code>、 <code>Undertow</code>容器（无需部署war文件）。</p>
<p>提供的<code>starters</code> 简化构建配置</p>
<p>尽可能自动配置<code>spring</code>应用。</p>
<p>提供生产指标,例如指标、健壮检查和外部化配置</p>
<p>完全没有代码生成和<code>XML</code>配置要求</p>
<p> 简言之，Spring Boot 是一个快速开发的框架,能够快速的整合第三方框架，简化 XML 配置，全部采用注解形式，内置 Tomcat 容器,帮助开发者能够实现快速开发，简化了应用系统的初始搭建以及开发过程。</p>
<p>常用的springboot starter项目依赖包，如果你要使用相应功能，只要加入相应的starter名称到pom.xml中即可，如果需要使用到配置或数据库连接，也只要在项目的application.properties或yaml中配置即可，项目启动时会自动在类路径中发现这两个配置文件并读取配置内容注入相应的类中。</p>
<p>spring-boot-starter-web-services: SOAP Web Services</p>
<p>spring-boot-starter-web: Web 和 RESTful 应用，这是默认常用的</p>
<p>spring-boot-starter-test:单元测试和集成测试，默认引用。</p>
<p>spring-boot-starter-jdbc: 传统 JDBC</p>
<p>spring-boot-starter-hateoas: 增加 HATEOAS 特性到服务。</p>
<p>spring-boot-starter-security: 使用spring安全实现验证和授权。</p>
<p>spring-boot-starter-data-jpa: Spring Data JPA with Hibernate</p>
<p>spring-boot-starter-cache: 激活 Spring Framework的缓存支持</p>
<p>spring-boot-starter-data-rest: 使用 Spring Data REST暴露简单的 REST 服务，</p>
<h2 id="与其他框架的区别"><a href="#与其他框架的区别" class="headerlink" title="与其他框架的区别"></a>与其他框架的区别</h2><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring，因此该框架所具备的功能，是为了让人们更容易的使用 Spring。所以说没有 Spring 强大的功能和生态，就不会有后期 Spring Boot 的火热，Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。</p>
<h3 id="SpringBoot-和-Spring区别"><a href="#SpringBoot-和-Spring区别" class="headerlink" title="SpringBoot 和 Spring区别"></a>SpringBoot 和 Spring区别</h3><h4 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h4><p>  作为<code>Java</code>开发人员，大家都<code>Spring</code>都不陌生，简而言之，<code>Spring</code>框架为开发<code>Java</code>应用程序提供了全面的基础架构支持。它包含一些很好的功能，如依赖注入和开箱即用的模块，如：<code>Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test</code>，这些模块缩短应用程序的开发时间，提高了应用开发的效率例如，在<code>Java Web</code>开发的早期阶段，我们需要编写大量的代码来将记录插入到数据库中。但是通过使用<code>Spring JDBC</code>模块的<code>JDBCTemplate</code>，我们可以将操作简化为几行代码。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><blockquote>
<p> 简而言之，我们可以说<code>Spring Boot</code>只是<code>Spring</code>本身的扩展，使开发，测试和部署更加方便。</p>
</blockquote>
<h3 id="Spring-和-SpringMVC"><a href="#Spring-和-SpringMVC" class="headerlink" title="Spring 和 SpringMVC"></a><strong>Spring 和 SpringMVC</strong></h3><p>Spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；</p>
<p>SpringMVC是Spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于Spring框架中WEB层开发的一部分；</p>
<h3 id="SpringBoot-和-SpringMVC-区别"><a href="#SpringBoot-和-SpringMVC-区别" class="headerlink" title="SpringBoot 和 SpringMVC 区别"></a>SpringBoot 和 SpringMVC 区别</h3><p>SpringBoot 是一个快速开发的框架,能够快速的整合第三方框架，简化 XML 配置，全部采用注解形式，内<br>嵌 Tomcat 容器,帮助开发者能够实现快速开发。SpringMVC 是一个封装了 Servlet API 的 MVC 框架，就像<br>其它的 MVC 框架，比如 Struts 一样负责处理 web 请求。SpringBoot 的 Web 组件默认集成的是 SpringMVC<br>框架。SpringMVC 通常被叫做控制层框架。</p>
<h3 id="SpringBoot-和-SpringCloud-区别"><a href="#SpringBoot-和-SpringCloud-区别" class="headerlink" title="SpringBoot 和 SpringCloud 区别"></a>SpringBoot 和 SpringCloud 区别</h3><p>SpringCloud 依赖于 SpringBoot 组件，或者说 Spring Cloud 构建于 Spring Boot 之上。它为微服务中涉及的<br>配置管理、服务治理、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理通<br>常我们使用 SpringMVC 编写 http 协议接口，同时使用 SpringCloud 作为一套完整的微服务解决框架。</p>
<h2 id="Spring-Boot-的核心：约定优于配置"><a href="#Spring-Boot-的核心：约定优于配置" class="headerlink" title="Spring Boot 的核心：约定优于配置"></a>Spring Boot 的核心：约定优于配置</h2><p>那么什么是约定优于配置呢？</p>
<p>约定优于配置（Convention Over Configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量、获得简单的好处，而又不失灵活性。</p>
<p>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为“user_info”，才需写有关这个名字的配置。</p>
<p>我们可以按照这个思路来设想，我们约定 Controller 层就是 Web 请求层可以省略 MVC 的配置；我们约定在 Service 结尾的类自动注入事务，就可以省略了 Spring 的切面事务配置。</p>
<p>在 Spring 体系中，Spring Boot JPA 就是约定优于配置最佳实现之一，不需要关注表结构，我们约定类名即是表名，属性名即是表的字段，String 对应 varchar，long 对应 bigint，只有需要一些特殊要求的属性，我们再单独进行配置，按照这个约定我们可以将以前的工作大大简化。</p>
<p>Spring Boot 体系将约定优于配置的思想展现得淋漓尽致，小到配置文件、中间件的默认配置，大到内置容器、生态中的各种 Starters 无不遵循此设计规则。Spring Boot 鼓励各软件组织方创建自己的 Starter，创建 Starter 的核心组件之一就是 autoconfigure 模块，也是 Starter 的核心功能，在启动的时候进行自动装配，属性默认化配置。</p>
<p>可以说正是因为 Spring Boot 简化的配置和众多的 Starters 才让 Spring Boot 变得简单、易用、快速上手，也可以说正是约定优于配置的思想彻底落地才让 Spring Boot 走向辉煌。Spring Boot 约定优于配置的思想让 Spring Boot 项目非常容易上手，让编程变得更简单，其实编程本该很简单，简单才是编程的美。</p>
<h2 id="Spring-Boot-2-0-都更新了什么"><a href="#Spring-Boot-2-0-都更新了什么" class="headerlink" title="Spring Boot 2.0 都更新了什么"></a>Spring Boot 2.0 都更新了什么</h2><p>2018 年 3 月 1 号 Spring Boot 2.0.0.RELEASE 正式发布，这是 Spring Boot 1.0 发布 4 年之后第一次重大修订，因此有多新功能和特性值得关注！在 Spring Boot 官方博客中我们了解到：Spring Boot 2.0 版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。</p>
<p>我们将 Spring Boot 2.0 更新的技术分为三类进行解读：</p>
<p>第一类，基础环境升级；<br><br>第二类，默认软件替换和优化；<br><br>第三类，新技术的引入。<br><br>基础环境升级<br><br>最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7<br><br>Spring Boot 2.0 要求 Java 8 作为最低版本，许多现有的 API 已更新，以利用 Java 8 的特性。例如，接口上的默认方法，函数回调以及新的 API，如 javax.time。如果你正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，需要升级你的 JDK。</p>
<p>Spring Boot 2.0 通过测试可以在 JDK 9 下正常运行，同时 Spring Boot 2.0 宣布不再支持 Java 6 和 7，据我了解国内绝大部分互联网公司的基本环境还在 JDK 7 或者 6 环境下运行，考虑升级 Spring Boot 2.0 的团队需要考虑这个因素。</p>
<p>依赖组件升级<br><br>Spring Boot 2.0 基于 Spring Framework 5 构建，本次 Spring Boot 的升级，同时也升级了部分其依赖的第三方组件，主要有以下几个：</p>
<ul>
<li>Jetty 9.4，Jetty 是一个开源的 Servlet 容器，它为基于 Java 的 Web 内容，例如 JSP 和 Servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。</li>
<li>Tomcat 8.5，Apache Tomcat 8.5.x 旨在取代 8.0.x，完全支持 Java 9。</li>
<li>Flyway 5，Flyway 是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway 可以像 SVN 管理不同人的代码那样，管理不同人的 SQL 脚本，从而做到数据库同步。</li>
<li>Hibernate 5.2，Hibernate 是一款非常流行的 ORM 框架。</li>
<li>Gradle 3.4，Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。</li>
<li>Thymeleaf 3.0，Thymeleaf 3 相对于 Thymeleaf 2 有非常大的性能提升。</li>
</ul>
<h2 id="SpringBoot-源码常用注解拾遗"><a href="#SpringBoot-源码常用注解拾遗" class="headerlink" title="SpringBoot 源码常用注解拾遗"></a>SpringBoot 源码常用注解拾遗</h2><h3 id="组合注解"><a href="#组合注解" class="headerlink" title="组合注解"></a>组合注解</h3><p>当可能大量同时使用到几个注解到同一个类上，就可以考虑将这几个注解到别的注解上。被注解的注解我们就称之为组合注解。</p>
<ul>
<li><p>元注解：可以注解到别的注解上的注解。</p>
</li>
<li><p>组合注解：被注解的注解我们就称之为组合注解。</p>
</li>
</ul>
<h3 id="Value-【Spring-提供】"><a href="#Value-【Spring-提供】" class="headerlink" title="@Value 【Spring 提供】"></a>@Value 【Spring 提供】</h3><p>@Value 就相当于传统 xml 配置文件中的 value 字段。</p>
<p>假设存在代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> 

<span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"i am name"</span><span class="token punctuation">)</span> 
<span class="token keyword">private</span> String name<span class="token punctuation">;</span> 

<span class="token punctuation">}</span> </code></pre>
<p>上面代码等价于的配置文件：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 
    &lt;property name ="name" value="i am name"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span> 
</code></pre>
<p>我们知道配置文件中的 value 的取值可以是：</p>
<ul>
<li><p>字面量</p>
</li>
<li><p>通过 <code>${key}</code> 方式从环境变量中获取值</p>
</li>
<li><p>通过 <code>${key}</code> 方式全局配置文件中获取值</p>
</li>
<li><p><code>#{SpEL}</code></p>
</li>
</ul>
<p>所以，我们就可以通过 <code>@Value(${key})</code> 的方式获取全局配置文件中的指定配置项。</p>
<h3 id="ConfigurationProperties-【SpringBoot-提供】"><a href="#ConfigurationProperties-【SpringBoot-提供】" class="headerlink" title="@ConfigurationProperties 【SpringBoot 提供】"></a>@ConfigurationProperties 【SpringBoot 提供】</h3><p>如果我们需要取 N 个配置项，通过 <code>@Value</code> 的方式去配置项需要一个一个去取，这就显得有点 low 了。我们可以使用 <code>@ConfigurationProperties</code>。</p>
<p>标有 <code>@ConfigurationProperties</code> 的类的所有属性和配置文件中相关的配置项进行绑定。（默认从全局配置文件中获取配置值），绑定之后我们就可以通过这个类去访问全局配置文件中的属性值了。</p>
<p>下面看一个实例：</p>
<p>1.在主配置文件中添加如下配置</p>
<pre class=" language-xml"><code class="language-xml">person.name=kundy
person.age=13
person.sex=male</code></pre>
<p>2.创建配置类，由于篇幅问题这里省略了 setter、getter 方法，但是实际开发中这个是必须的，否则无法成功注入。另外，@Component 这个注解也还是需要添加的。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span> 
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> 

<span class="token keyword">private</span> String name<span class="token punctuation">;</span> 
<span class="token keyword">private</span> Integer age<span class="token punctuation">;</span> 
<span class="token keyword">private</span> String sex<span class="token punctuation">;</span> 

<span class="token punctuation">}</span> </code></pre>
<p>这里 <code>@ConfigurationProperties</code> 有一个 prefix 参数，主要是用来指定该配置项在配置文件中的前缀。</p>
<p>3.测试，在 SpringBoot 环境中，编写个测试方法，注入 Person 类，即可通过 Person 对象取到配置文件的值。</p>
<h3 id="Import-【Spring-提供】"><a href="#Import-【Spring-提供】" class="headerlink" title="@Import 【Spring 提供】"></a>@Import 【Spring 提供】</h3><p>@Import 注解支持导入普通 java 类，并将其声明成一个bean。主要用于将多个分散的 java config 配置类融合成一个更大的 config 类。</p>
<ul>
<li><p>@Import 注解在 4.2 之前只支持导入配置类。</p>
</li>
<li><p>在4.2之后 @Import 注解支持导入普通的 java 类,并将其声明成一个 bean。</p>
</li>
</ul>
<p><strong>@Import 三种使用方式</strong></p>
<ul>
<li><p>直接导入普通的 Java 类。</p>
</li>
<li><p>配合自定义的 ImportSelector 使用。</p>
</li>
<li><p>配合 ImportBeanDefinitionRegistrar 使用。</p>
</li>
</ul>
<h4 id="1-直接导入普通的-Java-类"><a href="#1-直接导入普通的-Java-类" class="headerlink" title="1. 直接导入普通的 Java 类"></a>1. 直接导入普通的 Java 类</h4><p>1.创建一个普通的 Java 类。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span> 

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Circle sayHi()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

<span class="token punctuation">}</span> </code></pre>
<p>2.创建一个配置类，里面没有显式声明任何的 Bean，然后将刚才创建的 Circle 导入。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Circle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@Configuration</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfig</span> <span class="token punctuation">{</span> 

<span class="token punctuation">}</span> </code></pre>
<p>3.创建测试类。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 

ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
Circle circle <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Circle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
circle<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token punctuation">}</span> </code></pre>
<p>4.运行结果：</p>
<pre><code>&gt; Circle sayHi()</code></pre><p>可以看到我们顺利的从 IOC 容器中获取到了 Circle 对象，证明我们在配置类中导入的 Circle 类，确实被声明为了一个 Bean。</p>
<h4 id="2-配合自定义的-ImportSelector-使用"><a href="#2-配合自定义的-ImportSelector-使用" class="headerlink" title="2. 配合自定义的 ImportSelector 使用"></a>2. 配合自定义的 ImportSelector 使用</h4><p>ImportSelector 是一个接口，该接口中只有一个 selectImports 方法，用于返回全类名数组。所以利用该特性我们可以给容器动态导入 N 个 Bean。</p>
<p>1.创建普通 Java 类 Triangle。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Triangle</span> <span class="token punctuation">{</span> 

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Triangle sayHi()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token punctuation">}</span></code></pre>
<p>2.创建 ImportSelector 实现类，selectImports 返回 Triangle 的全类名。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">{</span> 

<span class="token annotation punctuation">@Override</span> 
<span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"annotation.importannotation.waytwo.Triangle"</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token punctuation">}</span> </code></pre>
<p>3.创建配置类，在原来的基础上还导入了 MyImportSelector。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Circle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>MyImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@Configuration</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigTwo</span> <span class="token punctuation">{</span> 

<span class="token punctuation">}</span> </code></pre>
<p>4.创建测试类</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 

ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigTwo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
Circle circle <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Circle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
Triangle triangle <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Triangle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
circle<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
triangle<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token punctuation">}</span> </code></pre>
<p>5.运行结果：</p>
<pre><code>&gt; Circle sayHi()  
&gt; Triangle sayHi()</code></pre><p>可以看到 Triangle 对象也被 IOC 容器成功的实例化出来了。</p>
<h4 id="3-配合-ImportBeanDefinitionRegistrar-使用"><a href="#3-配合-ImportBeanDefinitionRegistrar-使用" class="headerlink" title="3. 配合 ImportBeanDefinitionRegistrar 使用"></a>3. 配合 ImportBeanDefinitionRegistrar 使用</h4><p>ImportBeanDefinitionRegistrar 也是一个接口，它可以手动注册bean到容器中，从而我们可以对类进行个性化的定制。(需要搭配 @Import 与 @Configuration 一起使用。）</p>
<p>1.创建普通 Java 类 Rectangle。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span> 

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Rectangle sayHi()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

<span class="token punctuation">}</span></code></pre>
<p>2.创建 ImportBeanDefinitionRegistrar 实现类，实现方法直接手动注册一个名叫 rectangle 的 Bean 到 IOC 容器中。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyImportBeanDefinitionRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">{</span> 

<span class="token annotation punctuation">@Override</span> 
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">,</span> BeanDefinitionRegistry beanDefinitionRegistry<span class="token punctuation">)</span> <span class="token punctuation">{</span> 

RootBeanDefinition rootBeanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>Rectangle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 注册一个名字叫做 rectangle 的 bean </span>
beanDefinitionRegistry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"rectangle"</span><span class="token punctuation">,</span> rootBeanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 

<span class="token punctuation">}</span></code></pre>
<p>3.创建配置类，导入 MyImportBeanDefinitionRegistrar 类。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Circle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MyImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> MyImportBeanDefinitionRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@Configuration</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainConfigThree</span> <span class="token punctuation">{</span> 

<span class="token punctuation">}</span> </code></pre>
<p>4.创建测试类。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>MainConfigThree<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    Circle circle <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Circle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    Triangle triangle <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Triangle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    Rectangle rectangle <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Rectangle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    circle<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    triangle<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    rectangle<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> </code></pre>
<p>5.运行结果</p>
<pre><code>&gt; Circle sayHi()  
&gt; Triangle sayHi()  
&gt; Rectangle sayHi()</code></pre><p>嗯对，Rectangle 对象也被注册进来了。</p>
<h3 id="Conditional-【Spring提供】"><a href="#Conditional-【Spring提供】" class="headerlink" title="@Conditional 【Spring提供】"></a>@Conditional 【Spring提供】</h3><blockquote>
<p>@Conditional 注释可以实现只有在特定条件满足时才启用一些配置。</p>
</blockquote>
<p>下面看一个简单的例子：</p>
<p>1.创建普通 Java 类 ConditionBean，该类主要用来验证 Bean 是否成功加载。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionBean</span> <span class="token punctuation">{</span> 

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConditionBean sayHi()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

<span class="token punctuation">}</span> </code></pre>
<p>2.创建 Condition 实现类，@Conditional 注解只有一个 Condition 类型的参数，Condition 是一个接口，该接口只有一个返回布尔值的 matches() 方法，该方法返回 true 则条件成立，配置类生效。反之，则不生效。在该例子中我们直接返回 true。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCondition</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span> <span class="token punctuation">{</span> 

    <span class="token annotation punctuation">@Override</span> 
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span>ConditionContext conditionContext<span class="token punctuation">,</span> AnnotatedTypeMetadata annotatedTypeMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

<span class="token punctuation">}</span> </code></pre>
<p>3.创建配置类，可以看到该配置的 @Conditional 传了我们刚才创建的 Condition 实现类进去，用作条件判断。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span> 
<span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span>MyCondition<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionConfig</span> <span class="token punctuation">{</span> 

    <span class="token annotation punctuation">@Bean</span> 
    <span class="token keyword">public</span> ConditionBean <span class="token function">conditionBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

<span class="token punctuation">}</span> </code></pre>
<p>4.编写测试方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 

    ApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>ConditionConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    ConditionBean conditionBean <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>ConditionBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    conditionBean<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token punctuation">}</span> </code></pre>
<p>5.结果分析</p>
<p>因为 Condition 的 matches 方法直接返回了 true，配置类会生效，我们可以把 matches 改成返回 false，则配置类就不会生效了。</p>
<p>除了自定义 Condition，Spring 还为我们扩展了一些常用的 Condition。常用注解，可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247488634&amp;idx=1&amp;sn=b62b98d0c545aec50a2e1f5b25963059&amp;chksm=ebd62b56dca1a240e03125436df7a7cf2232364ac7116ea3f2639e198606ac46b6688877e247&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解Spring中的各种注解</a></p>
<hr>
<h2 id="SpringBoot-启动过程"><a href="#SpringBoot-启动过程" class="headerlink" title="SpringBoot 启动过程"></a>SpringBoot 启动过程</h2><p>在看源码的过程中，我们会看到以下四个类的方法经常会被调用，我们需要对一下几个类有点印象：</p>
<ul>
<li><p>ApplicationContextInitializer</p>
</li>
<li><p>ApplicationRunner</p>
</li>
<li><p>CommandLineRunner</p>
</li>
<li><p>SpringApplicationRunListener</p>
</li>
</ul>
<p>下面开始源码分析，先从 SpringBoot 的启动类的 run() 方法开始看，以下是调用链：<code>SpringApplication.run() -&gt; run(new Class[]{primarySource}, args) -&gt; new SpringApplication(primarySources)).run(args)</code>。</p>
<p>一直在run，终于到重点了，我们直接看 <code>new SpringApplication(primarySources)).run(args)</code> 这个方法。</p>
<p>上面的方法主要包括两大步骤：</p>
<ul>
<li><p>创建 SpringApplication 对象。</p>
</li>
<li><p>运行 run() 方法。</p>
</li>
</ul>
<h3 id="创建-SpringApplication-对象"><a href="#创建-SpringApplication-对象" class="headerlink" title="创建 SpringApplication 对象"></a>创建 SpringApplication 对象</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">SpringApplication</span><span class="token punctuation">(</span>ResourceLoader resourceLoader<span class="token punctuation">,</span> Class<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> primarySources<span class="token punctuation">)</span> <span class="token punctuation">{</span> 

<span class="token keyword">this</span><span class="token punctuation">.</span>sources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>bannerMode <span class="token operator">=</span> Mode<span class="token punctuation">.</span>CONSOLE<span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>addCommandLineProperties <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>addConversionService <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>headless <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>registerShutdownHook <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>additionalProfiles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>isCustomEnvironment <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span>resourceLoader <span class="token operator">=</span> resourceLoader<span class="token punctuation">;</span> 
Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">,</span> <span class="token string">"PrimarySources must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 保存主配置类（这里是一个数组，说明可以有多个主配置类） </span>
<span class="token keyword">this</span><span class="token punctuation">.</span>primarySources <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>primarySources<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 判断当前是否是一个 Web 应用 </span>
<span class="token keyword">this</span><span class="token punctuation">.</span>webApplicationType <span class="token operator">=</span> WebApplicationType<span class="token punctuation">.</span><span class="token function">deduceFromClasspath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationContextInitializer，然后保存起来 </span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setInitializers</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>ApplicationContextInitializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationListener，然后保存起来 </span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setListeners</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>ApplicationListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 从多个配置类中找到有 main 方法的主配置类（只有一个） </span>
<span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deduceMainApplicationClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token punctuation">}</span> </code></pre>
<h3 id="运行-run-方法"><a href="#运行-run-方法" class="headerlink" title="运行 run() 方法"></a>运行 run() 方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ConfigurableApplicationContext <span class="token function">run</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> 

<span class="token comment" spellcheck="true">// 创建计时器 </span>
StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 声明 IOC 容器 </span>
ConfigurableApplicationContext context <span class="token operator">=</span> null<span class="token punctuation">;</span> 
Collection<span class="token operator">&lt;</span>SpringBootExceptionReporter<span class="token operator">></span> exceptionReporters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 从类路径下找到 META/INF/Spring.factories 获取 SpringApplicationRunListeners </span>
SpringApplicationRunListeners listeners <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 回调所有 SpringApplicationRunListeners 的 starting() 方法 </span>
listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
Collection exceptionReporters<span class="token punctuation">;</span> 
<span class="token keyword">try</span> <span class="token punctuation">{</span> 
<span class="token comment" spellcheck="true">// 封装命令行参数 </span>
ApplicationArguments applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 准备环境，包括创建环境，创建环境完成后回调 SpringApplicationRunListeners#environmentPrepared()方法，表示环境准备完成 </span>
ConfigurableEnvironment environment <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configureIgnoreBeanInfo</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 打印 Banner </span>
Banner printedBanner <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 创建 IOC 容器（决定创建 web 的 IOC 容器还是普通的 IOC 容器） </span>
context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
exceptionReporters <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span>SpringBootExceptionReporter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>ConfigurableApplicationContext<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">/*

- 准备上下文环境，将 environment 保存到 IOC 容器中，并且调用 applyInitializers() 方法
- applyInitializers() 方法回调之前保存的所有的 ApplicationContextInitializer 的 initialize() 方法
- 然后回调所有的 SpringApplicationRunListener#contextPrepared() 方法 
- 最后回调所有的 SpringApplicationRunListener#contextLoaded() 方法 
  */</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareContext</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">// 刷新容器，IOC 容器初始化（如果是 Web 应用还会创建嵌入式的 Tomcat），扫描、创建、加载所有组件的地方 </span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">// 从 IOC 容器中获取所有的 ApplicationRunner 和 CommandLineRunner 进行回调 </span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> 
  <span class="token comment" spellcheck="true">// 调用 所有 SpringApplicationRunListeners#started()方法 </span>
  listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callRunners</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var10<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> var10<span class="token punctuation">,</span> exceptionReporters<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>var10<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> 
  <span class="token keyword">try</span> <span class="token punctuation">{</span> 
  listeners<span class="token punctuation">.</span><span class="token function">running</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">return</span> context<span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var9<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> var9<span class="token punctuation">,</span> exceptionReporters<span class="token punctuation">,</span> <span class="token punctuation">(</span>SpringApplicationRunListeners<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>var9<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span> 
  <span class="token punctuation">}</span> </code></pre>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>run() 阶段主要就是回调本节开头提到过的4个监听器中的方法与加载项目中组件到 IOC 容器中，而所有需要回调的监听器都是从类路径下的 META/INF/Spring.factories 中获取，从而达到启动前后的各种定制操作。</p>
<hr>
<h2 id="SpringBoot-自动配置原理"><a href="#SpringBoot-自动配置原理" class="headerlink" title="SpringBoot 自动配置原理"></a>SpringBoot 自动配置原理</h2><h3 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h3><p>SpringBoot 项目的一切都要从 @SpringBootApplication 这个注解开始说起。</p>
<p>@SpringBootApplication 标注在某个类上说明：</p>
<ul>
<li><p>这个类是 SpringBoot 的主配置类。</p>
</li>
<li><p>SpringBoot 就应该运行这个类的 main 方法来启动 SpringBoot 应用。</p>
</li>
</ul>
<p>该注解的定义如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootConfiguration</span> 
<span class="token annotation punctuation">@EnableAutoConfiguration</span> 
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span> 
excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span> 
type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> 
classes <span class="token operator">=</span> <span class="token punctuation">{</span>TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span> 
<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span> 
type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> 
classes <span class="token operator">=</span> <span class="token punctuation">{</span>AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span> 
<span class="token punctuation">)</span><span class="token punctuation">}</span> 
<span class="token punctuation">)</span> 
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span> 

<span class="token punctuation">}</span></code></pre>
<p>可以看到 SpringBootApplication 注解是一个组合注解（关于组合注解文章的开头有讲到），其主要组合了一下三个注解：</p>
<ul>
<li><p>@SpringBootConfiguration：该注解表示这是一个 SpringBoot 的配置类，其实它就是一个 @Configuration 注解而已。</p>
</li>
<li><p>@ComponentScan：开启组件扫描。</p>
</li>
<li><p>@EnableAutoConfiguration：从名字就可以看出来，就是这个类开启自动配置的。嗯，自动配置的奥秘全都在这个注解里面。</p>
</li>
</ul>
<h3 id="EnableAutoConfiguration-注解"><a href="#EnableAutoConfiguration-注解" class="headerlink" title="@EnableAutoConfiguration 注解"></a>@EnableAutoConfiguration 注解</h3><p>先看该注解是怎么定义的：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigurationPackage</span> 
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span> 
<span class="token punctuation">}</span></code></pre>
<p><strong>@AutoConfigurationPackage</strong></p>
<p>从字面意思理解就是自动配置包。点进去可以看到就是一个 @Import 注解：<code>@Import({Registrar.class})</code>，导入了一个 Registrar 的组件。关于 @Import 的用法文章上面也有介绍哦。</p>
<p>我们在 Registrar 类中的 registerBeanDefinitions 方法上打上断点，可以看到返回了一个包名，该包名其实就是主配置类所在的包。</p>
<p>一句话：@AutoConfigurationPackage 注解就是<strong>将主配置类（@SpringBootConfiguration标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器中</strong>。所以说，默认情况下主配置类包及子包以外的组件，Spring 容器是扫描不到的。</p>
<h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h3><p>该注解给当前配置类导入另外的 N 个自动配置类。（该注解详细用法上文有提及）。</p>
<p><strong>配置类导入规则</strong></p>
<p>那具体的导入规则是什么呢？我们来看一下源码。在开始看源码之前，先啰嗦两句。就像小马哥说的，我们看源码不用全部都看，不用每一行代码都弄明白是什么意思，我们只要抓住关键的地方就可以了。</p>
<p>我们知道 AutoConfigurationImportSelector 的 selectImports 就是用来返回需要导入的组件的全类名数组的，那么如何得到这些数组呢？</p>
<p>在 selectImports 方法中调用了一个 getAutoConfigurationEntry() 方法。</p>
<p>调用链：在 <code>getAutoConfigurationEntry() -&gt; getCandidateConfigurations() -&gt; loadFactoryNames()</code>。</p>
<p>在这里 <code>loadFactoryNames()</code> 方法传入了 EnableAutoConfiguration.class 这个参数。先记住这个参数，等下会用到。</p>
<p>loadFactoryNames() 中关键的三步：</p>
<ul>
<li><p>从当前项目的类路径中获取所有 META-INF/spring.factories 这个文件下的信息。</p>
</li>
<li><p>将上面获取到的信息封装成一个 Map 返回。</p>
</li>
<li><p>从返回的 Map 中通过刚才传入的 EnableAutoConfiguration.class 参数，获取该 key 下的所有值。</p>
</li>
</ul>
<p><strong>META-INF/spring.factories 探究</strong></p>
<p>听我这样说完可能会有点懵，我们来看一下 <code>META-INF/spring.factories</code> 这类文件是什么就不懵了。当然在很多第三方依赖中都会有这个文件，一般每导入一个第三方的依赖，除了本身的jar包以外，还会有一个 xxx-spring-boot-autoConfigure，这个就是第三方依赖自己编写的自动配置类。我们现在就以 spring-boot-autocongigure 这个依赖来说。</p>
<p>可以看到 EnableAutoConfiguration 下面有很多类，这些就是我们项目进行自动配置的类。</p>
<p>一句话：将类路径下 META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到 Spring 容器中。</p>
<p><strong>HttpEncodingAutoConfiguration</strong></p>
<p>通过上面方式，所有的自动配置类就被导进主配置类中了。但是这么多的配置类，明显有很多自动配置我们平常是没有使用到的，没理由全部都生效吧。</p>
<p>接下来我们以 HttpEncodingAutoConfiguration为例来看一个自动配置类是怎么工作的。为啥选这个类呢？主要是这个类比较的简单典型。</p>
<p>先看一下该类标有的注解：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span> <span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span>HttpProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token punctuation">(</span> type <span class="token operator">=</span> Type<span class="token punctuation">.</span>SERVLET <span class="token punctuation">)</span> <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span> 
    prefix <span class="token operator">=</span> <span class="token string">"spring.http.encoding"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"enabled"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpEncodingAutoConfiguration</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre>
<ul>
<li><p><strong>@Configuration：</strong>标记为配置类。</p>
</li>
<li><p><strong>@ConditionalOnWebApplication：</strong>web应用下才生效。</p>
</li>
<li><p><strong>@ConditionalOnClass：</strong>指定的类（依赖）存在才生效。</p>
</li>
<li><p><strong>@ConditionalOnProperty：</strong>主配置文件中存在指定的属性才生效。</p>
</li>
<li><p><strong>@EnableConfigurationProperties({HttpProperties.class})：</strong>启动指定类的ConfigurationProperties功能；将配置文件中对应的值和 HttpProperties 绑定起来；并把 HttpProperties 加入到 IOC 容器中。</p>
</li>
</ul>
<p>因为 <code>@EnableConfigurationProperties({HttpProperties.class})</code>把配置文件中的配置项与当前 HttpProperties 类绑定上了。</p>
<p>然后在 HttpEncodingAutoConfiguration 中又引用了 HttpProperties ，所以最后就能在 HttpEncodingAutoConfiguration 中使用配置文件中的值了。</p>
<p>最终通过 @Bean 和一些条件判断往容器中添加组件，实现自动配置。（当然该Bean中属性值是从 HttpProperties 中获取）</p>
<p><strong>HttpProperties</strong></p>
<p>HttpProperties 通过 @ConfigurationProperties 注解将配置文件与自身属性绑定。</p>
<p>所有在配置文件中能配置的属性都是在 xxxProperties 类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类。</p>
<pre><code>@ConfigurationProperties( prefix = "spring.http" )// 从配置文件中获取指定的值和bean的属性进行绑定 public class HttpProperties { }</code></pre><h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><ul>
<li><p>SpringBoot启动会加载大量的自动配置类。</p>
</li>
<li><p>我们看需要的功能有没有SpringBoot默认写好的自动配置类。</p>
</li>
<li><p>我们再来看这个自动配置类中到底配置了那些组件（只要我们要用的组件有，我们就不需要再来配置了）。</p>
</li>
<li><p>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值。<br>xxxAutoConfiguration：自动配置类给容器中添加组件。<br>xxxProperties：封装配置文件中相关属性。</p>
</li>
</ul>
<p>不知道小伙伴们有没有发现，很多需要待加载的类都放在类路径下的META-INF/Spring.factories 文件下，而不是直接写死这代码中，这样做就可以很方便我们自己或者是第三方去扩展，我们也可以实现自己 starter，让SpringBoot 去加载。现在明白为什么 SpringBoot 可以实现零配置，开箱即用了吧！</p>
<h2 id="SpringBoot-的启动原理"><a href="#SpringBoot-的启动原理" class="headerlink" title="SpringBoot 的启动原理"></a>SpringBoot 的启动原理</h2><p><a href="https://segmentfault.com/a/1190000017792883" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017792883</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '33e35f8a39d17339ae45',
        clientSecret: 'c2daf8c102c345db91ff32aa45b2a692c7bdee25',
        repo: 'Fly_tom.github.io',
        owner: 'Flyiyu',
        admin: "Flyiyu",
        id: '2020-02-08T15-33-02',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/02/08/2019-05-12-rabbitmq/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="RabbitMQ笔记">
                        
                        <span class="card-title">RabbitMQ笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            什么叫消息队列  消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-02-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/RabbitMQ/" class="post-category">
                                    RabbitMQ
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/RabbitMQ/">
                        <span class="chip bg-color">RabbitMQ</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/08/2019-04-11-quartz/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="quartz">
                        
                        <span class="card-title">quartz</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
一、什么是Quartz?Quartz是一个完全由Java编写的开源作业调度框架，为在Java应用程序中进行作业调度提供了简单却强大的机制。Quartz允许开发人员根据时间间隔来调度作业。它实现了作业和触发器的多对多的关系，还能把多个作业与
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-02-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/quartz/" class="post-category">
                                    quartz
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/quartz/">
                        <span class="chip bg-color">quartz</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align"
        style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://flytom.top" target="_blank">FlyTom</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>

            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>

    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->


    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
