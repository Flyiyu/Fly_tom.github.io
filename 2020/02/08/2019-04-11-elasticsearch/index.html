<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Elasticsearch笔记, Tom Blog">
    <meta name="description" content="7-2
Elasticsearch简介
https://my.oschina.net/happyBKs/blog/1798778
背景随着业务复杂度的提升以及微服务的兴起，传统单一项目会被按照业务规则进行垂直拆分，另外为了防止单点故障我们也">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Elasticsearch笔记 | Tom Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Tom Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Tom Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Elasticsearch笔记
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Elasticsearch/" class="post-category">
                                Elasticsearch
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-08
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                        9.1k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        32 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>7-2</p>
<h3 id="Elasticsearch简介"><a href="#Elasticsearch简介" class="headerlink" title="Elasticsearch简介"></a>Elasticsearch简介</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es8.jpg" alt="image"></p>
<p><a href="https://my.oschina.net/happyBKs/blog/1798778" target="_blank" rel="noopener">https://my.oschina.net/happyBKs/blog/1798778</a></p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>随着业务复杂度的提升以及微服务的兴起，传统单一项目会被按照业务规则进行垂直拆分，另外为了防止单点故障我们也会将重要的服务模块进行集群部署，通过负载均衡进行服务的调用。那么随着节点的增多，各个服务的日志也会散落在各个服务器上。这对于我们进行日志分析带来了巨大的挑战，总不能一台一台的登录去下载日志吧。那么我们需要一种收集日志的工具将散落在各个服务器节点上的日志收集起来，进行统一的查询及管理统计。那么ELK就可以做到这一点。</p>
<h4 id="Elasticsearch特性"><a href="#Elasticsearch特性" class="headerlink" title="Elasticsearch特性"></a>Elasticsearch特性</h4><ul>
<li>安装方便：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</li>
<li>JSON：输入/输出格式为 JSON，意味着不需要定义 Schema，快捷方便</li>
<li>RESTful：基本所有操作（索引、查询、甚至是配置）都可以通过 HTTP 接口进行</li>
<li>分布式：节点对外表现对等（每个节点都可以用来做入口）；加入节点自动均衡</li>
<li>多租户：可根据不同的用途分索引；可以同时操作多个索引</li>
</ul>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"name"</span> <span class="token operator">:</span> <span class="token string">"5i586tn"</span><span class="token punctuation">,</span> // node 名称
  <span class="token property">"cluster_name"</span> <span class="token operator">:</span> <span class="token string">"elasticsearch"</span><span class="token punctuation">,</span> // 集群名称
  <span class="token property">"cluster_uuid"</span> <span class="token operator">:</span> <span class="token string">"-Ij_g7DrQqeQRYt0BAIY2g"</span><span class="token punctuation">,</span>
  <span class="token property">"version"</span> <span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"number"</span> <span class="token operator">:</span> <span class="token string">"6.6.2"</span><span class="token punctuation">,</span>// es版本号
    <span class="token property">"build_flavor"</span> <span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>
    <span class="token property">"build_type"</span> <span class="token operator">:</span> <span class="token string">"zip"</span><span class="token punctuation">,</span>
    <span class="token property">"build_hash"</span> <span class="token operator">:</span> <span class="token string">"3bd3e59"</span><span class="token punctuation">,</span>
    <span class="token property">"build_date"</span> <span class="token operator">:</span> <span class="token string">"2019-03-06T15:16:26.864148Z"</span><span class="token punctuation">,</span>
    <span class="token property">"build_snapshot"</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token property">"lucene_version"</span> <span class="token operator">:</span> <span class="token string">"7.6.0"</span><span class="token punctuation">,</span>
    <span class="token property">"minimum_wire_compatibility_version"</span> <span class="token operator">:</span> <span class="token string">"5.6.0"</span><span class="token punctuation">,</span>
    <span class="token property">"minimum_index_compatibility_version"</span> <span class="token operator">:</span> <span class="token string">"5.0.0"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"tagline"</span> <span class="token operator">:</span> <span class="token string">"You Know, for Search"</span>
<span class="token punctuation">}</span></code></pre>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es1.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es2.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es3.png" alt="image"></p>
<p>###############################<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es.png" alt="image"></p>
<p>可以看到，我们成功的创建了一个twitter的节点，当然shard默认是5，我这里设置成了7<br>每一个绿色的小框框代表了一个shard，外面有黑色框框的代表主shard，没有的便是replication，横向的node对应了集群中每一个节点。至此简单的es集群就部署好了。</p>
<font size="3">
Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库--无论是开源还是私有。

<p>但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。</p>
<p>Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
<p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p>
<ul>
<li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<blockquote>
<p>Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 <strong>RESTful API</strong> 进行通信, 通过端口 9200 和 Elasticsearch 进行通信</p>
</blockquote>
<h3 id="es的几个概念："><a href="#es的几个概念：" class="headerlink" title="es的几个概念："></a>es的几个概念：</h3><p>（1） 接近实时（NRT）<br>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒）。</p>
<p>（2） 集群（cluster）<br>一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。在产品环境中显式地设定这个名字是一个好习惯，但是使用默认值来进行测试/开发也是不错的。</p>
<p>（3） 节点（node）<br>一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p>
<p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p>
<p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p>
<p>（4） 索引（index）<br>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。索引类似于关系型数据库中Database的概念。在一个集群中，如果你想，可以定义任意多的索引。</p>
<p>（5） 类型（type）<br>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。类型类似于关系型数据库中Table的概念。<br>         type 在6.0.0已经不赞成使用</p>
<p>（6）文档（document）<br>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。<br>在一个index/type里面，只要你想，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。文档类似于关系型数据库中Record的概念。实际上一个文档除了用户定义的数据外，还包括_index、_type和_id字段。</p>
<p>（7） 分片和复制（Primary shards &amp; Primary replicas）<br>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。</p>
<p>为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。<br>分片之所以重要，主要有两方面的原因：</p>
<p>允许你水平分割/扩展你的内容容量<br>允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量<br>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p>
<p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了。这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。复制之所以重要，主要有两方面的原因：</p>
<p>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。<br>扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行<br>总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制数量，但是不能改变分片的数量。</p>
<p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。一个索引的多个分片可以存放在集群中的一台主机上，也可以存放在多台主机上，这取决于你的集群机器数量。主分片和复制分片的具体位置是由ES内在的策略所决定的。</p>
<h3 id="Elasticsearch-存储结构"><a href="#Elasticsearch-存储结构" class="headerlink" title="Elasticsearch 存储结构"></a>Elasticsearch 存储结构</h3><p><strong>es中，存储数据的基本单位就是索引，比如说es中存储了一些订单系统的销售数据，就因该在es中创建一个索引，order—index，所有的销售数据就会都写到这个索引里面去，一个索引就像数据库。而type就相当于每一张表，<br>一个index里面可以有多个type，而mapping就相当于表的结构定义，定义了什么字段类型等，你往index的一个type里添加一行数据就叫做一个document，每一个document有多个filed，每一个filed就代表这个document的一个字段的值。</strong></p>
<pre><code>在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index)中,和数据库的对比.
 shards  分片
 primary shard 主分片
 replica shard 复制分片
 document 文档必须包含的三个节点
    _index  文档存储的地方
    _type  文档代表的对象的类
    _id  文档的唯一标识

关系数据库 -&gt; 数据库 -&gt; 表 -&gt; 行 -&gt; 列
Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields
索引相当于数据库，类型相当于表，文档相当于行，字段（Fields）相当于表的列（字段）。

</code></pre><p><strong>Mapping 映射</strong></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es10.png" alt="image"></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><a href="https://www.cnblogs.com/shoufeng/p/10692113.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoufeng/p/10692113.html</a></p>
<h4 id="1-核心数据类型"><a href="#1-核心数据类型" class="headerlink" title="1 核心数据类型"></a>1 核心数据类型</h4><ul>
<li><p>字符串类型 - string(不再支持), 用text或keyword类型来代替string</p>
</li>
<li><p>文本类型 - text 当一个字段需要用于全文搜索(会被分词), 比如产品名称、产品描述信息, 就应该使用text类型.</p>
<ul>
<li><blockquote>
<p>text的内容会被分词, 可以设置是否需要存储: “index”: “true|false”.<br>  text类型的字段不能用于排序, 也很少用于聚合</p>
</blockquote>
</li>
</ul>
</li>
<li><p>关键字类型 - keyword  当一个字段需要按照精确值进行过滤、排序、聚合等操作时, 就应该使用keyword类型.</p>
<pre><code>  - &gt; keyword的内容不会被分词, 可以设置是否需要存储: "index": "true|false".</code></pre></li>
<li><p>数字类型 - 8种</p>
<blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>有符号的8位整数, 范围: [-128 ~ 127]</td>
</tr>
<tr>
<td>short</td>
<td>有符号的16位整数, 范围: [-32768 ~ 32767]</td>
</tr>
<tr>
<td>integer</td>
<td>有符号的32位整数, 范围: [$-2^{31}$ ~ $2^{31}$-1]</td>
</tr>
<tr>
<td>long</td>
<td>有符号的32位整数, 范围: [$-2^{63}$ ~ $2^{63}$-1]</td>
</tr>
<tr>
<td>float</td>
<td>32位单精度浮点数</td>
</tr>
<tr>
<td>double</td>
<td>64位双精度浮点数</td>
</tr>
<tr>
<td>half_float</td>
<td>16位半精度IEEE 754浮点类型</td>
</tr>
<tr>
<td>scaled_float</td>
<td>缩放类型的的浮点数, 比如price字段只需精确到分, 57.34缩放因子为100, 存储结果为5734</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>使用注意事项:</strong></p>
<blockquote>
<p>尽可能选择范围小的数据类型, 字段的长度越短, 索引和搜索的效率越高;<br>优先考虑使用带缩放因子的浮点类型.</p>
</blockquote>
<ul>
<li>日期类型 - date</li>
<li>布尔类型 - boolean</li>
<li>二进制型 - binary</li>
<li>范围类型 - range<blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>integer_range</td>
<td>$-2^{31}$ ~ $2^{31}-1$</td>
</tr>
<tr>
<td>long_range</td>
<td>$-2^{63}$ ~ $2^{63}-1$</td>
</tr>
<tr>
<td>float_range</td>
<td>32位单精度浮点型</td>
</tr>
<tr>
<td>double_range</td>
<td>64位双精度浮点型</td>
</tr>
<tr>
<td>date_range</td>
<td>64位整数, 毫秒计时</td>
</tr>
<tr>
<td>ip_range</td>
<td>IP值的范围, 支持IPV4和IPV6, 或者这两种同时存在</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="2-复杂数据类型"><a href="#2-复杂数据类型" class="headerlink" title="2 复杂数据类型"></a>2 复杂数据类型</h4><ul>
<li>数组类型 - array</li>
<li>对象类型 - object</li>
<li>嵌套类型 - nested</li>
</ul>
<h4 id="3-地理数据类型"><a href="#3-地理数据类型" class="headerlink" title="3 地理数据类型"></a>3 地理数据类型</h4><ul>
<li>地理点类型 - geo point</li>
<li>地理形状类型 - geo_shape</li>
</ul>
<h4 id="4-专门数据类型"><a href="#4-专门数据类型" class="headerlink" title="4 专门数据类型"></a>4 专门数据类型</h4><ul>
<li>IP类型</li>
<li>计数数据类型 - token_count</li>
</ul>
<h4 id="es锁机制"><a href="#es锁机制" class="headerlink" title="es锁机制"></a>es锁机制</h4><h5 id="悲观锁并发控制"><a href="#悲观锁并发控制" class="headerlink" title="悲观锁并发控制"></a>悲观锁并发控制</h5><p>优点：方便<br>缺点：并发能力低每次只有一个</p>
<h5 id="乐观锁并发控制"><a href="#乐观锁并发控制" class="headerlink" title="乐观锁并发控制"></a>乐观锁并发控制</h5><p>es采用乐观锁</p>
<p>乐观锁不会加锁，会采用一个版本号</p>
<p>优点：并发能力高<br>缺点：每次操作都要比对版本号</p>
<h3 id="ES相关性算分-relevance"><a href="#ES相关性算分-relevance" class="headerlink" title="ES相关性算分 relevance"></a>ES相关性算分 relevance</h3><h3 id="ES节点角色"><a href="#ES节点角色" class="headerlink" title="ES节点角色"></a>ES节点角色</h3><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es13.png" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es20.png" alt="image"></p>
<ul>
<li>倒排索引- -旦生成,不能更改</li>
<li>其好处如下:<ul>
<li>不用考虑并发写文件的问题,杜绝了锁机制带来的性能问题</li>
<li>由于文件不再更改,可以充分利用文件系统缓存,只需载入- -次,只要内存足够,对该文件的读取都会从内存读取,性能高</li>
<li>利于生成缓存数据</li>
<li>利于对文件进行压缩存储,节省磁盘和内存存储空间</li>
</ul>
</li>
<li>坏处为需要写入新文档时,必须重新构建倒排索引文件,然后替换老文件后,新文档才<br>能被检索,导致文档实时性差<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es25.png" alt="image"></li>
</ul>
<h4 id="新文档搜索实时性"><a href="#新文档搜索实时性" class="headerlink" title="新文档搜索实时性"></a>新文档搜索实时性</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es26.png" alt="image"><br>当有一个新的文档，构建倒排索引文件，对两个新旧索引进行同时查询，最后再进行一个汇总</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es27.png" alt="image"></p>
<h3 id="Search运行机制"><a href="#Search运行机制" class="headerlink" title="Search运行机制"></a>Search运行机制</h3><ul>
<li>Search执行的时候实际分为两个步骤运行<ul>
<li>Query阶段</li>
<li>Fetch阶段<br>称为：Query-Then-Fetch<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es28.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es29.png" alt="image"></li>
</ul>
</li>
</ul>
<h4 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h4><p>es排序默认使用相关性算分进行排序</p>
<h3 id="集群的状态status"><a href="#集群的状态status" class="headerlink" title="集群的状态status"></a>集群的状态status</h3><p>① green: 所有primary shard和replica shard都已成功分配, 集群是100%可用的;</p>
<p>② yellow: 所有primary shard都已成功分配, 但至少有一个replica shard缺失. 此时集群所有功能都正常使用, 数据不会丢失, 搜索结果依然完整, 但集群的可用性减弱. —— 需要及时处理的警告.</p>
<p>③ red: 至少有一个primary shard(以及它的全部副本分片)缺失 —— 部分数据不能使用, 搜索只能返回部分数据, 而分配到这个分配上的写入请求会返回一个异常. 此时虽然可以运行部分功能, 但为了索引数据的完整性, 需要尽快修复集群.</p>
<h3 id="ES元数据"><a href="#ES元数据" class="headerlink" title="ES元数据"></a>ES元数据</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es14.png" alt="image"></p>
<h3 id="ES分词"><a href="#ES分词" class="headerlink" title="ES分词"></a>ES分词</h3><p><a href="https://www.jianshu.com/p/914f102bc174" target="_blank" rel="noopener">https://www.jianshu.com/p/914f102bc174</a><br>以及自定分词</p>
<h4 id="ES自带分词器"><a href="#ES自带分词器" class="headerlink" title="ES自带分词器"></a>ES自带分词器</h4><ul>
<li>Standard</li>
<li>Simple</li>
<li>Whitespace</li>
<li>Stop</li>
<li>Keyword</li>
<li>Pattern</li>
<li>Language</li>
</ul>
<h3 id="es查询"><a href="#es查询" class="headerlink" title="es查询"></a>es查询</h3><ul>
<li><p>URI Search</p>
<p>  <img src="https://raw.githubusercontent.com/Flyiyu/use/master/es15.png" alt="image"><br>  <img src="https://raw.githubusercontent.com/Flyiyu/use/master/es17.png" alt="image"></p>
<blockquote>
<p>GET /lib/_search</p>
</blockquote>
<ul>
<li><p>在url中使用查询参数</p>
<pre><code>// 泛查询
GET /lib/_search?q=tom
{
"profile": "true"
}

</code></pre></li>
</ul>
</li>
</ul>
<pre><code>GET /lib/_search?q=tom&amp;df=name
{
  "profile": "true"
}
```</code></pre><ul>
<li>Request Body<ul>
<li>使用ElasticSearch提供的，基于json格式的更加完备的Query Domain Specific Language (DSL查询)<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es16.jpg" alt="image"></li>
</ul>
</li>
</ul>
<h4 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h4><pre><code>GET，对应select:是从服务器查询，可以在服务器通过请求的参数区分查询的方式。
POST,对应Create:在服务器新建立一个资源，调用insert操作。
PUT，对应update操作:在服务器更新资源，调用update操作。
PATCH，对应update操作，在服务器更新资源，客户端提供改变的属性。（目前JDK7没有实现，tomcat7也不行。）
DELETE，对应DELETE操作，从服务器删除资源，调用delete语句。</code></pre><h3 id="Mapping参数"><a href="#Mapping参数" class="headerlink" title="Mapping参数"></a>Mapping参数</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es18.png" alt="image"></p>
<p>在7.0之后一个索引只可以有一个type</p>
<p>analyzer</p>
<p>分词器，默认为standard analyzer，当该字段被索引和搜索时对字段进行分词处理</p>
<p>boost</p>
<p>字段权重，默认为1.0</p>
<p>dynamic</p>
<p>Mapping中的字段类型一旦设定后，禁止直接修改，原因是：Lucene实现的倒排索引生成后不允许修改<br>只能新建一个索引，然后reindex数据<br>默认允许新增字段<br>通过dynamic参数来控制字段的新增：</p>
<p>true（默认）允许自动新增字段<br>false 不允许自动新增字段，但是文档可以正常写入，但无法对新增字段进行查询等操作<br>strict 文档不能写入，报错</p>
<p>index<br>控制当前字段是否索引，默认为true，即记录索引，false不记录，即不可搜索</p>
<pre><code>PUT my_index
{
  "mappings": {
    "_doc": {
      "dynamic": false, 
      "properties": {
        "user": { 
          "properties": {
            "name": {
              "type": "text"
            },
            "social_networks": { 
              "dynamic": true,
              "properties": {}
            }
          }
        }
      }
    }
  }
}</code></pre><p>定义后my_index这个索引下不能自动新增字段，但是在user.social_networks下可以自动新增子字段</p>
<h3 id="Java-API编辑"><a href="#Java-API编辑" class="headerlink" title="Java API编辑"></a>Java API编辑</h3><p>可以使用 Elasticsearch 内置的两个客户端：</p>
<h4 id="节点客户端（Node-client）"><a href="#节点客户端（Node-client）" class="headerlink" title="节点客户端（Node client）"></a>节点客户端（Node client）</h4><p>节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。</p>
<h4 id="传输客户端（Transport-client）"><a href="#传输客户端（Transport-client）" class="headerlink" title="传输客户端（Transport client）"></a>传输客户端（Transport client）</h4><p>轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。<br>两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。</p>
<pre><code>对于ES Client，有两种形式，一个是TransportClient，一个是NodeClient。
两个的区别为： TransportClient作为一个外部访问者，
通过HTTP去请求ES的集群，对于集群而言，它是一个外部因素。
NodeClient顾名思义，是作为ES集群的一个节点，它是ES中的一环，其他的节点对它是感知的，不像TransportClient那样，ES集群对它一无所知。
NodeClient通信的性能会更好，但是因为是ES的一环，所以它出问题，也会给ES集群带来问题。
NodeClient可以设置不作为数据节点，在elasticsearch.yml中设置，这样就不会在此节点上分配数据。</code></pre><p>提示<br>Java 客户端作为节点必须和 Elasticsearch 有相同的 主要 版本；否则，它们之间将无法互相理解。</p>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es6.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es7.png" alt="image"><br></p></font><p></p>
<h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es19.png" alt="image"></p>
<h3 id="文档分布式存储"><a href="#文档分布式存储" class="headerlink" title="文档分布式存储"></a>文档分布式存储</h3><h4 id="存储一个document是如何选择存储在哪个分片上面"><a href="#存储一个document是如何选择存储在哪个分片上面" class="headerlink" title="存储一个document是如何选择存储在哪个分片上面"></a>存储一个document是如何选择存储在哪个分片上面</h4><p><a href="https://www.cnblogs.com/wangshouchang/p/8049492.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangshouchang/p/8049492.html</a></p>
<p>.shard = hash(routing) % number_of_primary_shards</p>
<p>下面将对这个公式每个字段进行分析</p>
<ul>
<li>shard 哪个分片， 也就是分片id</li>
<li>routing 一个可变值，默认是文档的id</li>
<li>hash 一个哈希函数，对rounting字段进行哈希计算生成一个数字</li>
<li>number_of_primary_shards 主分片的数量，routing字段经过hash函数计算之后的值，将对 主分片的数量也就是 number_of_primary_shards 进行取与，之后得到的shard就是我们文档所在的分片的位置</li>
</ul>
<p>该算法与主分片数相关，这也就是主分片一旦创建就无法修改的原因</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es21.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es22.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es23.png" alt="image"><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es24.png" alt="image"></p>
<h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>深度分页是分布式存储系统必然会面临的一个问题<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es30.png" alt="image"></p>
<p>分页方式的应用场景<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es31.png" alt="image"></p>
<h3 id="ES聚合"><a href="#ES聚合" class="headerlink" title="ES聚合"></a>ES聚合</h3><p>es将聚合分析主要分为4类：</p>
<ul>
<li>Bucket 分桶类型，类似sql中的GROUP BY的语法<ul>
<li>Terms</li>
<li>Range</li>
<li>Date Range</li>
<li>Histogram</li>
<li>Date Histogram</li>
</ul>
</li>
<li>Metric指标分析类型，计算最大值、最小值、平均值 distinct conunt<ul>
<li>单值分析，只输出一个分析结果<ul>
<li>min、max、avg、sum</li>
<li>cardinality类型distinct count()</li>
</ul>
</li>
<li>多值分析，输出多个分析结果<ul>
<li>stats,extended stas</li>
<li>percentile,percentile rank</li>
<li>top hits</li>
</ul>
</li>
</ul>
</li>
<li>Pipeline管道分析类型，基于上一级的聚合分析结果进行再分析</li>
<li>Matrix矩阵分析类型</li>
</ul>
<h3 id="日志监控平台–平台架构ELK"><a href="#日志监控平台–平台架构ELK" class="headerlink" title="日志监控平台–平台架构ELK"></a>日志监控平台–平台架构ELK</h3><p>ElasticSearch是有其自己的套件的，简称ELK，即ElasticSearch，Logstash以及Kibana。ElasticSearch负责存储，Logstash负责收集数据来源，Kibana负责可视化数据，分工明确。</p>
<p>　　下面，我给大家用一个图来说明日志监控平台的架构，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/es9.png" alt="image"></p>
<p>　　通过上图，我们可以清晰的看到日志平台整个流向过程。首先，多个独立的Agent，这里就是图左边的三个LogStash节点，他们负责收集不同来源的数据，由一个Indexer负责进行汇总和分析数据，在这个当中有一个中间过程，这里我们使用了Broker，用Redis来实现这部分功能，其作用充当一个缓冲区，之后由ElasticSearch负责存储和搜索数据，最后由前段的Kibana可视化我们收集的数据。</p>
<p>　　这里说明几点需要注意的地方：</p>
<p>采用LogStash收集各种日志数据，其类型可以是：系统日志、文件、Redis、MQ等等。<br>Broker作为远程代理和中心代理的缓冲区，使用Redis进行实现，原因有二：其一，可以提高系统的性能；其二，可以提高系统的高可用性，当中心代理提取数据失败时，数据保存在Redis中，可以规避数据丢失的风险。<br>中心代理使用LogStash，负责从Broker中获取数据，可以执行相关的分析和处理，它提供有Filter功能。<br>ElasticSearch用于存储最终的数据，并对外提供搜索功能，基于Restful。<br>Kibana提供一个简单、丰富的Web View可视化界面，用于可视化ElasticSearch集群中的数据，支持各种查询、统计和展示。</p>
<p>ELK介绍<br>需求背景：</p>
<p>业务发展越来越庞大，服务器越来越多<br>各种访问日志、应用日志、错误日志量越来越多，导致运维人员无法很好的去管理日志<br>开发人员排查问题，需要到服务器上查日志，不方便<br>运营人员需要一些数据，需要我们运维到服务器上分析日志<br>为什么要用到ELK：</p>
<p>一般我们需要进行日志分析场景：直接在日志文件中 grep、awk 就可以获得自己想要的信息。但在规模较大也就是日志量多而复杂的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p>
<p>大型系统通常都是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p>
<p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p>
<p>收集－能够采集多种来源的日志数据<br>传输－能够稳定的把日志数据传输到中央系统<br>存储－如何存储日志数据<br>分析－可以支持 UI 分析<br>警告－能够提供错误报告，监控机制<br>而ELK则提供了一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用。是目前主流的一种日志系统。</p>
<p>ELK简介：</p>
<p>ELK是三个开源软件的缩写，分别为：Elasticsearch 、 Logstash以及Kibana , 它们都是开源软件。不过现在还新增了一个Beats，它是一个轻量级的日志收集处理工具(Agent)，Beats占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具，目前由于原本的ELK Stack成员中加入了 Beats 工具所以已改名为Elastic Stack。</p>
<p>Elastic Stack包含：</p>
<p>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。详细可参考Elasticsearch权威指南</p>
<p>Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。它可以从许多来源接收日志，这些来源包括 syslog、消息传递（例如 RabbitMQ）和JMX，它能够以多种方式输出数据，包括电子邮件、websockets和 Elasticsearch。</p>
<p>Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</p>
<p>Beats在这里是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、cpu、io等资源消耗比较高。相比 Logstash，Beats所占系统的CPU和内存几乎可以忽略不计<br>ELK Stack （5.0版本之后）–&gt; Elastic Stack == （ELK Stack + Beats）。目前Beats包含六种工具：</p>
<p>Packetbeat： 网络数据（收集网络流量数据）<br>Metricbeat： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）<br>Filebeat： 日志文件（收集文件数据）<br>Winlogbeat： windows事件日志（收集 Windows 事件日志数据）<br>Auditbeat：审计数据 （收集审计日志）<br>Heartbeat：运行时间监控 （收集系统运行时的数据）<br>关于x-pack工具：</p>
<p>x-pack对Elastic Stack提供了安全、警报、监控、报表、图表于一身的扩展包，是收费的</p>
<p>** Kibana索引用来存储数据，千万不要删除了它。它是将es数据通过kibana进行web展示的关键。这个配置后，在es的web界面里就会看到这个.kibana索引 **</p>
<h4 id="提高-Elasticsearch-的高可用性"><a href="#提高-Elasticsearch-的高可用性" class="headerlink" title="提高 Elasticsearch 的高可用性"></a>提高 Elasticsearch 的高可用性</h4><p>这时集群的作用就体现出来了。假如 Elasticsearch<br>只放在一台服务器上，即单机运行，假如这台主机突然断网了或者被攻击了，那么整个 Elasticsearch 的服务就不可用了。但如果改成<br>Elasticsearch 集群的话，有一台主机宕机了，还有其他的主机可以支撑，这样就仍然可以保证服务是可用的。</p>
<p>那假如一台主机宕机了，那么不就无法访问这台主机的数据了吗？那假如我要访问的数据正好存在这台主机上，那不就获取不到了吗？难道其他的主机里面也存了一份一模一样的数据？那这岂不是很浪费吗？</p>
<p>为了解答这个问题，这里就引出了 Elasticsearch<br>的信息存储机制了。首先解答上面的问题，一台主机宕机了，这台主机里面存的数据依然是可以被访问到的，因为在其他的主机上也有备份，但备份的时候也不是整台主机备份，是分片备份的，那这里就又引出了一个概念——分片。</p>
<p>分片，英文叫做 Shard，顾名思义，分片就是对数据切分成了多个部分。我们知道 Elasticsearch<br>中一个索引（Index）相当于是一个数据库，如存某网站的用户信息，我们就建一个名为 user<br>的索引。但索引存储的时候并不是整个存一起的，它是被分片存储的，Elasticsearch<br>默认会把一个索引分成五个分片，当然这个数字是可以自定义的。分片是数据的容器，数据保存在分片内，分片又被分配到集群内的各个节点里。当你的集群规模扩大或者缩小时，<br>Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里，所以相当于一份数据被分成了多份并保存在不同的主机上。</p>
<p>那这还是没解决问题啊，如果一台主机挂掉了，那么这个分片里面的数据不就无法访问了？别的主机都是存储的其他的分片。其实是可以访问的，因为其他主机存储了这个分片的备份，叫做副本，这里就引出了另外一个概念——副本。</p>
<p>副本，英文叫做 Replica，同样顾名思义，副本就是对原分片的复制，和原分片的内容是一样的，Elasticsearch<br>默认会生成一份副本，所以相当于是五个原分片和五个分片副本，相当于一份数据存了两份，并分了十个分片，当然副本的数量也是可以自定义的。这时我们只需要将某个分片的副本存在另外一台主机上，这样当某台主机宕机了，我们依然还可以从另外一台主机的副本中找到对应的数据。所以从外部来看，数据结果是没有任何区别的。</p>
<p>一般来说，Elasticsearch 会尽量把一个索引的不同分片存储在不同的主机上，分片的副本也尽可能存在不同的主机上，这样可以提高容错率，从而提高高可用性。</p>
<p>但这时假如你只有一台主机，那不就没办法了吗？分片和副本其实是没意义的，一台主机挂掉了，就全挂掉了。</p>
<p>（2）健康状态</p>
<p>针对一个索引，Elasticsearch 中其实有专门的衡量索引健康状况的标志，分为三个等级：</p>
<ul>
<li><p>green，绿色。这代表所有的主分片和副本分片都已分配。你的集群是 100% 可用的。</p>
</li>
<li></li>
</ul>
<p>yellow，黄色。所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。不过，你的高可用性在某种程度上被弱化。如果更多的分片消失，你就会丢数据了。所以可把<br>yellow 想象成一个需要及时调查的警告。</p>
<ul>
<li>red，红色。至少一个主分片以及它的全部副本都在缺失中。这意味着你在缺少数据：搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。</li>
</ul>
<p>如果你只有一台主机的话，其实索引的健康状况也是<br>yellow，因为一台主机，集群没有其他的主机可以防止副本，所以说，这就是一个不健康的状态，因此集群也是十分有必要的。</p>
<p>（3）存储空间</p>
<p>另外，既然是群集，那么存储空间肯定也是联合起来的，假如一台主机的存储空间是固定的，那么集群它相对于单个主机也有更多的存储空间，可存储的数据量也更大。</p>
<p>所以综上所述，我们需要一个集群！</p>
<p>二、详细了解 Elasticsearch 集群</p>
<p>接下来我们再来了解下集群的结构是怎样的。</p>
<p>首先我们应该清楚多台主机构成了一个集群，每台主机称作一个节点（Node）。</p>
<p>如图就是一个三节点的集群：</p>
<p>在图中，每个 Node 都有三个分片，其中 P 开头的代表 Primary 分片，即主分片，R 开头的代表 Replica 分片，即副本分片。所以图中主分片<br>1、2，副本分片 0 储存在 1 号节点，副本分片 0、1、2 储存在 2 号节点，主分片 0 和副本分片 1、2 储存在 3 号节点，一共是 3 个主分片和<br>6 个副本分片。同时我们还注意到 1 号节点还有个 MASTER<br>的标识，这代表它是一个主节点，它相比其他的节点更加特殊，它有权限控制整个集群，比如资源的分配、节点的修改等等。</p>
<p>这里就引出了一个概念就是节点的类型，我们可以将节点分为这么四个类型：</p>
<ul>
<li><p>主节点：即 Master<br>节点。主节点的主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点。稳定的主节点对集群的健康是非常重要的。默认情况下任何一个集群中的节点都有可能被选为主节点。索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择。虽然主节点也可以协调节点，路由搜索和从客户端新增数据到数据节点，但最好不要使用这些专用的主节点。一个重要的原则是，尽可能做尽量少的工作。</p>
</li>
<li><p>数据节点：即 Data 节点。数据节点主要是存储索引数据的节点，主要对文档进行增删改查操作，聚合操作等。数据节点对 CPU、内存、IO<br>要求较高，在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</p>
</li>
<li><p>负载均衡节点：也称作 Client<br>节点，也称作客户端节点。当一个节点既不配置为主节点，也不配置为数据节点时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，他协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接路由请求。</p>
</li>
<li><p>预处理节点：也称作 Ingest 节点，在索引数据之前可以先对数据做预处理操作，所有节点其实默认都是支持 Ingest 操作的，也可以专门将某个节点配置为<br>Ingest 节点。</p>
</li>
</ul>
<p>以上就是节点几种类型，一个节点其实可以对应不同的类型，如一个节点可以同时成为主节点和数据节点和预处理节点，但如果一个节点既不是主节点也不是数据节点，那么它就是负载均衡节点。具体的类型可以通过具体的配置文件来设置。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '33e35f8a39d17339ae45',
        clientSecret: 'c2daf8c102c345db91ff32aa45b2a692c7bdee25',
        repo: 'Fly_tom.github.io',
        owner: 'Flyiyu',
        admin: "Flyiyu",
        id: '2020-02-08T15-33-02',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/02/08/2019-04-11-idea-git-hexo-de-shi-yong-fly-tom/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="Git">
                        
                        <span class="card-title">Git</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Git的使用git的基本工作流程：

git clone：将远程的Master分支代码克隆到本地仓库
git checkout：切出分支出来开发
git add：将文件加入库跟踪区
git commit：将库跟踪区改变的代码提交到本地代码库
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-02-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Git-Hexo/" class="post-category">
                                    Git Hexo
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Git-Hexo/">
                        <span class="chip bg-color">Git Hexo</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/08/2019-04-11-dubbo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="Dubbo笔记">
                        
                        <span class="card-title">Dubbo笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            何为Dubbo

&nbsp; &nbsp; &nbsp;&nbsp;Dubbo是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。Dubbo采用全spring
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-02-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Dubbo/" class="post-category">
                                    Dubbo
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Dubbo/">
                        <span class="chip bg-color">Dubbo</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align"
        style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://flytom.club" target="_blank">FlyTom</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>

            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>

    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->


    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
