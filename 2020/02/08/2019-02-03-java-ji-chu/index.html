<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="java基础笔记, Tom Blog">
    <meta name="description" content="包括内容：基础知识点，集合类，队列，线程（基础），io
Java语言概述请描述一下javajava是一个面向对象的编程语言，有继承 封装 多态的特性，同时java也是一开源的语言，一次编译到处运行，有很完善的生态系统，包括各种各样的企业级框">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>java基础笔记 | Tom Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Tom Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Tom Blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        java基础笔记
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-08
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                        46.3k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        172 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>包括内容：基础知识点，集合类，队列，线程（基础），io</p>
<h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><h3 id="请描述一下java"><a href="#请描述一下java" class="headerlink" title="请描述一下java"></a>请描述一下java</h3><p>java是一个面向对象的编程语言，有继承 封装 多态的特性，同时java也是一开源的语言，一次编译到处运行，有很完善的生态系统，包括各种各样的企业级框架，同时也不用我们自己管理内存问题（但是要注意内存分配），有完善的垃圾回收机制</p>
<h3 id="jdk工具部分exe解释"><a href="#jdk工具部分exe解释" class="headerlink" title="jdk工具部分exe解释"></a><strong>jdk工具部分exe解释</strong></h3><pre><code>* jar.exe       jar包
* javadoc.exe   文档生成器
* Java.exe      解释器
* Javac.exe     编辑器</code></pre><h3 id="开发与运行Java程序需经过哪些过程？"><a href="#开发与运行Java程序需经过哪些过程？" class="headerlink" title="开发与运行Java程序需经过哪些过程？"></a><strong>开发与运行Java程序需经过哪些过程？</strong></h3><pre><code>* 用工具编辑源程序，也就是写代码，保存
* 用Java编辑器工具javac.exe编译源程序文件，生成字节码.class文件
* 用Java解释器工具Java.exe解释运行生成.class文件</code></pre><h3 id="Java是如何实现跨平台的？"><a href="#Java是如何实现跨平台的？" class="headerlink" title="Java是如何实现跨平台的？"></a><strong>Java是如何实现跨平台的？</strong></h3><ul>
<li>如下所示：<ul>
<li>跨平台是怎样实现的呢？这就要谈及Java虚拟机（Java Virtual Machine，简称 JVM）。</li>
<li>JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</li>
<li>而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。</li>
<li>JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。</li>
<li>注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</li>
<li>所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。</li>
<li>注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。</li>
</ul>
</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<p>编译</p>
<p>运行</p>
<p>编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。</p>
<p>运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。</p>
<p>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p>
<p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p>
<p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。</p>
<h3 id="Java中New一个对象是个怎么样的过程？"><a href="#Java中New一个对象是个怎么样的过程？" class="headerlink" title="Java中New一个对象是个怎么样的过程？"></a>Java中New一个对象是个怎么样的过程？</h3><p><a href="https://blog.csdn.net/qq_27686779/article/details/102942215" target="_blank" rel="noopener">https://blog.csdn.net/qq_27686779/article/details/102942215</a></p>
<h3 id="Java创建对象的几种方式"><a href="#Java创建对象的几种方式" class="headerlink" title="Java创建对象的几种方式"></a>Java创建对象的几种方式</h3><p>其实创建对象的方式有四种：</p>
<ul>
<li>用new关键字创建</li>
<li>调用对象的clone方法</li>
<li>利用反射，调用Class类的或者是Constructor类的newInstance（）方法</li>
<li>用反序列化，调用ObjectInputStream类的readObject（）方法</li>
</ul>
<h3 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h3><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。垃圾回收主要针对的是堆内存(heap)，</p>
<h4 id="如何判断对象是否需要回收？"><a href="#如何判断对象是否需要回收？" class="headerlink" title="如何判断对象是否需要回收？"></a>如何判断对象是否需要回收？</h4><p>有两种（采用第二种方式）</p>
<p>​    1 引用计数法(但是并没有采用)</p>
<p>为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。</p>
<p>​    2、<strong>可达性分析</strong>（采用）</p>
<p>这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。</p>
<h4 id="有哪些方式来回收这些垃圾呢？"><a href="#有哪些方式来回收这些垃圾呢？" class="headerlink" title="有哪些方式来回收这些垃圾呢？"></a>有哪些方式来回收这些垃圾呢？</h4><p>通过java的分代回收机制，堆中的对象主要分为三种</p>
<ul>
<li><p>刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成不可达的对象，快速死去，因此这块区域的特点是存活对象少，垃圾多。形象点描述这块区域为：新生代；</p>
</li>
<li><p>存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些存活时间较长的对象放在一起，它们的特点是存活对象多，垃圾少。形象点描述这块区域为：老年代；</p>
</li>
<li><p>永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：永久代。（不过在 Java 8 里已经把永久代删除了，把这块内存空间给了元空间，后续文章再讲解。）</p>
</li>
</ul>
<p>也就是说，常规的 Java 堆至少包括了 新生代 和 老年代 两块内存区域，而且这两块区域有很明显的特征：</p>
<ul>
<li>新生代：存活对象少、垃圾多</li>
<li>老年代：存活对象多、垃圾少</li>
</ul>
<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><hr>
<p>String是类类型，不是基本类型。</p>
<p>基本类型 有八种：整型 （4种）字符型 （1种）浮点型 （2种）布尔型（1种）</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0002.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0003.jpg" alt=""></p>
<h3 id="基本数据类型-amp-amp-包装类型"><a href="#基本数据类型-amp-amp-包装类型" class="headerlink" title="基本数据类型 &amp;&amp; 包装类型"></a>基本数据类型 &amp;&amp; 包装类型</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc8.png" alt=""></p>
<p>拆箱：和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc9.png" alt=""></p>
<p><strong>Java自带的线程安全的基本类型包括： AtomicInteger, AtomicLong, AtomicBoolean, AtomicIntegerArray,AtomicLongArray等</strong></p>
<h4 id="1-自动类型转换和强制类型转换规则"><a href="#1-自动类型转换和强制类型转换规则" class="headerlink" title="1.自动类型转换和强制类型转换规则"></a>1.自动类型转换和强制类型转换规则</h4><ul>
<li>自动类型转换也叫隐式类型转换</li>
<li>表达式的数据类型自动提升</li>
<li>从低位类型到高位类型自动转换；从高位类型到低位类型需要强制类型转换：</li>
<li>boolean类型与其他基本类型不能进行类型的转换（既不能进行自动类型的提升，也不能强制类型转换）</li>
</ul>
<h4 id="2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"><a href="#2-对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆" class="headerlink" title="2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆"></a>2.对于取值范围，在对应的包装器类中有常量记载，直接调用就可以了，无需记忆</h4><ul>
<li>基本类型byte 二进制位数：Byte.SIZE最小值：Byte.MIN_VALUE最大值：Byte.MAX_VALUE</li>
<li>基本类型short二进制位数：Short.SIZE最小值：Short.MIN_VALUE最大值：Short.MAX_VALUE</li>
<li>基本类型char二进制位数：Character.SIZE最小值：Character.MIN_VALUE最大值：Character.MAX_VALUE</li>
<li>基本类型double 二进制位数：Double.SIZE最小值：Double.MIN_VALUE最大值：Double.MAX_VALUE</li>
</ul>
<h4 id="3、基本类型出现的原因"><a href="#3、基本类型出现的原因" class="headerlink" title="3、基本类型出现的原因"></a>3、基本类型出现的原因</h4><p>在Java编程思想的第一章就讲到：万物皆对象，new一个对象存储在堆中，我们通过堆栈的引用来使用这些对象，但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效——特别是简单的小的变量。所以就出现了基本类型，同C++一样，Java采用了相似的做法，对于这些类型不是用new关键字来创建，而是直接将变量的值存储在堆栈中，因此更加高效。</p>
<h4 id="4、包装类型出现的原因"><a href="#4、包装类型出现的原因" class="headerlink" title="4、包装类型出现的原因"></a>4、包装类型出现的原因</h4><p>Java是一个面向对象的语言，基本类型并不具有对象的性质，为了与其他对象“接轨”就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h3 id="float-与-double"><a href="#float-与-double" class="headerlink" title="float 与 double"></a>float 与 double</h3><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<pre><code>1// float f = 1.1;</code></pre><p>1.1f 字面量才是 float 类型。</p>
<pre><code>1float f = 1.1f;</code></pre><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<pre><code>1short s1 = 1;2// s1 = s1 + 1;</code></pre><p>但是使用 += 运算符可以执行隐式类型转换。</p>
<pre><code>1s1 += 1;</code></pre><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<pre><code>1s1 = (short) (s1 + 1);</code></pre><p>StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting?</p>
<h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><p>&amp; 有两个作用，分别是 位与 和 逻辑与</p>
<p>&amp;&amp; 就是逻辑与</p>
<p><strong>长路与&amp;</strong>：两侧，都会被运算</p>
<p><strong>短路与&amp;&amp;</strong>：只要第一个是false，第二个就不进行运算了</p>
<h3 id="java-包访问权限"><a href="#java-包访问权限" class="headerlink" title="java 包访问权限"></a>java 包访问权限</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc1.gif" alt=""></p>
<h3 id="Java中的面向接口编程"><a href="#Java中的面向接口编程" class="headerlink" title="Java中的面向接口编程"></a>Java中的面向接口编程</h3><p> 面向接口编程是很多软件架构设计理论都倡导的编程方式，学习Java自然少不了这一部分，下面是我在学习过程中整理出来的关于如何在Java中实现面向接口编程的知识。</p>
<p>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地降低程序各模块之间的耦合，从而提高系统的可扩展性和可维护性。基于这种原则，通常推荐“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p>
<h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><p>首字母：字母、$和下划线。变量名：由$、字母、数字和下划线组成。</p>
<h3 id="循环、选择结构"><a href="#循环、选择结构" class="headerlink" title="循环、选择结构"></a>循环、选择结构</h3><ul>
<li>if</li>
<li>switch<blockquote>
<p>在switch 中可以使用的类型 Java支持的数据类型有五种<br>  他们分别是：<br>  byte、char、short、int、enum；<br>  以上是JDK1.6以前的版本。<br>  JDK1.7时，又增加了String</p>
</blockquote>
</li>
</ul>
<p>语法</p>
<pre><code>int is = 0;
switch (is) {
    case 1:
        System.out.println("**");
        break;
    case 2:
        break;
    default:
        System.out.println();
        break;
}</code></pre><ul>
<li>while</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 先判断再执行</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"好好学习，天天向上！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 先执行再判断</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>for</li>
</ul>
<pre><code> for (int is = 0; is &lt; 100; is++) {
     System.out.println("好好学习！");
 }</code></pre><h3 id="break-amp-amp-continue"><a href="#break-amp-amp-continue" class="headerlink" title="break &amp;&amp; continue"></a>break &amp;&amp; continue</h3><pre><code>continue 作用：跳过循环体中剩余的语句而执行下一次循环
break语句终止某个循环，程序跳转到循环块外的下一条语句</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code>public static void main(String[] args) {
    //声明数组
    String [] arr;
    int arr1[];

    //初始化数组
    int arr2[]=new int[]{1,2,3,4,5};
    arr2[5] = 12
    String[] array1={"马超","马云","关羽","刘备","张飞"};
    String[] array2=new String[]{"黄渤","张艺兴","孙红雷","小猪","牙哥","黄磊"};

    String[] array=new String[5];


    //查看数组的长度
    int length=array1.length;
    System.out.println("length：  "+array1.length);

    //输出数组
//      System.out.println(array1);     //结果：[Ljava.lang.String;@32f22097
    System.out.println("arr2:  "+Arrays.toString(arr2));

    //遍历数组
    for (int i = 0; i &lt; array1.length; i++) {
//          System.out.println(array1[i]);
    }
    //int数组转成string数组
    int[]  array3={1,2,3,4,5,6,7,8,9,0};
    String arrStrings=Arrays.toString(array3);
//      System.out.println(arrStrings);

    //从array中创建arraylist
    ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;(Arrays.asList(array1));
    System.out.println(arrayList);

    //数组中是否包含某一个值
    String a="马超";
    if (Arrays.asList(array1).contains(a)) {
        System.out.println("马超在这里");
    }

    //将数组转成set集合
    Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(array2));
    System.out.println(set);

    //将数组转成list集合
    List&lt;String&gt; list=new ArrayList&lt;String&gt;();
    for (int i = 0; i &lt; array2.length; i++) {
        list.add(array2[i]);
    }
    String[] arrStrings2={"1","2","3"};
    List&lt;String &gt; list2=java.util.Arrays.asList(arrStrings2);
    System.out.println(list2);


    //Arrays.fill()填充数组
    int[] arr3=new int[5];
    Arrays.fill(arr3, 10);  //将数组全部填充10
    for (int i = 0; i &lt; arr3.length; i++) {
        System.out.println(arr3[i]);
    }

    //数组排序
    int[] arr4 = {3, 7, 2, 1, 9};
    Arrays.sort(arr4);
    for (int i = 0; i &lt; arr4.length; i++) {
        System.out.println(arr4[i]);
    }

    int[] arr5 = {3, 7, 2, 1, 9,3,45,7,8,8,3,2,65,34,5};
    Arrays.sort(arr5, 1, 4);  //从第几个到第几个之间的进行排序
    for (int i = 0; i &lt; arr5.length; i++) {
        System.out.println(arr5[i]);
    }


    //复制数组
    int[] arr6 = {3, 7, 2, 1};
    int[] arr7=Arrays.copyOf(arr6, 10);  //指定新数组的长度

    int[] arr8=Arrays.copyOfRange(arr6, 1, 3); //只复制从索引[1]到索引[3]之间的元素（不包括索引[3]的元素）
    for (int i = 0; i &lt; arr8.length; i++) {
        System.out.println(arr8[i]);
    }

    //比较两个数组
    int[] arr9 = {1, 2, 3, 4,5,6,7,8,9,0};
    boolean arr10=Arrays.equals(arr6, arr9);
    System.out.println(arr10);

    //去重复
    //利用set的特性
    int[] arr11 = {1, 2, 3, 4,5,6,7,8,9,0,3,2,4,5,6,7,4,32,2,1,1,4,6,3};
    Set&lt;Integer&gt; set2=new HashSet&lt;Integer&gt;();
    for (int i = 0; i &lt; arr11.length; i++) {
        set2.add(arr11[i]);
    }
        System.out.println(set2);
    int[] arr12 = new int[set2.size()];
    int j=0;
    for (Integer i:set2) {
        arr12[j++]=i;
    }
    System.out.println(Arrays.toString(arr12));
}</code></pre><h3 id="OOP-继承-封装-多态-抽象"><a href="#OOP-继承-封装-多态-抽象" class="headerlink" title="OOP 继承 封装 多态 抽象"></a>OOP 继承 封装 多态 抽象</h3><p><strong>笔试回答即可</strong></p>
<p>多态</p>
<blockquote>
<p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，主要体现在编译时的多态性（重载），运行时的多态性（重写）</p>
</blockquote>
<p>继承</p>
<blockquote>
<p>继承是从已有类创建新类的过程，子类可以拥有父类的方法和变量，同时可以添加自己的方法和变量，提高了代码的可重用性</p>
</blockquote>
<p>封装</p>
<blockquote>
<p>封装是指隐藏对象的属性，只对外提供访问的接口，提高了代码的安全性</p>
</blockquote>
<p>抽象</p>
<blockquote>
<p>抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。</p>
</blockquote>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><h5 id="01-什么是封装"><a href="#01-什么是封装" class="headerlink" title="01.什么是封装"></a>01.什么是封装</h5><ul>
<li>封装概述<ul>
<li>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式，提高了代码的安全性</li>
</ul>
</li>
</ul>
<h5 id="02-封装好处分析"><a href="#02-封装好处分析" class="headerlink" title="02.封装好处分析"></a>02.封装好处分析</h5><ul>
<li>封装好处<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高代码复用性</li>
<li>提高安全性[禁止对象之间的不良交互提高模块化]</li>
</ul>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>就是保留父类的属性，开扩新的东西。通过子类可以实现继承，子类继承父类的所有属性，同时也可以直接添加和修改属性，提高了代码的可重用性</p>
<h5 id="继承好处和弊端"><a href="#继承好处和弊端" class="headerlink" title="继承好处和弊端"></a>继承好处和弊端</h5><ul>
<li><strong>继承的好处</strong><ul>
<li>a:提高了代码的复用性</li>
<li>b:提高了代码的维护性</li>
<li>c:让类与类之间产生了关系，是多态的前提</li>
</ul>
</li>
<li><strong>继承的弊端</strong><ul>
<li>类的耦合性增强了。</li>
<li>开发的原则：高内聚，低耦合。</li>
<li>耦合：类与类的关系</li>
<li>内聚：就是自己完成某件事情的能力</li>
</ul>
</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><blockquote>
<p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，主要体现在编译时的多态性（重载），运行时的多态性（重写）</p>
</blockquote>
<h5 id="01-什么是多态"><a href="#01-什么是多态" class="headerlink" title="01.什么是多态"></a>01.什么是多态</h5><ul>
<li>什么是多态？<ul>
<li>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li>
</ul>
</li>
</ul>
<h5 id="02-多态的实现条件"><a href="#02-多态的实现条件" class="headerlink" title="02.多态的实现条件"></a>02.多态的实现条件</h5><ul>
<li>多态实现条件？<ul>
<li>Java实现多态有三个必要条件：继承、重写、向上转型。<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>多态可以大概分为两种方式：方法重载与方法重写。</p>
<ul>
<li>方法重载（Overload）:编译时的多态性（也就是前绑定），方法可以根据不同参数类型进行不同的调用，方法名字一致。</li>
<li>方法重写（Override）:运行时的多态（也称为后绑定）。<br>要实现方法重写需要做：1.方法重写，也就是子类继承父类并重写了父类已经有的方法。 2.用父类型引用来引用子类型对象，这样可以实现调用同样的方法会根据子类对象的不同表示出不一样的行为。</li>
</ul>
<p><code>多态性</code>：<code>多态性</code>是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。<code>多态性</code>分为编译时的<code>多态性</code>和运行时的<code>多态性</code>。如果将对象的方法视为对象向外界提供的服务，那么运行时的<code>多态性</code>可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式， 但一切对 A 系统来说都是透明的。方法重载（overload）实现的是编译时的<code>多态性</code>（也称为前绑定），而方法重写<br>（override）实现的是运行时的<code>多态性</code>（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类<code>继承</code>父类并重写父类中已有的或<code>抽象</code>的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<p>4）    <code>抽象</code>：<code>抽象</code>是将一类对象的共同特征总结出来构造类的过程，包括数据<code>抽象</code>和行为<code>抽象</code>两方面。<code>抽象</code>只关注对象有哪些属性和行为，并不关注这些行为的细节是什么</p>
<p>父类Animal</p>
<pre><code> class Animal {
    int num = 10;
    static int age = 20;
    public void eat() {
        System.out.println("动物吃饭");
        }
    public static void sleep() {
        System.out.println("动物在睡觉");
        }
    public void run(){
        System.out.println("动物在奔跑");
       }
}</code></pre><p>子类Cat</p>
<pre><code>class Cat extends Animal {
    int num = 80;
    static int age = 90;
     String name = "tomCat";
    public void eat() {
        System.out.println("猫吃饭");
    }
    public static void sleep() {
        System.out.println("猫在睡觉");
    }
    public void catchMouse() {
        System.out.println("猫在抓老鼠");
    }
}</code></pre><p>测试类Demo_Test1</p>
<pre><code>class Demo_Test1 {
    public static void main(String[] args) {
    Animal am = new Cat();
    am.eat();
    am.sleep();
    am.run();
    //am.catchMouse();这里先注释掉，等会会说明
     //System.out.println(am.name);//这里先注释，待会说明
    System.out.println(am.num);
    System.out.println(am.age);
    }
}</code></pre><p>以上的三段代码充分体现了多态的三个前提，即：</p>
<p>1、存在继承关系Cat类继承了Animal类</p>
<p>2、子类要重写父类的方法子类重写(override)了父类的两个成员方法eat()，sleep()。其中eat()是非静态的，sleep()是静态的（static）。</p>
<p>3、父类数据类型的引用指向子类对象。</p>
<p>如果再深究一点呢，我们可以看看上面测试类的输出结果，或许对多态会有更深层次的认识。猜一猜上面<br>的结果是什么。</p>
<p>可以看出来</p>
<p>子类Cat重写了父类Animal的非静态成员方法am.eat();的输出结果为：猫吃饭。</p>
<p>子类重写了父类(Animal)的静态成员方法am.sleep();的输出结果为：动物在睡觉</p>
<p>未被子类（Cat）重写的父类（Animal）方法am.run()输出结果为：动物在奔跑</p>
<p><strong>那么我们可以根据以上情况总结出多态成员访问的特点：</strong></p>
<pre><code>1成员变量
2- 编译看左边(父类),运行看左边(父类)
3成员方法
4- 编译看左边(父类)，运行看右边(子类)。动态绑定
5静态方法
6- 编译看左边(父类)，运行看左边(父类)。
7
8(静态和类相关，算不上重写，所以，访问还是左边的)
9只有非静态的成员方法,编译看左边,运行看右边</code></pre><p><strong>那么多态有什么弊端呢？</strong></p>
<p>不能使用子类特有的成员属性和子类特有的成员方法。</p>
<p>参考：<a href="https://www.zhihu.com/question/30082151" target="_blank" rel="noopener">https://www.zhihu.com/question/30082151</a></p>
<p>很明显，执行强转语句Cat ct = (Cat)am;之后，ct就指向最开始在堆内存中创建的那个Cat类型的对象了。</p>
<p><strong>这就是多态的魅力吧，虽然它有缺点，但是它确实十分灵活，减少多余对象的创建，不用说为了使用子类的某个方法又去重新再堆内存中开辟一个新的子类对象。</strong></p>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><p><strong>1. 抽象类</strong></p>
<p>抽象类和普通类最大的区别是：</p>
<p><strong>抽象类不能被实例化，需要继承抽象类才能实例化其子类</strong>。</p>
<pre><code> public abstract class AbstractClassExample {

     protected int x;
     private int y;

     public abstract void func1();

     public void func2() {
         System.out.println("func2");
    }
}
public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}</code></pre><p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p><strong>从 Java 8 开始，接口也可以拥有默认的方法实现</strong>，这是因为不支持默认方法的接口的维护成本太高了。</p>
<p><strong>在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</strong></p>
<p><strong>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</strong></p>
<p><strong>接口的字段默认都是 static 和 final 的。</strong></p>
<pre><code> public interface InterfaceExample {
     void func1();

     default void func2(){
         System.out.println("func2");
     }

     int x = 123;
     // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}
public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println("func1");
    }
}</code></pre><p><strong>3. 比较</strong></p>
<ul>
<li><p><strong>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</strong></p>
</li>
<li><p>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</p>
</li>
<li><p><strong>接口的字段只能是 static 和 final 类型的</strong>，而抽象类的字段没有这种限制。</p>
</li>
<li><p><strong>接口的成员只能是 public 的</strong>，而抽象类的成员可以有多种访问权限。</p>
</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li><p>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</p>
</li>
<li><p>需要使用多重继承。</p>
</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li><p>需要在几个相关的类中共享代码。</p>
</li>
<li><p>需要能控制继承来的成员的访问权限，而不是都为 public。</p>
</li>
<li><p>需要继承非静态static和非常量final字段。</p>
</li>
</ul>
<p><strong>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</strong></p>
<ul>
<li><p>深入理解 abstract class 和 interface</p>
</li>
<li><p>When to Use Abstract Class and Interface</p>
</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>接口</strong></p>
<p>接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。</p>
<p><strong>抽象类</strong></p>
<p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：<br>abstract void fun() 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法</p>
<p>接口和抽象类的区别</p>
<p>1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</p>
<p>2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</p>
<p>3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p>
<p>4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p>5）抽象类中的方法子类必须全部实现,不然子类也是抽象类,而接口中的抽象方法子类必须全部实现。</p>
<p>6）抽象类是一种模板设计模式,而接口是一种行为规范。</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li><p><strong>访问父类的构造函数</strong>：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</p>
</li>
<li><p><strong>访问父类的成员</strong>：如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</p>
</li>
</ul>
<p>Using the Keyword super</p>
<h3 id="继承相关小问题"><a href="#继承相关小问题" class="headerlink" title="继承相关小问题"></a>继承相关小问题</h3><h4 id="接口是否可继承接口"><a href="#接口是否可继承接口" class="headerlink" title="接口是否可继承接口?"></a>接口是否可继承接口?</h4><p>可以，比如List 就继承了接口Collection</p>
<h4 id="抽象类是否可实现-implements-接口"><a href="#抽象类是否可实现-implements-接口" class="headerlink" title="抽象类是否可实现(implements)接口?"></a>抽象类是否可实现(implements)接口?</h4><p>可以，比如 MouseAdapter鼠标监听适配器 是一个抽象类，并且实现了MouseListener接口</p>
<h4 id="抽象类是否可继承实体类（concrete-class）？"><a href="#抽象类是否可继承实体类（concrete-class）？" class="headerlink" title="抽象类是否可继承实体类（concrete class）？"></a>抽象类是否可继承实体类（concrete class）？</h4><p>可以，所有抽象类，都继承了Object</p>
<h3 id="Java中的内部类分类"><a href="#Java中的内部类分类" class="headerlink" title="Java中的内部类分类"></a>Java中的内部类分类</h3><h4 id="1-1-Java中的内部类共分为四种："><a href="#1-1-Java中的内部类共分为四种：" class="headerlink" title="1.1 Java中的内部类共分为四种："></a>1.1 Java中的内部类共分为四种：</h4><ul>
<li>静态内部类static inner class (also called nested class)</li>
<li>成员内部类member inner class</li>
<li>局部内部类local inner class</li>
<li>匿名内部类anonymous inner class</li>
</ul>
<h4 id="02-内部类概述和访问特点"><a href="#02-内部类概述和访问特点" class="headerlink" title="02.内部类概述和访问特点"></a>02.内部类概述和访问特点</h4><ul>
<li>A:内部类概述:   <ul>
<li>把类定义在其他类的内部，这个类就被称为内部类。</li>
<li>举例：在类A中定义了一个类B，类B就是内部类。</li>
</ul>
</li>
<li>B:内部类访问特点<ul>
<li>a:内部类可以直接访问外部类的成员，包括私有。</li>
<li>b:外部类要访问内部类的成员，必须创建对象。</li>
</ul>
</li>
<li>C：内部类作用<ul>
<li>内部类作用主要实现功能的隐藏、减少内存开销，提高程序的运行速度</li>
</ul>
</li>
</ul>
<h5 id="2-1-内部类分类及成员内部类的直接使用"><a href="#2-1-内部类分类及成员内部类的直接使用" class="headerlink" title="2.1 内部类分类及成员内部类的直接使用"></a>2.1 内部类分类及成员内部类的直接使用</h5><ul>
<li>A:按照内部类位置分类<ul>
<li>成员位置:在成员位置定义的类，被称为成员内部类。   </li>
<li>局部位置:在局部位置定义的类，被称为局部内部类。</li>
</ul>
</li>
<li>B:成员内部类<ul>
<li>如何在测试类中直接访问内部类的成员。</li>
<li>格式:     外部类名.内部类名 对象名 = 外部类对象.内部类对象;</li>
</ul>
</li>
</ul>
<h5 id="2-2-成员内部类的常见修饰符及应用"><a href="#2-2-成员内部类的常见修饰符及应用" class="headerlink" title="2.2 成员内部类的常见修饰符及应用"></a>2.2 成员内部类的常见修饰符及应用</h5><ul>
<li>A:成员内部类的修饰符：<ul>
<li>private     为了保证数据的安全性</li>
<li>static         为了方便访问数据</li>
<li>注意事项: <ul>
<li>a:静态内部类访问的外部类数据必须用静态修饰。</li>
<li>b: 成员方法可以是静态的也可以是非静态的</li>
</ul>
</li>
</ul>
</li>
<li>B:成员内部类被静态修饰后的访问方式是:<pre><code>  * 格式:    外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre></li>
</ul>
<h5 id="2-3-局部内部类访问局部变量的问题"><a href="#2-3-局部内部类访问局部变量的问题" class="headerlink" title="2.3 局部内部类访问局部变量的问题"></a>2.3 局部内部类访问局部变量的问题</h5><ul>
<li>A: 可以直接访问外部类的成员</li>
<li>B: 可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能</li>
<li>C:局部内部类访问局部变量必须用final修饰<ul>
<li>为什么呢?<ul>
<li>因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，还要使用那个变量。 为了让数据还能继续被使用，就用fianl修饰，这样，在堆内存里面存储的其实是一个常量值。</li>
<li>当我们添加了final其实就是延长了生命周期 , 其实就是一个常量 , 常量在常量池中 , 在方法区中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="03-内部类和外部类联系"><a href="#03-内部类和外部类联系" class="headerlink" title="03.内部类和外部类联系"></a>03.内部类和外部类联系</h4><ul>
<li>内部类和外部类联系：<ul>
<li>内部类可以访问外部类所有的方法和属性，如果内部类和外部类有相同的成员方法和成员属性，内部类的成员方法调用要优先于外部类即内部类的优先级比较高（只限于类内部，在主方法内，内部类对象不能访问外部类的成员方法和成员属性），外部类只能访问内部类的静态常量或者通过创建内部类来访问内部类的成员属性和方法</li>
</ul>
</li>
</ul>
<h4 id="04-匿名内部类"><a href="#04-匿名内部类" class="headerlink" title="04.匿名内部类"></a>04.匿名内部类</h4><h5 id="4-1-匿名内部类的格式和理解"><a href="#4-1-匿名内部类的格式和理解" class="headerlink" title="4.1 匿名内部类的格式和理解"></a>4.1 匿名内部类的格式和理解</h5><ul>
<li>A:匿名内部类:    就是局部内部类的简化写法。</li>
<li>B:前提：            存在一个类或者接口;这里的类可以是具体类也可以是抽象类。</li>
<li>C:格式：<pre><code>  new 类名或者接口名(){
       重写方法;
  } ;</code></pre></li>
</ul>
<h5 id="4-2-本质是什么呢"><a href="#4-2-本质是什么呢" class="headerlink" title="4.2 本质是什么呢?"></a>4.2 本质是什么呢?</h5><ul>
<li><p>是一个继承了该类或者实现了该接口的子类匿名对象。</p>
</li>
<li><p>匿名内部类的面试题</p>
<ul>
<li>A:面试题<pre><code>按照要求，补齐代码
interface Inter { void show(); }
class Outer { //补齐代码 }
class OuterDemo {
public static void main(String[] args) {
      Outer.method().show();
  }
}
要求在控制台输出”HelloWorld”</code></pre></li>
</ul>
<ul>
<li>答案<br>//补齐代码<br>public static Inter method() {<br>  //匿名内部类<br>  return new Inter() {<pre><code>  public void show(){
      System.out.println("HelloWorld") ;
  } ;</code></pre>  }<br>}<br>```</li>
</ul>
</li>
</ul>
<ul>
<li>思考一下：匿名内部类的生命周期怎样，和所在方法是同步吗？</li>
</ul>
<h4 id="05-成员内部类介绍"><a href="#05-成员内部类介绍" class="headerlink" title="05.成员内部类介绍"></a>05.成员内部类介绍</h4><ul>
<li><p>要创建一个成员内部类的实例，需要拥有其外部类的一个实例的引用。假设外部类为A，成员内部类为B，则创建一个B类的实例的语法规则如下：</p>
<pre><code>  A a = new A();
  A.B b = a.new B();</code></pre></li>
<li><p>那么实际案例代码如下所示</p>
<pre><code>  public class Outer {

      private int value = 10;

      private static int staticValue=11;

      protected  class Nested {
          public int getValue() {
              // 可以访问外部类的非静态、静态、私有成员
              return value+staticValue;
          }
      }
  }

  public static void main(String[] args) {
      Outer outer=new Outer();
      Outer.Nested nested=outer.new Nested();
      System.out.println(nested.getValue());
  }</code></pre></li>
</ul>
<h4 id="06-局部内部类介绍"><a href="#06-局部内部类介绍" class="headerlink" title="06.局部内部类介绍"></a>06.局部内部类介绍</h4><ul>
<li>局部内部类可以简称为局部类，局部类可以在任何代码块中声明，并且其作用域位于代码块之中。例如，可以在一个方法快、一个if语句块、一个while语句块中声明一个局部类</li>
<li>如果类的实例只在作用域内使用的话，使用局部类可以说是一个好办法</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>

    String time <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofLocalizedDateTime</span><span class="token punctuation">(</span>FormatStyle<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> Logger <span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">class</span> <span class="token class-name">LoggerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time <span class="token operator">+</span> <span class="token string">" : "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LoggerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Outer outer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Logger logger<span class="token operator">=</span>outer<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="泛形"><a href="#泛形" class="headerlink" title="泛形"></a>泛形</h3><p><strong>什么是泛型</strong></p>
<p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。</p>
<p>在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</p>
<h4 id="泛形方法"><a href="#泛形方法" class="headerlink" title="泛形方法"></a>泛形方法</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 说明：
 * 1）&lt;E>非常重要，可以理解为声明此方法为泛型方法。
 * 2）只有声明了&lt;E>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
 * 3）&lt;E>表明该方法将使用泛型类型E，此时才可以在方法中使用泛型类型E。
 * 4）与泛型类的定义一样，此处E可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
 *
 * @param inputArray
 * @param &lt;E>
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 输出数组元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>E element <span class="token operator">:</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="泛形类"><a href="#泛形类" class="headerlink" title="泛形类"></a>泛形类</h4><h4 id="泛形接口"><a href="#泛形接口" class="headerlink" title="泛形接口"></a>泛形接口</h4><h4 id="泛形通配符：？"><a href="#泛形通配符：？" class="headerlink" title="泛形通配符：？"></a>泛形通配符：？</h4><h4 id="泛形的限定"><a href="#泛形的限定" class="headerlink" title="泛形的限定"></a>泛形的限定</h4><p>我们知道使用泛型类时：如果明确参数类型，那么泛型就代表一种类型；如果使用通配符？，那么泛型就代表任意类型。但有时候我们希望指定某些类型(不是一个，也不要所有)能作为参数类型，这应该怎么办呢？</p>
<pre><code>    Java中利用泛型的限定解决了这个问题，即泛型的限定。我们只需要按这样的格式书写：

   上限：&lt;？ extends E&gt;表示参数类型是E及其所有子类。

   下限：&lt;? super E&gt;表示参数类型是E及其所有超类(即父类)。</code></pre><h4 id="Java泛型中E、T、K、V等的含义"><a href="#Java泛型中E、T、K、V等的含义" class="headerlink" title="Java泛型中E、T、K、V等的含义"></a>Java泛型中E、T、K、V等的含义</h4><ul>
<li>E - Element (在集合中使用，因为集合中存放的是元素)（集合泛形）</li>
<li>T - Type（Java 类）（接口）</li>
<li>K - Key（键）</li>
<li>V - Value（值）</li>
<li>N - Number（数值类型）</li>
<li>？ -  表示不确定的java类型</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>enum 的全称为 enumeration， 是 JDK 1.5  中引入的新特性，存放在 java.lang 包中，另外到了JDK1.6后switch语句支持枚举类型。</p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71333103</a></p>
<h3 id="java类的初始化顺序"><a href="#java类的初始化顺序" class="headerlink" title="java类的初始化顺序"></a>java类的初始化顺序</h3><h4 id="本类的初始化顺序"><a href="#本类的初始化顺序" class="headerlink" title="本类的初始化顺序"></a>本类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitialOrderTest</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String staticField <span class="token operator">=</span> <span class="token string">"静态变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String field <span class="token operator">=</span> <span class="token string">"变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticField<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">InitialOrderTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>运行结果：<br><br>    静态变量<br><br>    静态初始化块<br>a<br>    变量<br><br>    初始化块<br><br>    构造器<br></p>
<h4 id="含有父类的初始化顺序"><a href="#含有父类的初始化顺序" class="headerlink" title="含有父类的初始化顺序"></a>含有父类的初始化顺序</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>   
    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String p_StaticField <span class="token operator">=</span> <span class="token string">"父类--静态变量"</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String p_Field <span class="token operator">=</span> <span class="token string">"父类--变量"</span><span class="token punctuation">;</span>   

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">", j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        j <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>   

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// 静态变量</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> String s_StaticField <span class="token operator">=</span> <span class="token string">"子类--静态变量"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 变量</span>
    <span class="token keyword">public</span> String s_Field <span class="token operator">=</span> <span class="token string">"子类--变量"</span><span class="token punctuation">;</span>   

    <span class="token comment" spellcheck="true">// 静态初始化块</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_StaticField<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--静态初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   
    <span class="token comment" spellcheck="true">// 初始化块</span>
    <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s_Field<span class="token punctuation">)</span><span class="token punctuation">;</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--初始化块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 构造器</span>
    <span class="token keyword">public</span> <span class="token function">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类--构造器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">",j="</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   

    <span class="token comment" spellcheck="true">// 程序入口</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">SubClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>  </code></pre>
<p>运行结果：<br>父类–静态变量<br>父类–静态初始化块<br>子类–静态变量<br>子类–静态初始化块<br>父类–变量<br>父类–初始化块<br>父类–构造器<br>子类–变量<br>子类–初始化块<br>子类–构造器</p>
<h2 id="equals-hashcode-String-StringBuffer-StringBuilder-记录"><a href="#equals-hashcode-String-StringBuffer-StringBuilder-记录" class="headerlink" title="== | equals | hashcode |String StringBuffer StringBuilder 记录"></a>== | equals | hashcode |String StringBuffer StringBuilder 记录</h2><h3 id="和-equals"><a href="#和-equals" class="headerlink" title="== 和 equals"></a>== 和 equals</h3><p>缓存池</p>
<pre><code>public class Main_1 {
 public static void main(String[] args) {
    Integer a = 1;
    Integer b = 2;
    Integer c = 3;
    Integer d = 3;
    Integer e = 321;
    Integer f = 321;
    Long g = 3L;
    System.out.println(c == d);//true，缓存池
    System.out.println(e == f);//false，不在缓存池
    System.out.println(c == (a + b));//true
    System.out.println(c.equals(a + b));//true
    System.out.println(g == (a + b));//true
    System.out.println(g.equals(a + b));//false
    System.out.println(g.equals(a + h));//true
 }
}</code></pre><p><strong>基本类型对应的缓冲池如下：</strong></p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p><strong>默认IntegerCache.low 是-127，Integer.high是128，如果在这个区间[-128,127]内，他就会把变量i当做一个变量，放到内存中，用比较是会得出true；但如果不在这个范围内，就会去new一个Integer对象，当运用“”时，会比较Integer两个对象地址，得出false。</strong></p>
<p><strong>所以最好使用equals来比较包装类型是否相等（阿里编码规范）</strong></p>
<p>== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ul>
<li><p>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</p>
</li>
<li><p>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</p>
</li>
</ul>
<pre><code>Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false</code></pre><ul>
<li>== 是java提供的等于比较运算符,用来比较两个变量指向的内存地址是否相同.</li>
<li>所以用”==”判断两个引用数据类型是否相等的时候，<strong>实际上是在判断两个引用是否指向同一个对象</strong></li>
<li>而equals()是Object提供的一个方法.Object中equals()方法的默认实现就是返回两个对象==的比较结果.但是equals()可以被重写,所以我们在具体使用的时候需要关注equals()方法有没有被重写.</li>
</ul>
<pre><code>public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
</code></pre><blockquote>
<p>当调用 String 类型数据的 equals() 方法时，首先会判断两个字符串的引用是否相等，也就是说两个字符串引用是否指向同一个对象，是则返回true。</p>
</blockquote>
<blockquote>
<p>如果不是指向同一个对象，则把两个字符串中的字符挨个进行比较。由于 s1 和 s3 字符串都是 “hello”，是可以匹配成功的，所以最终返回 true。</p>
</blockquote>
<p><strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?</strong></p>
<p><strong>因为hashCode()方法和equals()方法都可以通过自定义类重写</strong>，是可以做到equals相同，但是hashCode不同的</p>
<p>但是，在Object类的equals()方法中有这么一段话</p>
<p>翻译如下：</p>
<p>通常来讲，在重写这个方法的时候，也需要对hashCode方法进行重写，<br>以此来保证这两个方法的一致性——<br>当equals返回true的时候，这两个对象一定有相同的hashcode.</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><pre><code>public native int hashCode();</code></pre><p>Java中的类都有一个hashCode方法，这个方法用来生成hashCode值，这个值是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）生成的，这个值的作用是为了提高集合类的性能，例如HashSet、HashMap以及HashTable。</p>
<p><strong>哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。</strong></p>
<p>我们可以调用对象的hashCode方法来生成hashCode值，因为两个不同的对象可能会有相同的hashCode值，所有不能通过hashCode值来判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。</p>
<h3 id="hashCode-amp-amp-equals"><a href="#hashCode-amp-amp-equals" class="headerlink" title="hashCode() &amp;&amp; equals()"></a>hashCode() &amp;&amp; equals()</h3><p>重写 equals 方法的同时也需要重写 hashCode 方法，有没有想过为什么？</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc32.png" alt="image"></p>
<p>假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。</p>
<p>然而重写了equals，且s1.equals(s2)返回true，根据hashcode的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。</p>
<p>以下是关于hashcode的一些规定：</p>
<ul>
<li>两个对象相等，hashcode一定相等</li>
<li>两个对象不等，hashcode不一定不等</li>
<li>hashcode相等，两个对象不一定相等</li>
<li>hashcode不等，两个对象一定不等</li>
</ul>
<p><a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 <code>ToStringExample@4554617c</code> 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<pre><code>public class ToStringExample {

    private int number;

    public ToStringExample(int number) {
        this.number = number;
    }
}
ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
ToStringExample@4554617c</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><strong>String 被声明为 final，因此它不可被继承。</strong></p>
<pre><code>首先String不属于8中基本类型，String是一个对象

String 由于使用final 修饰存储在常量区（不是new出来的）

new出来的存储在对象存储在堆中，栈中存放的为引用地址。
</code></pre><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<pre><code>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}</code></pre><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<pre><code>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}</code></pre><p><strong>String 类的常用方法都有那些？</strong></p>
<ul>
<li>indexOf()：返回指定字符的索引</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h4 id="String不可变的好处"><a href="#String不可变的好处" class="headerlink" title="String不可变的好处"></a>String不可变的好处</h4><p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p><strong>注意：不是string创建后就默认进入池的，请看下方intern()</strong></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/ms0004.jpg" alt=""></p>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p>Program Creek : Why String is immutable in Java?</p>
<h4 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h4><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<pre><code>1String s1 = new String("aaa");
2String s2 = new String("aaa");
3System.out.println(s1 == s2);           // false
4String s3 = s1.intern();
5String s4 = s1.intern();
6System.out.println(s3 == s4);           // true</code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<pre><code>1String s5 = "bbb";
2String s6 = "bbb";
3System.out.println(s5 == s6);  // true</code></pre><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<ul>
<li><p>StackOverflow : What is String interning?</p>
</li>
<li><p>深入解析 String#intern</p>
</li>
</ul>
<h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li><p>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</p>
</li>
<li><p>而使用 new 的方式会在堆中创建一个字符串对象。</p>
</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<pre><code>public class NewStringTest {
    public static void main(String[] args) {
        String s = new String("abc");
    }
}</code></pre><p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<pre><code>// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V
         9: astore_1
// ...</code></pre><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</strong></p>
<h4 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h4><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p><strong>1. 可变性</strong></p>
<ul>
<li><p>String 不可变</p>
</li>
<li><p>StringBuffer 和 StringBuilder 可变</p>
</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li><p>String 不可变，因此是线程安全的</p>
</li>
<li><p>StringBuilder 不是线程安全的</p>
</li>
<li><p>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p>
</li>
</ul>
<h3 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer/StringBuilder"></a>StringBuffer/StringBuilder</h3><ul>
<li>StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口；其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组）进行存储，不同点是StringBuffer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变;两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</li>
</ul>
<p><strong>对于三者使用的总结：</strong></p>
<p>1.如果要操作少量的数据用 String</p>
<p>2.<strong>单线程</strong>操作字符串缓冲区下操作大量数据 StringBuilder</p>
<p>3.<strong>多线程</strong>操作字符串缓冲区下操作大量数据 StringBuffer</p>
<h4 id="String-和StringBuffer的区别？"><a href="#String-和StringBuffer的区别？" class="headerlink" title="String 和StringBuffer的区别？"></a>String 和StringBuffer的区别？</h4><p>String是immutable的,其内容一旦创建好之后，就不可以发生改变。</p>
<p>StringBuffer 是可以变长的，内容也可以发生改变<br>改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。</p>
<p><a href="https://blog.csdn.net/yeweiyang16/article/details/51755552" target="_blank" rel="noopener">https://blog.csdn.net/yeweiyang16/article/details/51755552</a></p>
<p><strong>初始化：可以指定给对象的实体的初始容量为参数字符串s的长度额外再加16个字符</strong></p>
<p><strong>扩容：尝试将新容量扩为大小变成原容量的1倍+2，然后if判断一下 容量如果不够，直接扩充到需要的容量大小。</strong></p>
<p>StackOverflow : String, StringBuffer, and StringBuilder</p>
<h4 id="5-String不可变的好处"><a href="#5-String不可变的好处" class="headerlink" title="5.String不可变的好处"></a>5.String不可变的好处</h4><ul>
<li><strong>5.1 可以缓存 hash 值</strong> <a href="https://github.com/yangchong211/YCBlogs" target="_blank" rel="noopener">博客</a><ul>
<li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
</ul>
</li>
<li><strong>5.2 String Pool 的需要</strong> <ul>
<li>如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
</ul>
</li>
<li><strong>5.3 安全性</strong> <ul>
<li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
</ul>
</li>
<li><strong>5.4 线程安全</strong> <ul>
<li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
</li>
</ul>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ul>
<li>Java基本数据类型传递参数时是值传递；引用类型传递参数时是引用传递。</li>
<li>值传递时，将实参的值传递一份给形参；引用传递时，将实参的地址值传递一份给形参。</li>
<li>值传递时，实参把它的值传递给对应的形参，函数接收的是原始值的一个拷贝，此时内存中存在两个相等的基本类型，即实参和形参，后面方法中的操作都是对形参这个值的修改，不影响实参的值。引用传递时，实参的引用(地址，而不是参数的值)被传递给方法中相对应的形参，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。</li>
<li>需要特殊考虑String，以及Integer、Double等几个基本类型包装类，它们都是immutable类型，因为没有提供自身修改的函数，每次操作都是新创建一个对象，所以要特殊对待。因为最后的操作不会修改实参，可以认为是和基本数据类型相似，为值传递。</li>
</ul>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p>
<pre><code>public class Dog {

     String name;

     Dog(String name) {
         this.name = name;
     }

     String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
 public class PassByValueExample {
     public static void main(String[] args) {
         Dog dog = new Dog("A");
         System.out.println(dog.getObjectAddress()); // Dog@4554617c
         func(dog);
         System.out.println(dog.getObjectAddress()); // Dog@4554617c
         System.out.println(dog.getName());          // A
     }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}</code></pre><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<pre><code> class PassByValueExample {
     public static void main(String[] args) {
         Dog dog = new Dog("A");
         func(dog);
         System.out.println(dog.getName());          // B
     }

     private static void func(Dog dog) {
         dog.setName("B");
    }
}</code></pre><p>StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</p>
<h2 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h2><hr>
<p>经典：</p>
<p><a href="https://fangjian0423.github.io/2016/03/12/java-Object-method/" target="_blank" rel="noopener">https://fangjian0423.github.io/2016/03/12/java-Object-method/</a></p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><pre><code> public native int hashCode()

 public boolean equals(Object obj)

 protected native Object clone() throws CloneNotSupportedException

 public String toString()

 public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException</code></pre><ul>
<li>getClass方法</li>
</ul>
<ul>
<li>返回当前运行时对象的Class对象</li>
</ul>
<ul>
<li>hashCode方法</li>
</ul>
<ul>
<li>该方法返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。（文章中有对hashcode的详细解释）</li>
</ul>
<ul>
<li>equals方法</li>
</ul>
<ul>
<li>如果重写了equals方法，通常有必要重写hashCode方法，这点已经在hashCode方法中说明了。</li>
</ul>
<ul>
<li>clone方法</li>
</ul>
<ul>
<li><p>创建并返回当前对象的一份拷贝。<strong>Object本身没有实现Cloneable接口</strong>，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</p>
</li>
<li><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
</li>
</ul>
<ul>
<li>toString方法</li>
</ul>
<ul>
<li>Object对象的默认实现，即输出类的名字@实例的哈希码的16进制。</li>
</ul>
<ul>
<li>notify方法：</li>
</ul>
<ul>
<li>唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。</li>
</ul>
<ul>
<li>notifyAll方法</li>
</ul>
<ul>
<li>跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</li>
</ul>
<ul>
<li>wait(long timeout) throws InterruptedException方法</li>
</ul>
<ul>
<li>wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。</li>
</ul>
<ul>
<li>wait(long timeout, int nanos) throws InterruptedException方法</li>
</ul>
<ul>
<li>跟wait(long timeout)方法类似，<strong>多了一个nanos参数，这个参数表示额外时间</strong>（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</li>
</ul>
<ul>
<li><p>wait() throws InterruptedException方法</p>
<p>需要注意的是 wait(0, 0)和wait(0)效果是一样的，即一直等待。</p>
</li>
</ul>
<ul>
<li>跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念。</li>
</ul>
<ul>
<li>finalize方法</li>
</ul>
<ul>
<li>该方法的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。</li>
</ul>
<p><strong>补充：什么是Native Method</strong></p>
<p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<pre><code>public class CloneExample {
    private int a;
    private int b;
}
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</code></pre><p>重写 clone() 得到以下实现：</p>
<pre><code>public class CloneExample {
    private int a;
    private int b;

    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
java.lang.CloneNotSupportedException: CloneExample</code></pre><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<pre><code>public class CloneExample implements Cloneable {
    private int a;
    private int b;

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</code></pre><p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<pre><code>public class ShallowCloneExample implements Cloneable {

    private int[] arr;

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222</code></pre><p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<pre><code>public class DeepCloneExample implements Cloneable {

    private int[] arr;

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }

    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}
DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2</code></pre><p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<pre><code>public class CloneConstructorExample {

    private int[] arr;

    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }

    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>运行时异常：</p>
<pre><code>NullPointerException 空指针异常
ArithmeticException 算术异常，比如除数为零
ClassCastException 类型转换异常
ConcurrentModificationException同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常 
IndexOutOfBoundsException 数组下标越界异常
NegativeArraySizeException 为数组分配的空间是负数异常</code></pre><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p>
<p>Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc3.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc7.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc4.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc6.png" alt=""><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc5.png" alt=""></p>
<h3 id="Error和Exception有什么区别"><a href="#Error和Exception有什么区别" class="headerlink" title="Error和Exception有什么区别?"></a>Error和Exception有什么区别?</h3><p>Error和Exception都实现了Throwable接口</p>
<p>Error指的是JVM层面的错误，比如内存不足OutOfMemoryError</p>
<p>Exception 指的是代码逻辑的异常，比如下标越界OutOfIndexException</p>
<h3 id="throw与throws的区别"><a href="#throw与throws的区别" class="headerlink" title="throw与throws的区别"></a>throw与throws的区别</h3><p>通过上面的两个demo可以得知：</p>
<p>1、throw用在方法体内，上面代码显示了，是直接在main方法体内</p>
<p>   throws用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。这个看上面的代码就理解了</p>
<p>2、throw是具体向外抛异常的，抛出的是一个异常实例</p>
<p>   throws声明了是哪种类型的异常，使它的调用者可以捕获这个异常</p>
<p>3、throw，如果执行了，那么一定是抛出了某种异常了，安生throws表示可能出现，但不一定。</p>
<p>4、同时出现的时候，throws出现在函数头、throw出现在函数体，两种不会由函数去处理，真正的处理由函数的上层调用处理</p>
<h4 id="throws-函数声明"><a href="#throws-函数声明" class="headerlink" title="throws 函数声明"></a>throws 函数声明</h4><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p>
<p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>
<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ExceptionType1<span class="token punctuation">,</span> ExceptionType2<span class="token punctuation">,</span> ExceptionTypeN <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">demo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>
        String s <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NumberFormatException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="for-中try还是for外try"><a href="#for-中try还是for外try" class="headerlink" title="for 中try还是for外try"></a>for 中try还是for外try</h3><p>try放在for循环的里面所有的for循环都会执行，当遇到异常时，抛出异常继续执行；放在外面，当遇到异常时，抛出异常，后面的循环就会终止，并不会执行。</p>
<h3 id="构造函数器-Constructor是否可被override-是否可以继承String类"><a href="#构造函数器-Constructor是否可被override-是否可以继承String类" class="headerlink" title="构造函数器/Constructor是否可被override?是否可以继承String类?"></a>构造函数器/Constructor是否可被override?是否可以继承String类?</h3><p>子类不能继承父类的构造方法，所以就不存在重写父类的构造方法。</p>
<p>String是final修饰的，所以不能够被继承</p>
<h3 id="try-catch-finally-执行顺序"><a href="#try-catch-finally-执行顺序" class="headerlink" title="try catch finally 执行顺序"></a>try catch finally 执行顺序</h3><p>try里的return和finally里的return 都会支持，但是当前方法<strong>只会采纳finally中return的值</strong></p>
<p><a href="https://www.cnblogs.com/superFish2016/p/6687549.html" target="_blank" rel="noopener">https://www.cnblogs.com/superFish2016/p/6687549.html</a></p>
<p><strong>总结以上测试：</strong></p>
<p>1、finally语句总会执行</p>
<p>2、如果try、catch中有return语句，finally中没有return，那么<strong>在finally中去修改除了包装类型和静态变量、全局变量以外的数据</strong>都不会对try、catch中返回的变量有任何的影响（包装类型、静态变量会改变、全局变量）。<strong>但是修改包装类型和静态变量、全局变量，会改变变量的值。</strong></p>
<p>3、尽量不要在finally中使用return语句，如果使用的话，会忽略try、catch中的返回语句，也会忽略try、catch中的异常，屏蔽了错误的发生。</p>
<p>4、finally中避免再次抛出异常，一旦finally中发生异常，代码执行将会抛出finally中的异常信息，try、catch中的异常将被忽略。</p>
<p><strong>所以在实际项目中，finally常常是用来关闭流或者数据库资源的，并不额外做其他操作。</strong></p>
<h3 id="Java中如何进行异常处理"><a href="#Java中如何进行异常处理" class="headerlink" title="Java中如何进行异常处理"></a>Java中如何进行异常处理</h3><h4 id="Java异常的分类和类结构图"><a href="#Java异常的分类和类结构图" class="headerlink" title="Java异常的分类和类结构图"></a>Java异常的分类和类结构图</h4><p>在Java中异常的继承主要有两个： Error和Exception 这两个，而Error就是jvm出现错误，以及系统奔溃等现象这些错误没办法通过程序来处理，所以在程序中不能使用catch来捕捉处理这类的异常。</p>
<p>对于Exception 又可以分为checkedException 和RuntimeException 这两种异常，checkedException异常在进行编译运行之前就可以知道会不会发生异常，如果不对这些异常进行抛出、捕获的话就不能通过编译。而RuntimeException就是运行的时候出现的异常在之前你是没办法确定是不是会出现异常。</p>
<blockquote>
<p>Java的异常处理是通过5个关键字来实现的：try、catch、 finally、throw、throws</p>
</blockquote>
<h4 id="try…catch…finally语句块"><a href="#try…catch…finally语句块" class="headerlink" title="try…catch…finally语句块"></a>try…catch…finally语句块</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">//try块中放可能发生异常的代码。</span>
     <span class="token comment" spellcheck="true">//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span>
     <span class="token comment" spellcheck="true">//如果发生异常，则尝试去匹配catch块。</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span>
    <span class="token comment" spellcheck="true">//catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span>
    <span class="token comment" spellcheck="true">//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span>
    <span class="token comment" spellcheck="true">//如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span>
    <span class="token comment" spellcheck="true">//如果try中没有发生异常，则所有的catch块将被忽略。</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//finally块通常是可选的。</span>
   <span class="token comment" spellcheck="true">//无论异常是否发生，异常是否匹配被处理，finally都会执行。</span>
   <span class="token comment" spellcheck="true">//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span>
  <span class="token comment" spellcheck="true">//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>需要注意的地方</strong></p>
<p>1、try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p>
<p>2、每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。</p>
<p>3、java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。<br>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：resumption model of exception handling（恢复式异常处理模式 ）<br>而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：termination model of exception handling（终结式异常处理模式）</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ol>
<li>不管有没有出现异常，finally块中代码都会执行；</li>
<li>当try和catch中有return时，finally仍然会执行；</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li>
</ol>
<p><strong>举例：</strong></p>
<p>情况1. try{} catch(){}finally{} return;<br>显然程序按顺序执行。</p>
<p>情况2. :try{ return; }catch(){} finally{} return;<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，最后执行try中return;</p>
<p>finally块之后的语句return，因为程序在try中已经return所以不再执行。</p>
<p>情况3. :try{ } catch(){return;} finally{} return;<br>程序先执行try，如果遇到异常执行catch块，<br>有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码，<br>最后执行catch块中return. finally之后也就是4处的代码不再执行。<br>无异常：执行完try再finally再return.</p>
<p>情况4:try{ return; }catch(){} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况5:try{} catch(){return;}finally{return;}<br>程序执行catch块中return之前（包括return语句中的表达式运算）代码；<br>再执行finally块，因为finally块中有return所以提前退出。</p>
<p>情况6:try{ return;}catch(){return;} finally{return;}<br>程序执行try块中return之前（包括return语句中的表达式运算）代码；<br>有异常：执行catch块中return之前（包括return语句中的表达式运算）代码；<br>则再执行finally块，因为finally块中有return所以提前退出。<br>无异常：则再执行finally块，因为finally块中有return所以提前退出。</p>
<p>最终结论：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。<br>如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的，<br>编译器把finally中的return实现为一个warning。</p>
<p>也就是说，如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）如果try catch中有return 就等待fianlly执行完成后再去执行其他的（finally 么有ret）</p>
<p>下面是个测试程序</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FinallyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            x<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>结果是2。<br>    在try语句中，在执行return语句时，要返回的结果已经准备好了，就在此时，程序转到finally执行了。<br>在转去之前，try中先把要返回的结果存放到不同于x的局部变量中去，执行完finally之后，在从中取出返回结果，<br>因此，即使finally中对变量x进行了改变，但是不会影响返回结果。<br>它应该使用栈保存返回值。<br><strong>finally中的return 会覆盖 try 或者catch中的返回值。</strong></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><hr>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li><p>修饰类：表示该类不能被继承</p>
</li>
<li><p>修饰方法：表示该方法不能被重写</p>
</li>
<li><p>修饰变量：表示该变量只能被赋值一次</p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
</li>
</ul>
<ul>
<li><p>对于基本类型，final 使数值不变；</p>
</li>
<li><p>对于引用类型，final 使引用不变，表示该引用只有一次指向对象的机会，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</p>
<ul>
<li>如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。</li>
</ul>
</li>
</ul>
<h4 id="final关键字的好处："><a href="#final关键字的好处：" class="headerlink" title="final关键字的好处："></a>final关键字的好处：</h4><p>（1）final关键字提高了性能。JVM和Java应用都会缓存final变量。</p>
<p>（2）final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</p>
<p>（3）使用final关键字，JVM会对方法、变量及类进行优化。</p>
<h4 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h4><h4 id="final通过反射是否可以修改"><a href="#final通过反射是否可以修改" class="headerlink" title="final通过反射是否可以修改"></a>final通过反射是否可以修改</h4><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>finally 是用于异常处理的场面，无论是否有异常抛出，都会执行</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>finalize是Object的方法，所有类都继承了该方法。 当一个对象满足垃圾回收的条件，并且被回收的时候，其finalize()方法就会被调用</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul>
<li>它的作用是什么？<ul>
<li>instanceof是Java的一个二元操作符，和==，&gt;，&lt;是同一类东西。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据。</li>
</ul>
</li>
<li>使用过程中注意事项有哪些？<ul>
<li>类的实例包含本身的实例，以及所有直接或间接子类的实例</li>
<li>instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误<pre><code>//比如下面就会编译错误
String s = null;
s instanceof null
s instanceof Integer</code></pre></li>
</ul>
</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a><strong>1. 静态变量</strong></h4><ul>
<li><p>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</p>
</li>
<li><p>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p>
</li>
</ul>
<pre><code> public class A {
     private int x;         // 实例变量
     private static int y;  // 静态变量

     public static void main(String[] args) {
         // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
         A a = new A();
         int x = a.x;
         int y = A.y;
    }
}</code></pre><h4 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a><strong>2. 静态方法</strong></h4><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，不能被重写。<strong>所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。</strong></p>
<pre><code>public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
}</code></pre><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>
<pre><code> public class A {
     private static int x;
     private int y;

     public static void func1(){
         int a = x;
         // int b = y;  // Non-static field 'y' cannot be referenced from a static context
         // int b = this.y;     // 'A.this' cannot be referenced from a static context
     }
}</code></pre><h4 id="3-静态语句块"><a href="#3-静态语句块" class="headerlink" title="3. 静态语句块"></a><strong>3. 静态语句块</strong></h4><p><strong>静态语句块在类初始化时运行一次。</strong></p>
<pre><code>public class A {
    static {
        System.out.println("123");
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}</code></pre><h4 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4. 静态内部类"></a><strong>4. 静态内部类</strong></h4><p><strong>非静态内部类依赖于外部类的实例，而静态内部类不需要。</strong></p>
<p>当一个内部类没有使用static修饰的时候，是不能直接使用内部类创建对象，须要先使用外部类对象.new内部类对象及(外部类对象.new 内部类（）)</p>
<p>而静态内部类只需要<code>new OuterClass.InnerClass();</code></p>
<pre><code> public class OuterClass {
     class InnerClass {
     }

     static class StaticInnerClass {
     }

     public static void main(String[] args) {
         // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
</code></pre><p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<h4 id="5-静态导包"><a href="#5-静态导包" class="headerlink" title="5. 静态导包"></a><strong>5. 静态导包</strong></h4><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<pre><code>import static com.xxx.ClassName.*</code></pre><h4 id="6-初始化顺序"><a href="#6-初始化顺序" class="headerlink" title="6. 初始化顺序"></a><strong>6. 初始化顺序</strong></h4><p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li><p>父类（静态变量、静态语句块）</p>
</li>
<li><p>子类（静态变量、静态语句块）</p>
</li>
<li><p>父类（实例变量、普通语句块）</p>
</li>
<li><p>父类（构造函数）</p>
</li>
<li><p>子类（实例变量、普通语句块）</p>
</li>
<li><p>子类（构造函数）</p>
</li>
</ul>
<h4 id="static关键字的特点"><a href="#static关键字的特点" class="headerlink" title="static关键字的特点"></a>static关键字的特点</h4><ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>被类的所有对象共享</li>
<li>可以通过类名调用【静态修饰的内容一般我们称其为：与类相关的，类成员】</li>
<li><strong>static的注意事项</strong><ul>
<li>在静态方法中是没有this关键字的</li>
<li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li>
<li>静态比对象先存在。博客</li>
<li>静态方法只能访问静态的成员变量和静态的成员方法【静态只能访问静态,非静态可以访问静态的也可以访问非静态的】</li>
</ul>
</li>
</ul>
<h4 id="static变量存储位置"><a href="#static变量存储位置" class="headerlink" title="static变量存储位置"></a>static变量存储位置</h4><ul>
<li>注意是：存储在JVM的方法区中</li>
<li>static变量在类加载时被初始化，存储在JVM的方法区中，整个内存中只有一个static变量的拷贝，可以使用类名直接访问，也可以通过类的实例化对象访问，一般不推荐通过实例化对象访问，通俗的讲static变量属于类，不属于对象，任何实例化的对象访问的都是同一个static变量，任何地放都可以通过类名来访问static变量。</li>
</ul>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><ul>
<li>通过在属性前面加上transient关键字，限制属性写入到文件或网络中</li>
<li>还可以在未实现系列化接口的引用类型属性前面加上transient关键字，避免对此类属性进行递归系列化时出现java.io.NotSerializableException异常</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">transient</span> String name<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加一个transient修饰的属性</span></code></pre>
<p>什么被序列化<br>属性（包括基本数据类型、数组、对其它对象的引用）<br>类名<br>什么不被序列化<br>static的属性<br>方法<br>加了transient修饰符的属性</p>
<h3 id="hascode"><a href="#hascode" class="headerlink" title="hascode"></a>hascode</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>根据这个方法的声明可知，它是一个本地方法，它的实现与本地机器有关，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。</p>
<p>对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及Hashtable，如果没有很好的覆写键的hashcode()和equals()方法，那么将无法正确的处理键。</p>
<p>　也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）—–HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。</p>
<p>所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。</p>
<h3 id="System-currentTimeMillis"><a href="#System-currentTimeMillis" class="headerlink" title="System.currentTimeMillis()"></a>System.currentTimeMillis()</h3><p>System位于java.lang包下，有很多可以获取到系统底层的东西：</p>
<p>System类本意就代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
<p>currentTimeMillis方法</p>
<pre><code>public static long currentTimeMillis()</code></pre><p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<p>可以直接把这个方法强制转换成date类型。</p>
<p>代码如下：</p>
<pre><code>long currentTime = System.currentTimeMillis();

SimpleDateFormat formatter = new SimpleDateFormat("yyyy年-MM月dd日-HH时mm分ss秒");

Date date = new Date(currentTime);

System.out.println(formatter.format(date));</code></pre><p>运行结果如下：</p>
<pre><code>当前时间:2017年-12月19日-10时14分28秒</code></pre><p>另：</p>
<p>可获得当前的系统和用户属性：</p>
<pre><code>String osName = System.getProperty(“os.name”);

String user = System.getProperty(“user.name”);

System.out.println(“当前操作系统是：” + osName);

System.out.println(“当前用户是：” + user);
</code></pre><p>System.getProperty 这个方法可以得到很多系统的属性。</p>
<h3 id="heap和stack有什么区别"><a href="#heap和stack有什么区别" class="headerlink" title="heap和stack有什么区别"></a>heap和stack有什么区别</h3><p>heap: 堆</p>
<p>stack: 栈</p>
<ul>
<li>存放的内容不一样：<ul>
<li>heap: 是存放对象的</li>
<li>stack: 是存放基本类型(int, float, boolean 等等)、引用(对象地址)、方法调用</li>
</ul>
</li>
<li>存取方式不一样：<ul>
<li>heap: 是自动增加大小的，所以不需要指定大小，但是存取相对较慢</li>
<li>stack: 先入后出的顺序，并且存取速度比较快</li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>每个类都有一个  <strong>Class</strong>  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName("com.mysql.jdbc.Driver")</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><p><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</p>
</li>
<li><p><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</p>
</li>
<li><p><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</p>
</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><p><strong>可扩展性</strong>  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</p>
</li>
<li><p><strong>类浏览器和可视化开发环境</strong>  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</p>
</li>
<li><p><strong>调试器和测试工具</strong>  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</p>
</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li><p><strong>性能开销</strong>  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li><p><strong>安全限制</strong>  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li><p><strong>内部暴露</strong>  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
<li><p>Trail: The Reflection API</p>
</li>
<li><p>深入解析 Java 反射（1）- 基础</p>
</li>
</ul>
<h3 id="什么是java序列化，如何实现java序列化？"><a href="#什么是java序列化，如何实现java序列化？" class="headerlink" title="什么是java序列化，如何实现java序列化？"></a>什么是java序列化，如何实现java序列化？</h3><p>序列化指的是把一个Java对象，通过某种介质进行传输，比如Socket输入输出流，或者保存在一个文件里。</p>
<p>实现java序列化的手段是让该类实现接口 Serializable，这个接口是一个标识性接口，没有任何方法，仅仅用于表示该类可以序列化。</p>
<p><strong>JAVA序列化ID问题</strong></p>
<p><a href="https://blog.csdn.net/qq_35370263/article/details/79482993" target="_blank" rel="noopener">https://blog.csdn.net/qq_35370263/article/details/79482993</a></p>
<p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单 1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p>
<h2 id="集合框架（容器）"><a href="#集合框架（容器）" class="headerlink" title="集合框架（容器）"></a>集合框架（容器）</h2><p><strong>什么是集合</strong></p>
<blockquote>
<p>通常情况下，把具有相同性质的一类东西，汇聚成一个整体，就可以称为集合。</p>
</blockquote>
<p><strong>什么是集合框架</strong></p>
<blockquote>
<p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p>
</blockquote>
<ul>
<li>接口：即表示集合的抽象数据类型。</li>
<li>实现：也就是集合框架中接口的具体实现。</li>
<li>算法：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Java集合框架图。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc14.png" alt=""></p>
<p>1) 首先查看jdk中Collection类的源码后:</p>
<pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {</code></pre><p>通过查看可以发现Collection是一个接口类，其继承了java迭代接口Iterable</p>
<p><strong>Collection接口中的方法如下:</strong><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc13.png" alt=""></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="List-三个子类的区别"><a href="#List-三个子类的区别" class="headerlink" title="List 三个子类的区别"></a>List 三个子类的区别</h4><p>ArrayList：底层使用object[]数组实现，内存地址都是连续的便于索引，查询快；在新增的时候需要申请一块连续的内存空间，所以增删比较慢。</p>
<p>LinkedList: 底层是基于链表实现，链表内存是散乱的，在储存自身内存地址的<br>同时，还储存着下一个元素的内存地址，所以查询慢，增删快。</p>
<p>Vector：底层数组实现，由于所有的方法都是采用synchronize，线程安全，效率慢。</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong>Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0(JDK1.8首次new的时候为0，当第一次添加的时候扩容为10)，JDK差异，每次约按1.5倍扩容。 JDK8 中ArrayList扩容的实现是通过grow()方法里使用语句newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)（即1.5倍扩容）计算容量，然后调用Arrays.copyof()方法进行对原数组进行复制。</strong></p>
<p><strong>若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</strong></p>
<ul>
<li><p>ArrayList底层其实就是一个Object类型的数组，非线程安全的集合。查询元素快，插入，删除中间元素慢，初始化的长度为10，每次扩容为原大小的1.5倍，可以通过构造方法改变初始容量大小。</p>
</li>
<li><p>ArrayList快在下标定位，慢在数组复制。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p>
</li>
<li><p>由于每次添加的时候，通过扩容机制判断原数组是否还有空间，若没有则重新实例化一个空间更大的新数组，把旧数组的数据拷贝到新数组中，耗费时间和性能</p>
</li>
<li><p>扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
</li>
</ul>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><h5 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h5><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setArray</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    array <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> E <span class="token function">get</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h5><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<p>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</p>
<p>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。<br>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote>
<p><font size="3"> 基于数组实现的线程安全的集合。线程同步（方法被synchronized修饰），性能比ArrayList差。 </font></p>
</blockquote>
<p>Vector 的数据结构和使用方法与ArrayList差不多。最大的不同就是Vector是线程安全的。几乎所有的对数据操作的方法都被synchronized关键字修饰。synchronized是线程同步的，当一个线程已经获得Vector对象的锁时，其他线程必须等待直到该锁被释放。从这里就可以得知Vector的性能要比ArrayList低。<br>若想要一个高性能，又是线程安全的ArrayList，可以使用Collections.synchronizedList(list);方法或者使用CopyOnWriteArrayList集合</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>基于双向循环链表实现的非线程安全的集合。查询元素慢，插入，删除中间元素快。</p>
<p><strong>数组是将元素在内存中连续存储的；它的优点：</strong>因为数据是<strong>连续存储</strong>的，<strong>内存地址连续</strong>，所以在查找数据的时候<strong>效率比较高</strong>；<strong>它的缺点</strong>：在存储之前，我们需要申请一块<strong>连续的内存空间</strong>，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据量比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低链表是动态申请内存空间，不需要像数组需要提前申请好内存的大小，<strong>链表只需在用的时候申请就可以</strong>，根据需<br>要来<strong>动态申请或者删除内存空间</strong>，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</p>
<h4 id="几种集合的区别"><a href="#几种集合的区别" class="headerlink" title="几种集合的区别"></a>几种集合的区别</h4><p>ArrayList查询快，写数据慢；LinkedList查询慢，写数据快<br>ArrayList查询快是因为底层是由数组实现，new的内存地址是连续的，通过下标定位数据快。写数据慢是因为复制数组耗时。LinkedList底层是双向循环链表，查询数据依次遍历慢。写数据只需修改指针引用。<br>ArrayList和LinkedList都不是线程安全的，小并发量的情况下可以使用Vector，若并发量很多，且读多写少可以考虑使用CopyOnWriteArrayList。</p>
<h4 id="遍历list集合"><a href="#遍历list集合" class="headerlink" title="遍历list集合"></a>遍历list集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * for循环遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * foreach遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 通过迭代器遍历
     */</span>
    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><a href="https://blog.csdn.net/qq_33642117/article/details/52040345" target="_blank" rel="noopener">https://blog.csdn.net/qq_33642117/article/details/52040345</a></p>
<blockquote>
<p>在选择的时候，如果顺序很重要，则可以选择TreeSet，如果操作性能和时间效率很重要的话，则可以选择HashSet</p>
</blockquote>
<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><blockquote>
<p>HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得，顺序不同</p>
</blockquote>
<blockquote>
<p>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置，存取速度比较快。</p>
</blockquote>
<ul>
<li>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树，底层实际上是一个HashMap。</li>
<li>所以可以直接总结出：HashSet实际上就是封装了HashMap，操作HashSet元素实际上就是操作HashMap。这也是面向对象的一种体现，重用性贼高！</li>
<li>无序，允许为null，，有且仅有一个元素为null！</li>
<li>线程不安全的。</li>
<li>HashSet还有一个子类LinkedHashSet</li>
</ul>
<blockquote>
<p><strong>HashSet到底是如何判断两个元素重复。</strong></p>
</blockquote>
<p>原来，HashSet是将数据存放到HashMap的Key中！HashMap是key-value形式的数据结构，它的key是唯一的。而HashSet原理就是利用HashMap key唯一的特点。</p>
<p><strong>HashMap中如何实现key的唯一性？</strong><br>当key-value键值对插入到HashMap中。</p>
<p>首先是对key值哈希，得到key在哈希数组中的下标。HashMap中哈希是调用对象key的hashCode()方法，然后再做异或处理。</p>
<p>如果当前下标上已经有值，说明有两个元素的映射到相同的下标。此时，需要第二次判断，调用key对象的equals方法，对象不相同则插入链表的表尾，对象相同则覆盖。</p>
<h4 id="TreeSet集合"><a href="#TreeSet集合" class="headerlink" title="TreeSet集合"></a>TreeSet集合</h4><ul>
<li>底层数据结构是红黑树(是一个自平衡的二叉树)</li>
<li>有排序功能，支持两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</li>
<li>有序，不允许为null</li>
<li>线程不安全的。</li>
<li><strong>当要排序的为一个对象时，需要通过重写进行排序</strong></li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>既然TreeSet可以自然排序,那么TreeSet必定是有排序规则的。</p>
<p>1:让存入的元素自定义比较规则。</p>
<p>2:给TreeSet指定排序规则。</p>
<p>方式一：元素自身具备比较性</p>
<p>元素自身具备比较性，需要元素实现Comparable接口，重写compareTo方法，也就是让元素自身具备比较性，这种方式叫做元素的自然排序也叫做默认排序。</p>
<p>方式二：容器具备比较性</p>
<p>当元素自身不具备比较性，或者自身具备的比较性不是所需要的。那么此时可以让容器自身具备。需要定义一个类实现接口Comparator，重写compare方法，并将该接口的子类实例对象作为参数传递给TreeMap集合的构造方法。</p>
<p>注意：当Comparable比较方式和Comparator比较方式同时存在时，以Comparator的比较方式为主；</p>
<p>注意：在重写compareTo或者compare方法时，必须要明确比较的主要条件相等时要比较次要条件。（假设姓名和年龄一直的人为相同的人，如果想要对人按照年龄的大小来排序，如果年龄相同的人，需要如何处理？不能直接return 0，因为可能姓名不同（年龄相同姓名不同的人是不同的人）。此时就需要进行次要条件判断（需要判断姓名），只有姓名和年龄同时相等的才可以返回0.）</p>
<h4 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h4><ul>
<li>迭代是有序的</li>
<li>允许为null，有且仅有一个元素为null！</li>
<li>底层实际上是一个HashMap+双向链表实例(其实就是LinkedHashMap)</li>
<li>线程不安全的。</li>
<li>性能比HashSet差一丢丢，因为要维护一个双向链表</li>
<li>初始容量与迭代无关，LinkedHashSet迭代的是双向链表</li>
</ul>
<h4 id="适用场景分析"><a href="#适用场景分析" class="headerlink" title="适用场景分析"></a>适用场景分析</h4><blockquote>
<p>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p>
</blockquote>
<h4 id="遍历set集合"><a href="#遍历set集合" class="headerlink" title="遍历set集合"></a>遍历set集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 迭代器遍历方式
     */</span>
    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 遍历
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String str<span class="token operator">:</span> set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="set-和list的区别"><a href="#set-和list的区别" class="headerlink" title="set 和list的区别"></a>set 和list的区别</h3><ul>
<li>List接口：存储一组不唯一，有序的对象</li>
<li>Set接口：存储一组唯一，无序的对象</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><a href="https://www.javazhiyin.com/54393.html" target="_blank" rel="noopener">https://www.javazhiyin.com/54393.html</a></p>
<p><strong>Map接口不是继承Collection接口；Map接口用于维护键／值对（key/value pairs），他的实现类有:</strong><br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc36.png" alt=""></p>
<h4 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc16.png" alt=""></p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><strong>底层是哈希表数据结构，线程是不同步的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法。</strong></p>
<h5 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h5><blockquote>
<p><strong>JDK1.8之前</strong></p>
</blockquote>
<p>JDK1.8 之前 HashMap 由 <strong>数组+链表</strong> 组成的（<strong>“链表散列”</strong> 即数组和链表的结合体），数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（HashMap 采用 “拉链法也就是链地址法” 解决冲突），如果定位到的数组位置不含链表（当前 entry 的 next 指向 null ）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为 O(1)，因为最新的 Entry 会插入链表头部(<strong>Java 7存入链表头部，Java 8存入链表尾部</strong>)，即需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过 key 对象的 equals 方法逐一比对查找.</p>
<blockquote>
<p>所谓 <strong>“拉链法”</strong> 就是将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc35.png" alt=""></p>
<blockquote>
<p><strong>JDK1.8之后</strong></p>
</blockquote>
<p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（<strong>默认为8</strong>）时，<strong>将链表转化为红黑树</strong>，<strong>以减少搜索时间</strong>。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc35.jpeg" alt=""></p>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p>! 从Hashtable的命名规范就可以看出，t没有大写，并不是我写错了</p>
<p>数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的，不可以存入null键null值。该集合是线程同步的。</p>
<p><strong>它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</strong></p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>底层是二叉树数据结构。线程不同步。可以用于给map集合中的键进行排序。</p>
<h4 id="LinkedHashMap："><a href="#LinkedHashMap：" class="headerlink" title="LinkedHashMap："></a>LinkedHashMap：</h4><p>该子类基于哈希表又融入了链表。可以Map集合进行增删提高效率。</p>
<p>LinkedHashMap是一个根据某种规则有序的hashmap。根据名字，我们也可以看出这个集合是有hash散列的功能的同时也有顺序。hashmap是无法根据某种顺序来访问数据的，例如放入集合的元素先后的顺序。list都有这个功能，可以根据放入集合的先后来访问具体的数据。</p>
<p><a href="https://www.javazhiyin.com/34466.html" target="_blank" rel="noopener">https://www.javazhiyin.com/34466.html</a></p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>1.8之前ConcurrentHashMap 底层采用 <strong>分段的数组+链表 实现</strong>，该类是线程安全的 Map 实现。与 Hashtable 相似，但 Hashtable 的 synchronized 是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对 hash 表的不同部分进行的修改。ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<p>到了 JDK1.8 的时候已经<strong>摒弃了Segment</strong>的概念，而是直接用 <strong>Node 数组+链表/红黑树</strong>的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<blockquote>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
</blockquote>
<p>JDK1.7的ConcurrentHashMap：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc37.jpg" alt=""></p>
<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点；Node: 链表节点）：<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc38.png" alt=""></p>
<p><a href="https://www.cnblogs.com/huangjuncong/p/9478505.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangjuncong/p/9478505.html</a></p>
<h4 id="遍历map集合"><a href="#遍历map集合" class="headerlink" title="遍历map集合"></a>遍历map集合</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 第二种
     */</span>
    <span class="token comment" spellcheck="true">//遍历map中的键</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//遍历map中的值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String value <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * 迭代器
     */</span>
    Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> entries <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>entries<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> entry <span class="token operator">=</span> entries<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * 通过键找值遍历（效率低）
     */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String value <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">", Value = "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>容器指的是集合框架</p>
<p>同步容器是通过syncrhoized关键字对线程不安全的操作进行加锁来保证线程安全的，其原理是使得多线程轮流获取同步锁进行对集合的操作，所以性能有所下降。，像Vector、Hashtable、Stack。</p>
<p> 为此，java.util.concurrent提供了多种并发容器，以：在原有集合的拷贝上进行操作，用修改后的集合替换原集合  的方式来达到并发且安全地使用集合类的目的。</p>
<pre><code>根据接口的类型，主要有以下四种接口，其他具体的容器均是对这些接口的实现类：</code></pre><p>Queue类型：阻塞队列BlockingQueue、非阻塞队列ConcurrentLinkedQueue</p>
<p>Map类型：ConcurrentMap</p>
<p>Set类型：ConcurrentSkipListSet、CopyOnWriteArraySet</p>
<p>List类型：CopyOnWriteArrayList</p>
<h4 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h4><font size="3">

<p>　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>　　<br>　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
</font>


<h3 id="集合面试问题"><a href="#集合面试问题" class="headerlink" title="集合面试问题"></a>集合面试问题</h3><h4 id="Collection-和-Collections的区别"><a href="#Collection-和-Collections的区别" class="headerlink" title="Collection 和 Collections的区别"></a>Collection 和 Collections的区别</h4><hr>
<p>Collection是接口，是List和Set的父接口</p>
<p>Collections是工具类，提供了排序，混淆等等很多实用方法</p>
<h4 id="Comparable-接口和-Comparator-接口有什么区别？"><a href="#Comparable-接口和-Comparator-接口有什么区别？" class="headerlink" title="Comparable 接口和 Comparator 接口有什么区别？"></a>Comparable 接口和 Comparator 接口有什么区别？</h4><hr>
<p>答：<br>详细可以看：<a href="https://blog.csdn.net/u011240877/article/details/53399019" target="_blank" rel="noopener">https://blog.csdn.net/u011240877/article/details/53399019</a></p>
<ul>
<li><p>对于一些普通的数据类型（比如 String, Integer, Double…），<strong>它们默认实现了Comparable 接口，实现了 compareTo 方法，我们可以直接使用。</strong></p>
</li>
<li><p>而对于一些自定义类，它们可能在不同情况下需要实现不同的比较策略，我们可以新创建 Comparator 接口，然后使用特定的 Comparator 实现进行比较。</p>
</li>
</ul>
<p><strong>对比：</strong></p>
<ul>
<li><p>Comparable简单，但是如果需要重新定义比较类型时，需要修改源代码。</p>
</li>
<li><p>Comparator不需要修改源代码，自定义一个比较器，实现自定义的比较方法。</p>
</li>
</ul>
<h4 id="Java-集合的快速失败机制-“fail-fast”"><a href="#Java-集合的快速失败机制-“fail-fast”" class="headerlink" title="Java 集合的快速失败机制 “fail-fast”"></a>Java 集合的快速失败机制 “fail-fast”</h4><hr>
<p>答：</p>
<p>它是 java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>
<p>可以知道<strong>在进行add，remove，clear等涉及到修改集合中的元素个数的操作时</strong>，modCount就会发生改变(modCount ++),所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化</p>
<p>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>解决办法：</p>
<ol>
<li><p>在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized；</p>
</li>
<li><p>使用 CopyOnWriteArrayList 来替换 ArrayList。</p>
</li>
</ol>
<p><strong>java.util.concurrent包中包含的并发集合类如下：</strong></p>
<p>详细：<a href="http://raychase.iteye.com/blog/1998965" target="_blank" rel="noopener">http://raychase.iteye.com/blog/1998965</a></p>
<pre><code>1ConcurrentHashMap23CopyOnWriteArrayList45CopyOnWriteArraySet</code></pre><h2 id="java日期处理-数学处理"><a href="#java日期处理-数学处理" class="headerlink" title="java日期处理 数学处理"></a>java日期处理 数学处理</h2><h3 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h3><blockquote>
<p>Date类用来指定日期和时间，其构造函数及常用方法如下：<br><br>public Date()从当前时间构造日期时间对象。<br><br>public String toString()转换成字符串。<br><br>public long getTime()它包含的是一个长整型数据long, 表示的是从GMT(格林尼治标准时间)1970年, 1 月 1日00:00:00这一刻之前或者是之后经历的毫秒数.</p>
</blockquote>
<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><blockquote>
<p>通过向SimpleDateFormat 的构造函数传递格式字符串“yyyy-MM-dd”,<br>yyyy是年,MM是月,dd是日. 字符的个数决定了日期是如何格式化的.传递“yy-MM-dd”会显示 13-2-22</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc11.png" alt=""></p>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><blockquote>
<p>Calendar类主要用于完成日期字段之间的相互操作的功能 <br><br>Calendar类是一个抽象基类,不能new，我们可以通过Calendar.getInstance得到其实例，下面列出Calendar的一些常用方法：<br><br>set(int year, int month, int date)设置日历字段 <br><br>set(int field, int value) 将给定的日历字段设置为给定值 <br><br>get(int field)返回给定日历字段的值 <br><br>getTime()返回一个表示此 Calendar 时间值（从历元至现在的毫秒偏移量）的 Date 对象。</p>
</blockquote>
<p>如果是1则代表的是对年份操作，2是对月份操作，3是对星期操作，5是对日期操作，11是对小时操作，12是对分钟操作，13是对秒操作，14是对毫秒操作。例如：Calendar calendar = Calendar.getInstance(); calendar .add(5,1);则表示对日期进行加一天操作</p>
<h4 id="Calendar示例"><a href="#Calendar示例" class="headerlink" title="Calendar示例"></a>Calendar示例</h4><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc10.png" alt=""></p>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><ul>
<li>abs()返回某数字的绝对值.</li>
<li>ceil()会找到下一个最大整数。</li>
<li>floor()返回紧邻的最小整数。</li>
<li>max()返回两个值中的最大值。</li>
<li>min()返回两个值中的最小值。</li>
<li>random()返回一个随机数，在0.0到1.0之间的双精度数。</li>
<li>round()返回与某浮点数值最接近的整数值。</li>
<li>sqrt()返回某数值的平方根。</li>
</ul>
<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><blockquote>
<p>Random类 伪随机数产生器。</p>
</blockquote>
<p>常用方法:</p>
<ul>
<li>public boolean nextBoolean()<br>该方法的作用是生成一个随机的boolean值。</li>
<li>public double nextDouble()<br>该方法的作用是生成一个随机的double值，数值介于[0,1.0)之间。</li>
<li>public int nextInt()<br>该方法的作用是生成一个随机的int值。</li>
<li>public int nextInt(int n)<br>该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。</li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * 将日期解析为指定格式的字符串
     */</span>
    Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    SimpleDateFormat simpleDateFormat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>simpleDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 将字符串解析为日期对象
     */</span>
    SimpleDateFormat sim <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String ss <span class="token operator">=</span> <span class="token string">"2020-01-01"</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Date parse <span class="token operator">=</span> sim<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parse<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sim<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>parse<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ParseException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">/**
     * Calendar使用
     */</span>
    Calendar calendar <span class="token operator">=</span> Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Date time <span class="token operator">=</span> calendar<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 设置日期
     */</span>
    calendar<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * Random随机数
     */</span>
    Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc12.png" alt=""></p>
<h2 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h2><p>Java中使用IO(输入输出）来读取和写入，读写设备上的数据、硬盘文件、内存、键盘……，根据数据的走向可分为输入流和输出流，这个走向是以内存为基准的，即往内存中读数据是输入流，从内存中往外写是输出流。</p>
<h4 id="IO-介绍"><a href="#IO-介绍" class="headerlink" title="IO 介绍"></a>IO 介绍</h4><p>我们通常所说的 BIO 是相对于 NIO 来说的，BIO 也就是 Java 开始之初推出的 IO 操作模块，BIO 是 BlockingIO 的缩写，顾名思义就是阻塞 IO 的意思。</p>
<p><strong>根据处理的数据类型可分为字节流和字符流</strong></p>
<p>  1.字节流可以处理所有数据类型的数据，在java中以Stream结尾</p>
<p>  2.字符流处理文本数据，在java中以Reader和Writer结尾。<br><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc17.png" alt=""></p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="输入流-InputStream"><a href="#输入流-InputStream" class="headerlink" title="输入流 InputStream"></a>输入流 InputStream</h4><p><strong>API</strong></p>
<ul>
<li>int read( )    读取一个字节，返回值为所读的字节</li>
<li>int read( byte b[ ] )   读取多个字节，放置到字节数组b中，通常读取的字节数量为b的长度，返回值为实际读取的字节的数量</li>
<li>int read( byte b[ ], int off, int len )   读取len个字节，放置到以下标off开始字节数组b中，返回值为实际读取的字节的数量</li>
<li>int available( )   返回值为流中尚未读取的字节的数量</li>
<li>long skip( long n )   读指针跳过n个字节不读，返回值为实际跳过的字节数量</li>
<li>close( )   流操作完毕后必须关闭</li>
</ul>
<p>代码</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    InputStream inputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将读取到的一个字节给i，中文占两个字节</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<h4 id="输出流-OutputStream"><a href="#输出流-OutputStream" class="headerlink" title="输出流 OutputStream"></a>输出流 OutputStream</h4><p><strong>API</strong></p>
<ul>
<li>void write( int b ); 　　//往流中写一个字节b</li>
<li>void write( byte b[ ] ); //往流中写一个字节数组b</li>
<li>void write( byte b[ ], int off, int len );  把字节数组b中从下标off开始，长度为len的字节写入流中</li>
<li>flush( )  刷空输出流，并输出所有被缓存的字节由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中。</li>
<li>close( ) 流操作完毕后必须关闭 </li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 没有则会创建文件</span>
    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    OutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        os<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"超哥"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="输入流-Reader"><a href="#输入流-Reader" class="headerlink" title="输入流 Reader"></a>输入流 Reader</h4><p><strong>API</strong></p>
<ul>
<li>int read() throws IOException;  读取一个字符，返回值为读取的字符</li>
<li>int read(char cbuf [  ]) throws IOException; 读取一系列字符到数组cbuf[]中，返回值为实际读取的字符的数量</li>
<li>abstract int read( char cbuf[ ] , int off , int len) throws IOException;   读取len个字符，从数组cbuf[]的下标off处开始存放，返回值为实际读取的字符数量，该方法必须由子类实现</li>
<li>boolean markSupported( ); 判断当前流是否支持做标记</li>
<li>void mark ( int readAheadLimit ) throws IOException;   给当前流作标记，最多支持readAheadLimit个字符的回溯。</li>
<li>void reset( ) throws IOException;    将当前流重置到做标记处</li>
<li>abstract void close( ) throws IOException;   关闭</li>
</ul>
<p><strong>代码</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Reader os <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span>file2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 关闭流</span>
            os<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="输出流-Writer"><a href="#输出流-Writer" class="headerlink" title="输出流 Writer"></a>输出流 Writer</h4><p><strong>API</strong></p>
<ul>
<li>void write (int c) throws IOException； 将整型值c的低16位写入输出流</li>
<li>void write ( String str ) throws IOException； 将字符串str中的字符写入输出流</li>
<li>void write( char cbuf[ ] )  throws IOException；  将字符数组cbuf[]写入输出流</li>
<li>abstract void write( char cbuf[ ] , int off , int len) throws IOException； 将字符数组cbuf[]中的从索引为off的位置处开始的len个字符写入输出流</li>
<li>void write( String str , int off , int len) throws IOException；  将字符串str 中从索引off开始处的len个字符写入输出流</li>
<li>flush( )   刷空输出流，并输出所有被缓存的字节。</li>
<li>close( )  关闭流</li>
</ul>
<h3 id="字节、字符流转换类"><a href="#字节、字符流转换类" class="headerlink" title="字节、字符流转换类"></a>字节、字符流转换类</h3><p>字节转为字符流</p>
<blockquote>
<p>字符 不需要转为字节流，字节流可以读取任意数据，而字符读取内容有限。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将字节流转换为字符流</span>
        InputStreamReader isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="缓冲流介绍"><a href="#缓冲流介绍" class="headerlink" title="缓冲流介绍"></a>缓冲流介绍</h4><blockquote>
<p>普通的字节、字符流都是一个字节一个字符这样读取的,而缓冲流则是将数据先缓冲起来,然后一起写入或者读取出来。<br>缓冲流为I/O流增加了内存缓冲区，使用缓冲流的好处是，能够更高效的读写信息。缓冲流要“套接”在相应的节点流(低级流)之上，对读写的数据提供了缓冲的功能。<br>缓冲输入流支持其父类的mark()和reset()方法：mark()用于“标记”当前位置，就像加入了一个书签，可以使用reset()方法返回这个标记重新读取数据</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java3.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将该文件以字节流的方式读取</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 字节缓冲流</span>
        BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fis<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>J2SDK提供了四种缓存流：<br><font size="4"><br><strong>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter</strong> </font></p>
<h4 id="缓冲流字节流"><a href="#缓冲流字节流" class="headerlink" title="缓冲流字节流"></a>缓冲流字节流</h4><pre><code>java.io.BufferedInputStream类可以对任何的InputStream流进行带缓冲的封装以达到性能的改善。该类在已定义输入流上再定义一个具有缓冲的输入流，可以从此流中成批地读取字符而不会每次都引起直接对数据源的读操作。数据输入时，首先被放入缓冲区，随后的读操作就是对缓冲区中的内容进行访问
java.io.BufferedOutputStream不直接写入输出流，先写入缓冲区，当缓冲区满时，字节数据才会写到BufferedOutputStream所连接的流，调用该类的flush()将缓冲区全部写入输出流</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="对象序列化概述"><a href="#对象序列化概述" class="headerlink" title="对象序列化概述"></a>对象序列化概述</h4><blockquote>
<p>一般地，对象不能脱离应用程序。但有时候，需要将对象的状态保存下来，在需要时再将对象恢复，即对象持久化（Persistence）。对象序列化（Object Serialization）可以将对象存储到外存中或以二进制形式通过网络传输。对象反串行化可以从这些数据中重构一个与原始对象状态相同的对象<br>为了实现对象系列化，对应的类必须实现下面的两种接口之一：<br>Serializable<br>Externalizable</p>
</blockquote>
<h4 id="将对象保存到磁盘文件"><a href="#将对象保存到磁盘文件" class="headerlink" title="将对象保存到磁盘文件"></a>将对象保存到磁盘文件</h4><ul>
<li>通过java.io.ObjectOutputStream可以将对象输出到磁盘文件、网络等设备</li>
<li>调用这个类的writeObject()方法，可以向特定的文件或网络输出对象</li>
<li>writeObject()方法序列化指定的对象，并遍历该对象对其它对象的引用，递归的序列化所有被引用到的其它对象，从而建立一个完整的序列化流</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        OutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Student需要序列化</span>
        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">setI</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="从磁盘读出保存的对象"><a href="#从磁盘读出保存的对象" class="headerlink" title="从磁盘读出保存的对象"></a>从磁盘读出保存的对象</h4><ul>
<li>通过java.io.ObjectInputStream对象可以从磁盘文件中读出保存的对象（或从网络中读出传递的对象）</li>
<li>调用这个类的readObject()方法，从特定的设备读出对象readObject()方法反序列化输入流中的对象，遍历该对象中所有对其它对象的引用，并递归的反序列化这些引用对象</li>
<li>readObject()方法返回的是Object对象，所以，需要对它进行必要的（向下）造型操作。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test9</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/java2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Student student <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a>BIO、NIO、AIO的区别</h4><p><a href="https://my.oschina.net/u/3471412/blog/2966696" target="_blank" rel="noopener">https://my.oschina.net/u/3471412/blog/2966696</a></p>
<ol>
<li>BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ol>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket又称“套接字”，应用程序通常通过“套接字”向网络发出请求或者应答网络请求。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h1>
详看java多线程基础笔记 和 线程池队列文章 （包含 线程 线程池 队列） ,本篇包含大概
</h1>

<p><a href="https://www.cnblogs.com/yjd_hycf_space/p/7526608.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/7526608.html</a></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc19.png" alt="image"></p>
<h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><table>
<thead>
<tr>
<th>术语</th>
<th>英文单词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>共享变量</td>
<td></td>
<td>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。</td>
</tr>
<tr>
<td>内存屏障</td>
<td>Memory Barriers</td>
<td>是一组处理器指令，用于实现对内存操作的顺序限制。</td>
</tr>
<tr>
<td>缓冲行</td>
<td>Cache line</td>
<td>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。</td>
</tr>
<tr>
<td>原子操作</td>
<td>Atomic operations</td>
<td>不可中断的一个或一系列操作。</td>
</tr>
<tr>
<td>缓存行填充</td>
<td>cache line fill</td>
<td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有）</td>
</tr>
<tr>
<td>缓存命中</td>
<td>cache hit</td>
<td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。</td>
</tr>
<tr>
<td>写命中</td>
<td>write hit</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。</td>
</tr>
<tr>
<td>写缺失</td>
<td>write misses the cache</td>
<td>一个有效的缓存行被写入到不存在的内存区域。</td>
</tr>
</tbody></table>
<p><strong>什么是进程</strong></p>
<p>进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程，或者更专业化来说：进程是指程序执行时的一个实例。</p>
<p><strong>进程时间片的概念</strong></p>
<p>一个操作系统中，如果同时运行着多个进程，他们是一定交替运行的。每个进程不管有没有运行完毕，都只占据一段时间的CPU。<br>这个运行时间就是进程时间片。它非常短促，所以感觉不到他们是交替占用CPU。</p>
<p><strong>什么是线程</strong></p>
<ul>
<li><p>线程：进程内部的控制流。它也是一段可运行的指令。</p>
</li>
<li><p>特点：资源占用小，线程间通信容易。</p>
</li>
<li><p>多进程是指操作系统能同时运行多个任务（程序）。</p>
</li>
</ul>
<p>多线程：</p>
<pre><code>指的是这个程序（一个进程）运行时产生了不止一个线程</code></pre><h3 id="线程进程的区别体现在几个方面："><a href="#线程进程的区别体现在几个方面：" class="headerlink" title="线程进程的区别体现在几个方面："></a>线程进程的区别体现在几个方面：</h3><p>第一：  因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p>
<p>第二：  体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。</p>
<p>3.属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。</p>
<p>4.线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；</p>
<p>5.线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；</p>
<p>第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p>
<p>并行与并发：</p>
<pre><code>1.    并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
2.    并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，
那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。
并发性（concurrency）和并行性（parallel）
</code></pre><p><strong>线程的特点</strong></p>
<ul>
<li>线程的运行方式和进程一样，在同一个进程内部，线程也是交替占用CPU。每个线程的运行时间，称为线程时间片。</li>
<li>线程有开始、中间和结束部分，即有一定的生命周期。</li>
<li>同一个进程中的多个线程是共享一块内存空间和一组系统资源。</li>
<li>线程不能作为具体的可执行命令体存在。最终用户不能直接执行线程，线程只能运行在进程中。</li>
</ul>
<p><strong>如何创建线程</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 两种方法来创建线程：</span>
<span class="token comment" spellcheck="true">// 继承java.lang.Thread类，并覆盖run( )方法。</span>
 <span class="token keyword">class</span> <span class="token class-name">mythread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">/* 覆盖该方法*/</span>
      <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 实现java.lang.Runnable接口，并实现run( )方法。</span>
<span class="token keyword">class</span> <span class="token class-name">mythread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>
      <span class="token annotation punctuation">@Override</span>
      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">/* 实现该方法*/</span>
      <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 一个线程的对象只能执行一次start()方法</span></code></pre>
<p><strong>线程的启动</strong></p>
<ul>
<li><p>新建的线程不会自动开始运行，必须通过start( )方法启动线程。如果不调用这个方法，线程将不会运行。</p>
</li>
<li><p>也就是说可以事先创建线程，并在需要的时候才启动他们。如：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承Thread的线程：</span>
Typer  t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Typer</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 实现Runnable接口的线程：</span>
Runnable  mt <span class="token operator">=</span>   <span class="token keyword">new</span> <span class="token class-name">Typer</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
Thread    t  <span class="token operator">=</span>   <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>mt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 父类的类型子类的对象</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
</ul>
<p><strong>线程执行过程</strong></p>
<ul>
<li><p>调用start( )方法时，将创建一个新的线程，并为线程分配系统资源，如内存。接着它将调用 run( ) 方法。</p>
</li>
<li><p>run( ) 方法中的代码定义执行线程所需的功能。</p>
<ul>
<li>run()方法能够调用其他方法，引用其他的类，申明变量。</li>
<li>run()方法在程序中确定另一个并发线程的执行入口。</li>
</ul>
</li>
<li><p>当run()方法中的任务完成返回时，该线程也将结束。</p>
</li>
</ul>
<p><strong>注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。<br>从程序运行的结果可以发现，多线程程序是乱序执行。</strong></p>
<h3 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h3><p>实现Runnable接口比继承Thread类所具有的优势：</p>
<ul>
<li>适合多个相同的程序代码的线程去处理同一个资源</li>
<li>可以避免java中的单继承的限制</li>
<li>增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</li>
<li>线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>下面的这个图非常重要!</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc18.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/xc2.png" alt=""></p>
<ol>
<li>新建状态（New）：新创建了一个线程对象。</li>
<li>就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li>
<li>运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li>
<li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ul>
<li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持    有的锁)</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li>
<li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li>
</ul>
</li>
<li>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程的调度</p>
<p>1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。</p>
<p>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：<br>static int MAX_PRIORITY<br>    线程可以具有的最高优先级，取值为10。<br>static int MIN_PRIORITY<br>    线程可以具有的最低优先级，取值为1。<br>static int NORM_PRIORITY<br>          分配给线程的默认优先级，取值为5。</p>
<p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p>
<p>每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。<br>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。<br>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p>
<p>2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p>
<p>3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p>
<p>4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p>
<p>5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
<p>6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。<br> 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公<br>共服务，在没有用户线程可服务时会自动离开。</li>
<li>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</li>
<li>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程<br>的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。</li>
<li>在 Daemon 线程中产生的新线程也是 Daemon 的。</li>
<li>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的<br>生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程<br>依旧是活跃的。</li>
<li>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,<br>程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线<br>程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统<br>中的可回收资源。</li>
<li>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周<br>期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依<br>赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退<br>出了；如果还有一个或以上的非守护线程则 JVM 不会退出。</li>
</ol>
<h3 id="yield-、sleep-、join-和interrupt-方法"><a href="#yield-、sleep-、join-和interrupt-方法" class="headerlink" title="yield()、sleep()、join()和interrupt()方法"></a>yield()、sleep()、join()和interrupt()方法</h3><p>1、yield()　</p>
<p>　　  yield()是Thread类的静态方法。它能让当前线程暂停，但不会阻塞该线程，而是由“运行状态”进入到“就绪状态”，从而让 其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是 当前线程又进入到“运行状态”继续运行！</p>
<p>　　值得注意的是，yield()方法不会释放锁。</p>
<p>2、sleep()</p>
<p>　　  sleep()是Thread类的静态方法。该方法声明抛出了InterrupedException异常。所以使用时，要么捕捉，要么声明抛出。</p>
<p>　　有2种重载方式：</p>
<p>——static void sleep(long millis)　　:　　让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。</p>
<p>——static void sleep(long millis , int nanos)　　：　　让当前正在执行的线程暂停millis毫秒加nanos微秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准度的影响。</p>
<p>　　sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。常用来暂停程序的运行。　　</p>
<p>　　同时注意，sleep()方法不会释放锁。</p>
<p>3、join()</p>
<p>　　join() 是Thread的一个实例方法。表示，当某个程序执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join的线程执行完毕。</p>
<p>有3种重载的形式：</p>
<p>——join()　　:　　等待被join的线程执行完成</p>
<p>——join(long millis)　　：　　等待被join的线程的时间最长为millis毫秒，若在millis毫秒内，被join的线程还未执行结束，则不等待。</p>
<p>——join(long millis , int nanos)　　:　　等待被join的线程的时间最长为millis毫秒加nanos微秒，若在此时间内，被join的线程还未执行结束，则不等待。</p>
<p>  即当前线程内，用某个线程对象调用join()后，会使当前线程等待，直到该线程对象的线程运行完毕，原线程才会继续运行。</p>
<p>4、interrupt()　　　</p>
<p>　　我们经常通过判断线程的中断标记来控制线程。　 　</p>
<p>　　  interrupt()是Thread类的一个实例方法，用于中断本线程。这个方法被调用时，会立即将线程的中断标志设置为“true”。所以当中断处于“阻塞状态”的线程时，由于处于阻塞状态，中断标记会被设置为“false”，抛出一个 InterruptedException。所以我们在线程的循环外捕获这个异常，就可以退出线程了。</p>
<p>　  interrupt()并不会中断处于“运行状态”的线程，它会把线程的“中断标记”设置为true，所以我们可以不断通过isInterrupted()来检测中断标记，从而在调用了interrupt()后终止线程，这也是通常我们对interrupt()的用法。</p>
<p>　　  Interrupted()是Thread类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，isInterrupted()是Thread类的实例方法，返回一个布尔类型来判断线程是否已经被中断。它们都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。
　　
　　
　　</p>
<h3 id="start-与-run-区别"><a href="#start-与-run-区别" class="headerlink" title="start 与 run 区别"></a>start 与 run 区别</h3><ol>
<li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</li>
<li>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运<br>行。</li>
<li>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运<br>行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</li>
</ol>
<h3 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h3><p>synchronized是一个重量级锁，相对于Lock，它会显得那么笨重 诚然，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。</p>
<p>  1、同步和异步的区别和联系</p>
<p> 　　  所谓同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其它的命令。</p>
<p>  异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p>
<p>   同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行(死心眼)。</p>
<p>异步在一定程度上可以看做是多线程的，请求一个方法后，就不管了，继续执行其他的方法。</p>
<p>1、原理</p>
<p><strong>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。</strong></p>
<p>　　  当当前线程调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)，当前线程就获取了“obj这个对象”的同步锁。</p>
<p>　　  不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。<br>例如，现在有个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。</p>
<p>2、基本规则</p>
<p>　　  第一条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>
<p>　　  第二条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</p>
<p>　  第三条 :  当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>
<p>1、普通同步方法，锁是当前实例对象</p>
<p>2、静态同步方法，锁是当前类的class对象</p>
<p>3、同步方法块，锁是括号里面的对象</p>
<p>3、实例锁和全局锁</p>
<p>  实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。<br>               实例锁对应的就是synchronized关键字。</p>
<p>  全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。<br>               全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</p>
<p>  就是说，一个非静态方法上的synchronized关键字，代表该方法依赖其所属对象。一个静态方法上synchronized关键字，代表该方法依赖这个类本身。</p>
<h4 id="synchronized-wait-notify结合-典型场景生产者消费者问题"><a href="#synchronized-wait-notify结合-典型场景生产者消费者问题" class="headerlink" title="synchronized, wait, notify结合:典型场景生产者消费者问题"></a>synchronized, wait, notify结合:典型场景生产者消费者问题</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
   * 生产者生产出来的产品交给店员
   */</span>
  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>product <span class="token operator">>=</span> MAX_PRODUCT<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
          <span class="token keyword">try</span>
          <span class="token punctuation">{</span>
              <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品已满,请稍候再生产"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
              e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token operator">++</span><span class="token punctuation">;</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者生产第"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>product <span class="token operator">+</span> <span class="token string">"个产品."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//通知等待区的消费者可以取出产品了</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">/**
   * 消费者从店员取产品
   */</span>
  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>product <span class="token operator">&lt;=</span> MIN_PRODUCT<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
          <span class="token keyword">try</span> 
          <span class="token punctuation">{</span>
              <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
              System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"缺货,稍候再取"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> 
          <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> 
          <span class="token punctuation">{</span>
              e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者取走了第"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>product <span class="token operator">+</span> <span class="token string">"个产品."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>product<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//通知等待去的生产者可以生产产品了</span>
  <span class="token punctuation">}</span>
</code></pre>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="Volatile的官方定义"><a href="#Volatile的官方定义" class="headerlink" title="Volatile的官方定义"></a>Volatile的官方定义</h4><p>  Java语言规范第三版中对volatile的定义如下：<br>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<p>  volatile这个关键字。其实这个关键字有两层语义。第一层语义就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化。我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。</p>
<p><strong>Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</strong></p>
<h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>　　为什么出现这种情况呢，我们需要先了解一下JMM（java内存模型）</p>
<p>　　java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>　　JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc31.png" alt=""></p>
<p>　需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p>
<p>  那么这种共享变量在多线程模型中的不可见性如何解决呢？比较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了，有点炮打蚊子的意思。比较合理的方式其实就是volatile</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><h4 id="ThreadLocal概念"><a href="#ThreadLocal概念" class="headerlink" title="ThreadLocal概念"></a>ThreadLocal概念</h4><p>ThreadLocal 是线程的局部变量， 是每一个线程所单独持有的，其他线程不能对其进行访问。</p>
<p>  ThreadLocal，直译为“线程本地”或“本地线程”，如果你真的这么认为，那就错了！其实，它就是一个容器，用于存放线程的局部变量，我认为应该叫做 ThreadLocalVariable（线程局部变量）才对，真不理解为什么当初 Sun 公司的工程师这样命名。</p>
<p>  当使用ThreadLocal维护变量的时候 为每一个使用该变量的线程提供一个独立的变量副本，即每个线程内部都会有一个该变量，这样同时多个线程访问该变量并不会彼此相互影响，因此他们使用的都是自己从内存中拷贝过来的变量的副本， 这样就不存在线程安全问题，也不会影响程序的执行性能。</p>
<p>  但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。</p>
<p><strong>跳出误区</strong></p>
<p>  需要重点强调的的是，不要拿ThreadLocal和synchronized做类比，因为这种比较压根就是无意义的！sysnchronized是一种互斥同步机制，是为了保证在多线程环境下对于共享资源的正确访问。而ThreadLocal从本质上讲，无非是提供了一个“线程级”的变量作用域，它是一种线程封闭（每个线程独享变量）技术，更直白点讲，ThreadLocal可以理解为将对象的作用范围限制在一个线程上下文中，使得变量的作用域为“线程级”。</p>
<h4 id="ThreadLocal常用方法介绍"><a href="#ThreadLocal常用方法介绍" class="headerlink" title="ThreadLocal常用方法介绍"></a>ThreadLocal常用方法介绍</h4><p>public void set(T value)：将值放入线程局部变量中</p>
<p>public T get()：从线程局部变量中获取值</p>
<p>public void remove()：从线程局部变量中移除值（有助于 JVM 垃圾回收）</p>
<p>protected T initialValue()：返回线程局部变量中的初始值（默认为 null） </p>
<p>为什么 initialValue() 方法是 protected 的呢？就是为了提醒程序员们，这个方法是要自己来实现的，给这个线程局部变量一个初始值吧。</p>
<h4 id="ThreadLocal内存泄露"><a href="#ThreadLocal内存泄露" class="headerlink" title="ThreadLocal内存泄露"></a>ThreadLocal内存泄露</h4><p><strong>内存泄漏memory leak：</strong> 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>
<p><strong>内存溢出 out of memory：</strong> 没内存可以分配给新的对象了。</p>
<p>我们知道，线程<code>Thread对象</code>中，每个线程对象内部都有一个的<code>ThreadLocalMap</code>对象。如果这个对象存储了多个大对象，则可能早出<code>内存溢出OOM</code>。为了防止这种情况发生，在ThreadLocal的源码中，有对应的策略，即调用 get（）、set（）、remove（） 方法，均会清除 ThreadLocal内部的 内存。</p>
<p><strong>ThreadLocal的内部是ThreadLocalMap</strong>。<strong>ThreadLocalMap内部是由一个Entry数组组成</strong>。Entry类的构造函数为 Entry（弱引用的ThreadLocal对象， Object value对象）。<strong>因为Entry的key是一个弱引用的ThreadLocal对象</strong>，<strong>所以在 垃圾回收 之前，将会清除此Entry对象的key</strong>。那么， ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value。这些 value 被Entry对象引用，所以value所占内存不会被释放。<strong>若在指定的线程任务里面，调用ThreadLocal对象的get（）、set（）、remove（）方法，可以避免出现内存泄露。</strong></p>
<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><pre><code>Runnable r[] = new Runnable[2];</code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>具体的可以看另一个文章 （java多线程基础笔记）</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc25.jpg" alt=""></p>
<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>  如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>  那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？  在Java中可以通过线程池来达到这样的效果.</p>
<p>  合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p>
<p>下为常见的四种：</p>
<ol>
<li>newCachedThreadPool ：大小不受限，当线程释放时，可重用该线程；</li>
<li>newFixedThreadPool ：大小固定，无可用线程时，任务需等待，直到有可用线程；</li>
<li>newSingleThreadExecutor ：创建一个单线程，任务会按顺序依次执行；</li>
<li>newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行</li>
</ol>
<h4 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h4><blockquote>
<p>阻塞队列提供了可阻塞的入队和出对操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用；</p>
</blockquote>
<p>在Java中，主要有以下类型的阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个支持延时获取元素的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 </li>
</ul>
<h2 id="JAVA-锁"><a href="#JAVA-锁" class="headerlink" title="JAVA 锁"></a>JAVA 锁</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>    乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为<br>别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数<br>据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），<br>如果失败则要重复读-比较-写的操作。</p>
<p>    java 中的乐观锁基本都是通过 CAS 操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>    悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人<br>会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。<br>java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，<br>才会转换为悲观锁，如 RetreenLock。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>    自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁<br>的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>    线程自旋是需要消耗 cpu 的，说白了就是让 cpu 在做无用功，如果一直获取不到锁，那线程<br>也不能一直占用 cpu 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁<br>的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p><strong>自旋锁的优缺点</strong></p>
<p>    自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来<br>说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>    但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合<br>使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p>
<p><strong>自旋锁时间阈值（1.6 引入了适应性自旋锁）</strong></p>
<p>    自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择<br>自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p>
<h4 id="Synchronized-同步锁"><a href="#Synchronized-同步锁" class="headerlink" title="Synchronized 同步锁"></a>Synchronized 同步锁</h4><p>    synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重<br>入锁</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>    ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完<br>成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等<br>避免多线程死锁的方法。</p>
<h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>    首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有<br>AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，<br>区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所<br>有操作转化成原子操作。<br>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。</v></p>
<p>    通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些<br>同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger<br>的性能是 ReentantLock 的好几倍。</p>
<h4 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h4><p>    本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫<br>做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受<br>影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p>
<h4 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h4><p>    为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如<br>果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写<br>锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p>
<p><strong>读锁</strong><br>    如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p>
<p><strong>写锁</strong><br>  如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。<br>总之，读的时候上读锁，写的时候上写锁！<br>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现<br>ReentrantReadWriteLock。</p>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>公平锁（Fair）</p>
<p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁（Nonfair）<br>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<ol>
<li>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</li>
<li>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</li>
</ol>
<h4 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h4><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p>
<p>独占锁</p>
<p>    独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。<br>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线<br>程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p>
<p>共享锁</p>
<p>    共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种<br>乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p>
<ol>
<li>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等<br>待线程的锁获取模式。</li>
<li>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，<br>或者被一个 写操作访问，但两者不能同时进行。</li>
</ol>
<h4 id="重量级锁（Mutex-Lock）"><a href="#重量级锁（Mutex-Lock）" class="headerlink" title="重量级锁（Mutex Lock）"></a>重量级锁（Mutex Lock）</h4><p>    <strong>Synchronized</strong> 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又<br>是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用<br>户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么<br>Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为<br>“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。<br>JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和<br>“偏向锁”。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>  锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。<br>锁升级<br>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，<br>也就是说只能从低到高升级，不会出现锁的降级）。<br>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，<br>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量<br>级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场<br>景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀<br>为重量级锁。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>  Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线<br>程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起<br>来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级<br>锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换<br>ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所<br>以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻<br>量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进<br>一步提高性能</p>
<h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul>
<li>减少锁持有时间</li>
</ul>
<p>只用在有线程安全要求的程序上加锁</p>
<ul>
<li>减小锁粒度</li>
</ul>
<p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。<br>降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是<br>ConcurrentHashMap。</p>
<ul>
<li>锁分离</li>
</ul>
<p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互<br>斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]<br>JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如<br>LinkedBlockingQueue 从头部取出，从尾部放数据</p>
<ul>
<li>锁粗化</li>
</ul>
<p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完<br>公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步<br>和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p>
<ul>
<li>锁消除<br>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这<br>些对象的锁操作，多数是因为程序员编码不规范引起</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>数组</strong></p>
<ul>
<li>数组作为数据存储结构的缺陷</li>
<li>在无序数组中，搜索是低效的</li>
<li>而在有序数组中插入效率又很低</li>
<li>不管在哪一种数组中删除效率都很低</li>
<li>创建一个数组之后，它的大小又是不可变的</li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>链表是一种有序的列表</li>
<li>链表的内容通常存储与内存中分散的位置上</li>
<li>链表由节点组成，每一个节点的结构都相同</li>
<li>节点分为数据域和链域，数据域是存放节点的内容，链域存放的是下一个节点的指针</li>
</ul>
<h3 id="单向链表（Single-Linked-List）"><a href="#单向链表（Single-Linked-List）" class="headerlink" title="单向链表（Single-Linked List）"></a>单向链表（Single-Linked List）</h3><p>　　单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。</p>
<p>　　单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc20.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Flyiyu/use/master/jc21.png" alt=""></p>
<h2 id="栈-stack-与堆-heap"><a href="#栈-stack-与堆-heap" class="headerlink" title="栈(stack)与堆(heap)"></a>栈(stack)与堆(heap)</h2><p>1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制；</p>
<ol>
<li><p>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中(对象可能在常量池里)（字符串常量对象存放在常量池中。）；</p>
</li>
<li><p>堆：存放所有new出来的对象；</p>
</li>
<li><p>静态域：存放静态成员（static定义的）；</p>
</li>
<li><p>常量池：存放字符串常量和基本类型常量（public static final）。有时，在嵌入式系统中，常量本身会和其他部分分割离开(由于版权等其他原因)，所以在这种情况下，可以选择将其放在ROM中 ；</p>
</li>
<li><p>非RAM存储：硬盘等永久存储空间</p>
</li>
</ol>
<p>堆栈是一种有序表。</p>
<p>堆栈只允许数据自有序列表（前端）作输入、输出操作。<br>堆栈的存取顺序就像手枪的弹夹一样，最先压进去的子弹会被最后打出来<br>具有先进后出FILO（First In Last Out）的特性</p>
<p>堆栈的典型操作</p>
<p>入栈：又称压栈，是指将数据放入堆栈</p>
<p>出栈：将数据从堆栈中取出来</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">private</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> obj<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 指向标
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> pointer<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/**
     * 数组的长度
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 给定一个默认的长度
     */</span>
    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 方法的重载
     *
     * @param size
     */</span>
    <span class="token keyword">public</span> <span class="token function">Stack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pointer <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断堆栈是否已经满了
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * 由于指向标的位置是从-1开始的，数组的下标是从0开始的
         */</span>
        <span class="token keyword">return</span> pointer <span class="token operator">==</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 入栈</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * // isFull满的
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"空间已满！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 对堆进行扩容</span>
            obj <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">/**
             * // 每次加一
             */</span>
            pointer<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">/**
             * 循环给数组赋值
             */</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            pointer<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 出栈
     *
     * @return
     */</span>
    <span class="token keyword">public</span> Object <span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"栈空间已空！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            Object o <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span><span class="token punctuation">;</span>
            pointer<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> o<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 判断堆栈是否为空
     *
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">/**
         * isEmpty空的
         * 如果pointer==-1就返回true
         */</span>
        <span class="token keyword">return</span> pointer <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Stack stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * 出栈
         */</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>主要是两个：队头，队尾</p>
<p>入队：队尾指针向后移动</p>
<p>出队：队头指针向后移动</p>
<h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><h4 id="1-形参与实参"><a href="#1-形参与实参" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h4><h3 id="1-形参与实参-1"><a href="#1-形参与实参-1" class="headerlink" title="1. 形参与实参"></a>1. 形参与实参</h3><p>我们先来重温一组语法：</p>
<blockquote>
<ol>
<li><p>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</p>
</li>
<li><p>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p>
</li>
</ol>
</blockquote>
<p>举个栗子：</p>
<pre><code>public static void func(int a){
 a=20;
 System.out.println(a);
}
public static void main(String[] args) {
 int a=10;//变量
 func(a);
}</code></pre><p>例子中<br>int a=10;中的a在被调用之前就已经创建并初始化，在调用func方法时，他被当做参数传入，所以这个a是实参。<br>而func(int a)中的a只有在func被调用时它的生命周期才开始，而在func调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。</p>
<h2 id="2-Java的数据类型"><a href="#2-Java的数据类型" class="headerlink" title="2. Java的数据类型"></a>2. Java的数据类型</h2><p>所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。<br>因此</p>
<blockquote>
<p>数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中。</p>
</blockquote>
<p>所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。<br>那么<br>Java的数据类型有哪些？</p>
<blockquote>
<ol>
<li>基本类型：编程语言中内置的最小粒度的数据类型。它包括四大类八种类型：</li>
</ol>
<blockquote>
<p>4种整数类型：byte、short、int、long<br>2种浮点数类型：float、double<br>1种字符类型：char<br>1种布尔类型：boolean</p>
</blockquote>
<ol start="2">
<li>引用类型：引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。它主要包括：</li>
</ol>
<blockquote>
<p>类<br>接口<br>数组</p>
</blockquote>
</blockquote>
<p>有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。</p>
<h2 id="3-JVM内存的划分及职能"><a href="#3-JVM内存的划分及职能" class="headerlink" title="3.JVM内存的划分及职能"></a>3.JVM内存的划分及职能</h2><p>Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznUXxpugnTGGCB8eWHmcg9sjc88CMjoWuagmLTgibGKIJchE6JkC1Plw.jpg" alt=""></p>
<p>有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：</p>
<h3 id="1-虚拟机栈"><a href="#1-虚拟机栈" class="headerlink" title="1. 虚拟机栈"></a>1. 虚拟机栈</h3><h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h3><h3 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h3><h3 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h3><h3 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h3><p>我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。</p>
<hr>
<blockquote>
<p><strong>1. 虚拟机栈</strong></p>
</blockquote>
<p>虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。</p>
<p>栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p>
<p>下图表示了一个Java栈的模型以及栈帧的组成：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozzhafOtSl5zaWYfOCzicibCgWQRISwTlEr0Kd1TJj3ibia5mQvb7sTUyVq5A.jpg" alt=""></p>
<p><strong>栈帧</strong>:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>每个栈帧中包括：</p>
<ol>
<li><p><strong>局部变量表</strong>:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。</p>
</li>
<li><p><strong>操作数栈</strong>:Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指操作数栈。</p>
</li>
<li><p><strong>指向运行时常量池的引用</strong>:存储程序执行时可能用到常量的引用。</p>
</li>
<li><p><strong>方法返回地址</strong>:存储方法执行完成后的返回地址。</p>
</li>
</ol>
<hr>
<blockquote>
<p><strong>2. 堆：</strong></p>
</blockquote>
<p>堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。</p>
<hr>
<blockquote>
<p><strong>3. 方法区：</strong></p>
</blockquote>
<p>方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。</p>
<p>方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。</p>
<hr>
<blockquote>
<p><strong>4. 本地方法栈：</strong></p>
</blockquote>
<p>本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。</p>
<p><strong>有人会疑惑：什么是本地方法？为什么Java还要调用本地方法？</strong></p>
<hr>
<blockquote>
<p><strong>5. 程序计数器：</strong></p>
</blockquote>
<p>线程私有的。<br>记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<hr>
<h2 id="4-数据如何在内存中存储？"><a href="#4-数据如何在内存中存储？" class="headerlink" title="4. 数据如何在内存中存储？"></a>4. 数据如何在内存中存储？</h2><p>从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有三个地方：</p>
<ul>
<li><p>堆</p>
</li>
<li><p>栈</p>
</li>
<li><p>静态方法区</p>
</li>
<li><p>常量区</p>
</li>
</ul>
<p>相应地，每个存储区域都有自己的内存分配策略：</p>
<ul>
<li><p>堆式：</p>
</li>
<li><p>栈式</p>
</li>
<li><p>静态</p>
</li>
</ul>
<p>我们已经知道：Java中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？<br>这里要分以下的情况进行探究：</p>
<blockquote>
<p><strong>1. 基本数据类型的存储：</strong></p>
<ul>
<li><p>A. 基本数据类型的局部变量</p>
</li>
<li><p>B. 基本数据类型的成员变量</p>
</li>
<li><p>C. 基本数据类型的静态变量</p>
</li>
</ul>
<p><strong>2. 引用数据类型的存储</strong></p>
</blockquote>
<hr>
<blockquote>
<p><strong>1. 基本数据类型的存储</strong></p>
</blockquote>
<hr>
<p>我们分别来研究一下：</p>
<h5 id="A-基本数据类型的局部变量"><a href="#A-基本数据类型的局部变量" class="headerlink" title="A.基本数据类型的局部变量"></a><strong>A.基本数据类型的局部变量</strong></h5><ol>
<li><p>定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的<strong>“虚拟机栈”</strong>，数据本身的值就是存储在栈空间里面。  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozznNuHDLtNxibO1b1yN7wV4HPSno4CHZWXaEicootMFec7t31G38HzFpSQ.png" alt=""></p>
</li>
</ol>
<pre><code>如上图，在方法内定义的变量直接存储在栈中，如</code></pre><pre><code>    int age=50;
    int weight=50;
    int grade=6;</code></pre><p>当我们写“int age=50；”，其实是分为两步的：</p>
<pre><code>    int age;//定义变量
    age=50;//赋值</code></pre><p>首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。因此我们可以知道：<br><strong>我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。</strong></p>
<p>我们再来看“int weight=50；”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。由此可见：<strong>栈中的数据在当前线程下是共享的</strong>。</p>
<p>那么如果再执行下面的代码呢？</p>
<pre><code>    weight=40；</code></pre><p>当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。由此可知：</p>
<p><strong>基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</strong></p>
<hr>
<h5 id="B-基本数据类型的成员变量"><a href="#B-基本数据类型的成员变量" class="headerlink" title="B. 基本数据类型的成员变量"></a><strong>B. 基本数据类型的成员变量</strong></h5><p>成员变量：顾名思义，就是在类体中定义的变量。<br>看下图：  </p>
<p><img src="images%5CxrXpc56zxwPIur5r0vPhEJpJP6QXmozziaY24epYoPoM45SJiajF9qCXtupO2539ia0NMKIYUo3yjhFibJ1ZgTvIWg.jpg" alt=""></p>
<p>我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> grade<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//篇幅较长，省略setter getter方法 </span>
    staticvoid <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"run...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//调用</span>
Person per<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。因此可知：<strong>基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</strong></p>
<hr>
<h5 id="C-基本数据类型的静态变量"><a href="#C-基本数据类型的静态变量" class="headerlink" title="C. 基本数据类型的静态变量"></a><strong>C. 基本数据类型的静态变量</strong></h5><p>前面提到<strong>方法区</strong>用来存储一些共享数据，因此<strong>基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失</strong></p>
<hr>
<blockquote>
<p><strong>2. 引用数据类型的存储:</strong></p>
</blockquote>
<p>上面提到：堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时</p>
<pre><code>Person per=new Person();</code></pre><p>实际上，它也是有两个过程：</p>
<pre><code>Person per;
//定义变量
per=new Person();
//赋值</code></pre><p>在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。因此可见：<br><strong>对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</strong></p>
<h2 id="Java的内存分配以及栈和堆的区别"><a href="#Java的内存分配以及栈和堆的区别" class="headerlink" title="Java的内存分配以及栈和堆的区别"></a>Java的内存分配以及栈和堆的区别</h2><ul>
<li><strong>先了解几个概念</strong><ul>
<li>栈</li>
<li>堆</li>
<li>方法区</li>
<li>本地方法去</li>
<li>寄存器<pre><code>A:栈: 存放的是局部变量
局部变量：在方法定义或者方法声明上的变量都是局部变量。
B:堆: 存放的是所有new出来的东西
特点：
  a: 每一个new出来的东西都会为其分配一个地制值。
  b: 每一个变量都有一个默认的值
      byte，short，int，long  -- 0
      float，double            -- 0.0
      char                    -- '\u0000'
      boolean                -- false
      引用数据类型               -- null       
  c: 使用完毕就变成了垃圾，等待垃圾回收器对其回收
C:方法区:(面向对象部分讲解)
D:本地方法区:(和系统相关)
E:寄存器:(cpu使用)</code></pre><h3 id="局部变量存储位置"><a href="#局部变量存储位置" class="headerlink" title="局部变量存储位置"></a>局部变量存储位置</h3></li>
</ul>
</li>
<li>在方法中声明的变量，即该变量是局部变量<ul>
<li>每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。</li>
<li>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。<a href="https://github.com/yangchong211/YCBlogs" target="_blank" rel="noopener">博客</a></li>
<li>当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在JAVA虚拟机栈中</li>
<li>当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在JAVA虚拟机的栈中，该变量所指向的对象是放在堆类存中的</li>
</ul>
</li>
</ul>
<h3 id="成员变量存储位置"><a href="#成员变量存储位置" class="headerlink" title="成员变量存储位置"></a>成员变量存储位置</h3><ul>
<li>在类中声明的变量是成员变量，也叫全局变量<ul>
<li>放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</li>
<li>同样在类中声明的变量即可是基本类型的变量，也可是引用类型的变量。</li>
<li>当声明的是基本类型的变量其变量名及其值放在堆内存中的</li>
<li>引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</li>
</ul>
</li>
</ul>
<h3 id="静态变量存储位置"><a href="#静态变量存储位置" class="headerlink" title="静态变量存储位置"></a>静态变量存储位置</h3><ul>
<li>静态变量其实就是常量<ul>
<li>注意是：存储在JVM的方法区中</li>
<li>static变量在类加载时被初始化，存储在JVM的方法区中，整个内存中只有一个static变量的拷贝，可以使用类名直接访问，也可以通过类的实例化对象访问，一般不推荐通过实例化对象访问，通俗的讲static变量属于类，不属于对象，任何实例化的对象访问的都是同一个static变量，任何地放都可以通过类名来访问static变量。</li>
</ul>
</li>
</ul>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><pre><code>/**
* Java中的main()方法详解
*/
public class HelloWorld {
    public static void main(String args[]) {
        System.out.println("Hello World!");
    }
}</code></pre><p>一、先说类：<br>HelloWorld 类中有main()方法，说明这是个java应用程序，通过JVM直接启动运行的程序。<br>既然是类，java允许类不加public关键字约束，当然类的定义只能限制为public或者无限制关键字（默认的）。</p>
<p>二、再说main()方法</p>
<blockquote>
<p>这个main()方法的声明为：public static void main(String args[])。必须这么定义，这是Java的规范。<br>为什么要这么定义，和JVM的运行有关系。<br>当一个类中有main()方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法。<br>由于JVM在运行这个Java应用程序的时候，首先会调用main方法，调用时不实例化这个类的对象，而是通过类名直接调用因此需要是限制为public static。(类名.main())<br>对于java中的main方法，jvm有限制，不能有返回值，因此返回值类型为void。<br>main方法中还有一个输入参数，类型为String[]，这个也是java的规范，main()方法中必须有一个入参，类型必须String[]，至于字符串数组的名字，这个是可以自己设定的，根据习惯，这个字符串数组的名字一般和sun java规范范例中mian参数名保持一致，取名为args。因此，main()方法定义必须是：“public static void main(String 字符串数组参数名[])”。</p>
</blockquote>
<p>三、main()方法中可以throw Exception<br>因此main()方法中可以抛出异常，main()方法上也可以声明抛出异常。</p>
<p>四、main()方法中字符串参数数组作用<br>main()方法中字符串参数数组作用是接收命令行输入参数的，命令行的参数之间用空格隔开。</p>
<h3 id="jdk1-8新特性学习"><a href="#jdk1-8新特性学习" class="headerlink" title="jdk1.8新特性学习"></a>jdk1.8新特性学习</h3><h4 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h4><p>以下是Java8中的引入的部分新特性。关于Java8新特性更详细的介绍可参考<a href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">这里</a>。</p>
<ul>
<li>接口默认方法和静态方法</li>
<li>Lambda 表达式</li>
<li>函数式接口</li>
<li>方法引用</li>
<li>Stream</li>
<li>Optional</li>
<li>Date/Time API</li>
<li>重复注解</li>
<li>扩展注解的支持</li>
<li>Base64</li>
<li>JavaFX</li>
<li>其它<ul>
<li>JDBC4.2规范</li>
<li>更好的类型推测机制</li>
<li>HashMap性能提升</li>
<li>IO/NIO 的改进</li>
<li>JavaScript引擎Nashorn</li>
<li>并发（Concurrency）</li>
<li>类依赖分析器jdeps</li>
<li>JVM的PermGen空间被移除</li>
</ul>
</li>
</ul>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><h3 id="时间复杂度-amp-amp-空间复杂度"><a href="#时间复杂度-amp-amp-空间复杂度" class="headerlink" title="时间复杂度&amp;&amp;空间复杂度"></a>时间复杂度&amp;&amp;空间复杂度</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="Gc"><a href="#Gc" class="headerlink" title="Gc"></a>Gc</h3><h3 id="各种树"><a href="#各种树" class="headerlink" title="各种树"></a>各种树</h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '33e35f8a39d17339ae45',
        clientSecret: 'c2daf8c102c345db91ff32aa45b2a692c7bdee25',
        repo: 'Fly_tom.github.io',
        owner: 'Flyiyu',
        admin: "Flyiyu",
        id: '2020-02-08T15-33-02',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/02/08/2019-02-03-java-she-ji-mo-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="java设计模式">
                        
                        <span class="card-title">java设计模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            单例模式(Singleton Pattern)优点：
(1) 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了
(2) 单例模式可以在系统设置全局的访问
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-02-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/02/08/2019-01-23-mybatis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="Mybatis笔记">
                        
                        <span class="card-title">Mybatis笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Mybatis简介
MyBatis 本是apache的一个开源项目iBatis, MyBatis 是一个高级映射的优秀的持久层orm框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis可以使用简
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-02-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Mybatis/" class="post-category">
                                    Mybatis
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Mybatis/">
                        <span class="chip bg-color">Mybatis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align"
        style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://flytom.club" target="_blank">FlyTom</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>

            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "6";
                    var startDate = "28";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>

    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->


    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
